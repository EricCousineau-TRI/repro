#pragma once

// GENERATED FILE DO NOT EDIT
// This file contains docstrings for the Python bindings that were
// automatically extracted by mkdoc.py from pybind11 / drake.

#if defined(__GNUG__)
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wunused-variable"
#endif

// root
constexpr struct /* root */ {

  // AllBodiesClosestDistanceConstraint
  struct /* AllBodiesClosestDistanceConstraint */ {

    // drake/multibody/rigid_body_constraint.h:849
    const char* doc = R"""()""";

    // AllBodiesClosestDistanceConstraint::AllBodiesClosestDistanceConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:852
      const char* doc = R"""()""";

    } ctor;

    // AllBodiesClosestDistanceConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:862
      const char* doc = R"""()""";

    } bounds;

    // AllBodiesClosestDistanceConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:859
      const char* doc = R"""()""";

    } eval;

    // AllBodiesClosestDistanceConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:861
      const char* doc = R"""()""";

    } name;

    // AllBodiesClosestDistanceConstraint::updateRobot
    struct /* updateRobot */ {

      // drake/multibody/rigid_body_constraint.h:858
      const char* doc = R"""()""";

    } updateRobot;

  } AllBodiesClosestDistanceConstraint;

  // Attachment
  struct /* Attachment */ {

    // drake/systems/controllers/QPCommon.h:349
    const char* doc = R"""()""";

    // Attachment::Attachment
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:355
      const char* doc = R"""()""";

      // drake/systems/controllers/QPCommon.h:365
      const char* doc_2 = R"""()""";

    } ctor;

    // Attachment::attach_to_frame
    struct /* attach_to_frame */ {

      // drake/systems/controllers/QPCommon.h:351
      const char* doc = R"""()""";

    } attach_to_frame;

    // Attachment::joint_type
    struct /* joint_type */ {

      // drake/systems/controllers/QPCommon.h:353
      const char* doc = R"""()""";

    } joint_type;

    // Attachment::urdf_filename
    struct /* urdf_filename */ {

      // drake/systems/controllers/QPCommon.h:352
      const char* doc = R"""()""";

    } urdf_filename;

  } Attachment;

  // BodyMotionParams
  struct /* BodyMotionParams */ {

    // drake/systems/controllers/QPCommon.h:160
    const char* doc = R"""()""";

    // BodyMotionParams::BodyMotionParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:161
      const char* doc = R"""()""";

    } ctor;

    // BodyMotionParams::Kd
    struct /* Kd */ {

      // drake/systems/controllers/QPCommon.h:168
      const char* doc = R"""()""";

    } Kd;

    // BodyMotionParams::Kp
    struct /* Kp */ {

      // drake/systems/controllers/QPCommon.h:167
      const char* doc = R"""()""";

    } Kp;

    // BodyMotionParams::accel_bounds
    struct /* accel_bounds */ {

      // drake/systems/controllers/QPCommon.h:169
      const char* doc = R"""()""";

    } accel_bounds;

    // BodyMotionParams::weight
    struct /* weight */ {

      // drake/systems/controllers/QPCommon.h:170
      const char* doc = R"""()""";

    } weight;

  } BodyMotionParams;

  // Bounds
  struct /* Bounds */ {

    // drake/systems/controllers/QPCommon.h:88
    const char* doc = R"""()""";

    // Bounds::Bounds
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:89
      const char* doc = R"""()""";

    } ctor;

    // Bounds::max
    struct /* max */ {

      // drake/systems/controllers/QPCommon.h:94
      const char* doc = R"""()""";

    } max;

    // Bounds::min
    struct /* min */ {

      // drake/systems/controllers/QPCommon.h:93
      const char* doc = R"""()""";

    } min;

  } Bounds;

  // DesiredBodyAcceleration
  struct /* DesiredBodyAcceleration */ {

    // drake/systems/controllers/QPCommon.h:291
    const char* doc = R"""()""";

    // DesiredBodyAcceleration::DesiredBodyAcceleration
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:292
      const char* doc = R"""()""";

    } ctor;

    // DesiredBodyAcceleration::T_task_to_world
    struct /* T_task_to_world */ {

      // drake/systems/controllers/QPCommon.h:302
      const char* doc = R"""()""";

    } T_task_to_world;

    // DesiredBodyAcceleration::accel_bounds
    struct /* accel_bounds */ {

      // drake/systems/controllers/QPCommon.h:298
      const char* doc = R"""()""";

    } accel_bounds;

    // DesiredBodyAcceleration::body_or_frame_id0
    struct /* body_or_frame_id0 */ {

      // drake/systems/controllers/QPCommon.h:295
      const char* doc = R"""()""";

    } body_or_frame_id0;

    // DesiredBodyAcceleration::body_path
    struct /* body_path */ {

      // drake/systems/controllers/QPCommon.h:301
      const char* doc = R"""()""";

    } body_path;

    // DesiredBodyAcceleration::body_vdot
    struct /* body_vdot */ {

      // drake/systems/controllers/QPCommon.h:296
      const char* doc = R"""()""";

    } body_vdot;

    // DesiredBodyAcceleration::control_pose_when_in_contact
    struct /* control_pose_when_in_contact */ {

      // drake/systems/controllers/QPCommon.h:299
      const char* doc = R"""()""";

    } control_pose_when_in_contact;

    // DesiredBodyAcceleration::use_spatial_velocity
    struct /* use_spatial_velocity */ {

      // drake/systems/controllers/QPCommon.h:300
      const char* doc = R"""()""";

    } use_spatial_velocity;

    // DesiredBodyAcceleration::weight
    struct /* weight */ {

      // drake/systems/controllers/QPCommon.h:297
      const char* doc = R"""()""";

    } weight;

    // DesiredBodyAcceleration::weight_multiplier
    struct /* weight_multiplier */ {

      // drake/systems/controllers/QPCommon.h:303
      const char* doc = R"""()""";

    } weight_multiplier;

  } DesiredBodyAcceleration;

  // DrakeJoint
  struct /* DrakeJoint */ {

    // drake/multibody/joints/drake_joint.h:66
    const char* doc =
R"""(A joint defines a spatial relationship between two rigid bodies.)""";

    // DrakeJoint::Clone
    struct /* Clone */ {

      // drake/multibody/joints/drake_joint.h:104
      const char* doc = R"""(Returns a clone of this DrakeJoint.)""";

    } Clone;

    // DrakeJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/drake_joint.h:220
      const char* doc =
R"""(Allows descendent classes to perform the actual clone operation.)""";

    } DoClone;

    // DrakeJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/drake_joint.h:227
      const char* doc =
R"""(Initializes any additional members within ``clone`` that could not be
set during construction.)""";

    } DoInitializeClone;

    // DrakeJoint::DrakeJoint
    struct /* ctor */ {

      // drake/multibody/joints/drake_joint.h:92
      const char* doc =
R"""(A constructor for use by concrete joints to define the joint's name,
fixed frame, and number of degrees of freedom.

Parameter ``name``:
    The joint's name. This can be anything; it does not have to be
    unique.

Parameter ``transform_to_parent_body``:
    Defines the configuration of the joint's fixed frame relative to
    the joint's parent body's frame.

Parameter ``num_positions``:
    The number of position states of the joint.

Parameter ``num_velocities``:
    The number of velocity states of the joint.)""";

    } ctor;

    // DrakeJoint::InitializeClone
    struct /* InitializeClone */ {

      // drake/multibody/joints/drake_joint.h:223
      const char* doc =
R"""(Initializes the private member variables within the provided `clone`.)""";

    } InitializeClone;

    // DrakeJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } SpringTorque;

    // DrakeJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } frictionTorque;

    // DrakeJoint::getJointLimitMax
    struct /* getJointLimitMax */ {

      // drake/multibody/joints/drake_joint.h:198
      const char* doc = R"""()""";

    } getJointLimitMax;

    // DrakeJoint::getJointLimitMin
    struct /* getJointLimitMin */ {

      // drake/multibody/joints/drake_joint.h:196
      const char* doc = R"""()""";

    } getJointLimitMin;

    // DrakeJoint::getName
    struct /* getName */ {

      // drake/multibody/joints/drake_joint.h:169
      const char* doc = R"""()""";

    } getName;

    // DrakeJoint::getNumPositions
    struct /* getNumPositions */ {

      // drake/multibody/joints/drake_joint.h:161
      const char* doc = R"""()""";

    } getNumPositions;

    // DrakeJoint::getNumVelocities
    struct /* getNumVelocities */ {

      // drake/multibody/joints/drake_joint.h:165
      const char* doc = R"""()""";

    } getNumVelocities;

    // DrakeJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/drake_joint.h:173
      const char* doc = R"""()""";

    } getPositionName;

    // DrakeJoint::getTransformToParentBody
    struct /* getTransformToParentBody */ {

      // drake/multibody/joints/drake_joint.h:157
      const char* doc = R"""()""";

    } getTransformToParentBody;

    // DrakeJoint::getVelocityName
    struct /* getVelocityName */ {

      // drake/multibody/joints/drake_joint.h:177
      const char* doc = R"""()""";

    } getVelocityName;

    // DrakeJoint::get_joint_limit_dissipation
    struct /* get_joint_limit_dissipation */ {

      // drake/multibody/joints/drake_joint.h:202
      const char* doc = R"""()""";

    } get_joint_limit_dissipation;

    // DrakeJoint::get_joint_limit_stiffness
    struct /* get_joint_limit_stiffness */ {

      // drake/multibody/joints/drake_joint.h:200
      const char* doc = R"""()""";

    } get_joint_limit_stiffness;

    // DrakeJoint::get_name
    struct /* get_name */ {

      // drake/multibody/joints/drake_joint.h:137
      const char* doc = R"""(Returns the name of this joint.)""";

    } get_name;

    // DrakeJoint::get_num_positions
    struct /* get_num_positions */ {

      // drake/multibody/joints/drake_joint.h:127
      const char* doc =
R"""(Returns the number of position states of this joint.)""";

    } get_num_positions;

    // DrakeJoint::get_num_velocities
    struct /* get_num_velocities */ {

      // drake/multibody/joints/drake_joint.h:132
      const char* doc =
R"""(Returns the number of velocity states of this joint.)""";

    } get_num_velocities;

    // DrakeJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/drake_joint.h:145
      const char* doc =
R"""(Returns the name of a particular position degree of freedom of this
joint.

Parameter ``index``:
    The index of the position degree of freedom. This value must be
    between 0 and get_num_positions() - 1.)""";

    } get_position_name;

    // DrakeJoint::get_transform_to_parent_body
    struct /* get_transform_to_parent_body */ {

      // drake/multibody/joints/drake_joint.h:120
      const char* doc =
R"""(Returns the transform `X_PF` giving the pose of the joint's "fixed"
frame `F` in its parent body frame `P`. Frame `F` is the joint frame
that is fixed to the parent body; thus `X_PF` is not configuration
dependent.

To clarify the sense of the returned transform `X_PF`, consider the
location of a point `Q` somewhere in space. Let `p_PQ` be point `Q`
measured and expressed in frame `P` and `p_FQ` be point `Q` measured
and expressed in frame `F`. Then `p_PQ` is given by:

```
p_PQ = X_PF * p_FQ
```)""";

    } get_transform_to_parent_body;

    // DrakeJoint::get_velocity_name
    struct /* get_velocity_name */ {

      // drake/multibody/joints/drake_joint.h:153
      const char* doc =
R"""(Returns the name of a particular velocity degree of freedom of this
joint.

Parameter ``index``:
    The index of the velocity degree of freedom. This value must be
    between 0 and get_num_velocities() - 1.)""";

    } get_velocity_name;

    // DrakeJoint::isFloating
    struct /* isFloating */ {

      // drake/multibody/joints/drake_joint.h:183
      const char* doc = R"""()""";

    } isFloating;

    // DrakeJoint::is_fixed
    struct /* is_fixed */ {

      // drake/multibody/joints/drake_joint.h:188
      const char* doc =
R"""(Returns `true` if this joint is a FixedJoint.)""";

    } is_fixed;

    // DrakeJoint::is_floating
    struct /* is_floating */ {

      // drake/multibody/joints/drake_joint.h:179
      const char* doc = R"""()""";

    } is_floating;

    // DrakeJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } jointTransform;

    // DrakeJoint::joint_limit_dissipation_
    struct /* joint_limit_dissipation_ */ {

      // drake/multibody/joints/drake_joint.h:216
      const char* doc = R"""()""";

    } joint_limit_dissipation_;

    // DrakeJoint::joint_limit_max_
    struct /* joint_limit_max_ */ {

      // drake/multibody/joints/drake_joint.h:214
      const char* doc = R"""()""";

    } joint_limit_max_;

    // DrakeJoint::joint_limit_min_
    struct /* joint_limit_min_ */ {

      // drake/multibody/joints/drake_joint.h:213
      const char* doc = R"""()""";

    } joint_limit_min_;

    // DrakeJoint::joint_limit_stiffness_
    struct /* joint_limit_stiffness_ */ {

      // drake/multibody/joints/drake_joint.h:215
      const char* doc = R"""()""";

    } joint_limit_stiffness_;

    // DrakeJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } motionSubspace;

    // DrakeJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } motionSubspaceDotTimesV;

    // DrakeJoint::name_
    struct /* name_ */ {

      // drake/multibody/joints/drake_joint.h:212
      const char* doc = R"""()""";

    } name_;

    // DrakeJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } qdot2v;

    // DrakeJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/drake_joint.h:192
      const char* doc = R"""()""";

    } randomConfiguration;

    // DrakeJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/drake_joint.h:204
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint.h:206
      const char* doc_2 = R"""()""";

    } v2qdot;

    // DrakeJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/drake_joint.h:190
      const char* doc = R"""()""";

    } zeroConfiguration;

  } DrakeJoint;

  // DrakeJointImpl
  struct /* DrakeJointImpl */ {

    // drake/multibody/joints/drake_joint_impl.h:75
    const char* doc = R"""()""";

    // DrakeJointImpl::DrakeJointImpl<Derived>
    struct /* ctor */ {

      // drake/multibody/joints/drake_joint_impl.h:96
      const char* doc = R"""()""";

    } ctor;

    // DrakeJointImpl::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } SpringTorque;

    // DrakeJointImpl::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } frictionTorque;

    // DrakeJointImpl::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } jointTransform;

    // DrakeJointImpl::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } motionSubspace;

    // DrakeJointImpl::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } motionSubspaceDotTimesV;

    // DrakeJointImpl::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } qdot2v;

    // DrakeJointImpl::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/drake_joint_impl.h:105
      const char* doc = R"""()""";

      // drake/multibody/joints/drake_joint_impl.h:106
      const char* doc_2 = R"""()""";

    } v2qdot;

  } DrakeJointImpl;

  // DrakeRobotState
  struct /* DrakeRobotState */ {

    // drake/systems/controllers/controlUtil.h:31
    const char* doc = R"""()""";

    // DrakeRobotState::q
    struct /* q */ {

      // drake/systems/controllers/controlUtil.h:34
      const char* doc = R"""()""";

    } q;

    // DrakeRobotState::qd
    struct /* qd */ {

      // drake/systems/controllers/controlUtil.h:35
      const char* doc = R"""()""";

    } qd;

    // DrakeRobotState::t
    struct /* t */ {

      // drake/systems/controllers/controlUtil.h:33
      const char* doc = R"""()""";

    } t;

  } DrakeRobotState;

  // DrakeShapes
  struct /* DrakeShapes */ {

    // DrakeShapes::Box
    struct /* Box */ {

      // drake/multibody/shapes/geometry.h:118
      const char* doc = R"""()""";

      // DrakeShapes::Box::Box
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:120
        const char* doc = R"""()""";

      } ctor;

      // DrakeShapes::Box::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:122
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Box::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:131
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Box::getFaces
      struct /* getFaces */ {

        // drake/multibody/shapes/geometry.h:129
        const char* doc = R"""()""";

      } getFaces;

      // DrakeShapes::Box::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:124
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Box::getTerrainContactPoints
      struct /* getTerrainContactPoints */ {

        // drake/multibody/shapes/geometry.h:133
        const char* doc = R"""()""";

      } getTerrainContactPoints;

      // DrakeShapes::Box::hasFaces
      struct /* hasFaces */ {

        // drake/multibody/shapes/geometry.h:125
        const char* doc = R"""()""";

      } hasFaces;

      // DrakeShapes::Box::size
      struct /* size */ {

        // drake/multibody/shapes/geometry.h:140
        const char* doc = R"""()""";

      } size;

    } Box;

    // DrakeShapes::Capsule
    struct /* Capsule */ {

      // drake/multibody/shapes/geometry.h:172
      const char* doc = R"""()""";

      // DrakeShapes::Capsule::Capsule
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:174
        const char* doc = R"""()""";

      } ctor;

      // DrakeShapes::Capsule::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:176
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Capsule::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:180
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Capsule::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:178
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Capsule::length
      struct /* length */ {

        // drake/multibody/shapes/geometry.h:188
        const char* doc = R"""()""";

      } length;

      // DrakeShapes::Capsule::radius
      struct /* radius */ {

        // drake/multibody/shapes/geometry.h:187
        const char* doc = R"""()""";

      } radius;

    } Capsule;

    // DrakeShapes::Cylinder
    struct /* Cylinder */ {

      // drake/multibody/shapes/geometry.h:148
      const char* doc = R"""()""";

      // DrakeShapes::Cylinder::Cylinder
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:150
        const char* doc = R"""()""";

      } ctor;

      // DrakeShapes::Cylinder::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:152
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Cylinder::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:156
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Cylinder::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:154
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Cylinder::length
      struct /* length */ {

        // drake/multibody/shapes/geometry.h:164
        const char* doc = R"""()""";

      } length;

      // DrakeShapes::Cylinder::radius
      struct /* radius */ {

        // drake/multibody/shapes/geometry.h:163
        const char* doc = R"""()""";

      } radius;

    } Cylinder;

    // DrakeShapes::Element
    struct /* Element */ {

      // drake/multibody/shapes/element.h:10
      const char* doc = R"""()""";

      // DrakeShapes::Element::Element
      struct /* ctor */ {

        // drake/multibody/shapes/element.h:12
        const char* doc = R"""()""";

        // drake/multibody/shapes/element.h:18
        const char* doc_2 = R"""()""";

        // drake/multibody/shapes/element.h:23
        const char* doc_3 = R"""()""";

        // drake/multibody/shapes/element.h:54
        const char* doc_4 = R"""()""";

        // drake/multibody/shapes/element.h:56
        const char* doc_5 = R"""()""";

      } ctor;

      // DrakeShapes::Element::SetLocalTransform
      struct /* SetLocalTransform */ {

        // drake/multibody/shapes/element.h:36
        const char* doc = R"""()""";

      } SetLocalTransform;

      // DrakeShapes::Element::T_element_to_local
      struct /* T_element_to_local */ {

        // drake/multibody/shapes/element.h:62
        const char* doc = R"""()""";

      } T_element_to_local;

      // DrakeShapes::Element::T_element_to_world
      struct /* T_element_to_world */ {

        // drake/multibody/shapes/element.h:61
        const char* doc = R"""()""";

      } T_element_to_world;

      // DrakeShapes::Element::clone
      struct /* clone */ {

        // drake/multibody/shapes/element.h:30
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Element::geometry
      struct /* geometry */ {

        // drake/multibody/shapes/element.h:63
        const char* doc = R"""()""";

      } geometry;

      // DrakeShapes::Element::getGeometry
      struct /* getGeometry */ {

        // drake/multibody/shapes/element.h:46
        const char* doc = R"""()""";

      } getGeometry;

      // DrakeShapes::Element::getLocalTransform
      struct /* getLocalTransform */ {

        // drake/multibody/shapes/element.h:34
        const char* doc = R"""()""";

      } getLocalTransform;

      // DrakeShapes::Element::getShape
      struct /* getShape */ {

        // drake/multibody/shapes/element.h:40
        const char* doc = R"""()""";

      } getShape;

      // DrakeShapes::Element::getTerrainContactPoints
      struct /* getTerrainContactPoints */ {

        // drake/multibody/shapes/element.h:49
        const char* doc = R"""()""";

      } getTerrainContactPoints;

      // DrakeShapes::Element::getWorldTransform
      struct /* getWorldTransform */ {

        // drake/multibody/shapes/element.h:32
        const char* doc = R"""()""";

      } getWorldTransform;

      // DrakeShapes::Element::hasGeometry
      struct /* hasGeometry */ {

        // drake/multibody/shapes/element.h:44
        const char* doc = R"""()""";

      } hasGeometry;

      // DrakeShapes::Element::setGeometry
      struct /* setGeometry */ {

        // drake/multibody/shapes/element.h:42
        const char* doc = R"""()""";

      } setGeometry;

      // DrakeShapes::Element::setWorldTransform
      struct /* setWorldTransform */ {

        // drake/multibody/shapes/element.h:59
        const char* doc = R"""()""";

      } setWorldTransform;

      // DrakeShapes::Element::updateWorldTransform
      struct /* updateWorldTransform */ {

        // drake/multibody/shapes/element.h:38
        const char* doc = R"""()""";

      } updateWorldTransform;

    } Element;

    // DrakeShapes::Geometry
    struct /* Geometry */ {

      // drake/multibody/shapes/geometry.h:32
      const char* doc = R"""()""";

      // DrakeShapes::Geometry::Geometry
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:34
        const char* doc = R"""()""";

        // drake/multibody/shapes/geometry.h:77
        const char* doc_2 = R"""()""";

        // drake/multibody/shapes/geometry.h:80
        const char* doc_3 = R"""()""";

      } ctor;

      // DrakeShapes::Geometry::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:38
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Geometry::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:65
        const char* doc = R"""()""";

        // drake/multibody/shapes/geometry.h:83
        const char* doc_2 = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Geometry::getFaces
      struct /* getFaces */ {

        // drake/multibody/shapes/geometry.h:59
        const char* doc = R"""()""";

      } getFaces;

      // DrakeShapes::Geometry::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:43
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Geometry::getShape
      struct /* getShape */ {

        // drake/multibody/shapes/geometry.h:40
        const char* doc = R"""()""";

      } getShape;

      // DrakeShapes::Geometry::getTerrainContactPoints
      struct /* getTerrainContactPoints */ {

        // drake/multibody/shapes/geometry.h:67
        const char* doc = R"""()""";

      } getTerrainContactPoints;

      // DrakeShapes::Geometry::hasFaces
      struct /* hasFaces */ {

        // drake/multibody/shapes/geometry.h:47
        const char* doc =
R"""(Returns:
    `true` if this geometry can return faces.)""";

      } hasFaces;

      // DrakeShapes::Geometry::shape
      struct /* shape */ {

        // drake/multibody/shapes/geometry.h:88
        const char* doc = R"""()""";

      } shape;

    } Geometry;

    // DrakeShapes::Mesh
    struct /* Mesh */ {

      // drake/multibody/shapes/geometry.h:198
      const char* doc = R"""()""";

      // DrakeShapes::Mesh::LoadObjFile
      struct /* LoadObjFile */ {

        // drake/multibody/shapes/geometry.h:260
        const char* doc =
R"""(Loads triangle mesh from an obj file into the provided vectors of
vertices and triangles.

This method can optionally attempt to triangulate the mesh as it is
read. This triangulation is conservative. Non-triangular faces are
decomposed into a set of *equivalent* triangles. It places certain
requirements on the mesh for the triangulation to be valid. If these
requirements are not met, an exception is thrown. These requirements
are: 1. Non-triangular faces cannot contain a sequence of co-linear
vertices. 2. Non-triangular faces must be close to planar; the
decomposed triangles normals can deviate by no more than 30 degrees
from their edge-adjacent neighbors. 3. Decomposed triangles must have
an area larger than 10⁻¹⁰ m².

NOTE: The triangulation method is simple. Even if these requirements
are met, triangulation might fail.

Parameter ``vertices``:
    Vector of 3D vertices in the mesh.

Parameter ``triangles``:
    Vector of indices for each triangle in the mesh. The i-th entry of
    ``triangles`` holds a 3D vector of integer indices into
    ``vertices`` corresponding to the vertices forming the i-th
    triangle.

Parameter ``triangulate``:
    Specifies the triangulation policy.

On output, `vertices.size()` corresponds to the number of vertices in
the mesh while `triangles.size()` corresponds to the number of
triangles in the mesh.)""";

      } LoadObjFile;

      // DrakeShapes::Mesh::Mesh
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:210
        const char* doc =
R"""(Constructs a representation of a mesh to be loaded from
``resolved_filename``. ``uri`` provides a unique identifier used to
interact with BotVisualizer.)""";

      } ctor;

      // DrakeShapes::Mesh::TriangulatePolicy
      struct /* TriangulatePolicy */ {

        // drake/multibody/shapes/geometry.h:201
        const char* doc =
R"""(Specification of how the Mesh should process faces during parsing. */)""";

        // DrakeShapes::Mesh::TriangulatePolicy::kFailOnNonTri
        struct /* kFailOnNonTri */ {

          // drake/multibody/shapes/geometry.h:202
          const char* doc =
R"""(< Non-triangular faces cause an exception to be thrown.)""";

        } kFailOnNonTri;

        // DrakeShapes::Mesh::TriangulatePolicy::kTry
        struct /* kTry */ {

          // drake/multibody/shapes/geometry.h:203
          const char* doc =
R"""(< The parser will attempt to triangulate non-triangular < faces,
throwing an exception if the attempt fails.)""";

        } kTry;

      } TriangulatePolicy;

      // DrakeShapes::Mesh::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:212
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Mesh::extractMeshVertices
      struct /* extractMeshVertices */ {

        // drake/multibody/shapes/geometry.h:232
        const char* doc = R"""()""";

      } extractMeshVertices;

      // DrakeShapes::Mesh::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:221
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Mesh::getFaces
      struct /* getFaces */ {

        // drake/multibody/shapes/geometry.h:219
        const char* doc = R"""()""";

      } getFaces;

      // DrakeShapes::Mesh::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:214
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Mesh::hasFaces
      struct /* hasFaces */ {

        // drake/multibody/shapes/geometry.h:215
        const char* doc = R"""()""";

      } hasFaces;

      // DrakeShapes::Mesh::resolved_filename_
      struct /* resolved_filename_ */ {

        // drake/multibody/shapes/geometry.h:230
        const char* doc = R"""()""";

      } resolved_filename_;

      // DrakeShapes::Mesh::scale_
      struct /* scale_ */ {

        // drake/multibody/shapes/geometry.h:228
        const char* doc = R"""()""";

      } scale_;

      // DrakeShapes::Mesh::uri_
      struct /* uri_ */ {

        // drake/multibody/shapes/geometry.h:229
        const char* doc = R"""()""";

      } uri_;

    } Mesh;

    // DrakeShapes::MeshPoints
    struct /* MeshPoints */ {

      // drake/multibody/shapes/geometry.h:294
      const char* doc = R"""()""";

      // DrakeShapes::MeshPoints::MeshPoints
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:296
        const char* doc = R"""()""";

      } ctor;

      // DrakeShapes::MeshPoints::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:298
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::MeshPoints::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:303
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::MeshPoints::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:301
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::MeshPoints::points
      struct /* points */ {

        // drake/multibody/shapes/geometry.h:310
        const char* doc = R"""()""";

      } points;

    } MeshPoints;

    // DrakeShapes::Shape
    struct /* Shape */ {

      // drake/multibody/shapes/geometry.h:11
      const char* doc = R"""()""";

      // DrakeShapes::Shape::BOX
      struct /* BOX */ {

        // drake/multibody/shapes/geometry.h:13
        const char* doc = R"""()""";

      } BOX;

      // DrakeShapes::Shape::CAPSULE
      struct /* CAPSULE */ {

        // drake/multibody/shapes/geometry.h:18
        const char* doc = R"""()""";

      } CAPSULE;

      // DrakeShapes::Shape::CYLINDER
      struct /* CYLINDER */ {

        // drake/multibody/shapes/geometry.h:15
        const char* doc = R"""()""";

      } CYLINDER;

      // DrakeShapes::Shape::MESH
      struct /* MESH */ {

        // drake/multibody/shapes/geometry.h:16
        const char* doc = R"""()""";

      } MESH;

      // DrakeShapes::Shape::MESH_POINTS
      struct /* MESH_POINTS */ {

        // drake/multibody/shapes/geometry.h:17
        const char* doc = R"""()""";

      } MESH_POINTS;

      // DrakeShapes::Shape::SPHERE
      struct /* SPHERE */ {

        // drake/multibody/shapes/geometry.h:14
        const char* doc = R"""()""";

      } SPHERE;

      // DrakeShapes::Shape::UNKNOWN
      struct /* UNKNOWN */ {

        // drake/multibody/shapes/geometry.h:12
        const char* doc = R"""()""";

      } UNKNOWN;

    } Shape;

    // DrakeShapes::ShapeToString
    struct /* ShapeToString */ {

      // drake/multibody/shapes/geometry.h:24
      const char* doc = R"""()""";

    } ShapeToString;

    // DrakeShapes::Sphere
    struct /* Sphere */ {

      // drake/multibody/shapes/geometry.h:92
      const char* doc = R"""()""";

      // DrakeShapes::Sphere::Sphere
      struct /* ctor */ {

        // drake/multibody/shapes/geometry.h:94
        const char* doc = R"""()""";

      } ctor;

      // DrakeShapes::Sphere::clone
      struct /* clone */ {

        // drake/multibody/shapes/geometry.h:96
        const char* doc = R"""()""";

      } clone;

      // DrakeShapes::Sphere::getBoundingBoxPoints
      struct /* getBoundingBoxPoints */ {

        // drake/multibody/shapes/geometry.h:100
        const char* doc = R"""()""";

      } getBoundingBoxPoints;

      // DrakeShapes::Sphere::getPoints
      struct /* getPoints */ {

        // drake/multibody/shapes/geometry.h:98
        const char* doc = R"""()""";

      } getPoints;

      // DrakeShapes::Sphere::getTerrainContactPoints
      struct /* getTerrainContactPoints */ {

        // drake/multibody/shapes/geometry.h:102
        const char* doc = R"""()""";

      } getTerrainContactPoints;

      // DrakeShapes::Sphere::radius
      struct /* radius */ {

        // drake/multibody/shapes/geometry.h:109
        const char* doc = R"""()""";

      } radius;

    } Sphere;

    // DrakeShapes::VisualElement
    struct /* VisualElement */ {

      // drake/multibody/shapes/visual_element.h:12
      const char* doc = R"""()""";

      // DrakeShapes::VisualElement::VisualElement
      struct /* ctor */ {

        // drake/multibody/shapes/visual_element.h:14
        const char* doc = R"""()""";

        // drake/multibody/shapes/visual_element.h:21
        const char* doc_2 =
R"""(Constructs a geometry at a specified transform with a given material
(i.e. a color specified as a 4-vector of RGBA, each on [0, 1]).)""";

        // drake/multibody/shapes/visual_element.h:27
        const char* doc_3 =
R"""(Copy constructor for use by, e.g., std::vector. */)""";

        // drake/multibody/shapes/visual_element.h:29
        const char* doc_4 = R"""()""";

      } ctor;

      // DrakeShapes::VisualElement::getMaterial
      struct /* getMaterial */ {

        // drake/multibody/shapes/visual_element.h:42
        const char* doc =
R"""(Retrieves the element's material color, in RGBA format.)""";

      } getMaterial;

      // DrakeShapes::VisualElement::material
      struct /* material */ {

        // drake/multibody/shapes/visual_element.h:45
        const char* doc = R"""()""";

      } material;

      // DrakeShapes::VisualElement::name
      struct /* name */ {

        // drake/multibody/shapes/visual_element.h:46
        const char* doc = R"""()""";

      } name;

      // DrakeShapes::VisualElement::setMaterial
      struct /* setMaterial */ {

        // drake/multibody/shapes/visual_element.h:37
        const char* doc =
R"""(Sets the element's material color, in RGBA format.)""";

      } setMaterial;

    } VisualElement;

  } DrakeShapes;

  // EulerConstraint
  struct /* EulerConstraint */ {

    // drake/multibody/rigid_body_constraint.h:519
    const char* doc = R"""()""";

    // EulerConstraint::EulerConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:521
      const char* doc = R"""()""";

    } ctor;

    // EulerConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:528
      const char* doc = R"""()""";

    } bounds;

    // EulerConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:526
      const char* doc = R"""()""";

    } eval;

    // EulerConstraint::evalrpy
    struct /* evalrpy */ {

      // drake/multibody/rigid_body_constraint.h:532
      const char* doc = R"""()""";

    } evalrpy;

    // EulerConstraint::null_constraint_row
    struct /* null_constraint_row */ {

      // drake/multibody/rigid_body_constraint.h:534
      const char* doc = R"""()""";

    } null_constraint_row;

  } EulerConstraint;

  // FixedAxisOneDoFJoint
  struct /* FixedAxisOneDoFJoint */ {

    // drake/multibody/joints/fixed_axis_one_dof_joint.h:23
    const char* doc = R"""()""";

    // FixedAxisOneDoFJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:229
      const char* doc =
R"""(Initializes the private member variables within the provided `clone`.)""";

    } DoInitializeClone;

    // FixedAxisOneDoFJoint::FixedAxisOneDoFJoint<Derived>
    struct /* ctor */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:26
      const char* doc = R"""()""";

    } ctor;

    // FixedAxisOneDoFJoint::SetJointLimitDynamics
    struct /* SetJointLimitDynamics */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:148
      const char* doc = R"""()""";

    } SetJointLimitDynamics;

    // FixedAxisOneDoFJoint::SetSpringDynamics
    struct /* SetSpringDynamics */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:203
      const char* doc =
R"""(Set the spring stiffness and nominal position. The resuting force will
be torque = stiffness * (nominal_position - position).)""";

    } SetSpringDynamics;

    // FixedAxisOneDoFJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:129
      const char* doc =
R"""(Compute the spring torque for a simple singleaxis joint. Since this is
a one DOF joint, the input and output vectors will be length 1.

Torque is computed to be included in the dynamics bias terms, and thus
appears here with a "positive" gain.)""";

    } SpringTorque;

    // FixedAxisOneDoFJoint::coulomb_friction
    struct /* coulomb_friction */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:222
      const char* doc = R"""()""";

    } coulomb_friction;

    // FixedAxisOneDoFJoint::coulomb_window
    struct /* coulomb_window */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:223
      const char* doc = R"""()""";

    } coulomb_window;

    // FixedAxisOneDoFJoint::damping
    struct /* damping */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:221
      const char* doc = R"""()""";

    } damping;

    // FixedAxisOneDoFJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:108
      const char* doc = R"""()""";

    } frictionTorque;

    // FixedAxisOneDoFJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:215
      const char* doc = R"""()""";

    } getPositionName;

    // FixedAxisOneDoFJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:208
      const char* doc = R"""()""";

    } get_position_name;

    // FixedAxisOneDoFJoint::joint_axis
    struct /* joint_axis */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:219
      const char* doc = R"""()""";

    } joint_axis;

    // FixedAxisOneDoFJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:39
      const char* doc = R"""()""";

    } motionSubspace;

    // FixedAxisOneDoFJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:53
      const char* doc = R"""()""";

    } motionSubspaceDotTimesV;

    // FixedAxisOneDoFJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:78
      const char* doc = R"""()""";

    } qdot2v;

    // FixedAxisOneDoFJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:158
      const char* doc = R"""()""";

    } randomConfiguration;

    // FixedAxisOneDoFJoint::setDynamics
    struct /* setDynamics */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:192
      const char* doc = R"""()""";

    } setDynamics;

    // FixedAxisOneDoFJoint::setJointLimits
    struct /* setJointLimits */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:138
      const char* doc = R"""()""";

    } setJointLimits;

    // FixedAxisOneDoFJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:93
      const char* doc = R"""()""";

    } v2qdot;

    // FixedAxisOneDoFJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/fixed_axis_one_dof_joint.h:154
      const char* doc = R"""()""";

    } zeroConfiguration;

  } FixedAxisOneDoFJoint;

  // FixedJoint
  struct /* FixedJoint */ {

    // drake/multibody/joints/fixed_joint.h:12
    const char* doc = R"""()""";

    // FixedJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/fixed_joint.h:126
      const char* doc = R"""()""";

    } DoClone;

    // FixedJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/fixed_joint.h:127
      const char* doc = R"""()""";

    } DoInitializeClone;

    // FixedJoint::FixedJoint
    struct /* ctor */ {

      // drake/multibody/joints/fixed_joint.h:14
      const char* doc = R"""()""";

    } ctor;

    // FixedJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/fixed_joint.h:106
      const char* doc = R"""()""";

    } SpringTorque;

    // FixedJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/fixed_joint.h:98
      const char* doc = R"""()""";

    } frictionTorque;

    // FixedJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/fixed_joint.h:120
      const char* doc = R"""()""";

    } getPositionName;

    // FixedJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/fixed_joint.h:113
      const char* doc = R"""()""";

    } get_position_name;

    // FixedJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/fixed_joint.h:22
      const char* doc = R"""()""";

    } jointTransform;

    // FixedJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/fixed_joint.h:29
      const char* doc = R"""()""";

    } motionSubspace;

    // FixedJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/fixed_joint.h:43
      const char* doc = R"""()""";

    } motionSubspaceDotTimesV;

    // FixedJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/fixed_joint.h:68
      const char* doc = R"""()""";

    } qdot2v;

    // FixedJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/fixed_joint.h:115
      const char* doc = R"""()""";

    } randomConfiguration;

    // FixedJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/fixed_joint.h:83
      const char* doc = R"""()""";

    } v2qdot;

    // FixedJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/fixed_joint.h:114
      const char* doc = R"""()""";

    } zeroConfiguration;

  } FixedJoint;

  // ForceTorqueMeasurement
  struct /* ForceTorqueMeasurement */ {

    // drake/multibody/force_torque_measurement.h:5
    const char* doc = R"""()""";

    // ForceTorqueMeasurement::frame_idx
    struct /* frame_idx */ {

      // drake/multibody/force_torque_measurement.h:6
      const char* doc = R"""()""";

    } frame_idx;

    // ForceTorqueMeasurement::wrench
    struct /* wrench */ {

      // drake/multibody/force_torque_measurement.h:7
      const char* doc = R"""()""";

    } wrench;

  } ForceTorqueMeasurement;

  // GazeConstraint
  struct /* GazeConstraint */ {

    // drake/multibody/rigid_body_constraint.h:561
    const char* doc = R"""()""";

    // GazeConstraint::GazeConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:563
      const char* doc = R"""()""";

    } ctor;

    // GazeConstraint::get_axis
    struct /* get_axis */ {

      // drake/multibody/rigid_body_constraint.h:571
      const char* doc = R"""()""";

    } get_axis;

    // GazeConstraint::get_conethreshold
    struct /* get_conethreshold */ {

      // drake/multibody/rigid_body_constraint.h:570
      const char* doc = R"""()""";

    } get_conethreshold;

  } GazeConstraint;

  // GazeDirConstraint
  struct /* GazeDirConstraint */ {

    // drake/multibody/rigid_body_constraint.h:625
    const char* doc = R"""()""";

    // GazeDirConstraint::GazeDirConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:627
      const char* doc = R"""()""";

    } ctor;

    // GazeDirConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:632
      const char* doc = R"""()""";

    } bounds;

    // GazeDirConstraint::get_dir
    struct /* get_dir */ {

      // drake/multibody/rigid_body_constraint.h:636
      const char* doc = R"""()""";

    } get_dir;

  } GazeDirConstraint;

  // GazeOrientConstraint
  struct /* GazeOrientConstraint */ {

    // drake/multibody/rigid_body_constraint.h:581
    const char* doc = R"""()""";

    // GazeOrientConstraint::GazeOrientConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:583
      const char* doc = R"""()""";

    } ctor;

    // GazeOrientConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:590
      const char* doc = R"""()""";

    } bounds;

    // GazeOrientConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:588
      const char* doc = R"""()""";

    } eval;

    // GazeOrientConstraint::evalOrientation
    struct /* evalOrientation */ {

      // drake/multibody/rigid_body_constraint.h:594
      const char* doc = R"""()""";

    } evalOrientation;

  } GazeOrientConstraint;

  // GazeTargetConstraint
  struct /* GazeTargetConstraint */ {

    // drake/multibody/rigid_body_constraint.h:661
    const char* doc = R"""()""";

    // GazeTargetConstraint::GazeTargetConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:663
      const char* doc = R"""()""";

    } ctor;

    // GazeTargetConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:669
      const char* doc = R"""()""";

    } bounds;

    // GazeTargetConstraint::get_gaze_origin
    struct /* get_gaze_origin */ {

      // drake/multibody/rigid_body_constraint.h:674
      const char* doc = R"""()""";

    } get_gaze_origin;

    // GazeTargetConstraint::get_target
    struct /* get_target */ {

      // drake/multibody/rigid_body_constraint.h:673
      const char* doc = R"""()""";

    } get_target;

  } GazeTargetConstraint;

  // GravityCompensationTorqueConstraint
  struct /* GravityCompensationTorqueConstraint */ {

    // drake/multibody/rigid_body_constraint.h:976
    const char* doc = R"""()""";

    // GravityCompensationTorqueConstraint::GravityCompensationTorqueConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:979
      const char* doc = R"""()""";

    } ctor;

    // GravityCompensationTorqueConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:987
      const char* doc = R"""()""";

    } bounds;

    // GravityCompensationTorqueConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:984
      const char* doc = R"""()""";

    } eval;

    // GravityCompensationTorqueConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:986
      const char* doc = R"""()""";

    } name;

  } GravityCompensationTorqueConstraint;

  // HardwareGains
  struct /* HardwareGains */ {

    // drake/systems/controllers/QPCommon.h:181
    const char* doc = R"""()""";

    // HardwareGains::HardwareGains
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:182
      const char* doc = R"""()""";

    } ctor;

    // HardwareGains::ff_const
    struct /* ff_const */ {

      // drake/systems/controllers/QPCommon.h:198
      const char* doc = R"""()""";

    } ff_const;

    // HardwareGains::ff_f_d
    struct /* ff_f_d */ {

      // drake/systems/controllers/QPCommon.h:197
      const char* doc = R"""()""";

    } ff_f_d;

    // HardwareGains::ff_qd
    struct /* ff_qd */ {

      // drake/systems/controllers/QPCommon.h:196
      const char* doc = R"""()""";

    } ff_qd;

    // HardwareGains::ff_qd_d
    struct /* ff_qd_d */ {

      // drake/systems/controllers/QPCommon.h:199
      const char* doc = R"""()""";

    } ff_qd_d;

    // HardwareGains::k_f_p
    struct /* k_f_p */ {

      // drake/systems/controllers/QPCommon.h:192
      const char* doc = R"""()""";

    } k_f_p;

    // HardwareGains::k_q_i
    struct /* k_q_i */ {

      // drake/systems/controllers/QPCommon.h:194
      const char* doc = R"""()""";

    } k_q_i;

    // HardwareGains::k_q_p
    struct /* k_q_p */ {

      // drake/systems/controllers/QPCommon.h:193
      const char* doc = R"""()""";

    } k_q_p;

    // HardwareGains::k_qd_p
    struct /* k_qd_p */ {

      // drake/systems/controllers/QPCommon.h:195
      const char* doc = R"""()""";

    } k_qd_p;

  } HardwareGains;

  // HardwareParams
  struct /* HardwareParams */ {

    // drake/systems/controllers/QPCommon.h:212
    const char* doc = R"""()""";

    // HardwareParams::HardwareParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:213
      const char* doc = R"""()""";

    } ctor;

    // HardwareParams::gains
    struct /* gains */ {

      // drake/systems/controllers/QPCommon.h:221
      const char* doc = R"""()""";

    } gains;

    // HardwareParams::joint_is_force_controlled
    struct /* joint_is_force_controlled */ {

      // drake/systems/controllers/QPCommon.h:222
      const char* doc = R"""()""";

    } joint_is_force_controlled;

    // HardwareParams::joint_is_position_controlled
    struct /* joint_is_position_controlled */ {

      // drake/systems/controllers/QPCommon.h:223
      const char* doc = R"""()""";

    } joint_is_position_controlled;

  } HardwareParams;

  // HelicalJoint
  struct /* HelicalJoint */ {

    // drake/multibody/joints/helical_joint.h:11
    const char* doc = R"""()""";

    // HelicalJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/helical_joint.h:41
      const char* doc = R"""()""";

    } DoClone;

    // HelicalJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/helical_joint.h:42
      const char* doc = R"""()""";

    } DoInitializeClone;

    // HelicalJoint::HelicalJoint
    struct /* ctor */ {

      // drake/multibody/joints/helical_joint.h:13
      const char* doc = R"""()""";

    } ctor;

    // HelicalJoint::axis
    struct /* axis */ {

      // drake/multibody/joints/helical_joint.h:35
      const char* doc = R"""()""";

    } axis;

    // HelicalJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/helical_joint.h:26
      const char* doc = R"""()""";

    } jointTransform;

    // HelicalJoint::pitch
    struct /* pitch */ {

      // drake/multibody/joints/helical_joint.h:36
      const char* doc = R"""()""";

    } pitch;

  } HelicalJoint;

  // IKResults
  struct /* IKResults */ {

    // drake/multibody/rigid_body_ik.h:65
    const char* doc =
R"""(Return type for simplified versions of IK functions.)""";

    // IKResults::infeasible_constraints
    struct /* infeasible_constraints */ {

      // drake/multibody/rigid_body_ik.h:68
      const char* doc = R"""()""";

    } infeasible_constraints;

    // IKResults::info
    struct /* info */ {

      // drake/multibody/rigid_body_ik.h:67
      const char* doc = R"""()""";

    } info;

    // IKResults::q_sol
    struct /* q_sol */ {

      // drake/multibody/rigid_body_ik.h:66
      const char* doc = R"""()""";

    } q_sol;

  } IKResults;

  // IKoptions
  struct /* IKoptions */ {

    // drake/multibody/ik_options.h:8
    const char* doc = R"""()""";

    // drake/multibody/inverse_kinematics_backend.h:13
    const char* doc_2 = R"""()""";

    // IKoptions::IKoptions
    struct /* ctor */ {

      // drake/multibody/ik_options.h:35
      const char* doc = R"""()""";

      // drake/multibody/ik_options.h:36
      const char* doc_2 = R"""()""";

    } ctor;

    // IKoptions::getAdditionaltSamples
    struct /* getAdditionaltSamples */ {

      // drake/multibody/ik_options.h:75
      const char* doc = R"""()""";

    } getAdditionaltSamples;

    // IKoptions::getDebug
    struct /* getDebug */ {

      // drake/multibody/ik_options.h:67
      const char* doc = R"""()""";

    } getDebug;

    // IKoptions::getFixInitialState
    struct /* getFixInitialState */ {

      // drake/multibody/ik_options.h:76
      const char* doc = R"""()""";

    } getFixInitialState;

    // IKoptions::getIterationsLimit
    struct /* getIterationsLimit */ {

      // drake/multibody/ik_options.h:73
      const char* doc = R"""()""";

    } getIterationsLimit;

    // IKoptions::getMajorFeasibilityTolerance
    struct /* getMajorFeasibilityTolerance */ {

      // drake/multibody/ik_options.h:70
      const char* doc = R"""()""";

    } getMajorFeasibilityTolerance;

    // IKoptions::getMajorIterationsLimit
    struct /* getMajorIterationsLimit */ {

      // drake/multibody/ik_options.h:72
      const char* doc = R"""()""";

    } getMajorIterationsLimit;

    // IKoptions::getMajorOptimalityTolerance
    struct /* getMajorOptimalityTolerance */ {

      // drake/multibody/ik_options.h:69
      const char* doc = R"""()""";

    } getMajorOptimalityTolerance;

    // IKoptions::getQ
    struct /* getQ */ {

      // drake/multibody/ik_options.h:62
      const char* doc = R"""()""";

    } getQ;

    // IKoptions::getQa
    struct /* getQa */ {

      // drake/multibody/ik_options.h:64
      const char* doc = R"""()""";

    } getQa;

    // IKoptions::getQv
    struct /* getQv */ {

      // drake/multibody/ik_options.h:66
      const char* doc = R"""()""";

    } getQv;

    // IKoptions::getRobotPtr
    struct /* getRobotPtr */ {

      // drake/multibody/ik_options.h:38
      const char* doc = R"""()""";

    } getRobotPtr;

    // IKoptions::getSequentialSeedFlag
    struct /* getSequentialSeedFlag */ {

      // drake/multibody/ik_options.h:68
      const char* doc = R"""()""";

    } getSequentialSeedFlag;

    // IKoptions::getSuperbasicsLimit
    struct /* getSuperbasicsLimit */ {

      // drake/multibody/ik_options.h:71
      const char* doc = R"""()""";

    } getSuperbasicsLimit;

    // IKoptions::getq0
    struct /* getq0 */ {

      // drake/multibody/ik_options.h:78
      const char* doc = R"""()""";

    } getq0;

    // IKoptions::getqd0
    struct /* getqd0 */ {

      // drake/multibody/ik_options.h:80
      const char* doc = R"""()""";

    } getqd0;

    // IKoptions::getqdf
    struct /* getqdf */ {

      // drake/multibody/ik_options.h:82
      const char* doc = R"""()""";

    } getqdf;

    // IKoptions::setAdditionaltSamples
    struct /* setAdditionaltSamples */ {

      // drake/multibody/ik_options.h:59
      const char* doc = R"""()""";

    } setAdditionaltSamples;

    // IKoptions::setDebug
    struct /* setDebug */ {

      // drake/multibody/ik_options.h:48
      const char* doc = R"""()""";

    } setDebug;

    // IKoptions::setDefaultParams
    struct /* setDefaultParams */ {

      // drake/multibody/ik_options.h:32
      const char* doc = R"""()""";

    } setDefaultParams;

    // IKoptions::setFixInitialState
    struct /* setFixInitialState */ {

      // drake/multibody/ik_options.h:55
      const char* doc = R"""()""";

    } setFixInitialState;

    // IKoptions::setIterationsLimit
    struct /* setIterationsLimit */ {

      // drake/multibody/ik_options.h:54
      const char* doc = R"""()""";

    } setIterationsLimit;

    // IKoptions::setMajorFeasibilityTolerance
    struct /* setMajorFeasibilityTolerance */ {

      // drake/multibody/ik_options.h:51
      const char* doc = R"""()""";

    } setMajorFeasibilityTolerance;

    // IKoptions::setMajorIterationsLimit
    struct /* setMajorIterationsLimit */ {

      // drake/multibody/ik_options.h:53
      const char* doc = R"""()""";

    } setMajorIterationsLimit;

    // IKoptions::setMajorOptimalityTolerance
    struct /* setMajorOptimalityTolerance */ {

      // drake/multibody/ik_options.h:50
      const char* doc = R"""()""";

    } setMajorOptimalityTolerance;

    // IKoptions::setQ
    struct /* setQ */ {

      // drake/multibody/ik_options.h:45
      const char* doc =
R"""(Sets the quadratic cost matrix Q where the cost for the optimization
is formulated as q_err' Q q_err, where q_err = q - q_nominal)""";

    } setQ;

    // IKoptions::setQa
    struct /* setQa */ {

      // drake/multibody/ik_options.h:46
      const char* doc = R"""()""";

    } setQa;

    // IKoptions::setQv
    struct /* setQv */ {

      // drake/multibody/ik_options.h:47
      const char* doc = R"""()""";

    } setQv;

    // IKoptions::setSequentialSeedFlag
    struct /* setSequentialSeedFlag */ {

      // drake/multibody/ik_options.h:49
      const char* doc = R"""()""";

    } setSequentialSeedFlag;

    // IKoptions::setSuperbasicsLimit
    struct /* setSuperbasicsLimit */ {

      // drake/multibody/ik_options.h:52
      const char* doc = R"""()""";

    } setSuperbasicsLimit;

    // IKoptions::setq0
    struct /* setq0 */ {

      // drake/multibody/ik_options.h:56
      const char* doc = R"""()""";

    } setq0;

    // IKoptions::setqd0
    struct /* setqd0 */ {

      // drake/multibody/ik_options.h:57
      const char* doc = R"""()""";

    } setqd0;

    // IKoptions::setqdf
    struct /* setqdf */ {

      // drake/multibody/ik_options.h:58
      const char* doc = R"""()""";

    } setqdf;

    // IKoptions::updateRobot
    struct /* updateRobot */ {

      // drake/multibody/ik_options.h:60
      const char* doc = R"""()""";

    } updateRobot;

  } IKoptions;

  // IntegratorParams
  struct /* IntegratorParams */ {

    // drake/systems/controllers/QPCommon.h:71
    const char* doc = R"""()""";

    // IntegratorParams::IntegratorParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:72
      const char* doc = R"""()""";

    } ctor;

    // IntegratorParams::clamps
    struct /* clamps */ {

      // drake/systems/controllers/QPCommon.h:78
      const char* doc = R"""()""";

    } clamps;

    // IntegratorParams::eta
    struct /* eta */ {

      // drake/systems/controllers/QPCommon.h:79
      const char* doc = R"""()""";

    } eta;

    // IntegratorParams::gains
    struct /* gains */ {

      // drake/systems/controllers/QPCommon.h:77
      const char* doc = R"""()""";

    } gains;

  } IntegratorParams;

  // JointNames
  struct /* JointNames */ {

    // drake/systems/controllers/controlUtil.h:132
    const char* doc = R"""()""";

    // JointNames::drake
    struct /* drake */ {

      // drake/systems/controllers/controlUtil.h:134
      const char* doc = R"""()""";

    } drake;

    // JointNames::robot
    struct /* robot */ {

      // drake/systems/controllers/controlUtil.h:133
      const char* doc = R"""()""";

    } robot;

  } JointNames;

  // JointSoftLimitParams
  struct /* JointSoftLimitParams */ {

    // drake/systems/controllers/QPCommon.h:101
    const char* doc = R"""()""";

    // JointSoftLimitParams::JointSoftLimitParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:102
      const char* doc = R"""()""";

    } ctor;

    // JointSoftLimitParams::disable_when_body_in_support
    struct /* disable_when_body_in_support */ {

      // drake/systems/controllers/QPCommon.h:115
      const char* doc = R"""()""";

    } disable_when_body_in_support;

    // JointSoftLimitParams::enabled
    struct /* enabled */ {

      // drake/systems/controllers/QPCommon.h:114
      const char* doc = R"""()""";

    } enabled;

    // JointSoftLimitParams::k_logistic
    struct /* k_logistic */ {

      // drake/systems/controllers/QPCommon.h:121
      const char* doc = R"""()""";

    } k_logistic;

    // JointSoftLimitParams::kd
    struct /* kd */ {

      // drake/systems/controllers/QPCommon.h:119
      const char* doc = R"""()""";

    } kd;

    // JointSoftLimitParams::kp
    struct /* kp */ {

      // drake/systems/controllers/QPCommon.h:118
      const char* doc = R"""()""";

    } kp;

    // JointSoftLimitParams::lb
    struct /* lb */ {

      // drake/systems/controllers/QPCommon.h:116
      const char* doc = R"""()""";

    } lb;

    // JointSoftLimitParams::ub
    struct /* ub */ {

      // drake/systems/controllers/QPCommon.h:117
      const char* doc = R"""()""";

    } ub;

    // JointSoftLimitParams::weight
    struct /* weight */ {

      // drake/systems/controllers/QPCommon.h:120
      const char* doc = R"""()""";

    } weight;

  } JointSoftLimitParams;

  // KinematicModifications
  struct /* KinematicModifications */ {

    // drake/systems/controllers/QPCommon.h:370
    const char* doc = R"""()""";

    // KinematicModifications::KinematicModifications
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:375
      const char* doc = R"""()""";

    } ctor;

    // KinematicModifications::attachments
    struct /* attachments */ {

      // drake/systems/controllers/QPCommon.h:373
      const char* doc = R"""()""";

    } attachments;

    // KinematicModifications::collision_groups_to_keep
    struct /* collision_groups_to_keep */ {

      // drake/systems/controllers/QPCommon.h:372
      const char* doc = R"""()""";

    } collision_groups_to_keep;

  } KinematicModifications;

  // KinematicPath
  struct /* KinematicPath */ {

    // drake/multibody/kinematic_path.h:6
    const char* doc = R"""()""";

    // KinematicPath::body_path
    struct /* body_path */ {

      // drake/multibody/kinematic_path.h:9
      const char* doc = R"""()""";

    } body_path;

    // KinematicPath::joint_direction_signs
    struct /* joint_direction_signs */ {

      // drake/multibody/kinematic_path.h:8
      const char* doc = R"""()""";

    } joint_direction_signs;

    // KinematicPath::joint_path
    struct /* joint_path */ {

      // drake/multibody/kinematic_path.h:7
      const char* doc = R"""()""";

    } joint_path;

  } KinematicPath;

  // KinematicsCache
  struct /* KinematicsCache */ {

    // drake/multibody/kinematics_cache.h:75
    const char* doc = R"""()""";

    // KinematicsCache::CreateCacheElement
    struct /* CreateCacheElement */ {

      // drake/multibody/kinematics_cache-inl.h:27
      const char* doc =
R"""(Requests a cache entry for a body mobilized by a joint with
``num_positions`` and ``num_velocities``.)""";

      // drake/multibody/kinematics_cache.h:146
      const char* doc_2 =
R"""(Requests a cache entry for a body mobilized by a joint with
``num_positions`` and ``num_velocities``.)""";

    } CreateCacheElement;

    // KinematicsCache::DataInCalcFrameSpatialVelocityJacobianInWorldFrame
    struct /* DataInCalcFrameSpatialVelocityJacobianInWorldFrame */ {

      // drake/multibody/kinematics_cache.h:104
      const char* doc =
R"""(Preallocated variables used in
CalcFrameSpatialVelocityJacobianInWorldFrame.)""";

      // KinematicsCache::DataInCalcFrameSpatialVelocityJacobianInWorldFrame::J_positions
      struct /* J_positions */ {

        // drake/multibody/kinematics_cache.h:107
        const char* doc =
R"""(Jacobians used as an intermediate representation since the Jacobian
can not be transformed in place.)""";

      } J_positions;

      // KinematicsCache::DataInCalcFrameSpatialVelocityJacobianInWorldFrame::J_velocities
      struct /* J_velocities */ {

        // drake/multibody/kinematics_cache.h:108
        const char* doc = R"""()""";

      } J_velocities;

      // KinematicsCache::DataInCalcFrameSpatialVelocityJacobianInWorldFrame::v_or_q_indices
      struct /* v_or_q_indices */ {

        // drake/multibody/kinematics_cache.h:110
        const char* doc =
R"""(Vector of indices used to transform to the world frame.)""";

      } v_or_q_indices;

    } DataInCalcFrameSpatialVelocityJacobianInWorldFrame;

    // KinematicsCache::DataInGeometricJacobian
    struct /* DataInGeometricJacobian */ {

      // drake/multibody/kinematics_cache.h:95
      const char* doc =
R"""(Preallocated variables used in GeometricJacobian. Preallocated as the
size of the path is dependent on the base body/frame and end effector
body/frame.)""";

      // KinematicsCache::DataInGeometricJacobian::end_body_ancestors
      struct /* end_body_ancestors */ {

        // drake/multibody/kinematics_cache.h:98
        const char* doc = R"""()""";

      } end_body_ancestors;

      // KinematicsCache::DataInGeometricJacobian::kinematic_path
      struct /* kinematic_path */ {

        // drake/multibody/kinematics_cache.h:96
        const char* doc = R"""()""";

      } kinematic_path;

      // KinematicsCache::DataInGeometricJacobian::start_body_ancestors
      struct /* start_body_ancestors */ {

        // drake/multibody/kinematics_cache.h:97
        const char* doc = R"""()""";

      } start_body_ancestors;

    } DataInGeometricJacobian;

    // KinematicsCache::KinematicsCache<T>
    struct /* ctor */ {

      // drake/multibody/kinematics_cache-inl.h:33
      const char* doc =
R"""(Constructor for a KinematicsCache given the number of positions and
velocities per body in the vectors ``num_joint_positions`` and
``num_joint_velocities``, respectively.

For a RigidBodyTree with `nbodies` rigid bodies, `num_joint_positions`
and `num_joint_velocities` are vectors of size `nbodies` containing in
the i-th entry the number of positions and the number of velocities
for the i-th RigidBody in the RigidBodyTree.

Note that you will typically not create a KinematicsCache object using
this constructor. Instead, you usually obtain a KinematicsCache object
by calling RigidBodyTree::CreateKinematicsCache() or
RigidBodyTree::CreateKinematicsCacheWithType(). The second option is
useful if you need a particular type for your cache like
Eigen::AutoDiffScalar.

For examples on how to create and use the KinematicsCache, see
rigid_body_tree_dynamics_test.cc and
rigid_body_tree_kinematics_test.cc.

Parameter ``num_positions``:
    Total number of positions in the RigidBodyTree.

Parameter ``num_velocities``:
    Total number of velocities in the RigidBodyTree.

Parameter ``num_joint_positions``:
    A `std::vector<int>` containing in the i-th entry the number of
    positions for the i-th body in the RigidBodyTree.

Parameter ``num_joint_velocities``:
    A `std::vector<int>` containing in the i-th entry the number of
    velocities for the i-th body in the RigidBodyTree.)""";

      // drake/multibody/kinematics_cache.h:140
      const char* doc_2 =
R"""(Constructor for a KinematicsCache given the number of positions and
velocities per body in the vectors ``num_joint_positions`` and
``num_joint_velocities``, respectively.

For a RigidBodyTree with `nbodies` rigid bodies, `num_joint_positions`
and `num_joint_velocities` are vectors of size `nbodies` containing in
the i-th entry the number of positions and the number of velocities
for the i-th RigidBody in the RigidBodyTree.

Note that you will typically not create a KinematicsCache object using
this constructor. Instead, you usually obtain a KinematicsCache object
by calling RigidBodyTree::CreateKinematicsCache() or
RigidBodyTree::CreateKinematicsCacheWithType(). The second option is
useful if you need a particular type for your cache like
Eigen::AutoDiffScalar.

For examples on how to create and use the KinematicsCache, see
rigid_body_tree_dynamics_test.cc and
rigid_body_tree_kinematics_test.cc.

Parameter ``num_positions``:
    Total number of positions in the RigidBodyTree.

Parameter ``num_velocities``:
    Total number of velocities in the RigidBodyTree.

Parameter ``num_joint_positions``:
    A `std::vector<int>` containing in the i-th entry the number of
    positions for the i-th body in the RigidBodyTree.

Parameter ``num_joint_velocities``:
    A `std::vector<int>` containing in the i-th entry the number of
    velocities for the i-th body in the RigidBodyTree.)""";

    } ctor;

    // KinematicsCache::areInertiasCached
    struct /* areInertiasCached */ {

      // drake/multibody/kinematics_cache-inl.h:156
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:187
      const char* doc_2 = R"""()""";

    } areInertiasCached;

    // KinematicsCache::checkCachedKinematicsSettings
    struct /* checkCachedKinematicsSettings */ {

      // drake/multibody/kinematics_cache-inl.h:102
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:161
      const char* doc_2 = R"""()""";

    } checkCachedKinematicsSettings;

    // KinematicsCache::geometric_jacobian_temp
    struct /* geometric_jacobian_temp */ {

      // drake/multibody/kinematics_cache.h:100
      const char* doc = R"""()""";

    } geometric_jacobian_temp;

    // KinematicsCache::getNumPositions
    struct /* getNumPositions */ {

      // drake/multibody/kinematics_cache-inl.h:177
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:199
      const char* doc_2 = R"""()""";

    } getNumPositions;

    // KinematicsCache::getNumVelocities
    struct /* getNumVelocities */ {

      // drake/multibody/kinematics_cache-inl.h:183
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:205
      const char* doc_2 = R"""()""";

    } getNumVelocities;

    // KinematicsCache::getQ
    struct /* getQ */ {

      // drake/multibody/kinematics_cache-inl.h:124
      const char* doc =
R"""(Returns `q`, the generalized position vector of the RigidBodyTree that
was used to compute this KinematicsCache.)""";

      // drake/multibody/kinematics_cache.h:167
      const char* doc_2 =
R"""(Returns `q`, the generalized position vector of the RigidBodyTree that
was used to compute this KinematicsCache.)""";

    } getQ;

    // KinematicsCache::getV
    struct /* getV */ {

      // drake/multibody/kinematics_cache-inl.h:129
      const char* doc =
R"""(Returns `v`, the generalized velocity vector of the RigidBodyTree that
was used to compute this KinematicsCache.)""";

      // drake/multibody/kinematics_cache.h:171
      const char* doc_2 =
R"""(Returns `v`, the generalized velocity vector of the RigidBodyTree that
was used to compute this KinematicsCache.)""";

    } getV;

    // KinematicsCache::getX
    struct /* getX */ {

      // drake/multibody/kinematics_cache-inl.h:138
      const char* doc =
R"""(Returns `x`, the state vector of the RigidBodyTree that was used to
compute this KinematicsCache. This is the concatenation of `q`, the
RigidBodyTree's generalized position vector, and `v` the
RigidBodyTree's generalized velocity vector into a single vector.
Within `x`, `q` precedes `v`.)""";

      // drake/multibody/kinematics_cache.h:178
      const char* doc_2 =
R"""(Returns `x`, the state vector of the RigidBodyTree that was used to
compute this KinematicsCache. This is the concatenation of `q`, the
RigidBodyTree's generalized position vector, and `v` the
RigidBodyTree's generalized velocity vector into a single vector.
Within `x`, `q` precedes `v`.)""";

    } getX;

    // KinematicsCache::get_element
    struct /* get_element */ {

      // drake/multibody/kinematics_cache-inl.h:65
      const char* doc =
R"""(Returns constant reference to a cache entry for body ``body_id``.)""";

      // drake/multibody/kinematics_cache.h:149
      const char* doc_2 =
R"""(Returns constant reference to a cache entry for body ``body_id``.)""";

    } get_element;

    // KinematicsCache::get_mutable_element
    struct /* get_mutable_element */ {

      // drake/multibody/kinematics_cache-inl.h:71
      const char* doc =
R"""(Returns mutable pointer to a cache entry for body ``body_id``.)""";

      // drake/multibody/kinematics_cache.h:152
      const char* doc_2 =
R"""(Returns mutable pointer to a cache entry for body ``body_id``.)""";

    } get_mutable_element;

    // KinematicsCache::get_num_cache_elements
    struct /* get_num_cache_elements */ {

      // drake/multibody/kinematics_cache-inl.h:169
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:193
      const char* doc_2 = R"""()""";

    } get_num_cache_elements;

    // KinematicsCache::get_num_positions
    struct /* get_num_positions */ {

      // drake/multibody/kinematics_cache-inl.h:174
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:195
      const char* doc_2 = R"""()""";

    } get_num_positions;

    // KinematicsCache::get_num_velocities
    struct /* get_num_velocities */ {

      // drake/multibody/kinematics_cache-inl.h:180
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:201
      const char* doc_2 = R"""()""";

    } get_num_velocities;

    // KinematicsCache::hasV
    struct /* hasV */ {

      // drake/multibody/kinematics_cache-inl.h:150
      const char* doc =
R"""(Returns `true` if this KinematicsCache object has a valid `v` vector.
`v` is the generalized velocity vector of the RigidBodyTree that was
used to compute this KinematicsCache.)""";

      // drake/multibody/kinematics_cache.h:183
      const char* doc_2 =
R"""(Returns `true` if this KinematicsCache object has a valid `v` vector.
`v` is the generalized velocity vector of the RigidBodyTree that was
used to compute this KinematicsCache.)""";

    } hasV;

    // KinematicsCache::initialize
    struct /* initialize */ {

      // drake/multibody/kinematics_cache-inl.h:78
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache-inl.h:90
      const char* doc_2 = R"""()""";

      // drake/multibody/kinematics_cache.h:155
      const char* doc_3 = R"""()""";

      // drake/multibody/kinematics_cache.h:158
      const char* doc_4 = R"""()""";

    } initialize;

    // KinematicsCache::setInertiasCached
    struct /* setInertiasCached */ {

      // drake/multibody/kinematics_cache-inl.h:153
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:185
      const char* doc_2 = R"""()""";

    } setInertiasCached;

    // KinematicsCache::setJdotVCached
    struct /* setJdotVCached */ {

      // drake/multibody/kinematics_cache-inl.h:164
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:191
      const char* doc_2 = R"""()""";

    } setJdotVCached;

    // KinematicsCache::setPositionKinematicsCached
    struct /* setPositionKinematicsCached */ {

      // drake/multibody/kinematics_cache-inl.h:159
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:189
      const char* doc_2 = R"""()""";

    } setPositionKinematicsCached;

    // KinematicsCache::spatial_velocity_jacobian_temp
    struct /* spatial_velocity_jacobian_temp */ {

      // drake/multibody/kinematics_cache.h:113
      const char* doc = R"""()""";

    } spatial_velocity_jacobian_temp;

  } KinematicsCache;

  // KinematicsCacheElement
  struct /* KinematicsCacheElement */ {

    // drake/multibody/kinematics_cache.h:23
    const char* doc = R"""()""";

    // KinematicsCacheElement::KinematicsCacheElement<T>
    struct /* ctor */ {

      // drake/multibody/kinematics_cache-inl.h:17
      const char* doc = R"""()""";

      // drake/multibody/kinematics_cache.h:65
      const char* doc_2 = R"""()""";

    } ctor;

    // KinematicsCacheElement::crb_in_world
    struct /* crb_in_world */ {

      // drake/multibody/kinematics_cache.h:50
      const char* doc = R"""()""";

    } crb_in_world;

    // KinematicsCacheElement::get_num_positions
    struct /* get_num_positions */ {

      // drake/multibody/kinematics_cache.h:67
      const char* doc = R"""()""";

    } get_num_positions;

    // KinematicsCacheElement::get_num_velocities
    struct /* get_num_velocities */ {

      // drake/multibody/kinematics_cache.h:68
      const char* doc = R"""()""";

    } get_num_velocities;

    // KinematicsCacheElement::inertia_in_world
    struct /* inertia_in_world */ {

      // drake/multibody/kinematics_cache.h:49
      const char* doc = R"""()""";

    } inertia_in_world;

    // KinematicsCacheElement::motion_subspace_in_body
    struct /* motion_subspace_in_body */ {

      // drake/multibody/kinematics_cache.h:33
      const char* doc = R"""()""";

    } motion_subspace_in_body;

    // KinematicsCacheElement::motion_subspace_in_body_dot_times_v
    struct /* motion_subspace_in_body_dot_times_v */ {

      // drake/multibody/kinematics_cache.h:60
      const char* doc = R"""()""";

    } motion_subspace_in_body_dot_times_v;

    // KinematicsCacheElement::motion_subspace_in_world
    struct /* motion_subspace_in_world */ {

      // drake/multibody/kinematics_cache.h:36
      const char* doc = R"""()""";

    } motion_subspace_in_world;

    // KinematicsCacheElement::motion_subspace_in_world_dot_times_v
    struct /* motion_subspace_in_world_dot_times_v */ {

      // drake/multibody/kinematics_cache.h:62
      const char* doc = R"""()""";

    } motion_subspace_in_world_dot_times_v;

    // KinematicsCacheElement::qdot_to_v
    struct /* qdot_to_v */ {

      // drake/multibody/kinematics_cache.h:42
      const char* doc = R"""()""";

    } qdot_to_v;

    // KinematicsCacheElement::transform_to_world
    struct /* transform_to_world */ {

      // drake/multibody/kinematics_cache.h:30
      const char* doc = R"""()""";

    } transform_to_world;

    // KinematicsCacheElement::twist_in_world
    struct /* twist_in_world */ {

      // drake/multibody/kinematics_cache.h:58
      const char* doc = R"""()""";

    } twist_in_world;

    // KinematicsCacheElement::v_to_qdot
    struct /* v_to_qdot */ {

      // drake/multibody/kinematics_cache.h:48
      const char* doc = R"""()""";

    } v_to_qdot;

  } KinematicsCacheElement;

  // MinDistanceConstraint
  struct /* MinDistanceConstraint */ {

    // drake/multibody/rigid_body_constraint.h:872
    const char* doc = R"""()""";

    // MinDistanceConstraint::MinDistanceConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:874
      const char* doc = R"""()""";

    } ctor;

    // MinDistanceConstraint::Penalty
    struct /* Penalty */ {

      // drake/multibody/rigid_body_constraint.h:898
      const char* doc =
R"""(Evaluates a smooth hinge loss function for the elements of `distance`.
Specifically, it sets `penalty[i]` to f(`distance[i]`,
`distance_threshold`) and `dpenalty_ddistance[i]` to
∂f/∂x(`distance[i]`, `distance_threshold`), where

⎧ ⎪ (1 - x/d) exp(1/(x/d - 1)), x < d f(x, d) = ⎨ . ⎪ 0, x ≥ d ⎩

@pre `distance_threshold` is greater than 0.)""";

    } Penalty;

    // MinDistanceConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:901
      const char* doc = R"""()""";

    } bounds;

    // MinDistanceConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:880
      const char* doc = R"""()""";

    } eval;

    // MinDistanceConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:882
      const char* doc = R"""()""";

    } name;

  } MinDistanceConstraint;

  // MultipleTimeKinematicConstraint
  struct /* MultipleTimeKinematicConstraint */ {

    // drake/multibody/rigid_body_constraint.h:330
    const char* doc = R"""()""";

    // MultipleTimeKinematicConstraint::MultipleTimeKinematicConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:332
      const char* doc = R"""()""";

    } ctor;

    // MultipleTimeKinematicConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:343
      const char* doc = R"""()""";

    } bounds;

    // MultipleTimeKinematicConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:338
      const char* doc = R"""()""";

    } eval;

    // MultipleTimeKinematicConstraint::eval_valid
    struct /* eval_valid */ {

      // drake/multibody/rigid_body_constraint.h:340
      const char* doc = R"""()""";

    } eval_valid;

    // MultipleTimeKinematicConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:337
      const char* doc = R"""()""";

    } getNumConstraint;

    // MultipleTimeKinematicConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:336
      const char* doc = R"""()""";

    } isTimeValid;

    // MultipleTimeKinematicConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:345
      const char* doc = R"""()""";

    } name;

    // MultipleTimeKinematicConstraint::numValidTime
    struct /* numValidTime */ {

      // drake/multibody/rigid_body_constraint.h:350
      const char* doc = R"""()""";

    } numValidTime;

    // MultipleTimeKinematicConstraint::updateRobot
    struct /* updateRobot */ {

      // drake/multibody/rigid_body_constraint.h:347
      const char* doc = R"""()""";

    } updateRobot;

  } MultipleTimeKinematicConstraint;

  // MultipleTimeLinearPostureConstraint
  struct /* MultipleTimeLinearPostureConstraint */ {

    // drake/multibody/rigid_body_constraint.h:216
    const char* doc = R"""()""";

    // MultipleTimeLinearPostureConstraint::MultipleTimeLinearPostureConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:218
      const char* doc = R"""()""";

    } ctor;

    // MultipleTimeLinearPostureConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:232
      const char* doc = R"""()""";

    } bounds;

    // MultipleTimeLinearPostureConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:223
      const char* doc = R"""()""";

    } eval;

    // MultipleTimeLinearPostureConstraint::feval
    struct /* feval */ {

      // drake/multibody/rigid_body_constraint.h:226
      const char* doc = R"""()""";

    } feval;

    // MultipleTimeLinearPostureConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:225
      const char* doc = R"""()""";

    } getNumConstraint;

    // MultipleTimeLinearPostureConstraint::geval
    struct /* geval */ {

      // drake/multibody/rigid_body_constraint.h:228
      const char* doc = R"""()""";

    } geval;

    // MultipleTimeLinearPostureConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:222
      const char* doc = R"""()""";

    } isTimeValid;

    // MultipleTimeLinearPostureConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:230
      const char* doc = R"""()""";

    } name;

    // MultipleTimeLinearPostureConstraint::numValidTime
    struct /* numValidTime */ {

      // drake/multibody/rigid_body_constraint.h:236
      const char* doc = R"""()""";

    } numValidTime;

    // MultipleTimeLinearPostureConstraint::validTimeInd
    struct /* validTimeInd */ {

      // drake/multibody/rigid_body_constraint.h:237
      const char* doc = R"""()""";

    } validTimeInd;

  } MultipleTimeLinearPostureConstraint;

  // PIDOutput
  struct /* PIDOutput */ {

    // drake/systems/controllers/QPCommon.h:342
    const char* doc = R"""()""";

    // PIDOutput::q_ref
    struct /* q_ref */ {

      // drake/systems/controllers/QPCommon.h:343
      const char* doc = R"""()""";

    } q_ref;

    // PIDOutput::qddot_des
    struct /* qddot_des */ {

      // drake/systems/controllers/QPCommon.h:344
      const char* doc = R"""()""";

    } qddot_des;

  } PIDOutput;

  // ParseThreeVectorAttribute
  struct /* ParseThreeVectorAttribute */ {

    // drake/multibody/parsers/xml_util.h:116
    const char* doc =
R"""(Parses a three vector value from parameter ``node``, which is an XML
node. The value is specified by an attribute within the XML whose name
is apecified by parameter ``attribute_name``.This method also supports
a three vector specified by a single scalar value, which it
automatically converts into a three vector by using the same scalar
value for all three dimensions.

Parameter ``node``:
    A pointer to the XML element node that contains an attribute with
    a three vector or a scalar value.

Parameter ``attribute_name``:
    The name of the attribute containing the three vector or scalar
    value.

Parameter ``val``:
    The three vector where the results should be stored.

Returns:
    Whether the three vector was successfully parsed from the XML
    element node.

Throws:
    s ValueError If any problem is encountered parsing the three
    vector value.)""";

  } ParseThreeVectorAttribute;

  // ParseThreeVectorValue
  struct /* ParseThreeVectorValue */ {

    // drake/multibody/parsers/xml_util.h:60
    const char* doc =
R"""(Parses a three vector value from parameter ``strval``. There are two
formats of ``strval`` that can be successfully parsed. The first
format is "val1 val2 val3" where val1, val2, and val3 are double
values. The second valid format is "val" where val is a double type.
In this case, this method automatically converts the val1 scalar value
into a three vector by using the same scalar value for all three
dimensions.

Parameter ``strval``:
    A pointer to the character array describing a three vector or a
    scalar value.

Parameter ``val``:
    The three vector into which the results should be stored.

Returns:
    Whether the three vector was successfully parsed from ``strval``.

Throws:
    s ValueError If any problem is encountered parsing the three
    vector value.)""";

    // drake/multibody/parsers/xml_util.h:75
    const char* doc_2 =
R"""(Parses a three vector value from parameter ``node``, which is an XML
node. It also supports a single scalar value, which it automatically
converts to a three vector by using the same scalar value for all
three dimensions.

Parameter ``node``:
    A pointer to the XML element node that contains either a three
    vector or a scalar value.

Parameter ``val``:
    The three vector into which the results should be stored.

Returns:
    Whether the three vector was successfully parsed from the XML
    element node.

Throws:
    s ValueError If any problem is encountered parsing the three
    vector value.)""";

    // drake/multibody/parsers/xml_util.h:95
    const char* doc_3 =
R"""(Parses a three vector value from parameter ``node``, which is an XML
node. The value is contained in an element within ``node``, as
specified by parameter ``element_name``. This method also supports a
three vector specified by a single scalar value, which it
automatically converts into a three vector by using the same scalar
value for all three dimensions.

Parameter ``node``:
    A pointer to the XML element node that contains either a three
    vector or a scalar value.

Parameter ``element_name``:
    The name of the child XML element containing the scale three
    vector or scalar value.

Parameter ``val``:
    The three vector where the results should be stored.

Returns:
    Whether the three vector was successfully parsed from the XML
    element node.

Throws:
    s ValueError If any problem is encountered parsing the three
    vector value.)""";

  } ParseThreeVectorValue;

  // Point2LineSegDistConstraint
  struct /* Point2LineSegDistConstraint */ {

    // drake/multibody/rigid_body_constraint.h:762
    const char* doc = R"""()""";

    // Point2LineSegDistConstraint::Point2LineSegDistConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:764
      const char* doc = R"""()""";

    } ctor;

    // Point2LineSegDistConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:773
      const char* doc = R"""()""";

    } bounds;

    // Point2LineSegDistConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:770
      const char* doc = R"""()""";

    } eval;

    // Point2LineSegDistConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:772
      const char* doc = R"""()""";

    } name;

  } Point2LineSegDistConstraint;

  // Point2PointDistanceConstraint
  struct /* Point2PointDistanceConstraint */ {

    // drake/multibody/rigid_body_constraint.h:739
    const char* doc = R"""()""";

    // Point2PointDistanceConstraint::Point2PointDistanceConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:741
      const char* doc = R"""()""";

    } ctor;

    // Point2PointDistanceConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:750
      const char* doc = R"""()""";

    } bounds;

    // Point2PointDistanceConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:747
      const char* doc = R"""()""";

    } eval;

    // Point2PointDistanceConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:749
      const char* doc = R"""()""";

    } name;

  } Point2PointDistanceConstraint;

  // PositionConstraint
  struct /* PositionConstraint */ {

    // drake/multibody/rigid_body_constraint.h:353
    const char* doc = R"""()""";

    // PositionConstraint::PositionConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:355
      const char* doc = R"""()""";

    } ctor;

    // PositionConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:362
      const char* doc = R"""()""";

    } bounds;

    // PositionConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:360
      const char* doc = R"""()""";

    } eval;

    // PositionConstraint::evalNames
    struct /* evalNames */ {

      // drake/multibody/rigid_body_constraint.h:370
      const char* doc = R"""()""";

    } evalNames;

    // PositionConstraint::evalPositions
    struct /* evalPositions */ {

      // drake/multibody/rigid_body_constraint.h:367
      const char* doc = R"""()""";

    } evalPositions;

    // PositionConstraint::get_n_pts
    struct /* get_n_pts */ {

      // drake/multibody/rigid_body_constraint.h:373
      const char* doc = R"""()""";

    } get_n_pts;

    // PositionConstraint::get_pts
    struct /* get_pts */ {

      // drake/multibody/rigid_body_constraint.h:372
      const char* doc = R"""()""";

    } get_pts;

    // PositionConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:364
      const char* doc = R"""()""";

    } name;

  } PositionConstraint;

  // PositionIndices
  struct /* PositionIndices */ {

    // drake/systems/controllers/QPCommon.h:41
    const char* doc = R"""()""";

    // PositionIndices::ankles
    struct /* ankles */ {

      // drake/systems/controllers/QPCommon.h:44
      const char* doc = R"""()""";

    } ankles;

    // PositionIndices::arms
    struct /* arms */ {

      // drake/systems/controllers/QPCommon.h:45
      const char* doc = R"""()""";

    } arms;

    // PositionIndices::back_bky
    struct /* back_bky */ {

      // drake/systems/controllers/QPCommon.h:48
      const char* doc = R"""()""";

    } back_bky;

    // PositionIndices::back_bkz
    struct /* back_bkz */ {

      // drake/systems/controllers/QPCommon.h:47
      const char* doc = R"""()""";

    } back_bkz;

    // PositionIndices::knees
    struct /* knees */ {

      // drake/systems/controllers/QPCommon.h:43
      const char* doc = R"""()""";

    } knees;

    // PositionIndices::legs
    struct /* legs */ {

      // drake/systems/controllers/QPCommon.h:42
      const char* doc = R"""()""";

    } legs;

    // PositionIndices::neck
    struct /* neck */ {

      // drake/systems/controllers/QPCommon.h:46
      const char* doc = R"""()""";

    } neck;

  } PositionIndices;

  // PostureChangeConstraint
  struct /* PostureChangeConstraint */ {

    // drake/multibody/rigid_body_constraint.h:948
    const char* doc = R"""()""";

    // PostureChangeConstraint::PostureChangeConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:950
      const char* doc = R"""()""";

    } ctor;

    // PostureChangeConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:962
      const char* doc = R"""()""";

    } bounds;

    // PostureChangeConstraint::feval
    struct /* feval */ {

      // drake/multibody/rigid_body_constraint.h:956
      const char* doc = R"""()""";

    } feval;

    // PostureChangeConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:955
      const char* doc = R"""()""";

    } getNumConstraint;

    // PostureChangeConstraint::geval
    struct /* geval */ {

      // drake/multibody/rigid_body_constraint.h:958
      const char* doc = R"""()""";

    } geval;

    // PostureChangeConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:960
      const char* doc = R"""()""";

    } name;

    // PostureChangeConstraint::setJointChangeBounds
    struct /* setJointChangeBounds */ {

      // drake/multibody/rigid_body_constraint.h:966
      const char* doc = R"""()""";

    } setJointChangeBounds;

  } PostureChangeConstraint;

  // PostureConstraint
  struct /* PostureConstraint */ {

    // drake/multibody/rigid_body_constraint.h:171
    const char* doc = R"""()""";

    // PostureConstraint::PostureConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:173
      const char* doc = R"""()""";

    } ctor;

    // PostureConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:182
      const char* doc = R"""()""";

    } bounds;

    // PostureConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:177
      const char* doc = R"""()""";

    } isTimeValid;

    // PostureConstraint::setJointLimits
    struct /* setJointLimits */ {

      // drake/multibody/rigid_body_constraint.h:178
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_constraint.h:180
      const char* doc_2 = R"""()""";

    } setJointLimits;

  } PostureConstraint;

  // PrismaticJoint
  struct /* PrismaticJoint */ {

    // drake/multibody/joints/prismatic_joint.h:15
    const char* doc =
R"""(A prismatic joint moves linearly along one axis.)""";

    // PrismaticJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/prismatic_joint.h:56
      const char* doc = R"""()""";

    } DoClone;

    // PrismaticJoint::PrismaticJoint
    struct /* ctor */ {

      // drake/multibody/joints/prismatic_joint.h:28
      const char* doc =
R"""(The constructor that initializes the name, position, and axis of
motion of this prismatic joint.

Parameter ``name``:
    The name of this joint.

Parameter ``transform_to_parent_body``:
    The transform from this joint's frame to this joint's parent's
    frame.

Parameter ``translation_axis``:
    The axis along which this joint moves.)""";

    } ctor;

    // PrismaticJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/prismatic_joint.h:40
      const char* doc = R"""()""";

    } jointTransform;

    // PrismaticJoint::translation_axis
    struct /* translation_axis */ {

      // drake/multibody/joints/prismatic_joint.h:51
      const char* doc = R"""()""";

    } translation_axis;

  } PrismaticJoint;

  // QPControllerDebugData
  struct /* QPControllerDebugData */ {

    // drake/systems/controllers/QPCommon.h:315
    const char* doc = R"""()""";

    // QPControllerDebugData::A_ls
    struct /* A_ls */ {

      // drake/systems/controllers/QPCommon.h:333
      const char* doc = R"""()""";

    } A_ls;

    // QPControllerDebugData::Aeq
    struct /* Aeq */ {

      // drake/systems/controllers/QPCommon.h:322
      const char* doc = R"""()""";

    } Aeq;

    // QPControllerDebugData::Ain_lb_ub
    struct /* Ain_lb_ub */ {

      // drake/systems/controllers/QPCommon.h:324
      const char* doc = R"""()""";

    } Ain_lb_ub;

    // QPControllerDebugData::B
    struct /* B */ {

      // drake/systems/controllers/QPCommon.h:319
      const char* doc = R"""()""";

    } B;

    // QPControllerDebugData::B_ls
    struct /* B_ls */ {

      // drake/systems/controllers/QPCommon.h:334
      const char* doc = R"""()""";

    } B_ls;

    // QPControllerDebugData::Jcom
    struct /* Jcom */ {

      // drake/systems/controllers/QPCommon.h:335
      const char* doc = R"""()""";

    } Jcom;

    // QPControllerDebugData::Jcomdotv
    struct /* Jcomdotv */ {

      // drake/systems/controllers/QPCommon.h:336
      const char* doc = R"""()""";

    } Jcomdotv;

    // QPControllerDebugData::Qneps
    struct /* Qneps */ {

      // drake/systems/controllers/QPCommon.h:327
      const char* doc = R"""()""";

    } Qneps;

    // QPControllerDebugData::Qnfdiag
    struct /* Qnfdiag */ {

      // drake/systems/controllers/QPCommon.h:326
      const char* doc = R"""()""";

    } Qnfdiag;

    // QPControllerDebugData::S
    struct /* S */ {

      // drake/systems/controllers/QPCommon.h:329
      const char* doc = R"""()""";

    } S;

    // QPControllerDebugData::active_supports
    struct /* active_supports */ {

      // drake/systems/controllers/QPCommon.h:316
      const char* doc = R"""()""";

    } active_supports;

    // QPControllerDebugData::alpha
    struct /* alpha */ {

      // drake/systems/controllers/QPCommon.h:320
      const char* doc = R"""()""";

    } alpha;

    // QPControllerDebugData::beq
    struct /* beq */ {

      // drake/systems/controllers/QPCommon.h:323
      const char* doc = R"""()""";

    } beq;

    // QPControllerDebugData::beta
    struct /* beta */ {

      // drake/systems/controllers/QPCommon.h:337
      const char* doc = R"""()""";

    } beta;

    // QPControllerDebugData::bin_lb_ub
    struct /* bin_lb_ub */ {

      // drake/systems/controllers/QPCommon.h:325
      const char* doc = R"""()""";

    } bin_lb_ub;

    // QPControllerDebugData::f
    struct /* f */ {

      // drake/systems/controllers/QPCommon.h:321
      const char* doc = R"""()""";

    } f;

    // QPControllerDebugData::nc
    struct /* nc */ {

      // drake/systems/controllers/QPCommon.h:317
      const char* doc = R"""()""";

    } nc;

    // QPControllerDebugData::normals
    struct /* normals */ {

      // drake/systems/controllers/QPCommon.h:318
      const char* doc = R"""()""";

    } normals;

    // QPControllerDebugData::s1
    struct /* s1 */ {

      // drake/systems/controllers/QPCommon.h:330
      const char* doc = R"""()""";

    } s1;

    // QPControllerDebugData::s1dot
    struct /* s1dot */ {

      // drake/systems/controllers/QPCommon.h:331
      const char* doc = R"""()""";

    } s1dot;

    // QPControllerDebugData::s2dot
    struct /* s2dot */ {

      // drake/systems/controllers/QPCommon.h:332
      const char* doc = R"""()""";

    } s2dot;

    // QPControllerDebugData::x_bar
    struct /* x_bar */ {

      // drake/systems/controllers/QPCommon.h:328
      const char* doc = R"""()""";

    } x_bar;

  } QPControllerDebugData;

  // QPControllerOutput
  struct /* QPControllerOutput */ {

    // drake/systems/controllers/QPCommon.h:308
    const char* doc = R"""()""";

    // QPControllerOutput::q_ref
    struct /* q_ref */ {

      // drake/systems/controllers/QPCommon.h:309
      const char* doc = R"""()""";

    } q_ref;

    // QPControllerOutput::qd_ref
    struct /* qd_ref */ {

      // drake/systems/controllers/QPCommon.h:310
      const char* doc = R"""()""";

    } qd_ref;

    // QPControllerOutput::qdd
    struct /* qdd */ {

      // drake/systems/controllers/QPCommon.h:311
      const char* doc = R"""()""";

    } qdd;

    // QPControllerOutput::u
    struct /* u */ {

      // drake/systems/controllers/QPCommon.h:312
      const char* doc = R"""()""";

    } u;

  } QPControllerOutput;

  // QPControllerParams
  struct /* QPControllerParams */ {

    // drake/systems/controllers/QPCommon.h:232
    const char* doc = R"""()""";

    // QPControllerParams::Kp_accel
    struct /* Kp_accel */ {

      // drake/systems/controllers/QPCommon.h:260
      const char* doc = R"""()""";

    } Kp_accel;

    // QPControllerParams::Kp_ang
    struct /* Kp_ang */ {

      // drake/systems/controllers/QPCommon.h:256
      const char* doc = R"""()""";

    } Kp_ang;

    // QPControllerParams::QPControllerParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:233
      const char* doc = R"""()""";

    } ctor;

    // QPControllerParams::W_kdot
    struct /* W_kdot */ {

      // drake/systems/controllers/QPCommon.h:255
      const char* doc = R"""()""";

    } W_kdot;

    // QPControllerParams::body_motion
    struct /* body_motion */ {

      // drake/systems/controllers/QPCommon.h:251
      const char* doc = R"""()""";

    } body_motion;

    // QPControllerParams::center_of_mass_observer_gain
    struct /* center_of_mass_observer_gain */ {

      // drake/systems/controllers/QPCommon.h:264
      const char* doc = R"""()""";

    } center_of_mass_observer_gain;

    // QPControllerParams::contact_threshold
    struct /* contact_threshold */ {

      // drake/systems/controllers/QPCommon.h:261
      const char* doc = R"""()""";

    } contact_threshold;

    // QPControllerParams::hardware
    struct /* hardware */ {

      // drake/systems/controllers/QPCommon.h:254
      const char* doc = R"""()""";

    } hardware;

    // QPControllerParams::joint_soft_limits
    struct /* joint_soft_limits */ {

      // drake/systems/controllers/QPCommon.h:253
      const char* doc = R"""()""";

    } joint_soft_limits;

    // QPControllerParams::min_knee_angle
    struct /* min_knee_angle */ {

      // drake/systems/controllers/QPCommon.h:262
      const char* doc = R"""()""";

    } min_knee_angle;

    // QPControllerParams::slack_limit
    struct /* slack_limit */ {

      // drake/systems/controllers/QPCommon.h:258
      const char* doc = R"""()""";

    } slack_limit;

    // QPControllerParams::use_center_of_mass_observer
    struct /* use_center_of_mass_observer */ {

      // drake/systems/controllers/QPCommon.h:263
      const char* doc = R"""()""";

    } use_center_of_mass_observer;

    // QPControllerParams::vref_integrator
    struct /* vref_integrator */ {

      // drake/systems/controllers/QPCommon.h:252
      const char* doc = R"""()""";

    } vref_integrator;

    // QPControllerParams::w_grf
    struct /* w_grf */ {

      // drake/systems/controllers/QPCommon.h:259
      const char* doc = R"""()""";

    } w_grf;

    // QPControllerParams::w_slack
    struct /* w_slack */ {

      // drake/systems/controllers/QPCommon.h:257
      const char* doc = R"""()""";

    } w_slack;

    // QPControllerParams::whole_body
    struct /* whole_body */ {

      // drake/systems/controllers/QPCommon.h:250
      const char* doc = R"""()""";

    } whole_body;

  } QPControllerParams;

  // QPControllerState
  struct /* QPControllerState */ {

    // drake/systems/controllers/QPCommon.h:20
    const char* doc = R"""()""";

    // QPControllerState::active
    struct /* active */ {

      // drake/systems/controllers/QPCommon.h:25
      const char* doc = R"""()""";

    } active;

    // QPControllerState::cbasis
    struct /* cbasis */ {

      // drake/systems/controllers/QPCommon.h:34
      const char* doc = R"""()""";

    } cbasis;

    // QPControllerState::cbasis_len
    struct /* cbasis_len */ {

      // drake/systems/controllers/QPCommon.h:36
      const char* doc = R"""()""";

    } cbasis_len;

    // QPControllerState::center_of_mass_observer_state
    struct /* center_of_mass_observer_state */ {

      // drake/systems/controllers/QPCommon.h:29
      const char* doc = R"""()""";

    } center_of_mass_observer_state;

    // QPControllerState::foot_contact_prev
    struct /* foot_contact_prev */ {

      // drake/systems/controllers/QPCommon.h:22
      const char* doc = R"""()""";

    } foot_contact_prev;

    // QPControllerState::last_com_ddot
    struct /* last_com_ddot */ {

      // drake/systems/controllers/QPCommon.h:30
      const char* doc = R"""()""";

    } last_com_ddot;

    // QPControllerState::num_active_contact_pts
    struct /* num_active_contact_pts */ {

      // drake/systems/controllers/QPCommon.h:26
      const char* doc = R"""()""";

    } num_active_contact_pts;

    // QPControllerState::q_integrator_state
    struct /* q_integrator_state */ {

      // drake/systems/controllers/QPCommon.h:24
      const char* doc = R"""()""";

    } q_integrator_state;

    // QPControllerState::t_prev
    struct /* t_prev */ {

      // drake/systems/controllers/QPCommon.h:21
      const char* doc = R"""()""";

    } t_prev;

    // QPControllerState::vbasis
    struct /* vbasis */ {

      // drake/systems/controllers/QPCommon.h:33
      const char* doc = R"""()""";

    } vbasis;

    // QPControllerState::vbasis_len
    struct /* vbasis_len */ {

      // drake/systems/controllers/QPCommon.h:35
      const char* doc = R"""()""";

    } vbasis_len;

    // QPControllerState::vref_integrator_state
    struct /* vref_integrator_state */ {

      // drake/systems/controllers/QPCommon.h:23
      const char* doc = R"""()""";

    } vref_integrator_state;

  } QPControllerState;

  // QuasiStaticConstraint
  struct /* QuasiStaticConstraint */ {

    // drake/multibody/rigid_body_constraint.h:117
    const char* doc =
R"""(@class QuasiStaticConstraint -- Constrain the Center of Mass (CoM) is
within the support polygon. The support polygon is a shrunk area of
the contact polygon

Parameter ``robot``:
    $Parameter ``tspan``:

-- The time span of this constraint being active

Parameter ``model_instance_id_set``:
    -- The set of the robots in the RigidBodyTree for which the CoM is
    computed

Parameter ``shrinkFactor``:
    -- The factor to shrink the contact polygon. The shrunk area is
    the support polygon.

Parameter ``active``:
    -- Whether the constraint is on/off. If active = false, even the
    time t is within tspan, the constraint is still inactive

Parameter ``num_bodies``:
    -- The total number of ground contact bodies/frames

Parameter ``num_pts``:
    -- The total number of ground contact points

Parameter ``bodies``:
    -- The index of ground contact bodies/frames

Parameter ``num_body_pts``:
    -- The number of contact points on each contact body/frame

Parameter ``body_pts``:
    -- The contact points on each contact body/frame

Function: @function eval --evaluate the constraint

Parameter ``t``:
    --the time to evaluate the constraint

Parameter ``weights``:
    --the weight associate with each ground contact point

Parameter ``c``:
    -- c = CoM-weights'*support_vertex

Parameter ``dc``:
    -- dc = [dcdq dcdweiths] @function addContact -- add contact body
    and points

Parameter ``num_new_bodies``:
    -- number of new contact bodies

Parameter ``body``:
    -- the index of new contact bodies/frames

Parameter ``body_pts``:
    -- body_pts[i] are the contact points on body[i])""";

    // QuasiStaticConstraint::QuasiStaticConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:119
      const char* doc = R"""()""";

    } ctor;

    // QuasiStaticConstraint::addContact
    struct /* addContact */ {

      // drake/multibody/rigid_body_constraint.h:134
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_constraint.h:137
      const char* doc_2 = R"""()""";

    } addContact;

    // QuasiStaticConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:130
      const char* doc = R"""()""";

    } bounds;

    // QuasiStaticConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:127
      const char* doc = R"""()""";

    } eval;

    // QuasiStaticConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:126
      const char* doc = R"""()""";

    } getNumConstraint;

    // QuasiStaticConstraint::getNumWeights
    struct /* getNumWeights */ {

      // drake/multibody/rigid_body_constraint.h:133
      const char* doc = R"""()""";

    } getNumWeights;

    // QuasiStaticConstraint::isActive
    struct /* isActive */ {

      // drake/multibody/rigid_body_constraint.h:132
      const char* doc = R"""()""";

    } isActive;

    // QuasiStaticConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:125
      const char* doc = R"""()""";

    } isTimeValid;

    // QuasiStaticConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:131
      const char* doc = R"""()""";

    } name;

    // QuasiStaticConstraint::setActive
    struct /* setActive */ {

      // drake/multibody/rigid_body_constraint.h:142
      const char* doc = R"""()""";

    } setActive;

    // QuasiStaticConstraint::setShrinkFactor
    struct /* setShrinkFactor */ {

      // drake/multibody/rigid_body_constraint.h:141
      const char* doc = R"""()""";

    } setShrinkFactor;

    // QuasiStaticConstraint::updateRobot
    struct /* updateRobot */ {

      // drake/multibody/rigid_body_constraint.h:143
      const char* doc = R"""()""";

    } updateRobot;

    // QuasiStaticConstraint::updateRobotnum
    struct /* updateRobotnum */ {

      // drake/multibody/rigid_body_constraint.h:144
      const char* doc = R"""()""";

    } updateRobotnum;

  } QuasiStaticConstraint;

  // QuatConstraint
  struct /* QuatConstraint */ {

    // drake/multibody/rigid_body_constraint.h:451
    const char* doc = R"""()""";

    // QuatConstraint::QuatConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:453
      const char* doc = R"""()""";

    } ctor;

    // QuatConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:459
      const char* doc = R"""()""";

    } bounds;

    // QuatConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:457
      const char* doc = R"""()""";

    } eval;

    // QuatConstraint::evalOrientationProduct
    struct /* evalOrientationProduct */ {

      // drake/multibody/rigid_body_constraint.h:463
      const char* doc = R"""()""";

    } evalOrientationProduct;

  } QuatConstraint;

  // QuaternionBallJoint
  struct /* QuaternionBallJoint */ {

    // drake/multibody/joints/quaternion_ball_joint.h:61
    const char* doc =
R"""(Defines a 3 dof tree joint (mobilizer) that uses a unit quaternion as
the generalized orientation coordinates.

<h3>Generalized coordinates (configuration variables)</h3> There are 4
generalized coordinates q, organized as a quaternion. A tree joint
connects an inboard (parent) body P to an outboard (child) body B. In
those terms this joint's generalized coordinates are:

```
------------- T
    q = |    q_PB     |
         -------------  4×1
          qw qx qy qz
```

where `q_PB` is the quaternion that is equivalent to the rotation
matrix `R_PB`. The second line shows the 4 generalized coordinate
scalars in order. Note that `qw` is the scalar part of the quaternion
while `[qx qy qz]` is the vector part. See multibody_spatial_pose for
more information about this notation.

The time derivatives qdot of the generalized coordinates, _not_ to be
confused with the generalized velocity variables v, are:

```
------------- T
 qdot = |   qdot_PB   |
         -------------  4×1
```

where `qdot_PB = d/dt q_PB` is the time derivative of the quaternion.

<h3>Generalized velocity</h3> There are 3 generalized velocity
variables v, organized as follows:

```
--------- T
    v = | ω_PB_B  |
         --------- 3×1
```

where `ω_PB_B` is B's angular velocity in P, expressed in B.

Note that The time derivatives of the generalized velocities are:

```
--------- T
 vdot = | α_PB_B  |
         --------- 3×1
```

where `α_PB_B` is B's angular acceleration in P, expressed in B.)""";

    // QuaternionBallJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/quaternion_ball_joint.h:300
      const char* doc = R"""()""";

    } DoClone;

    // QuaternionBallJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/quaternion_ball_joint.h:301
      const char* doc = R"""()""";

    } DoInitializeClone;

    // QuaternionBallJoint::QuaternionBallJoint
    struct /* ctor */ {

      // drake/multibody/joints/quaternion_ball_joint.h:63
      const char* doc = R"""()""";

    } ctor;

    // QuaternionBallJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/quaternion_ball_joint.h:266
      const char* doc = R"""()""";

    } SpringTorque;

    // QuaternionBallJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/quaternion_ball_joint.h:258
      const char* doc = R"""()""";

    } frictionTorque;

    // QuaternionBallJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/quaternion_ball_joint.h:290
      const char* doc = R"""()""";

    } getPositionName;

    // QuaternionBallJoint::getVelocityName
    struct /* getVelocityName */ {

      // drake/multibody/joints/quaternion_ball_joint.h:294
      const char* doc = R"""()""";

    } getVelocityName;

    // QuaternionBallJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/quaternion_ball_joint.h:282
      const char* doc = R"""()""";

    } get_position_name;

    // QuaternionBallJoint::get_velocity_name
    struct /* get_velocity_name */ {

      // drake/multibody/joints/quaternion_ball_joint.h:283
      const char* doc = R"""()""";

    } get_velocity_name;

    // QuaternionBallJoint::isFloating
    struct /* isFloating */ {

      // drake/multibody/joints/quaternion_ball_joint.h:280
      const char* doc = R"""()""";

    } isFloating;

    // QuaternionBallJoint::is_floating
    struct /* is_floating */ {

      // drake/multibody/joints/quaternion_ball_joint.h:276
      const char* doc = R"""()""";

    } is_floating;

    // QuaternionBallJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/quaternion_ball_joint.h:74
      const char* doc =
R"""(Returns the transform `X_PB(q)` where P is the parent body and B the
child body connected by this joint.)""";

    } jointTransform;

    // QuaternionBallJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/quaternion_ball_joint.h:84
      const char* doc = R"""()""";

    } motionSubspace;

    // QuaternionBallJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/quaternion_ball_joint.h:98
      const char* doc = R"""()""";

    } motionSubspaceDotTimesV;

    // QuaternionBallJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/quaternion_ball_joint.h:154
      const char* doc =
R"""(For the QuaternionBallJoint, computes the matrix `N⁺(q)`∊ℝ³ˣ⁴ that
maps generalized coordinate time derivatives qdot to generalized
velocities v, with `v=N⁺ qdot`. The name signifies that `N⁺=pinv(N)`
where `N(q)` is the matrix that maps v to qdot with `qdot=N v` and
`pinv()` is the pseudoinverse (in this case the left pseudoinverse).

See the class description for precise definitions of the generalized
coordinates and velocities. Because the velocities are not the time
derivatives of the coordinates, rotations and translations are
reversed, and different expressed-in frames are employed, `N⁺` has the
following elaborate structure:

```
-----------
 N⁺ = | Nq⁺_PB_B  |
       ----------- 3×4
```

where `Nq_PB_B` is the matrix that maps angular velocity `ω_PB_B` to
quaternion time derivative `qdot_PB` such that
`qdot_PB=Nq_PB_B*ω_PB_B`, and `Nq⁺_PB_B` is the left pseudoinverse of
`Nq_PB_B`.

Parameter ``q``:
    The 4-element generalized configuration variable. See the class
    documentation for details. See warning below regarding the effect
    if the contained quaternion is not normalized.

Parameter ``qdot_to_v``:
    The matrix `N⁺`.

Parameter ``dqdot_to_v``:
    Unused, must be `nullptr` on entry.

@warning Let `s` be the norm of the quaternion in `q`. If `s ≠ 1`,
then we will calculate `s*Nq⁺_PB_B` so the resulting angular velocity
vector will be scaled by `s` as well. This method neither performs a
normalization check nor normalizes the quaternion orientation
parameters. Implications for integration techniques must be carefully
considered.)""";

    } qdot2v;

    // QuaternionBallJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/quaternion_ball_joint.h:285
      const char* doc = R"""()""";

    } randomConfiguration;

    // QuaternionBallJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/quaternion_ball_joint.h:222
      const char* doc =
R"""(For the QuaternionBallJoint, computes the matrix `N(q)`∊ℝ⁴ˣ³ that maps
generalized velocities v to generalized coordinate time derivatives
qdot, with `qdot=N v`.

See the class description for precise definitions of the generalized
coordinates and velocities. Because the velocities are not the time
derivatives of the coordinates, rotations and translations are
reversed, and different expressed-in frames are employed, `N` has the
following elaborate structure:

```
-------
  N = |Nq_PB_B|
       ------- 4×3
```

where `Nq_PB_B` is the matrix that maps angular velocity `ω_PB_B` to
quaternion time derivative `qdot_PB` such that
`qdot_PB=Nq_PB_B*ω_PB_B`.

Parameter ``q``:
    The 4-element generalized configuration variable. See the class
    documentation for details. See warning below regarding the effect
    if the contained quaternion is not normalized.

Parameter ``v_to_qdot``:
    The matrix `N`.

Parameter ``dv_to_qdot``:
    Unused, must be `nullptr` on entry.

@warning Let `s` be the norm of the quaternion in `q`. If `s ≠ 1`,
then we will calculate `s*Nq_PB_B` so the resulting quaternion
derivative will be scaled by `s` as well. This method neither performs
a normalization check nor normalizes the quaternion orientation
parameters. Implications for integration techniques must be carefully
considered.)""";

    } v2qdot;

    // QuaternionBallJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/quaternion_ball_joint.h:284
      const char* doc = R"""()""";

    } zeroConfiguration;

  } QuaternionBallJoint;

  // QuaternionFloatingJoint
  struct /* QuaternionFloatingJoint */ {

    // drake/multibody/joints/quaternion_floating_joint.h:77
    const char* doc =
R"""(Defines a 6 dof tree joint (mobilizer) that uses a unit quaternion as
the generalized orientation coordinates.

<h3>Generalized coordinates (configuration variables)</h3> There are 7
generalized coordinates q, organized as a position vector and
quaternion. A tree joint connects an inboard (parent) body P to an
outboard (child) body B. In those terms this joint's generalized
coordinates are:

```
--------- ------------- T
    q = | p_PB_P  |    q_PB     |
         --------- -------------  7×1
         px py pz   qw qx qy qz
```

where `p_PB_P` is the position vector from P's origin Po to B's origin
Bo, expressed in the P basis, and `q_PB` is the quaternion that is
equivalent to the rotation matrix `R_PB`. The second line shows the 7
generalized coordinate scalars in order. Note that `qw` is the scalar
part of the quaternion while `[qx qy qz]` is the vector part. See
multibody_spatial_pose for more information about this notation.

The time derivatives qdot of the generalized coordinates, _not_ to be
confused with the generalized velocity variables v, are:

```
--------- ------------- T
 qdot = | v_PB_P  |   qdot_PB   |
         --------- -------------  7×1
```

where `v_PB_P = d_P/dt p_PB_P` is the velocity of point Bo measured
and expressed in the P frame, where we have emphasized that the
derivative is taken in P, and `qdot_PB = d/dt q_PB` is the time
derivative of the quaternion.

<h3>Generalized velocity</h3> There are 6 generalized velocity
variables v, organized as follows:

```
--------- -------- T
    v = | ω_PB_B  | v_PB_B |
         --------- --------  6×1
```

where `ω_PB_B` is B's angular velocity in P, expressed in B, and
`v_PB_B` is point Bo's translational velocity in P, expressed in B.

Note that the rotational and translational quantities are in the
reverse order from those in the generalized coordinates, and that the
velocities are expressed in the _child_ frame B rather than in the
parent. Clearly these are _not_ the derivatives of the generalized
coordinates!

The time derivatives of the generalized velocities are:

```
--------- ----------- T
 vdot = | α_PB_B  | vdot_PB_B |
         --------- -----------  6×1
```

where `α_PB_B` is B's angular acceleration in P, expressed in B, and
`vdot_PB_B = d_B/dt v_PB_B` where we have emphasized that the
derivative is taken in the B frame, so this is *not* the acceleration
of Bo in P. That acceleration is given by `a_PB_B = vdot_PB_B + ω_PB_B
× v_PB_B` (still in B). Re-expressing `a_PB_B` in P provides the
configuration second derivative `a_PB_P = d²_P/dt² p_PB_P =
R_PB*a_PB_B`.)""";

    // QuaternionFloatingJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/quaternion_floating_joint.h:342
      const char* doc = R"""()""";

    } DoClone;

    // QuaternionFloatingJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/quaternion_floating_joint.h:343
      const char* doc = R"""()""";

    } DoInitializeClone;

    // QuaternionFloatingJoint::QuaternionFloatingJoint
    struct /* ctor */ {

      // drake/multibody/joints/quaternion_floating_joint.h:79
      const char* doc = R"""()""";

    } ctor;

    // QuaternionFloatingJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/quaternion_floating_joint.h:308
      const char* doc = R"""()""";

    } SpringTorque;

    // QuaternionFloatingJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/quaternion_floating_joint.h:300
      const char* doc = R"""()""";

    } frictionTorque;

    // QuaternionFloatingJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/quaternion_floating_joint.h:332
      const char* doc = R"""()""";

    } getPositionName;

    // QuaternionFloatingJoint::getVelocityName
    struct /* getVelocityName */ {

      // drake/multibody/joints/quaternion_floating_joint.h:336
      const char* doc = R"""()""";

    } getVelocityName;

    // QuaternionFloatingJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/quaternion_floating_joint.h:324
      const char* doc = R"""()""";

    } get_position_name;

    // QuaternionFloatingJoint::get_velocity_name
    struct /* get_velocity_name */ {

      // drake/multibody/joints/quaternion_floating_joint.h:325
      const char* doc = R"""()""";

    } get_velocity_name;

    // QuaternionFloatingJoint::isFloating
    struct /* isFloating */ {

      // drake/multibody/joints/quaternion_floating_joint.h:322
      const char* doc = R"""()""";

    } isFloating;

    // QuaternionFloatingJoint::is_floating
    struct /* is_floating */ {

      // drake/multibody/joints/quaternion_floating_joint.h:318
      const char* doc = R"""()""";

    } is_floating;

    // QuaternionFloatingJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/quaternion_floating_joint.h:90
      const char* doc =
R"""(Returns the transform `X_PB(q)` where P is the parent body and B the
child body connected by this joint.)""";

    } jointTransform;

    // QuaternionFloatingJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/quaternion_floating_joint.h:99
      const char* doc = R"""()""";

    } motionSubspace;

    // QuaternionFloatingJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/quaternion_floating_joint.h:113
      const char* doc = R"""()""";

    } motionSubspaceDotTimesV;

    // QuaternionFloatingJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/quaternion_floating_joint.h:172
      const char* doc =
R"""(For the QuaternionFloatingJoint, computes the matrix `N⁺(q)`∊ℝ⁶ˣ⁷ that
maps generalized coordinate time derivatives qdot to generalized
velocities v, with `v=N⁺ qdot`. The name signifies that `N⁺=pinv(N)`
where `N(q)` is the matrix that maps v to qdot with `qdot=N v` and
`pinv()` is the pseudoinverse (in this case the left pseudoinverse).

See the class description for precise definitions of the generalized
coordinates and velocities. Because the velocities are not the time
derivatives of the coordinates, rotations and translations are
reversed, and different expressed-in frames are employed, `N⁺` has the
following elaborate structure:

```
-------- -----------
      |  0₃ₓ₃  | Nq⁺_PB_B  |
 N⁺ = |--------|-----------|
      |  R_BP  |   0₃ₓ₄    |
       -------- ----------- 6×7
```

where `Nq_PB_B` is the matrix that maps angular velocity `ω_PB_B` to
quaternion time derivative `qdot_PB` such that
`qdot_PB=Nq_PB_B*ω_PB_B`, and `Nq⁺_PB_B` is the left pseudoinverse of
`Nq_PB_B`.

Parameter ``q``:
    The 7-element generalized configuration variable. See the class
    documentation for details. See warning below regarding the effect
    if the contained quaternion is not normalized.

Parameter ``qdot_to_v``:
    The matrix `N⁺`.

Parameter ``dqdot_to_v``:
    Unused, must be `nullptr` on entry.

@warning Let `s` be the norm of the quaternion in `q`. If `s ≠ 1`,
then we will calculate `s*Nq⁺_PB_B` in the upper right block of `N⁺`
so the resulting angular velocity vector will be scaled by `s` as
well. This method neither performs a normalization check nor
normalizes the quaternion orientation parameters. Implications for
integration techniques must be carefully considered.)""";

    } qdot2v;

    // QuaternionFloatingJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/quaternion_floating_joint.h:327
      const char* doc = R"""()""";

    } randomConfiguration;

    // QuaternionFloatingJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/quaternion_floating_joint.h:255
      const char* doc =
R"""(For the QuaternionFloatingJoint, computes the matrix `N(q)`∊ℝ⁷ˣ⁶ that
maps generalized velocities v to generalized coordinate time
derivatives qdot, with `qdot=N v`.

See the class description for precise definitions of the generalized
coordinates and velocities. Because the velocities are not the time
derivatives of the coordinates, rotations and translations are
reversed, and different expressed-in frames are employed, `N` has the
following elaborate structure:

```
------- ------
      |  0₃ₓ₃ | R_PB |
      |-------|------|
  N = |       |      |
      |Nq_PB_B| 0₄ₓ₃ |
      |       |      |
       -------------- 7×6
```

where `Nq_PB_B` is the matrix that maps angular velocity `ω_PB_B` to
quaternion time derivative `qdot_PB` such that
`qdot_PB=Nq_PB_B*ω_PB_B`.

Parameter ``q``:
    The 7-element generalized configuration variable. See the class
    documentation for details. See warning below regarding the effect
    if the contained quaternion is not normalized.

Parameter ``v_to_qdot``:
    The matrix `N`.

Parameter ``dv_to_qdot``:
    Unused, must be `nullptr` on entry.

@warning Let `s` be the norm of the quaternion in `q`. If `s ≠ 1`,
then we will calculate `s*Nq_PB_B` in the lower left block of `N` so
the resulting quaternion derivative will be scaled by `s` as well.
This method neither performs a normalization check nor normalizes the
quaternion orientation parameters. Implications for integration
techniques must be carefully considered.)""";

    } v2qdot;

    // QuaternionFloatingJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/quaternion_floating_joint.h:326
      const char* doc = R"""()""";

    } zeroConfiguration;

  } QuaternionFloatingJoint;

  // RelativeGazeDirConstraint
  struct /* RelativeGazeDirConstraint */ {

    // drake/multibody/rigid_body_constraint.h:720
    const char* doc = R"""()""";

    // RelativeGazeDirConstraint::RelativeGazeDirConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:722
      const char* doc = R"""()""";

    } ctor;

    // RelativeGazeDirConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:728
      const char* doc = R"""()""";

    } eval;

    // RelativeGazeDirConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:730
      const char* doc = R"""()""";

    } name;

  } RelativeGazeDirConstraint;

  // RelativeGazeTargetConstraint
  struct /* RelativeGazeTargetConstraint */ {

    // drake/multibody/rigid_body_constraint.h:701
    const char* doc = R"""()""";

    // RelativeGazeTargetConstraint::RelativeGazeTargetConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:703
      const char* doc = R"""()""";

    } ctor;

    // RelativeGazeTargetConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:709
      const char* doc = R"""()""";

    } eval;

    // RelativeGazeTargetConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:711
      const char* doc = R"""()""";

    } name;

  } RelativeGazeTargetConstraint;

  // RelativePositionConstraint
  struct /* RelativePositionConstraint */ {

    // drake/multibody/rigid_body_constraint.h:426
    const char* doc = R"""()""";

    // RelativePositionConstraint::RelativePositionConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:428
      const char* doc = R"""()""";

    } ctor;

    // RelativePositionConstraint::evalNames
    struct /* evalNames */ {

      // drake/multibody/rigid_body_constraint.h:440
      const char* doc = R"""()""";

    } evalNames;

    // RelativePositionConstraint::evalPositions
    struct /* evalPositions */ {

      // drake/multibody/rigid_body_constraint.h:438
      const char* doc = R"""()""";

    } evalPositions;

  } RelativePositionConstraint;

  // RelativeQuatConstraint
  struct /* RelativeQuatConstraint */ {

    // drake/multibody/rigid_body_constraint.h:494
    const char* doc = R"""()""";

    // RelativeQuatConstraint::RelativeQuatConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:496
      const char* doc = R"""()""";

    } ctor;

    // RelativeQuatConstraint::evalOrientationProduct
    struct /* evalOrientationProduct */ {

      // drake/multibody/rigid_body_constraint.h:504
      const char* doc = R"""()""";

    } evalOrientationProduct;

    // RelativeQuatConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:500
      const char* doc = R"""()""";

    } name;

  } RelativeQuatConstraint;

  // RevoluteJoint
  struct /* RevoluteJoint */ {

    // drake/multibody/joints/revolute_joint.h:14
    const char* doc = R"""()""";

    // RevoluteJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/revolute_joint.h:43
      const char* doc = R"""()""";

    } DoClone;

    // RevoluteJoint::RevoluteJoint
    struct /* ctor */ {

      // drake/multibody/joints/revolute_joint.h:16
      const char* doc = R"""()""";

    } ctor;

    // RevoluteJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/revolute_joint.h:30
      const char* doc = R"""()""";

    } jointTransform;

    // RevoluteJoint::rotation_axis
    struct /* rotation_axis */ {

      // drake/multibody/joints/revolute_joint.h:38
      const char* doc = R"""()""";

    } rotation_axis;

  } RevoluteJoint;

  // RigidBody
  struct /* RigidBody */ {

    // drake/multibody/collision/collision_filter.h:13
    const char* doc = R"""()""";

    // drake/multibody/collision/element.h:22
    const char* doc_2 = R"""()""";

    // drake/multibody/rigid_body.h:21
    const char* doc_3 = R"""()""";

    // drake/multibody/rigid_body_actuator.h:7
    const char* doc_4 = R"""()""";

    // RigidBody::AddCollisionElement
    struct /* AddCollisionElement */ {

      // drake/multibody/rigid_body.h:241
      const char* doc =
R"""(Adds the given collision ``element`` to the body with the given group
name.

Parameter ``group_name``:
    The collision element's group name.

Parameter ``element``:
    The element to associate with the rigid body.)""";

    } AddCollisionElement;

    // RigidBody::AddVisualElement
    struct /* AddVisualElement */ {

      // drake/multibody/rigid_body.h:227
      const char* doc = R"""()""";

    } AddVisualElement;

    // RigidBody::ApplyTransformToJointFrame
    struct /* ApplyTransformToJointFrame */ {

      // drake/multibody/rigid_body.h:410
      const char* doc =
R"""(Transforms all of the visual, collision, and inertial elements
associated with this body to the proper joint frame. This is
necessary, for instance, to support SDF loading where the child frame
can be specified independently from the joint frame. In our
RigidBodyTree classes, the body frame IS the joint frame.

Parameter ``transform_body_to_joint``:
    The transform from this body's frame to the joint's frame.)""";

    } ApplyTransformToJointFrame;

    // RigidBody::CanCollideWith
    struct /* CanCollideWith */ {

      // drake/multibody/rigid_body.h:340
      const char* doc =
R"""(Returns `true` if this body should be checked for collisions with the
``other`` body. CanCollideWith should be commutative: A can collide
with B implies B can collide with A.

Parameter ``other``:
    The body to query against.

Returns:
    `true` if collision between this and other should be tested.)""";

    } CanCollideWith;

    // RigidBody::Clone
    struct /* Clone */ {

      // drake/multibody/rigid_body.h:41
      const char* doc =
R"""(Returns a clone of this RigidBody.

*Important note!* The following are not cloned: - the joint - the
parent RigidBody - the visual elements - the collision elements

The parent is *not* cloned because the reference to it can only be
determined by the RigidBodyTree (which owns both this body and the
parent body). Both the parent and the joint are expected to be set by
calling add_joint().

The visual and collision elements will be cloned pending identified
need.)""";

    } Clone;

    // RigidBody::ComputeWorldFixedPose
    struct /* ComputeWorldFixedPose */ {

      // drake/multibody/rigid_body.h:310
      const char* doc =
R"""(Reports `X_WBₙ`, the pose of this body, `Bₙ`, in the world frame based
on the *rigid* kinematic path from `Bₙ` to `W`. As such, the world-
fixed pose is only defined for bodies that are rigidly fixed to the
world.

For this body, with depth `n` in the tree, `Bₙ`, `X_WBₙ` is defined
as:

`X_WBₙ ≡ X_WB₁ * X_B₁B₂ * ... * X_Bₙ₋₂Bₙ₋₁ * X_Bₙ₋₁Bₙ`

`X_Bₖ₋₁Bₖ` represents the transform from one body's frame (`Bₖ`) to
its parent's frame (Bₖ₋₁). By construction, body `Bₖ` has a single
inboard joint. This joint defines several frames, discussed in
rigid_body_tree_frames, including its parent frame: `Pₖ ≡ Bₖ₋₁`. This
allows us to compute `X_Bₖ₋₁Bₖ` as follows: - `X_Bₖ₋₁Bₖ = X_PₖBₖ`
because `Pₖ ≡ Bₖ₋₁` - `X_PₖBₖ ≡ X_PₖFₖ * X_FₖMₖ(q) * X_MₖBₖ`, where: -
`X_MₖBₖ = I` in Drake's implementation. - `X_FₖMₖ(q) = I` because we
only follow FixedJoint instances.

If the body is not rigidly fixed to the world, an exception will be
thrown.

Returns:
    `X_WBₙ`.

See also:
    IsRigidlyFixedToWorld)""";

    } ComputeWorldFixedPose;

    // RigidBody::IsRigidlyFixedToWorld
    struct /* IsRigidlyFixedToWorld */ {

      // drake/multibody/rigid_body.h:283
      const char* doc =
R"""(Reports if there is a path in this tree from this body to the world
where all joints are *fixed*. This method throws an exception if the
RigidBodyTree is invalid in that: - This node is the descendant of a
parentless node that is *not* the world node, or - This node does not
have a valid DrakeJoint.)""";

    } IsRigidlyFixedToWorld;

    // RigidBody::RigidBody<U>
    struct /* ctor */ {

      // drake/multibody/rigid_body.h:23
      const char* doc = R"""()""";

    } ctor;

    // RigidBody::add_joint
    struct /* add_joint */ {

      // drake/multibody/rigid_body.h:103
      const char* doc =
R"""(Adds degrees of freedom to this body by connecting it to ``parent``
with ``joint``. The body takes ownership of the joint.

This method aborts with an error message if the user attempts to
assign a joint to a body that already has one.

Note that this is specifically a tree joint and that by "parent" we
mean a body that is closer to "world" in the tree topology.

The ``parent`` pointer is copied and stored meaning its lifetime must
exceed the lifetime of this RigidBody.

Parameter ``parent``:
    The RigidBody this body gets connected to.

Parameter ``joint``:
    The DrakeJoint connecting this body to ``parent`` and adding
    degrees of freedom to this body.

Returns:
    A pointer to the joint just added to the body.)""";

    } add_joint;

    // RigidBody::adjacentTo
    struct /* adjacentTo */ {

      // drake/multibody/rigid_body.h:331
      const char* doc =
R"""(Reports if this body is considered "adjacent" to the given body.

"Adjacency" refers to the idea that the bodies are connected to each
other in the rigid body tree by a non-floating joint. By this
definition, a rigid body is *not* adjacent to itself.

In the degenerate case where one rigid body is a parent of the other,
but with no joint assigned, the rigid bodies will be considered
adjacent. Conversely, the degenerate case where a joint is assigned,
but the parent relationship is not set, the rigid bodies will *not* be
considered adjacent.

Parameter ``other``:
    The body to test against this body.

Returns:
    `true` if the bodies are "adjacent".)""";

    } adjacentTo;

    // RigidBody::appendCollisionElementIdsFromThisBody
    struct /* appendCollisionElementIdsFromThisBody */ {

      // drake/multibody/rigid_body.h:342
      const char* doc = R"""()""";

      // drake/multibody/rigid_body.h:347
      const char* doc_2 = R"""()""";

    } appendCollisionElementIdsFromThisBody;

    // RigidBody::collision_elements_begin
    struct /* collision_elements_begin */ {

      // drake/multibody/rigid_body.h:424
      const char* doc = R"""()""";

    } collision_elements_begin;

    // RigidBody::collision_elements_end
    struct /* collision_elements_end */ {

      // drake/multibody/rigid_body.h:428
      const char* doc = R"""()""";

    } collision_elements_end;

    // RigidBody::getJoint
    struct /* getJoint */ {

      // drake/multibody/rigid_body.h:120
      const char* doc =
R"""(An accessor to this rigid body's parent joint. By "parent joint" we
mean the joint through which this rigid body connects to its parent
rigid body in the rigid body tree.

Returns:
    The parent joint of this rigid body.)""";

    } getJoint;

    // RigidBody::get_body_index
    struct /* get_body_index */ {

      // drake/multibody/rigid_body.h:193
      const char* doc =
R"""(Returns the "body index" of this `RigidBody`. This is the index within
the vector of `RigidBody` objects within the `RigidBodyTree`.)""";

    } get_body_index;

    // RigidBody::get_center_of_mass
    struct /* get_center_of_mass */ {

      // drake/multibody/rigid_body.h:385
      const char* doc =
R"""(Gets the center of mass of this rigid body. The center of mass is
expressed in this body's frame.)""";

    } get_center_of_mass;

    // RigidBody::get_collision_element_ids
    struct /* get_collision_element_ids */ {

      // drake/multibody/rigid_body.h:249
      const char* doc =
R"""(Returns:
    A reference to an `std::vector` of collision elements that
    represent the collision geometry of this rigid body.)""";

    } get_collision_element_ids;

    // RigidBody::get_contact_points
    struct /* get_contact_points */ {

      // drake/multibody/rigid_body.h:356
      const char* doc =
R"""(Returns the points on this rigid body that should be checked for
collision with the environment. These are the contact points that were
saved by RigidBody::set_contact_points().)""";

    } get_contact_points;

    // RigidBody::get_group_to_collision_ids_map
    struct /* get_group_to_collision_ids_map */ {

      // drake/multibody/rigid_body.h:265
      const char* doc =
R"""(Returns a map of collision element group names to vectors of collision
element IDs. These are the collision element groups created through
calls to RigidBody::AddCollisionElementToGroup().)""";

    } get_group_to_collision_ids_map;

    // RigidBody::get_mass
    struct /* get_mass */ {

      // drake/multibody/rigid_body.h:373
      const char* doc = R"""(Returns the mass of this rigid body.)""";

    } get_mass;

    // RigidBody::get_model_instance_id
    struct /* get_model_instance_id */ {

      // drake/multibody/rigid_body.h:66
      const char* doc =
R"""(Returns the ID of the model instance to which this rigid body belongs.)""";

    } get_model_instance_id;

    // RigidBody::get_model_name
    struct /* get_model_name */ {

      // drake/multibody/rigid_body.h:56
      const char* doc =
R"""(Returns the name of the model defining this rigid body.)""";

    } get_model_name;

    // RigidBody::get_mutable_collision_element_ids
    struct /* get_mutable_collision_element_ids */ {

      // drake/multibody/rigid_body.h:256
      const char* doc =
R"""(Returns a reference to an `std::vector` of collision elements that
represent the collision geometry of this rigid body.)""";

    } get_mutable_collision_element_ids;

    // RigidBody::get_mutable_group_to_collision_ids_map
    struct /* get_mutable_group_to_collision_ids_map */ {

      // drake/multibody/rigid_body.h:273
      const char* doc =
R"""(Returns a map of collision element group names to vectors of collision
element IDs. These are the collision element groups created through
calls to RigidBody::AddCollisionElementToGroup().)""";

    } get_mutable_group_to_collision_ids_map;

    // RigidBody::get_mutable_joint
    struct /* get_mutable_joint */ {

      // drake/multibody/rigid_body.h:131
      const char* doc =
R"""(An accessor to this rigid body's mutable inboard joint. Also called
"parent joint".

Throws:
    s std::runtime_error if there is no joint (joint == nullptr)

Returns:
    The mutable inboard joint of this rigid body.)""";

    } get_mutable_joint;

    // RigidBody::get_name
    struct /* get_name */ {

      // drake/multibody/rigid_body.h:46
      const char* doc = R"""(Returns the name of this rigid body.)""";

    } get_name;

    // RigidBody::get_num_collision_elements
    struct /* get_num_collision_elements */ {

      // drake/multibody/rigid_body.h:436
      const char* doc =
R"""(Reports the total number of *registered* collision elements attached
to this body. See Model::AddElement() for definition of "registered".)""";

    } get_num_collision_elements;

    // RigidBody::get_parent
    struct /* get_parent */ {

      // drake/multibody/rigid_body.h:154
      const char* doc =
R"""(Returns a const pointer to this rigid body's parent rigid body.)""";

    } get_parent;

    // RigidBody::get_position_start_index
    struct /* get_position_start_index */ {

      // drake/multibody/rigid_body.h:209
      const char* doc =
R"""(Returns the start index of this body's parent jont's position states;
see RigidBody::set_position_start_index() for more information.)""";

    } get_position_start_index;

    // RigidBody::get_spatial_inertia
    struct /* get_spatial_inertia */ {

      // drake/multibody/rigid_body.h:396
      const char* doc =
R"""(Returns the spatial inertia of this rigid body.)""";

    } get_spatial_inertia;

    // RigidBody::get_velocity_start_index
    struct /* get_velocity_start_index */ {

      // drake/multibody/rigid_body.h:225
      const char* doc =
R"""(Returns the start index of this body's parent jont's velocity states;
see RigidBody::set_velocity_start_index() for more information.)""";

    } get_velocity_start_index;

    // RigidBody::get_visual_elements
    struct /* get_visual_elements */ {

      // drake/multibody/rigid_body.h:229
      const char* doc = R"""()""";

    } get_visual_elements;

    // RigidBody::hasParent
    struct /* hasParent */ {

      // drake/multibody/rigid_body.h:168
      const char* doc = R"""()""";

    } hasParent;

    // RigidBody::has_as_parent
    struct /* has_as_parent */ {

      // drake/multibody/rigid_body.h:177
      const char* doc =
R"""(Checks if a particular rigid body is the parent of this rigid body.

Parameter ``other``:
    The potential parent of this rigid body.

Returns:
    true if the supplied rigid body parameter other is the parent of
    this rigid body.)""";

    } has_as_parent;

    // RigidBody::has_joint
    struct /* has_joint */ {

      // drake/multibody/rigid_body.h:141
      const char* doc = R"""(Reports if the body has a parent joint.)""";

    } has_joint;

    // RigidBody::has_parent_body
    struct /* has_parent_body */ {

      // drake/multibody/rigid_body.h:164
      const char* doc =
R"""(Returns whether this RigidBody has a "parent", which is a RigidBody
that is connected to this RigidBody via a DrakeJoint and is closer to
the root of the RigidBodyTree relative to this RigidBody. In other
words, the parent RigidBody is part of a kinematic path from this
RigidBody to the root of the RigidBodyTree. Thus, by definition, all
RigidBody objects should have a parent RigidBody except for the
RigidBodyTree's root, which is the world.)""";

    } has_parent_body;

    // RigidBody::setJoint
    struct /* setJoint */ {

      // drake/multibody/rigid_body.h:82
      const char* doc =
R"""(Sets the parent joint through which this rigid body connects to its
parent rigid body.

Parameter ``joint``:
    The parent joint of this rigid body. Note that this rigid body
    assumes ownership of this joint.)""";

    } setJoint;

    // RigidBody::set_body_index
    struct /* set_body_index */ {

      // drake/multibody/rigid_body.h:187
      const char* doc =
R"""(Sets the "body index" of this `RigidBody`. The "body index" is the
index of this `RigidBody` within the vector of `RigidBody` objects
within the `RigidBodyTree`. Users should NOT call this method. It is
only here to be used internally by RigidBodyTree.)""";

    } set_body_index;

    // RigidBody::set_center_of_mass
    struct /* set_center_of_mass */ {

      // drake/multibody/rigid_body.h:379
      const char* doc =
R"""(Sets the center of mass of this rigid body. The center of mass is
expressed in this body's frame.)""";

    } set_center_of_mass;

    // RigidBody::set_contact_points
    struct /* set_contact_points */ {

      // drake/multibody/rigid_body.h:363
      const char* doc =
R"""(Saves the points on this rigid body that should be checked for
collision between this rigid body and the environment. These contact
points can be obtained through RigidBody::get_contact_points().)""";

    } set_contact_points;

    // RigidBody::set_mass
    struct /* set_mass */ {

      // drake/multibody/rigid_body.h:368
      const char* doc = R"""(Sets the mass of this rigid body.)""";

    } set_mass;

    // RigidBody::set_model_instance_id
    struct /* set_model_instance_id */ {

      // drake/multibody/rigid_body.h:71
      const char* doc =
R"""(Sets the ID of the model instance to which this rigid body belongs.)""";

    } set_model_instance_id;

    // RigidBody::set_model_name
    struct /* set_model_name */ {

      // drake/multibody/rigid_body.h:61
      const char* doc =
R"""(Sets the name of the model defining this rigid body.)""";

    } set_model_name;

    // RigidBody::set_name
    struct /* set_name */ {

      // drake/multibody/rigid_body.h:51
      const char* doc = R"""(Sets the name of this rigid body.)""";

    } set_name;

    // RigidBody::set_parent
    struct /* set_parent */ {

      // drake/multibody/rigid_body.h:149
      const char* doc =
R"""(Sets the parent rigid body. This is the rigid body that is connected
to this rigid body's joint.

Parameter ``parent``:
    A pointer to this rigid body's parent rigid body.)""";

    } set_parent;

    // RigidBody::set_position_start_index
    struct /* set_position_start_index */ {

      // drake/multibody/rigid_body.h:203
      const char* doc =
R"""(Sets the start index of this rigid body's mobilizer joint's contiguous
generalized coordinates `q` (joint position state variables) within
the full RigidBodyTree generalized coordinate vector.

For more details about the semantics of ``position_start_index``, see
the documentation for RigidBodyTree.)""";

    } set_position_start_index;

    // RigidBody::set_spatial_inertia
    struct /* set_spatial_inertia */ {

      // drake/multibody/rigid_body.h:390
      const char* doc =
R"""(Sets the spatial inertia of this rigid body.)""";

    } set_spatial_inertia;

    // RigidBody::set_velocity_start_index
    struct /* set_velocity_start_index */ {

      // drake/multibody/rigid_body.h:219
      const char* doc =
R"""(Sets the start index of this rigid body's mobilizer joint's contiguous
generalized velocity `v` (joint velocity state variables) within the
full RigidBodyTree generalized velocity vector.

For more details about the semantics of ``velocity_start_index``, see
the documentation for RigidBodyTree.)""";

    } set_velocity_start_index;

  } RigidBody;

  // RigidBodyActuator
  struct /* RigidBodyActuator */ {

    // drake/multibody/rigid_body_actuator.h:14
    const char* doc =
R"""(Defines a physical actuator (i.e., an electric motor and step-down
transmission) that operates on a joint. This class assumes the
actuator has a single DOF.)""";

    // RigidBodyActuator::RigidBodyActuator
    struct /* ctor */ {

      // drake/multibody/rigid_body_actuator.h:32
      const char* doc =
R"""(The constructor.

Parameter ``name``:
    The name of the actuator.

Parameter ``body``:
    A pointer to the rigid body whose joint's actuator is being
    described by this class.

Parameter ``reduction``:
    The gear reduction ratio of the actuator.

Parameter ``effort_limit_min``:
    The actuator's minimum effort limit. This has units of Nm for
    revolute joints and N for prismatic joints.

Parameter ``effort_limit_max``:
    The actuator's maximum effort limit. This has units of Nm for
    revolute joints and N for prismatic joints.)""";

    } ctor;

    // RigidBodyActuator::body_
    struct /* body_ */ {

      // drake/multibody/rigid_body_actuator.h:39
      const char* doc = R"""()""";

    } body_;

    // RigidBodyActuator::effort_limit_max_
    struct /* effort_limit_max_ */ {

      // drake/multibody/rigid_body_actuator.h:42
      const char* doc = R"""()""";

    } effort_limit_max_;

    // RigidBodyActuator::effort_limit_min_
    struct /* effort_limit_min_ */ {

      // drake/multibody/rigid_body_actuator.h:41
      const char* doc = R"""()""";

    } effort_limit_min_;

    // RigidBodyActuator::name_
    struct /* name_ */ {

      // drake/multibody/rigid_body_actuator.h:38
      const char* doc = R"""()""";

    } name_;

    // RigidBodyActuator::reduction_
    struct /* reduction_ */ {

      // drake/multibody/rigid_body_actuator.h:40
      const char* doc = R"""()""";

    } reduction_;

  } RigidBodyActuator;

  // RigidBodyConstraint
  struct /* RigidBodyConstraint */ {

    // drake/multibody/inverse_kinematics_backend.h:12
    const char* doc =
R"""(@class RigidBodyConstraint The abstract base class. All constraints
used in the inverse kinematics problem are inherited from
RigidBodyConstraint. There are 6 main categories of the
RigidBodyConstraint, each category has its own interface)""";

    // drake/multibody/rigid_body_constraint.h:27
    const char* doc_2 =
R"""(@class RigidBodyConstraint The abstract base class. All constraints
used in the inverse kinematics problem are inherited from
RigidBodyConstraint. There are 6 main categories of the
RigidBodyConstraint, each category has its own interface)""";

    // RigidBodyConstraint::RigidBodyConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:64
      const char* doc = R"""()""";

    } ctor;

    // RigidBodyConstraint::getCategory
    struct /* getCategory */ {

      // drake/multibody/rigid_body_constraint.h:68
      const char* doc = R"""()""";

    } getCategory;

    // RigidBodyConstraint::getRobotPointer
    struct /* getRobotPointer */ {

      // drake/multibody/rigid_body_constraint.h:69
      const char* doc = R"""()""";

    } getRobotPointer;

    // RigidBodyConstraint::getTimeString
    struct /* getTimeString */ {

      // drake/multibody/rigid_body_constraint.h:73
      const char* doc = R"""()""";

    } getTimeString;

    // RigidBodyConstraint::getType
    struct /* getType */ {

      // drake/multibody/rigid_body_constraint.h:67
      const char* doc = R"""()""";

    } getType;

    // RigidBodyConstraint::set_robot
    struct /* set_robot */ {

      // drake/multibody/rigid_body_constraint.h:75
      const char* doc = R"""()""";

    } set_robot;

    // RigidBodyConstraint::set_type
    struct /* set_type */ {

      // drake/multibody/rigid_body_constraint.h:74
      const char* doc = R"""()""";

    } set_type;

    // RigidBodyConstraint::tspan
    struct /* tspan */ {

      // drake/multibody/rigid_body_constraint.h:76
      const char* doc = R"""()""";

    } tspan;

  } RigidBodyConstraint;

  // RigidBodyDistanceConstraint
  struct /* RigidBodyDistanceConstraint */ {

    // drake/multibody/rigid_body_distance_constraint.h:12
    const char* doc =
R"""(Defines a "relative distance constraint" that models a constraint
between points on two different rigid bodies. The relative distance
constraint is specified by the indexes of two different `RigidBody`
objects (bodyA and bodyB), two `Vector3d` objects representing a point
relative to the origin on each `RigidBody` object (r_AP and r_BQ), and
a distance between these two points (distance).)""";

    // RigidBodyDistanceConstraint::RigidBodyDistanceConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_distance_constraint.h:26
      const char* doc =
R"""(The constructor

Parameter ``bodyA_index_in``:
    Index of first RigidBody involved in constraint.

Parameter ``r_AP_in``:
    Point on first RigidBody to measure distance from.

Parameter ``bodyB_index_in``:
    Index of second RigidBody involved in constraint.

Parameter ``r_BQ_in``:
    Point on second RigidBody to measure distance from.

Parameter ``distance_in``:
    Distance the two points should be separated by.)""";

    } ctor;

    // RigidBodyDistanceConstraint::bodyA_index
    struct /* bodyA_index */ {

      // drake/multibody/rigid_body_distance_constraint.h:32
      const char* doc = R"""()""";

    } bodyA_index;

    // RigidBodyDistanceConstraint::bodyB_index
    struct /* bodyB_index */ {

      // drake/multibody/rigid_body_distance_constraint.h:33
      const char* doc = R"""()""";

    } bodyB_index;

    // RigidBodyDistanceConstraint::distance
    struct /* distance */ {

      // drake/multibody/rigid_body_distance_constraint.h:36
      const char* doc = R"""()""";

    } distance;

    // RigidBodyDistanceConstraint::r_AP
    struct /* r_AP */ {

      // drake/multibody/rigid_body_distance_constraint.h:34
      const char* doc = R"""()""";

    } r_AP;

    // RigidBodyDistanceConstraint::r_BQ
    struct /* r_BQ */ {

      // drake/multibody/rigid_body_distance_constraint.h:35
      const char* doc = R"""()""";

    } r_BQ;

  } RigidBodyDistanceConstraint;

  // RigidBodyFrame
  struct /* RigidBodyFrame */ {

    // drake/multibody/rigid_body_frame.h:30
    const char* doc =
R"""(Multibody systems typically have distinguished frames of interest that
need to be monitored. A frame is fully described by the body it is
rigidly attached to and the pose of this frame with respect to that
body. RigidBodyFrame provides an abstraction to describe these frames.

Template parameter ``T``:
    The type being integrated. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

    // RigidBodyFrame::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
    struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

      // drake/multibody/rigid_body_frame.h:32
      const char* doc = R"""()""";

    } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

    // RigidBodyFrame::RigidBodyFrame<T>
    struct /* ctor */ {

      // drake/multibody/rigid_body_frame.h:32
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_frame.h:32
      const char* doc_2 = R"""()""";

      // drake/multibody/rigid_body_frame.h:41
      const char* doc_3 = R"""()""";

      // drake/multibody/rigid_body_frame.h:50
      const char* doc_4 = R"""()""";

      // drake/multibody/rigid_body_frame.h:60
      const char* doc_5 = R"""()""";

    } ctor;

    // RigidBodyFrame::get_frame_index
    struct /* get_frame_index */ {

      // drake/multibody/rigid_body_frame.h:126
      const char* doc =
R"""(Returns the index of this `RigidBodyFrame` within the vector of
`RigidBodyFrame` objects in the `RigidBodyTree`.)""";

    } get_frame_index;

    // RigidBodyFrame::get_model_instance_id
    struct /* get_model_instance_id */ {

      // drake/multibody/rigid_body_frame.h:67
      const char* doc =
R"""(Returns the ID of the model instance to which this rigid body frame
belongs.)""";

    } get_model_instance_id;

    // RigidBodyFrame::get_mutable_rigid_body
    struct /* get_mutable_rigid_body */ {

      // drake/multibody/rigid_body_frame.h:86
      const char* doc =
R"""(Returns the rigid body to which this frame is attached.)""";

    } get_mutable_rigid_body;

    // RigidBodyFrame::get_mutable_transform_to_body
    struct /* get_mutable_transform_to_body */ {

      // drake/multibody/rigid_body_frame.h:120
      const char* doc =
R"""(Returns the transform between the coordinate frame that belongs to
this `RigidBodyFrame` and the coordinate frame that belongs to the
`RigidBody` to which this frame is attached.)""";

    } get_mutable_transform_to_body;

    // RigidBodyFrame::get_name
    struct /* get_name */ {

      // drake/multibody/rigid_body_frame.h:72
      const char* doc = R"""(Returns the name of this frame.)""";

    } get_name;

    // RigidBodyFrame::get_rigid_body
    struct /* get_rigid_body */ {

      // drake/multibody/rigid_body_frame.h:77
      const char* doc =
R"""(Returns the rigid body to which this frame is attached.)""";

    } get_rigid_body;

    // RigidBodyFrame::get_transform_to_body
    struct /* get_transform_to_body */ {

      // drake/multibody/rigid_body_frame.h:107
      const char* doc =
R"""(Returns the transform between the coordinate frame that belongs to
this `RigidBodyFrame` and the coordinate frame that belongs to the
`RigidBody` to which this frame is attached (which is obtainable by
calling RigidBodyFrame::get_rigid_body()).

Let `B` be the coordinate frame of the `RigidBody` to which this
`RigidBodyFrame` is attached and `F` be the coordinate frame of this
`RigidBodyFrame`. Furthermore, let `p_B` be the location of a point
measured from `B`'s origin and expressed in coordinate frame `B`, and
`p_F` be the location of the same point but measured from `F`'s origin
and expressed in coordinate frame `F`.

The returned value is `T_BF` where:

```
p_B = T_BF * p_F;
```)""";

    } get_transform_to_body;

    // RigidBodyFrame::has_as_rigid_body
    struct /* has_as_rigid_body */ {

      // drake/multibody/rigid_body_frame.h:148
      const char* doc =
R"""(Returns true if this frame's rigid body is equal to the
``rigid_body``.)""";

    } has_as_rigid_body;

    // RigidBodyFrame::set_frame_index
    struct /* set_frame_index */ {

      // drake/multibody/rigid_body_frame.h:158
      const char* doc =
R"""(Sets the index of this frame. This is the index in the vector of
`RigidBodyFrames` within the `RigidBodyTree`.)""";

    } set_frame_index;

    // RigidBodyFrame::set_name
    struct /* set_name */ {

      // drake/multibody/rigid_body_frame.h:131
      const char* doc = R"""(Sets the name of this `RigidBodyFrame`.)""";

    } set_name;

    // RigidBodyFrame::set_rigid_body
    struct /* set_rigid_body */ {

      // drake/multibody/rigid_body_frame.h:141
      const char* doc = R"""()""";

    } set_rigid_body;

    // RigidBodyFrame::set_transform_to_body
    struct /* set_transform_to_body */ {

      // drake/multibody/rigid_body_frame.h:168
      const char* doc = R"""()""";

    } set_transform_to_body;

  } RigidBodyFrame;

  // RigidBodyLoop
  struct /* RigidBodyLoop */ {

    // drake/multibody/rigid_body_loop.h:28
    const char* doc =
R"""(Defines a "loop joint" that models a kinematic loop formed by a chain
of rigid bodies and their regular joints. The loop joint is specified
by two `RigidBodyFrame` objects that must be attached to two different
`RigidBody` objects. The coordinate frames defined by the two
`RigidBodyFrame` objects are constrained to have the same origin. The
orientations of the two frames are partially constrained based on the
axis of rotation (i.e., the two frames are only allowed to rotate
relative to each other along the axis of rotation).

Template parameter ``T``:
    The type being integrated. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

    // RigidBodyLoop::RigidBodyLoop<T>
    struct /* ctor */ {

      // drake/multibody/rigid_body_loop.h:43
      const char* doc =
R"""(Constructs a kinematic loop by fully constraining the origins and
partially constraining the orientations of two frames. The two frames
are defined relative to two rigid bodies that should be connected via
a loop joint.

Parameter ``frameA``:
    A frame defined relative to the loop joint's "parent" rigid body.

Parameter ``frameB``:
    A frame defined relative to the loop joint's "child" rigid body.

Parameter ``axis``:
    The loop joint's axis of rotation expressed in the coordinate
    frame of ``frameA``.)""";

    } ctor;

    // RigidBodyLoop::axis_
    struct /* axis_ */ {

      // drake/multibody/rigid_body_loop.h:48
      const char* doc = R"""()""";

    } axis_;

    // RigidBodyLoop::frameA_
    struct /* frameA_ */ {

      // drake/multibody/rigid_body_loop.h:47
      const char* doc = R"""()""";

    } frameA_;

    // RigidBodyLoop::frameB_
    struct /* frameB_ */ {

      // drake/multibody/rigid_body_loop.h:47
      const char* doc = R"""()""";

    } frameB_;

  } RigidBodyLoop;

  // RigidBodyTree
  struct /* RigidBodyTree */ {

    // drake/multibody/ik_options.h:6
    const char* doc =
R"""(Maintains a vector of RigidBody objects that are arranged into a
kinematic tree via DrakeJoint objects. It provides various utility
methods for computing kinematic and dynamics properties of the
RigidBodyTree.

The internal organization of a RigidBodyTree's generalized state
vector is as follows:

```
[model instance 1's generalized coordinate vector]
[model instance 2's generalized coordinate vector]
...
[model instance 1's generalized velocity vector]
[model instance 2's generalized velocity vector]
...
```

Each RigidBody maintains for its joint that connects to its parent the
indices of the joint's generalized coordinate vector and generalized
velocity vector in the RigidBodyTree's generalized state vector.

The starting index of the joint's generalized coordinate vector in the
RigidBodyTree's generalized state vector can be obtained by executing
RigidBody::get_position_start_index().

The starting index of the joint's generalized velocity vector in the
RigidBodyTree's generalized state vector can be computed as follows:
RigidBodyTree::get_num_positions() +
RigidBody::get_velocity_start_index().

Note that the velocity index starts at the beginning of the velocity
state variables and not at the beginning of the full state of the
RigidBodyTree. This is why the total number of positions needs to be
added to the velocity index to get its index in the RigidBodyTree's
full state vector.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

    // drake/multibody/rigid_body_tree.h:109
    const char* doc_2 =
R"""(Maintains a vector of RigidBody objects that are arranged into a
kinematic tree via DrakeJoint objects. It provides various utility
methods for computing kinematic and dynamics properties of the
RigidBodyTree.

The internal organization of a RigidBodyTree's generalized state
vector is as follows:

```
[model instance 1's generalized coordinate vector]
[model instance 2's generalized coordinate vector]
...
[model instance 1's generalized velocity vector]
[model instance 2's generalized velocity vector]
...
```

Each RigidBody maintains for its joint that connects to its parent the
indices of the joint's generalized coordinate vector and generalized
velocity vector in the RigidBodyTree's generalized state vector.

The starting index of the joint's generalized coordinate vector in the
RigidBodyTree's generalized state vector can be obtained by executing
RigidBody::get_position_start_index().

The starting index of the joint's generalized velocity vector in the
RigidBodyTree's generalized state vector can be computed as follows:
RigidBodyTree::get_num_positions() +
RigidBody::get_velocity_start_index().

Note that the velocity index starts at the beginning of the velocity
state variables and not at the beginning of the full state of the
RigidBodyTree. This is why the total number of positions needs to be
added to the velocity index to get its index in the RigidBodyTree's
full state vector.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

    // drake/multibody/rigid_body_tree.h:1833
    const char* doc_3 = R"""()""";

    // drake/systems/controllers/inverse_dynamics.h:13
    const char* doc_4 =
R"""(Maintains a vector of RigidBody objects that are arranged into a
kinematic tree via DrakeJoint objects. It provides various utility
methods for computing kinematic and dynamics properties of the
RigidBodyTree.

The internal organization of a RigidBodyTree's generalized state
vector is as follows:

```
[model instance 1's generalized coordinate vector]
[model instance 2's generalized coordinate vector]
...
[model instance 1's generalized velocity vector]
[model instance 2's generalized velocity vector]
...
```

Each RigidBody maintains for its joint that connects to its parent the
indices of the joint's generalized coordinate vector and generalized
velocity vector in the RigidBodyTree's generalized state vector.

The starting index of the joint's generalized coordinate vector in the
RigidBodyTree's generalized state vector can be obtained by executing
RigidBody::get_position_start_index().

The starting index of the joint's generalized velocity vector in the
RigidBodyTree's generalized state vector can be computed as follows:
RigidBodyTree::get_num_positions() +
RigidBody::get_velocity_start_index().

Note that the velocity index starts at the beginning of the velocity
state variables and not at the beginning of the full state of the
RigidBodyTree. This is why the total number of positions needs to be
added to the velocity index to get its index in the RigidBodyTree's
full state vector.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

    // drake/systems/controllers/inverse_dynamics_controller.h:17
    const char* doc_5 =
R"""(Maintains a vector of RigidBody objects that are arranged into a
kinematic tree via DrakeJoint objects. It provides various utility
methods for computing kinematic and dynamics properties of the
RigidBodyTree.

The internal organization of a RigidBodyTree's generalized state
vector is as follows:

```
[model instance 1's generalized coordinate vector]
[model instance 2's generalized coordinate vector]
...
[model instance 1's generalized velocity vector]
[model instance 2's generalized velocity vector]
...
```

Each RigidBody maintains for its joint that connects to its parent the
indices of the joint's generalized coordinate vector and generalized
velocity vector in the RigidBodyTree's generalized state vector.

The starting index of the joint's generalized coordinate vector in the
RigidBodyTree's generalized state vector can be obtained by executing
RigidBody::get_position_start_index().

The starting index of the joint's generalized velocity vector in the
RigidBodyTree's generalized state vector can be computed as follows:
RigidBodyTree::get_num_positions() +
RigidBody::get_velocity_start_index().

Note that the velocity index starts at the beginning of the velocity
state variables and not at the beginning of the full state of the
RigidBodyTree. This is why the total number of positions needs to be
added to the velocity index to get its index in the RigidBodyTree's
full state vector.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

    // RigidBodyTree::AddCollisionFilterGroupMember
    struct /* AddCollisionFilterGroupMember */ {

      // drake/multibody/rigid_body_tree.h:1593
      const char* doc =
R"""(Adds a RigidBody to a collision filter group. The RigidBody is
referenced by name and model instance id. The process will fail if the
body cannot be found or if the group cannot be found.

Parameter ``group_name``:
    The collision filter group name to add the body to.

Parameter ``body_name``:
    The name of the body to add.

Parameter ``model_id``:
    The id of the model instance to which this body belongs.

Throws:
    s std::logic_error in response to failure conditions.)""";

    } AddCollisionFilterGroupMember;

    // RigidBodyTree::AddCollisionFilterIgnoreTarget
    struct /* AddCollisionFilterIgnoreTarget */ {

      // drake/multibody/rigid_body_tree.h:1606
      const char* doc =
R"""(Adds a collision group to the set of groups ignored by the specified
collision filter group. Will fail if the specified group name does not
refer to an existing collision filter group. (The target group name
need not exist at this time.)

Parameter ``group_name``:
    $Parameter ``target_group_name``:

Throws:
    s std::logic_error in response to failure conditions.)""";

    } AddCollisionFilterIgnoreTarget;

    // RigidBodyTree::B
    struct /* B */ {

      // drake/multibody/rigid_body_tree.h:1693
      const char* doc = R"""()""";

    } B;

    // RigidBodyTree::CalcBodyPoseInWorldFrame
    struct /* CalcBodyPoseInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:375
      const char* doc =
R"""(Computes the pose `X_WB` of ``body``'s frame B in the world frame W.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody. @retval `X_WB`)""";

    } CalcBodyPoseInWorldFrame;

    // RigidBodyTree::CalcBodySpatialVelocityInWorldFrame
    struct /* CalcBodySpatialVelocityInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:409
      const char* doc =
R"""(Computes the spatial velocity `V_WB` of ``body``'s frame B measured
and expressed in the world frame W.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody. @retval `V_WB`)""";

    } CalcBodySpatialVelocityInWorldFrame;

    // RigidBodyTree::CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame
    struct /* CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:575
      const char* doc =
R"""(Computes `Jdot_WB * v`, where `J_WB` is the Jacobian of the spatial
velocity `V_WB` of body frame B measured and expressed in the world
frame W, and `v` is the generalized velocity.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody. @retval `Jdot_WB * v`)""";

    } CalcBodySpatialVelocityJacobianDotTimesVInWorldFrame;

    // RigidBodyTree::CalcBodySpatialVelocityJacobianInWorldFrame
    struct /* CalcBodySpatialVelocityJacobianInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:519
      const char* doc =
R"""(Computes the Jacobian `J_WB` of the spatial velocity `V_WB` of body
frame B measured and expressed in the world frame `W` such that `V_WB
= J_WB * v`, where `v` is the generalized velocity.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WB` computed with respect to the time derivative of
    the generalized position such that `V_WB = J_WB * qdot`. `false`
    for `J_WB` computed with respect to `v`. @retval `J_WB`)""";

      // drake/multibody/rigid_body_tree.h:536
      const char* doc_2 =
R"""(Computes the Jacobian `J_WB` of the spatial velocity `V_WB` of body
frame B measured and expressed in the world frame `W` such that `V_WB
= J_WB * v`, where `v` is the generalized velocity. This version does
not allocate memory and will assert if `J_WB` is incorrectly sized.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WB` computed with respect to the time derivative of
    the generalized position such that `V_WB = J_WB * qdot`. `false`
    for `J_WB` computed with respect to `v`.

Parameter ``J_WB``:
    Pointer to the output Jacobian.)""";

    } CalcBodySpatialVelocityJacobianInWorldFrame;

    // RigidBodyTree::CalcFramePoseInWorldFrame
    struct /* CalcFramePoseInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:388
      const char* doc =
R"""(Computes the pose `X_WF` of ``frame_F`` in the world frame W.
``frame_F`` does not necessarily need to be owned by this
RigidBodyTree. However, the RigidBody to which ``frame_F`` attaches to
has to be owned by this RigidBodyTree.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``frame_F``:
    Reference to the RigidBodyFrame. @retval `X_WF`)""";

      // drake/multibody/rigid_body_tree.h:400
      const char* doc_2 =
R"""(Computes the pose `X_WF` of the rigid body frame F in the world frame
W. Frame F is rigidly attached to ``body``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody.

Parameter ``X_BF``:
    The pose of frame F in body frame B. @retval `X_WF`)""";

    } CalcFramePoseInWorldFrame;

    // RigidBodyTree::CalcFrameSpatialVelocityInWorldFrame
    struct /* CalcFrameSpatialVelocityInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:419
      const char* doc =
R"""(Computes the spatial velocity `V_WF` of RigidBodyFrame ``frame_F``
measured and expressed in the world frame W. ``frame_F`` does not
necessarily need to be owned by this RigidBodyTree. However, the
RigidBody to which ``frame_F`` attaches to has to be owned by this
RigidBodyTree.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``frame_F``:
    Reference to the RigidBodyFrame. @retval `V_WF`)""";

      // drake/multibody/rigid_body_tree.h:432
      const char* doc_2 =
R"""(Computes the spatial velocity `V_WF` of the frame F measured and
expressed in the world frame W. Frame F is rigidly attached to
``body``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody.

Parameter ``X_BF``:
    The pose of frame F in body frame B. @retval `V_WF`)""";

    } CalcFrameSpatialVelocityInWorldFrame;

    // RigidBodyTree::CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame
    struct /* CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:550
      const char* doc =
R"""(Computes `Jdot_WF * v`, where `J_WF` is the Jacobian of spatial
velocity, `V_WF`, of frame F measured and expressed in the world frame
W, and `v` is the generalized velocity. Frame F is rigidly attached to
``body``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``body``:
    Reference to the RigidBody.

Parameter ``X_BF``:
    The pose of frame F in body frame B. @retval `Jdot_WF * v`)""";

      // drake/multibody/rigid_body_tree.h:562
      const char* doc_2 =
R"""(Computes `Jdot_WF * v`, where `J_WF` is the Jacobian of spatial
velocity `V_WF` of frame F measured and expressed in the world frame
W, and `v` is the generalized velocity. ``frame_F`` does not
necessarily need to be owned by this RigidBodyTree. However, the
RigidBody to which ``frame_F`` attaches to has to be owned by this
RigidBodyTree.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``frame_F``:
    Reference to the RigidBodyFrame. @retval `Jdot_WF * v`)""";

    } CalcFrameSpatialVelocityJacobianDotTimesVInWorldFrame;

    // RigidBodyTree::CalcFrameSpatialVelocityJacobianInWorldFrame
    struct /* CalcFrameSpatialVelocityJacobianInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:447
      const char* doc =
R"""(Computes the Jacobian `J_WF` of the spatial velocity `V_WF` of frame F
measured and expressed in the world frame W such that `V_WF = J_WF *
v`, where `v` is the generalized velocity. Frame F is rigidly attached
to ``body``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``B``:
    Reference to the RigidBody.

Parameter ``X_BF``:
    The pose of frame F in body frame B.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WF` computed with respect to the time derivative of
    the generalized position such that `V_WF = J_WF * qdot`. `false`
    for `J_WF` computed with respect to `v`. @retval `J_WF`)""";

      // drake/multibody/rigid_body_tree.h:464
      const char* doc_2 =
R"""(Computes the Jacobian `J_WF` of the spatial velocity `V_WF` of frame F
measured and expressed in the world frame W such that `V_WF = J_WF *
v`, where `v` is the generalized velocity. Frame F is rigidly attached
to ``body``. This version does not allocate memory and will assert if
`J_WF` is incorrectly sized.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``B``:
    Reference to the RigidBody.

Parameter ``X_BF``:
    The pose of frame F in body frame B.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WF` computed with respect to the time derivative of
    the generalized position such that `V_WF = J_WF * qdot`. `false`
    for `J_WF` computed with respect to `v`.

Parameter ``J_WF``:
    Pointer to the output Jacobian.)""";

      // drake/multibody/rigid_body_tree.h:480
      const char* doc_3 =
R"""(Computes the Jacobian `J_WF` of the spatial velocity `V_WF` of frame F
measured and expressed in the world frame W such that `V_WF = J_WF *
v`, where `v` is the generalized velocity. ``frame_F`` does not
necessarily need to be owned by this RigidBodyTree. However, the
RigidBody to which ``frame_F`` attaches to has to be owned by this
RigidBodyTree.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``frame_F``:
    Reference to the RigidBodyFrame.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WF` computed with respect to the time derivative of
    the generalized position such that `V_WF = J_WF * qdot`. `false`
    for `J_WF` computed with respect to `v`. @retval `J_WF`)""";

      // drake/multibody/rigid_body_tree.h:501
      const char* doc_4 =
R"""(Computes the Jacobian `J_WF` of the spatial velocity `V_WF` of frame F
measured and expressed in the world frame W such that `V_WF = J_WF *
v`, where `v` is the generalized velocity. ``frame_F`` does not
necessarily need to be owned by this RigidBodyTree. However, the
RigidBody to which ``frame_F`` attaches to has to be owned by this
RigidBodyTree. This version does not allocate memory and will assert
if `J_WF` is incorrectly sized.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``frame_F``:
    Reference to the RigidBodyFrame.

Parameter ``in_terms_of_qdot``:
    `true` for `J_WF` computed with respect to the time derivative of
    the generalized position such that `V_WF = J_WF * qdot`. `false`
    for `J_WF` computed with respect to `v`.

Parameter ``J_WF``:
    Pointer to the output Jacobian.)""";

    } CalcFrameSpatialVelocityJacobianInWorldFrame;

    // RigidBodyTree::CalcGeneralizedSpringForces
    struct /* CalcGeneralizedSpringForces */ {

      // drake/multibody/rigid_body_tree.h:854
      const char* doc =
R"""(Computes the generalized forces that correspond to joint springs.

Spring forces are computed joint-by-joint and are a function of
position only (they do not couple between joints))""";

    } CalcGeneralizedSpringForces;

    // RigidBodyTree::CheckCacheValidity
    struct /* CheckCacheValidity */ {

      // drake/multibody/rigid_body_tree.h:242
      const char* doc =
R"""(Checks whether ``cache`` is valid for use with this RigidBodyTree.
Throws a std::runtime_error exception if it is not valid.)""";

    } CheckCacheValidity;

    // RigidBodyTree::Clone
    struct /* Clone */ {

      // drake/multibody/rigid_body_tree.h:123
      const char* doc =
R"""(Returns a deep clone of this RigidBodyTree<double>. Currently,
everything *except* for collision and visual elements are cloned. Only
supported for T = double.)""";

      // drake/multibody/rigid_body_tree.h:1827
      const char* doc_2 = R"""()""";

    } Clone;

    // RigidBodyTree::ComputeMaximumDepthCollisionPoints
    struct /* ComputeMaximumDepthCollisionPoints */ {

      // drake/multibody/rigid_body_tree.h:1261
      const char* doc =
R"""(Computes the point of closest approach between bodies in the
RigidBodyTree that are in contact.

Parameter ``cache``:
    [in] a KinematicsCache constructed by RigidBodyTree::doKinematics
    given `q` and `v`.

Collision points are returned as a vector of PointPair's. See the
documentation for PointPair for details. The collision point on the
surface of each body is stored in the PointPair structure in the frame
of the corresponding body.

Parameter ``use_margins``:
    If `true` the model uses the representation with margins. If
    `false`, the representation without margins is used instead.

Throws:
    s std::runtime_error based on the criteria of
    DiscardZeroGradient() only if ``throws_if_missing_gradient`` is
    true.)""";

    } ComputeMaximumDepthCollisionPoints;

    // RigidBodyTree::CreateKinematicsCache
    struct /* CreateKinematicsCache */ {

      // drake/multibody/rigid_body_tree.h:250
      const char* doc =
R"""(Creates a KinematicsCache to perform computations with this
RigidBodyTree. The returned KinematicsCache is consistently templated
on the scalar type for this RigidBodyTree instance. Aborts if this
RigidBodyTree was not previously initialized with a call to
RigidBodyTree::compile().

Returns:
    The created KinematicsCache.)""";

    } CreateKinematicsCache;

    // RigidBodyTree::CreateKinematicsCacheFromBodiesVector
    struct /* CreateKinematicsCacheFromBodiesVector */ {

      // drake/multibody/rigid_body_tree.h:287
      const char* doc =
R"""(Creates a KinematicsCache given a reference to a vector of rigid
bodies contained within a RigidBodyTree. This method is static since
all the information to create the corresponding KinematicsCache
resides in the input parameter vector `bodies`.

Parameter ``bodies``:
    A vector of unique pointers to the rigid bodies of a given
    RigidBodyTree for which a KinematicsCache needs to be created.

Returns:
    The created KinematicsCache.)""";

    } CreateKinematicsCacheFromBodiesVector;

    // RigidBodyTree::CreateKinematicsCacheWithType
    struct /* CreateKinematicsCacheWithType */ {

      // drake/multibody/rigid_body_tree.h:271
      const char* doc =
R"""(A helper template method used to create a KinematicsCache templated on
`CacheT` from a RigidBodyTree templated on `T`, with `CacheT` and `T`
not necessarily the same scalar type. This method is particularly
useful in mex files where only a reference to a
`RigidBodyTree<double>` is available to create kinematics caches on
different scalar types. Aborts if this RigidBodyTree was not
previously initialized with a call to RigidBodyTree::compile().

Users should not call this method but instead create KinematicsCache
objects with RigidBodyTree:CreateKinematicsCache().

Template parameter ``CacheT``:
    The scalar type for the returned KinematicsCache.

Returns:
    A KinematicsCache templated on `CacheT` that can be used for
    computations on this RigidBodyTree with methods instantiated on
    `CacheT`.)""";

    } CreateKinematicsCacheWithType;

    // RigidBodyTree::DefineCollisionFilterGroup
    struct /* DefineCollisionFilterGroup */ {

      // drake/multibody/rigid_body_tree.h:1581
      const char* doc =
R"""(Attempts to define a new collision filter group. The given name *must*
be unique since the last invocation of compile() (or construction,
whichever is more recent). Duplicate names or attempting to add more
collision filter groups than the system can handle will lead to
failure. In the event of failure, an exception is thrown.
kMaxNumCollisionFilterGroups defines the limit of total collision
filter groups that are supported.

Parameter ``name``:
    The unique name of the new group. @trhows std::logic_error in
    response to failure conditions.)""";

    } DefineCollisionFilterGroup;

    // RigidBodyTree::FindAncestorBodies
    struct /* FindAncestorBodies */ {

      // drake/multibody/rigid_body_tree.h:745
      const char* doc =
R"""(Finds the ancestors of a body. The ancestors include the body's
parent, the parent's parent, etc., all the way to the root of this
RigidBodyTree, which represents the world.

Parameter ``body_index``:
    The index of the body in this RigidBodyTree for which the
    ancestors of the body are found. Ancestors are returned in a
    vector of body indexes.

Parameter ``ancestor_bodies``:
    A vector of body indexes of the ancestor bodies of the body with
    index ``body_index``.)""";

      // drake/multibody/rigid_body_tree.h:750
      const char* doc_2 =
R"""(Identical to the above overload, expect that this function return the
ancestor bodies instead of using an output argument.)""";

    } FindAncestorBodies;

    // RigidBodyTree::FindBaseBodies
    struct /* FindBaseBodies */ {

      // drake/multibody/rigid_body_tree.h:1329
      const char* doc =
R"""(Obtains a vector of indexes of the bodies that are directly attached
to the world via any type of joint. This method has a time complexity
of `O(N)` where `N` is the number of bodies in the tree, which can be
determined by calling RigidBodyTree::get_num_bodies().)""";

    } FindBaseBodies;

    // RigidBodyTree::FindBody
    struct /* FindBody */ {

      // drake/multibody/rigid_body_tree.h:1288
      const char* doc =
R"""(Finds a body with the specified ``body_name`` belonging to a model
with the specified ``model_name`` and ``model_id``. Note that if
``model_name`` is the empty string and ``model_id`` is -1, every model
is searched. If ``model_name`` and ``model_id`` are inconsistent, no
body will be found and an exception will be thrown.

Parameter ``body_name``:
    The name of the body to find.

Parameter ``model_name``:
    The name of the model to which the body belongs. If this value is
    an empty string, every model is searched.

Parameter ``model_id``:
    The ID of the model to which the body belongs. If this value is
    -1, every model is searched.

Throws:
    s std::logic_error if multiple matching bodies are found or no
    matching bodies are found.)""";

      // drake/multibody/rigid_body_tree.h:1298
      const char* doc_2 =
R"""(Reports the RigidBody that owns the collision element indicated by the
id.

Parameter ``element_id``:
    The id to query.

Returns:
    A pointer to the owning RigidBody.

Throws:
    s std::logic_error if no body can be mapped to the element id.)""";

    } FindBody;

    // RigidBodyTree::FindBodyIndex
    struct /* FindBodyIndex */ {

      // drake/multibody/rigid_body_tree.h:1350
      const char* doc =
R"""(Obtains the index of a rigid body within this rigid body tree. The
rigid body tree maintains a vector of pointers to all rigid bodies
that are part of the rigid body tree. The index of a rigid body is the
index within this vector at which a pointer to the rigid body is
stored.

Parameter ``body_name``:
    The body whose index we want to find. It should be unique within
    the searched models, otherwise an exception will be thrown.

Parameter ``model_instance_id``:
    The ID of the model instance. This parameter is optional. If
    supplied, only the model instance with the specified instance ID
    is searched; otherwise, all model instances are searched.

Returns:
    The index of the specified rigid body.

Throws:
    s std::logic_error if no rigid body with the specified
    ``body_name`` and ``model_id`` was found or if multiple matching
    rigid bodies were found.)""";

    } FindBodyIndex;

    // RigidBodyTree::FindChildBodyOfJoint
    struct /* FindChildBodyOfJoint */ {

      // drake/multibody/rigid_body_tree.h:1391
      const char* doc =
R"""(Obtains a pointer to the rigid body whose parent joint is named
``joint_name`` and is part of a model instance with ID
``model_instance_id``.

Parameter ``joint_name``:
    The name of the parent joint of the rigid body to find.

Parameter ``model_instance_id``:
    The ID of the model instance that owns the rigid body to find.
    This parameter is optional. If supplied, the set of rigid bodies
    to search through is restricted to those that belong to the
    specified model instance. Otherwise, all rigid bodies in this tree
    are searched.

Returns:
    A pointer to the rigid body whose parent joint is named
    ``joint_name`` joint and, if ``model_instance_id`` is specified,
    is part of the specified model instance.

Throws:
    s std::runtime_error If either no rigid body is found or multiple
    matching rigid bodies are found.)""";

    } FindChildBodyOfJoint;

    // RigidBodyTree::FindChildrenOfBody
    struct /* FindChildrenOfBody */ {

      // drake/multibody/rigid_body_tree.h:1361
      const char* doc =
R"""(Returns a vector of indexes of bodies that are the children of the
body at index ``parent_body_index``. The resulting list can be further
filtered to be bodies that belong to model instance ID
``model_instance_id``. This method has a time complexity of `O(N)`
where `N` is the number of bodies in the tree, which can be determined
by calling RigidBodyTree::get_num_bodies().)""";

    } FindChildrenOfBody;

    // RigidBodyTree::FindCollisionElement
    struct /* FindCollisionElement */ {

      // drake/multibody/rigid_body_tree.h:1024
      const char* doc =
R"""(Retrieve a `const` pointer to an element of the collision model. Note:
The use of Find (instead of get) and the use of CamelCase both imply a
potential runtime cost are carried over from the collision model
accessor method.)""";

    } FindCollisionElement;

    // RigidBodyTree::FindIndexOfChildBodyOfJoint
    struct /* FindIndexOfChildBodyOfJoint */ {

      // drake/multibody/rigid_body_tree.h:1419
      const char* doc =
R"""(Returns the index within the vector of rigid bodies of the rigid body
whose parent joint is named ``joint_name`` and is part of a model
instance with ID ``model_instance_id``.

Parameter ``joint_name``:
    The name of the parent joint of the rigid body whose index is
    being searched for.

Parameter ``model_instance_id``:
    The ID of the model instance that owns the rigid body to find.
    This parameter is optional. If supplied, the set of rigid bodies
    to search through is restricted to those that belong to the
    specified model instance. Otherwise, all rigid bodies in this tree
    are searched.

Returns:
    The index of the rigid body whose parent joint is named
    ``joint_name`` and, if ``model_instance_id`` is specified, is part
    of the specified model instance.

Throws:
    s std::runtime_error If either no rigid body is found or multiple
    matching rigid bodies are found.)""";

    } FindIndexOfChildBodyOfJoint;

    // RigidBodyTree::FindKinematicPath
    struct /* FindKinematicPath */ {

      // drake/multibody/rigid_body_tree.h:759
      const char* doc =
R"""(Find the kinematic path between two bodies or frames. This function
will not allocate memory if `path`, `start_body_ancestors` and
`end_body_ancestors` are preallocated.)""";

    } FindKinematicPath;

    // RigidBodyTree::FindModelInstanceBodies
    struct /* FindModelInstanceBodies */ {

      // drake/multibody/rigid_body_tree.h:1312
      const char* doc =
R"""(Returns a vector of pointers to all rigid bodies in this tree that
belong to a particular model instance.

Parameter ``model_instance_id``:
    The ID of the model instance whose rigid bodies are being searched
    for.

Returns:
    A vector of pointers to every rigid body belonging to the
    specified model instance.)""";

    } FindModelInstanceBodies;

    // RigidBodyTree::GetActuator
    struct /* GetActuator */ {

      // drake/multibody/rigid_body_tree.h:1487
      const char* doc =
R"""(Obtains a rigid body actuator from this rigid body tree. The actuator
is selected based on its name.

Parameter ``name``:
    The name of the rigid body actuator to get.

Returns:
    A const reference to the rigid body actuator with name ``name``.

Throws:
    s ValueError if no rigid body actuator with name ``name`` exists.)""";

    } GetActuator;

    // RigidBodyTree::GetQDotToVelocityMapping
    struct /* GetQDotToVelocityMapping */ {

      // drake/multibody/rigid_body_tree.h:661
      const char* doc = R"""()""";

    } GetQDotToVelocityMapping;

    // RigidBodyTree::GetVelocityToQDotMapping
    struct /* GetVelocityToQDotMapping */ {

      // drake/multibody/rigid_body_tree.h:657
      const char* doc = R"""()""";

    } GetVelocityToQDotMapping;

    // RigidBodyTree::LumpedSpatialInertiaInWorldFrame
    struct /* LumpedSpatialInertiaInWorldFrame */ {

      // drake/multibody/rigid_body_tree.h:354
      const char* doc =
R"""(Computes the summed spatial inertia in the world frame of all bodies
that belong to model instances in ``model_instance_id_set``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``model_instance_id_set``:
    A set of model instance ID values corresponding to the model
    instances whose spatial inertia should be included in the returned
    value.

Returns:
    The summed spatial inertia.)""";

      // drake/multibody/rigid_body_tree.h:367
      const char* doc_2 =
R"""(Computes the summed spatial inertia in the world frame of all the
bodies in ``bodies_of_interest``.

Parameter ``cache``:
    Reference to the KinematicsCache.

Parameter ``bodies_of_interest``:
    Vector of bodies, whose spatial inertia will be summed and
    returned.

Returns:
    The summed spatial inertia.)""";

    } LumpedSpatialInertiaInWorldFrame;

    // RigidBodyTree::RigidBodyTree<T>
    struct /* ctor */ {

      // drake/multibody/rigid_body_tree.h:114
      const char* doc =
R"""(A constructor that initializes the gravity vector to be [0, 0, -9.81]
and a single RigidBody named "world". This RigidBody can be accessed
by calling RigidBodyTree::world().)""";

    } ctor;

    // RigidBodyTree::a_grav
    struct /* a_grav */ {

      // drake/multibody/rigid_body_tree.h:1692
      const char* doc = R"""()""";

    } a_grav;

    // RigidBodyTree::actuators
    struct /* actuators */ {

      // drake/multibody/rigid_body_tree.h:1681
      const char* doc = R"""()""";

    } actuators;

    // RigidBodyTree::addCollisionElement
    struct /* addCollisionElement */ {

      // drake/multibody/rigid_body_tree.h:1015
      const char* doc =
R"""(Adds a new collision element to the tree. The input ``element`` will
be copied and that copy will be stored in the tree, associated with
the given ``body``. This association is pending. It is necessary to
call compile() in order for the element to be fully integrated into
the RigidBodyTree.

Parameter ``element``:
    the element to add.

Parameter ``body``:
    the body to associate the element with.

Parameter ``group_name``:
    a group name to tag the associated element with.)""";

    } addCollisionElement;

    // RigidBodyTree::addDistanceConstraint
    struct /* addDistanceConstraint */ {

      // drake/multibody/rigid_body_tree.h:1497
      const char* doc =
R"""(For details on parameters see RigidBodyDistanceContraint.)""";

    } addDistanceConstraint;

    // RigidBodyTree::addFrame
    struct /* addFrame */ {

      // drake/multibody/rigid_body_tree.h:161
      const char* doc =
R"""(Adds a frame.

Parameter ``frame``:
    Frame to be added. @pre Neither a body nor frame with the same
    identifying information (name and model id / name) should already
    exist in the tree.

Throws:
    s std::runtime_error if preconditions are not met.)""";

    } addFrame;

    // RigidBodyTree::add_model_instance
    struct /* add_model_instance */ {

      // drake/multibody/rigid_body_tree.h:135
      const char* doc =
R"""(Adds a new model instance to this `RigidBodyTree`. The model instance
is identified by a unique model instance ID, which is the return value
of this method.)""";

    } add_model_instance;

    // RigidBodyTree::add_rigid_body
    struct /* add_rigid_body */ {

      // drake/multibody/rigid_body_tree.h:1569
      const char* doc =
R"""(Adds and takes ownership of a rigid body. This also adds a frame whose
pose is the same as the body's.

A RigidBodyTree is the sole owner and manager of the RigidBody's in
it. A body is assigned a unique id (RigidBody::id()) when added to a
RigidBodyTree. This unique id can be use to access a body using
RigidBodyTree::get_bodies()[id].

Parameter ``body``:
    The rigid body to add to this rigid body tree.

Returns:
    A bare, unowned pointer to the ``body``. @pre Neither a body nor
    frame with the same identifying information (name and model id /
    name) should already exist in the tree.

Throws:
    s std::runtime_error if preconditions are not met.)""";

    } add_rigid_body;

    // RigidBodyTree::allCollisions
    struct /* allCollisions */ {

      // drake/multibody/rigid_body_tree.h:1230
      const char* doc = R"""()""";

    } allCollisions;

    // RigidBodyTree::bodies
    struct /* bodies */ {

      // drake/multibody/rigid_body_tree.h:1664
      const char* doc = R"""()""";

    } bodies;

    // RigidBodyTree::centerOfMass
    struct /* centerOfMass */ {

      // drake/multibody/rigid_body_tree.h:340
      const char* doc = R"""()""";

    } centerOfMass;

    // RigidBodyTree::centerOfMassJacobian
    struct /* centerOfMassJacobian */ {

      // drake/multibody/rigid_body_tree.h:697
      const char* doc = R"""()""";

    } centerOfMassJacobian;

    // RigidBodyTree::centerOfMassJacobianDotTimesV
    struct /* centerOfMassJacobianDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:704
      const char* doc = R"""()""";

    } centerOfMassJacobianDotTimesV;

    // RigidBodyTree::centroidalMomentumMatrix
    struct /* centroidalMomentumMatrix */ {

      // drake/multibody/rigid_body_tree.h:680
      const char* doc = R"""()""";

    } centroidalMomentumMatrix;

    // RigidBodyTree::centroidalMomentumMatrixDotTimesV
    struct /* centroidalMomentumMatrixDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:688
      const char* doc = R"""()""";

    } centroidalMomentumMatrixDotTimesV;

    // RigidBodyTree::collidingPoints
    struct /* collidingPoints */ {

      // drake/multibody/rigid_body_tree.h:1269
      const char* doc = R"""()""";

    } collidingPoints;

    // RigidBodyTree::collidingPointsCheckOnly
    struct /* collidingPointsCheckOnly */ {

      // drake/multibody/rigid_body_tree.h:1265
      const char* doc = R"""()""";

    } collidingPointsCheckOnly;

    // RigidBodyTree::collisionDetect
    struct /* collisionDetect */ {

      // drake/multibody/rigid_body_tree.h:1145
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_tree.h:1162
      const char* doc_2 = R"""()""";

      // drake/multibody/rigid_body_tree.h:1180
      const char* doc_3 = R"""()""";

      // drake/multibody/rigid_body_tree.h:1197
      const char* doc_4 = R"""()""";

      // drake/multibody/rigid_body_tree.h:1214
      const char* doc_5 = R"""()""";

    } collisionDetect;

    // RigidBodyTree::collisionDetectFromPoints
    struct /* collisionDetectFromPoints */ {

      // drake/multibody/rigid_body_tree.h:1135
      const char* doc =
R"""(Computes the *signed* distance from the given points to the nearest
body in the RigidBodyTree.

Parameter ``cache``:
    a KinematicsCache constructed by RigidBodyTree::doKinematics given
    `q` and `v`.

Parameter ``points``:
    A 3xN matrix of points, in world frame, to which signed distance
    will be computed.

Parameter ``phi``:
    Resized to N elements and filled with the computed signed
    distances, or inf if no closest point was found.

Parameter ``normal``:
    Resized to 3xN elements and filled with collision element normals
    in world frame, at the closest point on the collision geometry to
    each point in `points`. Undefined where no closest point was
    found.

Parameter ``x``:
    Resized to 3xN elements and filled with the closest points on the
    collision geometry to each point in `points`, in world frame.
    Undefined where no closest point was found.

Parameter ``body_x``:
    Resized to 3xN elements and filled with the closest points on the
    collision geometry to each point in `points`, in the body frame of
    the closest body. Undefined where no closest point was found.

Parameter ``body_idx``:
    Resized to N elements and filled with the body idx of the closest
    body to each point in `points`, or -1 where no closest body was
    found.

Parameter ``use_margins``:
    Whether to pad each collision body with a narrow (see
    bullet_model) margin to improve stability of normal estimation at
    the cost of the accuracy of closest points calculations.)""";

    } collisionDetectFromPoints;

    // RigidBodyTree::collisionRaycast
    struct /* collisionRaycast */ {

      // drake/multibody/rigid_body_tree.h:1095
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_tree.h:1101
      const char* doc_2 = R"""()""";

    } collisionRaycast;

    // RigidBodyTree::compactToFull
    struct /* compactToFull */ {

      // drake/multibody/rigid_body_tree.h:1519
      const char* doc = R"""()""";

    } compactToFull;

    // RigidBodyTree::compile
    struct /* compile */ {

      // drake/multibody/rigid_body_tree.h:197
      const char* doc = R"""()""";

    } compile;

    // RigidBodyTree::computeContactJacobians
    struct /* computeContactJacobians */ {

      // drake/multibody/rigid_body_tree.h:996
      const char* doc =
R"""(Computes the Jacobian for many points in the format currently used by
MATLAB. (possibly should be scheduled for deletion, taking
accumulateContactJacobians() with it))""";

    } computeContactJacobians;

    // RigidBodyTree::computePositionNameToIndexMap
    struct /* computePositionNameToIndexMap */ {

      // drake/multibody/rigid_body_tree.h:169
      const char* doc =
R"""(Returns a map from DOF position name to DOF index within the output
vector of this RigidBodyTree.

**WARNING:** There is a known bug in this method, see: #4697.)""";

    } computePositionNameToIndexMap;

    // RigidBodyTree::distance_constraints
    struct /* distance_constraints */ {

      // drake/multibody/rigid_body_tree.h:1690
      const char* doc = R"""()""";

    } distance_constraints;

    // RigidBodyTree::doKinematics
    struct /* doKinematics */ {

      // drake/multibody/rigid_body_tree.h:296
      const char* doc =
R"""(Initializes a `KinematicsCache` with the given configuration ``q``,
computes the kinematics, and returns the cache.

This method is explicitly instantiated in rigid_body_tree.cc for a
small set of supported `DerivedQ`.)""";

      // drake/multibody/rigid_body_tree.h:305
      const char* doc_2 =
R"""(Initializes a `KinematicsCache` with the given configuration ``q`` and
velocity ``v``, computes the kinematics, and returns the cache.

This method is explicitly instantiated in rigid_body_tree.cc for a
small set of supported `DerivedQ` and `DerivedV`.)""";

      // drake/multibody/rigid_body_tree.h:315
      const char* doc_3 =
R"""(Computes the kinematics on the given ``cache``.

This method is explicitly instantiated in rigid_body_tree.cc for a
small set of supported Scalar types.)""";

    } doKinematics;

    // RigidBodyTree::drawKinematicTree
    struct /* drawKinematicTree */ {

      // drake/multibody/rigid_body_tree.h:237
      const char* doc = R"""()""";

    } drawKinematicTree;

    // RigidBodyTree::dynamicsBiasTerm
    struct /* dynamicsBiasTerm */ {

      // drake/multibody/rigid_body_tree.h:801
      const char* doc =
R"""(Compute the term $ C(q, v, f_\text{ext}) $ in the manipulator
equations \f[ H(q) \dot{v} + C(q, v, f_\text{ext}) = B(q) u \f]

Convenience method that calls inverseDynamics with $ \dot{v} = 0 $.
See inverseDynamics for argument descriptions.

See also:
    inverseDynamics)""";

    } dynamicsBiasTerm;

    // RigidBodyTree::findAncestorBodies
    struct /* findAncestorBodies */ {

      // drake/multibody/rigid_body_tree.h:754
      const char* doc = R"""()""";

    } findAncestorBodies;

    // RigidBodyTree::findFrame
    struct /* findFrame */ {

      // drake/multibody/rigid_body_tree.h:1439
      const char* doc =
R"""(Finds a frame of the specified ``frame_name`` belonging to a model
with the specified ``model_id``.

Parameter ``frame_name``:
    The name of the frame to find.

Parameter ``model_id``:
    The ID of the model to which the frame belongs. If this value is
    -1, search all models.

Returns:
    The frame with the specified name and model instance ID.

Throws:
    s std::logic_error if either multiple matching frames are found or
    no matching frame is found.)""";

    } findFrame;

    // RigidBodyTree::findJoint
    struct /* findJoint */ {

      // drake/multibody/rigid_body_tree.h:1395
      const char* doc = R"""()""";

    } findJoint;

    // RigidBodyTree::findJointId
    struct /* findJointId */ {

      // drake/multibody/rigid_body_tree.h:1423
      const char* doc = R"""()""";

    } findJointId;

    // RigidBodyTree::findKinematicPath
    struct /* findKinematicPath */ {

      // drake/multibody/rigid_body_tree.h:765
      const char* doc = R"""()""";

    } findKinematicPath;

    // RigidBodyTree::findLink
    struct /* findLink */ {

      // drake/multibody/rigid_body_tree.h:1319
      const char* doc =
R"""(This is a deprecated version of `FindBody(...)`. Please use
`FindBody(...)` instead.)""";

    } findLink;

    // RigidBodyTree::findLinkId
    struct /* findLinkId */ {

      // drake/multibody/rigid_body_tree.h:1369
      const char* doc =
R"""(This is a deprecated version of `FindBodyIndex(...)`. Please use
`FindBodyIndex(...)` instead.)""";

    } findLinkId;

    // RigidBodyTree::forwardKinPositionGradient
    struct /* forwardKinPositionGradient */ {

      // drake/multibody/rigid_body_tree.h:927
      const char* doc = R"""()""";

    } forwardKinPositionGradient;

    // RigidBodyTree::frames
    struct /* frames */ {

      // drake/multibody/rigid_body_tree.h:1674
      const char* doc = R"""()""";

    } frames;

    // RigidBodyTree::frictionTorques
    struct /* frictionTorques */ {

      // drake/multibody/rigid_body_tree.h:845
      const char* doc = R"""()""";

    } frictionTorques;

    // RigidBodyTree::geometricJacobian
    struct /* geometricJacobian */ {

      // drake/multibody/rigid_body_tree.h:952
      const char* doc = R"""()""";

    } geometricJacobian;

    // RigidBodyTree::geometricJacobianDotTimesV
    struct /* geometricJacobianDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:968
      const char* doc = R"""()""";

    } geometricJacobianDotTimesV;

    // RigidBodyTree::getBodyOrFrameName
    struct /* getBodyOrFrameName */ {

      // drake/multibody/rigid_body_tree.h:1475
      const char* doc = R"""()""";

    } getBodyOrFrameName;

    // RigidBodyTree::getMass
    struct /* getMass */ {

      // drake/multibody/rigid_body_tree.h:336
      const char* doc =
R"""(Computes the total combined mass of a set of model instances.

Parameter ``model_instance_id_set``:
    A set of model instance ID values corresponding to the model
    instances whose masses should be included in the returned value.

Returns:
    The total combined mass of the model instances in
    ``model_instance_id_set``.)""";

    } getMass;

    // RigidBodyTree::getNumContacts
    struct /* getNumContacts */ {

      // drake/multibody/rigid_body_tree.h:720
      const char* doc = R"""()""";

    } getNumContacts;

    // RigidBodyTree::getNumJointLimitConstraints
    struct /* getNumJointLimitConstraints */ {

      // drake/multibody/rigid_body_tree.h:718
      const char* doc = R"""()""";

    } getNumJointLimitConstraints;

    // RigidBodyTree::getNumPositionConstraints
    struct /* getNumPositionConstraints */ {

      // drake/multibody/rigid_body_tree.h:1514
      const char* doc = R"""()""";

    } getNumPositionConstraints;

    // RigidBodyTree::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/rigid_body_tree.h:229
      const char* doc = R"""()""";

    } getPositionName;

    // RigidBodyTree::getRandomConfiguration
    struct /* getRandomConfiguration */ {

      // drake/multibody/rigid_body_tree.h:201
      const char* doc = R"""()""";

    } getRandomConfiguration;

    // RigidBodyTree::getStateName
    struct /* getStateName */ {

      // drake/multibody/rigid_body_tree.h:235
      const char* doc = R"""()""";

    } getStateName;

    // RigidBodyTree::getTerrainContactPoints
    struct /* getTerrainContactPoints */ {

      // drake/multibody/rigid_body_tree.h:1091
      const char* doc =
R"""(Gets the contact points defined by a body's collision elements.

Parameter ``body``:
    The body who's collision elements are searched.

Parameter ``terrain_points``:
    Contact points are added to this matrix.

Parameter ``group_name``:
    If a group name was given, use it to look up the subset of
    collision elements that belong to that collision group. Otherwise,
    uses the full set of collision elements that belong to the body.

Throws:
    s std::runtime_error if an invalid group name is given.)""";

    } getTerrainContactPoints;

    // RigidBodyTree::getVelocityName
    struct /* getVelocityName */ {

      // drake/multibody/rigid_body_tree.h:233
      const char* doc = R"""()""";

    } getVelocityName;

    // RigidBodyTree::getZeroConfiguration
    struct /* getZeroConfiguration */ {

      // drake/multibody/rigid_body_tree.h:199
      const char* doc = R"""()""";

    } getZeroConfiguration;

    // RigidBodyTree::get_bodies
    struct /* get_bodies */ {

      // drake/multibody/rigid_body_tree.h:1668
      const char* doc = R"""(List of bodies.)""";

    } get_bodies;

    // RigidBodyTree::get_body
    struct /* get_body */ {

      // drake/multibody/rigid_body_tree.h:1447
      const char* doc =
R"""(Returns the body at index ``body_index``. Parameter ``body_index``
must be between zero and the number of bodies in this tree, which can
be determined by calling RigidBodyTree::get_num_bodies().)""";

    } get_body;

    // RigidBodyTree::get_frames
    struct /* get_frames */ {

      // drake/multibody/rigid_body_tree.h:1677
      const char* doc = R"""(List of frames.)""";

    } get_frames;

    // RigidBodyTree::get_mutable_body
    struct /* get_mutable_body */ {

      // drake/multibody/rigid_body_tree.h:1457
      const char* doc =
R"""(Returns the body at index ``body_index``. Parameter ``body_index``
must be between zero and the number of bodies in this tree, which can
be determined by calling RigidBodyTree::get_num_bodies().)""";

    } get_mutable_body;

    // RigidBodyTree::get_next_clique_id
    struct /* get_next_clique_id */ {

      // drake/multibody/rigid_body_tree.h:138
      const char* doc = R"""()""";

    } get_next_clique_id;

    // RigidBodyTree::get_num_actuators
    struct /* get_num_actuators */ {

      // drake/multibody/rigid_body_tree.h:1640
      const char* doc =
R"""(Returns the number of actuators in this RigidBodyTree.)""";

    } get_num_actuators;

    // RigidBodyTree::get_num_bodies
    struct /* get_num_bodies */ {

      // drake/multibody/rigid_body_tree.h:1463
      const char* doc =
R"""(Returns the number of bodies in this tree. This includes the one body
that represents the world.)""";

    } get_num_bodies;

    // RigidBodyTree::get_num_frames
    struct /* get_num_frames */ {

      // drake/multibody/rigid_body_tree.h:1470
      const char* doc =
R"""(Returns the number of frames in this tree.)""";

    } get_num_frames;

    // RigidBodyTree::get_num_model_instances
    struct /* get_num_model_instances */ {

      // drake/multibody/rigid_body_tree.h:146
      const char* doc =
R"""(Returns the number of model instances in the tree, not including the
world.)""";

    } get_num_model_instances;

    // RigidBodyTree::get_num_positions
    struct /* get_num_positions */ {

      // drake/multibody/rigid_body_tree.h:1624
      const char* doc =
R"""(Returns the number of position states outputted by this RigidBodyTree.)""";

    } get_num_positions;

    // RigidBodyTree::get_num_velocities
    struct /* get_num_velocities */ {

      // drake/multibody/rigid_body_tree.h:1632
      const char* doc =
R"""(Returns the number of velocity states outputted by this RigidBodyTree.)""";

    } get_num_velocities;

    // RigidBodyTree::get_number_of_bodies
    struct /* get_number_of_bodies */ {

      // drake/multibody/rigid_body_tree.h:1473
      const char* doc = R"""()""";

    } get_number_of_bodies;

    // RigidBodyTree::get_number_of_model_instances
    struct /* get_number_of_model_instances */ {

      // drake/multibody/rigid_body_tree.h:149
      const char* doc = R"""()""";

    } get_number_of_model_instances;

    // RigidBodyTree::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/rigid_body_tree.h:214
      const char* doc =
R"""(Returns the name of the position state at index ``position_num``
within this `RigidBodyTree`'s state vector.

Parameter ``position_num``:
    An index value between zero and number_of_positions().

Returns:
    The name of the position value at index ``position_num``.)""";

    } get_position_name;

    // RigidBodyTree::get_velocity_name
    struct /* get_velocity_name */ {

      // drake/multibody/rigid_body_tree.h:225
      const char* doc =
R"""(Returns the name of the velocity state at index ``velocity_num``
within this `RigidBodyTree`'s state vector.

Parameter ``velocity_num``:
    An index value between number_of_positions() and
    number_of_veocities().

Returns:
    The name of the velocity value at index ``velocity_num``.)""";

    } get_velocity_name;

    // RigidBodyTree::initialized
    struct /* initialized */ {

      // drake/multibody/rigid_body_tree.h:1646
      const char* doc =
R"""(Returns whether this RigidBodyTree is initialized. It is initialized
after compile() is called.)""";

    } initialized;

    // RigidBodyTree::inverseDynamics
    struct /* inverseDynamics */ {

      // drake/multibody/rigid_body_tree.h:836
      const char* doc =
R"""(Compute \f[ H(q) \dot{v} + C(q, v, f_\text{ext}) \f] that is, the left
hand side of the manipulator equations \f[ H(q) \dot{v} + C(q, v,
f_\text{ext}) = B(q) u \f]

Note that the 'dynamics bias term' $ C(q, v, f_\text{ext}) $ can be
computed by simply setting $ \dot{v} = 0$. Note also that if only the
gravitational terms contained in $ C(q, v, f_\text{ext}) $ are
required, one can set *include_velocity_terms* to false.
Alternatively, one can pass in a KinematicsCache created with $ v = 0$
or without specifying the velocity vector.

Algorithm: recursive Newton-Euler. Does not explicitly compute mass
matrix.

Parameter ``cache``:
    a KinematicsCache constructed given $ q $ and $ v $

Parameter ``external_wrenches``:
    external wrenches exerted upon bodies ($ f_\text{ext} $).
    Expressed in body frame.

Parameter ``vd``:
    $ \dot{v} $

Parameter ``include_velocity_terms``:
    whether to include velocity-dependent terms in $ C(q, v,
    f_\text{ext}) $. Setting *include_velocity_terms* to false is
    Equivalent to setting $ v = 0 $

Returns:
    $ H(q) \dot{v} + C(q, v, f_\text{ext}) $)""";

    } inverseDynamics;

    // RigidBodyTree::is_part_of_model_instances
    struct /* is_part_of_model_instances */ {

      // drake/multibody/rigid_body_tree.h:322
      const char* doc =
R"""(Returns true if ``body`` is part of a model instance whose ID is in
``model_instance_id_set``.)""";

    } is_part_of_model_instances;

    // RigidBodyTree::jointLimitConstraints
    struct /* jointLimitConstraints */ {

      // drake/multibody/rigid_body_tree.h:711
      const char* doc = R"""()""";

    } jointLimitConstraints;

    // RigidBodyTree::joint_limit_max
    struct /* joint_limit_max */ {

      // drake/multibody/rigid_body_tree.h:1650
      const char* doc = R"""()""";

    } joint_limit_max;

    // RigidBodyTree::joint_limit_min
    struct /* joint_limit_min */ {

      // drake/multibody/rigid_body_tree.h:1649
      const char* doc = R"""()""";

    } joint_limit_min;

    // RigidBodyTree::loops
    struct /* loops */ {

      // drake/multibody/rigid_body_tree.h:1685
      const char* doc = R"""()""";

    } loops;

    // RigidBodyTree::massMatrix
    struct /* massMatrix */ {

      // drake/multibody/rigid_body_tree.h:781
      const char* doc =
R"""(Compute the positive definite mass (configuration space) matrix $ H(q)
$, defined by $T = \frac{1}{2} v^T H(q) v $, where $ T $ is kinetic
energy.

The mass matrix also appears in the manipulator equations \f[ H(q)
\dot{v} + C(q, v, f_\text{ext}) = B(q) u \f]

Parameter ``cache``:
    a KinematicsCache constructed given $ q $

Returns:
    the mass matrix $ H(q) $)""";

    } massMatrix;

    // RigidBodyTree::number_of_positions
    struct /* number_of_positions */ {

      // drake/multibody/rigid_body_tree.h:1627
      const char* doc = R"""()""";

    } number_of_positions;

    // RigidBodyTree::number_of_velocities
    struct /* number_of_velocities */ {

      // drake/multibody/rigid_body_tree.h:1635
      const char* doc = R"""()""";

    } number_of_velocities;

    // RigidBodyTree::parseBodyOrFrameID
    struct /* parseBodyOrFrameID */ {

      // drake/multibody/rigid_body_tree.h:1491
      const char* doc = R"""()""";

      // drake/multibody/rigid_body_tree.h:1494
      const char* doc_2 = R"""()""";

    } parseBodyOrFrameID;

    // RigidBodyTree::positionConstraints
    struct /* positionConstraints */ {

      // drake/multibody/rigid_body_tree.h:1502
      const char* doc = R"""()""";

    } positionConstraints;

    // RigidBodyTree::positionConstraintsJacDotTimesV
    struct /* positionConstraintsJacDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:1511
      const char* doc = R"""()""";

    } positionConstraintsJacDotTimesV;

    // RigidBodyTree::positionConstraintsJacobian
    struct /* positionConstraintsJacobian */ {

      // drake/multibody/rigid_body_tree.h:1507
      const char* doc = R"""()""";

    } positionConstraintsJacobian;

    // RigidBodyTree::relativeQuaternion
    struct /* relativeQuaternion */ {

      // drake/multibody/rigid_body_tree.h:877
      const char* doc = R"""()""";

    } relativeQuaternion;

    // RigidBodyTree::relativeQuaternionJacobian
    struct /* relativeQuaternionJacobian */ {

      // drake/multibody/rigid_body_tree.h:913
      const char* doc = R"""()""";

    } relativeQuaternionJacobian;

    // RigidBodyTree::relativeQuaternionJacobianDotTimesV
    struct /* relativeQuaternionJacobianDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:941
      const char* doc = R"""()""";

    } relativeQuaternionJacobianDotTimesV;

    // RigidBodyTree::relativeRollPitchYaw
    struct /* relativeRollPitchYaw */ {

      // drake/multibody/rigid_body_tree.h:886
      const char* doc = R"""()""";

    } relativeRollPitchYaw;

    // RigidBodyTree::relativeRollPitchYawJacobian
    struct /* relativeRollPitchYawJacobian */ {

      // drake/multibody/rigid_body_tree.h:920
      const char* doc = R"""()""";

    } relativeRollPitchYawJacobian;

    // RigidBodyTree::relativeRollPitchYawJacobianDotTimesV
    struct /* relativeRollPitchYawJacobianDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:947
      const char* doc = R"""()""";

    } relativeRollPitchYawJacobianDotTimesV;

    // RigidBodyTree::relativeTransform
    struct /* relativeTransform */ {

      // drake/multibody/rigid_body_tree.h:987
      const char* doc = R"""()""";

    } relativeTransform;

    // RigidBodyTree::relativeTwist
    struct /* relativeTwist */ {

      // drake/multibody/rigid_body_tree.h:974
      const char* doc = R"""()""";

    } relativeTwist;

    // RigidBodyTree::removeCollisionGroupsIf
    struct /* removeCollisionGroupsIf */ {

      // drake/multibody/rigid_body_tree.h:1030
      const char* doc = R"""()""";

    } removeCollisionGroupsIf;

    // RigidBodyTree::resolveCenterOfPressure
    struct /* resolveCenterOfPressure */ {

      // drake/multibody/rigid_body_tree.h:727
      const char* doc =
R"""(Computes CoP in world frame. Normal and point on contact plane should
be in world frame too.)""";

    } resolveCenterOfPressure;

    // RigidBodyTree::surfaceTangents
    struct /* surfaceTangents */ {

      // drake/multibody/rigid_body_tree.h:171
      const char* doc = R"""()""";

    } surfaceTangents;

    // RigidBodyTree::transformCollisionFrame
    struct /* transformCollisionFrame */ {

      // drake/multibody/rigid_body_tree.h:193
      const char* doc =
R"""(Applies the given transform to the given ``body``'s collision
elements, displacing them from their current configurations. These new
poses will be considered the elements' pose with respect to the body.

This is important to the parsing code to maintain a Drake
RigidBodyTree invariant. RigidBody instances do not maintain their own
pose relative to their in-board joint. The joint's space is considered
to be the body's space. So, if a URDF or SDF file defines the body
with a non-identity pose relative to the parent, the parser uses this
to move the collision elements relative to the effective body frame --
that of the parent joint.

Parameter ``body``:
    The body whose collision elements will be moved.

Parameter ``displace_transform``:
    The transform to apply to each collision element.

Parameter ``True``:
    if the collision element was successfully updated.

Returns:
    true if the @body's elements were successfully transformed.)""";

    } transformCollisionFrame;

    // RigidBodyTree::transformPoints
    struct /* transformPoints */ {

      // drake/multibody/rigid_body_tree.h:863
      const char* doc = R"""()""";

    } transformPoints;

    // RigidBodyTree::transformPointsJacobian
    struct /* transformPointsJacobian */ {

      // drake/multibody/rigid_body_tree.h:897
      const char* doc = R"""()""";

    } transformPointsJacobian;

    // RigidBodyTree::transformPointsJacobianDotTimesV
    struct /* transformPointsJacobianDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:932
      const char* doc = R"""()""";

    } transformPointsJacobianDotTimesV;

    // RigidBodyTree::transformQDotMappingToVelocityMapping
    struct /* transformQDotMappingToVelocityMapping */ {

      // drake/multibody/rigid_body_tree.h:652
      const char* doc =
R"""(Converts a matrix A, which transforms the time derivative of
generalized coordinates (qdot) to an output space X, to a matrix B,
which transforms generalized velocities (v) to the same space X. For
example, A could be a Jacobian matrix that transforms qdot to spatial
velocities at the end effector. Formally, this would be the matrix of
partial derivatives of end-effector configuration computed with
respect to the generalized coordinates (q). This function would allow
the user to transform this Jacobian matrix to the more commonly used
one: the matrix of partial derivatives of end-effector configuration
computed with respect to quasi-coordinates (ꝗ).

Parameter ``Ap``:
    a `m x nq` sized matrix, where `nq` is the dimension of the
    generalized coordinates.

Returns ``B``:
    , a `m x nv` sized matrix, where `nv` is the dimension of the
    generalized velocities.

See also:
    transformVelocityMappingToQDotMapping())""";

    } transformQDotMappingToVelocityMapping;

    // RigidBodyTree::transformQDotToVelocity
    struct /* transformQDotToVelocity */ {

      // drake/multibody/rigid_body_tree.h:592
      const char* doc =
R"""(Converts a vector of the time derivative of generalized coordinates
(qdot) to generalized velocity (v).

Parameter ``cache``:
    the kinematics cache, which is assumed to be up-to-date with
    respect to the state

Parameter ``qdot``:
    a `nq` dimensional vector, where `nq` is the dimension of the
    generalized coordinates.

Returns:
    a `nv` dimensional vector, where `nv` is the dimension of the
    generalized velocities.

See also:
    transformVelocityToQDot())""";

    } transformQDotToVelocity;

    // RigidBodyTree::transformSpatialAcceleration
    struct /* transformSpatialAcceleration */ {

      // drake/multibody/rigid_body_tree.h:979
      const char* doc = R"""()""";

    } transformSpatialAcceleration;

    // RigidBodyTree::transformVelocityMappingToQDotMapping
    struct /* transformVelocityMappingToQDotMapping */ {

      // drake/multibody/rigid_body_tree.h:629
      const char* doc =
R"""(Converts a matrix B, which transforms generalized velocities (v) to an
output space X, to a matrix A, which transforms the time derivative of
generalized coordinates (qdot) to the same output X. For example, B
could be a Jacobian matrix that transforms generalized velocities to
spatial velocities at the end-effector. Formally, this would be the
matrix of partial derivatives of end-effector configuration computed
with respect to quasi-coordinates (ꝗ). This function would allow
transforming that Jacobian so that all partial derivatives would be
computed with respect to qdot.

Parameter ``Av``:
    , a `m x nv` sized matrix, where `nv` is the dimension of the
    generalized velocities.

Returns ``A``:
    a `m x nq` sized matrix, where `nq` is the dimension of the
    generalized coordinates.

See also:
    transformQDotMappingToVelocityMapping())""";

    } transformVelocityMappingToQDotMapping;

    // RigidBodyTree::transformVelocityToQDot
    struct /* transformVelocityToQDot */ {

      // drake/multibody/rigid_body_tree.h:607
      const char* doc =
R"""(Converts a vector of generalized velocities (v) to the time derivative
of generalized coordinates (qdot).

Parameter ``cache``:
    the kinematics cache, which is assumed to be up-to-date with
    respect to the state

Parameter ``v``:
    a `nv` dimensional vector, where `nv` is the dimension of the
    generalized velocities.

Returns ``qdot``:
    a `nq` dimensional vector, where `nq` is the dimension of the
    generalized coordinates.

See also:
    transformQDotToVelocity())""";

    } transformVelocityToQDot;

    // RigidBodyTree::updateCollisionElements
    struct /* updateCollisionElements */ {

      // drake/multibody/rigid_body_tree.h:1064
      const char* doc =
R"""(Updates the collision elements registered with the collision detection
engine. Note: If U is not a double then the transforms from kinematics
cache will be forcefully cast to doubles (discarding any gradient
information). Callers that set ``throw_if_missing_gradient`` to
`false` are responsible for ensuring that future code is secure
despite all gradients with respect to the collision engine being
arbitrarily set to zero.

See also:
    ComputeMaximumDepthCollisionPoints for an example.

Throws:
    s std::runtime_error based on the criteria of
    DiscardZeroGradient() only if ``throws_if_missing_gradient`` is
    true.)""";

    } updateCollisionElements;

    // RigidBodyTree::updateDynamicCollisionElements
    struct /* updateDynamicCollisionElements */ {

      // drake/multibody/rigid_body_tree.h:1075
      const char* doc =
R"""(See also:
    updateCollisionElements

Throws:
    s std::runtime_error based on the criteria of
    DiscardZeroGradient() only if ``throws_if_missing_gradient`` is
    true.)""";

    } updateDynamicCollisionElements;

    // RigidBodyTree::world
    struct /* world */ {

      // drake/multibody/rigid_body_tree.h:1613
      const char* doc =
R"""(Returns a mutable reference to the RigidBody associated with the world
in the model. This is the root of the RigidBodyTree.)""";

      // drake/multibody/rigid_body_tree.h:1619
      const char* doc_2 =
R"""(Returns a const reference to the RigidBody associated with the world
in the model. This is the root of the RigidBodyTree.)""";

    } world;

    // RigidBodyTree::worldMomentumMatrix
    struct /* worldMomentumMatrix */ {

      // drake/multibody/rigid_body_tree.h:665
      const char* doc = R"""()""";

    } worldMomentumMatrix;

    // RigidBodyTree::worldMomentumMatrixDotTimesV
    struct /* worldMomentumMatrixDotTimesV */ {

      // drake/multibody/rigid_body_tree.h:673
      const char* doc = R"""()""";

    } worldMomentumMatrixDotTimesV;

  } RigidBodyTree;

  // RigidBodyTreeConstants
  struct /* RigidBodyTreeConstants */ {

    // drake/multibody/rigid_body_tree.h:46
    const char* doc =
R"""(Defines RigidBodyTree constants. A separate struct is necessary to
avoid having these constants being templated on `<T>`. For more
details about the problem with having these templated on `<T>`, see
#4169.)""";

  } RigidBodyTreeConstants;

  // RobotJointIndexMap
  struct /* RobotJointIndexMap */ {

    // drake/systems/controllers/controlUtil.h:126
    const char* doc = R"""()""";

    // RobotJointIndexMap::drake_to_robot
    struct /* drake_to_robot */ {

      // drake/systems/controllers/controlUtil.h:127
      const char* doc = R"""()""";

    } drake_to_robot;

    // RobotJointIndexMap::robot_to_drake
    struct /* robot_to_drake */ {

      // drake/systems/controllers/controlUtil.h:128
      const char* doc = R"""()""";

    } robot_to_drake;

  } RobotJointIndexMap;

  // RobotPropertyCache
  struct /* RobotPropertyCache */ {

    // drake/systems/controllers/QPCommon.h:51
    const char* doc = R"""()""";

    // RobotPropertyCache::foot_ids
    struct /* foot_ids */ {

      // drake/systems/controllers/QPCommon.h:53
      const char* doc = R"""()""";

    } foot_ids;

    // RobotPropertyCache::position_indices
    struct /* position_indices */ {

      // drake/systems/controllers/QPCommon.h:52
      const char* doc = R"""()""";

    } position_indices;

  } RobotPropertyCache;

  // RollPitchYawFloatingJoint
  struct /* RollPitchYawFloatingJoint */ {

    // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:16
    const char* doc = R"""()""";

    // RollPitchYawFloatingJoint::DoClone
    struct /* DoClone */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:312
      const char* doc = R"""()""";

    } DoClone;

    // RollPitchYawFloatingJoint::DoInitializeClone
    struct /* DoInitializeClone */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:313
      const char* doc = R"""()""";

    } DoInitializeClone;

    // RollPitchYawFloatingJoint::RollPitchYawFloatingJoint
    struct /* ctor */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:25
      const char* doc = R"""()""";

    } ctor;

    // RollPitchYawFloatingJoint::SpringTorque
    struct /* SpringTorque */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:284
      const char* doc = R"""()""";

    } SpringTorque;

    // RollPitchYawFloatingJoint::frictionTorque
    struct /* frictionTorque */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:276
      const char* doc = R"""()""";

    } frictionTorque;

    // RollPitchYawFloatingJoint::getPositionName
    struct /* getPositionName */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:307
      const char* doc = R"""()""";

    } getPositionName;

    // RollPitchYawFloatingJoint::get_position_name
    struct /* get_position_name */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:303
      const char* doc = R"""()""";

    } get_position_name;

    // RollPitchYawFloatingJoint::isFloating
    struct /* isFloating */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:298
      const char* doc = R"""()""";

    } isFloating;

    // RollPitchYawFloatingJoint::is_floating
    struct /* is_floating */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:294
      const char* doc = R"""()""";

    } is_floating;

    // RollPitchYawFloatingJoint::jointTransform
    struct /* jointTransform */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:33
      const char* doc = R"""()""";

    } jointTransform;

    // RollPitchYawFloatingJoint::motionSubspace
    struct /* motionSubspace */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:49
      const char* doc = R"""()""";

    } motionSubspace;

    // RollPitchYawFloatingJoint::motionSubspaceDotTimesV
    struct /* motionSubspaceDotTimesV */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:110
      const char* doc = R"""()""";

    } motionSubspaceDotTimesV;

    // RollPitchYawFloatingJoint::qdot2v
    struct /* qdot2v */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:244
      const char* doc = R"""()""";

    } qdot2v;

    // RollPitchYawFloatingJoint::randomConfiguration
    struct /* randomConfiguration */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:301
      const char* doc = R"""()""";

    } randomConfiguration;

    // RollPitchYawFloatingJoint::v2qdot
    struct /* v2qdot */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:260
      const char* doc = R"""()""";

    } v2qdot;

    // RollPitchYawFloatingJoint::zeroConfiguration
    struct /* zeroConfiguration */ {

      // drake/multibody/joints/roll_pitch_yaw_floating_joint.h:300
      const char* doc = R"""()""";

    } zeroConfiguration;

  } RollPitchYawFloatingJoint;

  // Side
  struct /* Side */ {

    // drake/systems/controllers/side.h:8
    const char* doc = R"""()""";

    // Side::Side
    struct /* ctor */ {

      // drake/systems/controllers/side.h:18
      const char* doc = R"""()""";

      // drake/systems/controllers/side.h:21
      const char* doc_2 = R"""()""";

    } ctor;

    // Side::SideEnum
    struct /* SideEnum */ {

      // drake/systems/controllers/side.h:10
      const char* doc = R"""()""";

      // Side::SideEnum::LEFT
      struct /* LEFT */ {

        // drake/systems/controllers/side.h:10
        const char* doc = R"""()""";

      } LEFT;

      // Side::SideEnum::RIGHT
      struct /* RIGHT */ {

        // drake/systems/controllers/side.h:10
        const char* doc = R"""()""";

      } RIGHT;

    } SideEnum;

    // Side::operator!=
    struct /* operator_ne */ {

      // drake/systems/controllers/side.h:26
      const char* doc = R"""()""";

    } operator_ne;

    // Side::operator<
    struct /* operator_lt */ {

      // drake/systems/controllers/side.h:27
      const char* doc = R"""()""";

    } operator_lt;

    // Side::operator<=
    struct /* operator_le */ {

      // drake/systems/controllers/side.h:28
      const char* doc = R"""()""";

    } operator_le;

    // Side::operator>
    struct /* operator_gt */ {

      // drake/systems/controllers/side.h:29
      const char* doc = R"""()""";

    } operator_gt;

    // Side::operator>=
    struct /* operator_ge */ {

      // drake/systems/controllers/side.h:30
      const char* doc = R"""()""";

    } operator_ge;

    // Side::oppositeSide
    struct /* oppositeSide */ {

      // drake/systems/controllers/side.h:32
      const char* doc = R"""()""";

    } oppositeSide;

    // Side::toString
    struct /* toString */ {

      // drake/systems/controllers/side.h:33
      const char* doc = R"""()""";

    } toString;

    // Side::underlying
    struct /* underlying */ {

      // drake/systems/controllers/side.h:23
      const char* doc = R"""()""";

    } underlying;

  } Side;

  // SingleTimeKinematicConstraint
  struct /* SingleTimeKinematicConstraint */ {

    // drake/multibody/rigid_body_constraint.h:305
    const char* doc = R"""()""";

    // SingleTimeKinematicConstraint::SingleTimeKinematicConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:307
      const char* doc = R"""()""";

    } ctor;

    // SingleTimeKinematicConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:315
      const char* doc = R"""()""";

    } bounds;

    // SingleTimeKinematicConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:313
      const char* doc = R"""()""";

    } eval;

    // SingleTimeKinematicConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:312
      const char* doc = R"""()""";

    } getNumConstraint;

    // SingleTimeKinematicConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:311
      const char* doc = R"""()""";

    } isTimeValid;

    // SingleTimeKinematicConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:317
      const char* doc = R"""()""";

    } name;

    // SingleTimeKinematicConstraint::set_num_constraint
    struct /* set_num_constraint */ {

      // drake/multibody/rigid_body_constraint.h:322
      const char* doc = R"""()""";

    } set_num_constraint;

    // SingleTimeKinematicConstraint::updateRobot
    struct /* updateRobot */ {

      // drake/multibody/rigid_body_constraint.h:319
      const char* doc = R"""()""";

    } updateRobot;

  } SingleTimeKinematicConstraint;

  // SingleTimeLinearPostureConstraint
  struct /* SingleTimeLinearPostureConstraint */ {

    // drake/multibody/rigid_body_constraint.h:271
    const char* doc = R"""()""";

    // SingleTimeLinearPostureConstraint::SingleTimeLinearPostureConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:273
      const char* doc = R"""()""";

    } ctor;

    // SingleTimeLinearPostureConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:281
      const char* doc = R"""()""";

    } bounds;

    // SingleTimeLinearPostureConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:286
      const char* doc = R"""()""";

    } eval;

    // SingleTimeLinearPostureConstraint::feval
    struct /* feval */ {

      // drake/multibody/rigid_body_constraint.h:282
      const char* doc = R"""()""";

    } feval;

    // SingleTimeLinearPostureConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:280
      const char* doc = R"""()""";

    } getNumConstraint;

    // SingleTimeLinearPostureConstraint::geval
    struct /* geval */ {

      // drake/multibody/rigid_body_constraint.h:284
      const char* doc = R"""()""";

    } geval;

    // SingleTimeLinearPostureConstraint::isTimeValid
    struct /* isTimeValid */ {

      // drake/multibody/rigid_body_constraint.h:279
      const char* doc = R"""()""";

    } isTimeValid;

    // SingleTimeLinearPostureConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:288
      const char* doc = R"""()""";

    } name;

  } SingleTimeLinearPostureConstraint;

  // StringToDouble
  struct /* StringToDouble */ {

    // drake/multibody/parsers/xml_util.h:129
    const char* doc =
R"""(Converts a string to a double value.

Parameter ``str``:
    A pointer to a string containing a representation of a double
    value.

Returns:
    The corresponding double value that was represented in ``str``.

Throws:
    s ValueError If any problem is encountered while parsing the
    double value represented within ``str``.)""";

  } StringToDouble;

  // TVLQRData
  struct /* TVLQRData */ {

    // drake/systems/controllers/zmpUtil.h:7
    const char* doc = R"""()""";

    // TVLQRData::A
    struct /* A */ {

      // drake/systems/controllers/zmpUtil.h:10
      const char* doc = R"""()""";

    } A;

    // TVLQRData::B
    struct /* B */ {

      // drake/systems/controllers/zmpUtil.h:11
      const char* doc = R"""()""";

    } B;

    // TVLQRData::C
    struct /* C */ {

      // drake/systems/controllers/zmpUtil.h:12
      const char* doc = R"""()""";

    } C;

    // TVLQRData::D
    struct /* D */ {

      // drake/systems/controllers/zmpUtil.h:13
      const char* doc = R"""()""";

    } D;

    // TVLQRData::N
    struct /* N */ {

      // drake/systems/controllers/zmpUtil.h:19
      const char* doc = R"""()""";

    } N;

    // TVLQRData::Q1
    struct /* Q1 */ {

      // drake/systems/controllers/zmpUtil.h:17
      const char* doc = R"""()""";

    } Q1;

    // TVLQRData::Qy
    struct /* Qy */ {

      // drake/systems/controllers/zmpUtil.h:14
      const char* doc = R"""()""";

    } Qy;

    // TVLQRData::R
    struct /* R */ {

      // drake/systems/controllers/zmpUtil.h:15
      const char* doc = R"""()""";

    } R;

    // TVLQRData::R1
    struct /* R1 */ {

      // drake/systems/controllers/zmpUtil.h:18
      const char* doc = R"""()""";

    } R1;

    // TVLQRData::u0
    struct /* u0 */ {

      // drake/systems/controllers/zmpUtil.h:16
      const char* doc = R"""()""";

    } u0;

  } TVLQRData;

  // VRefIntegratorParams
  struct /* VRefIntegratorParams */ {

    // drake/systems/controllers/QPCommon.h:56
    const char* doc = R"""()""";

    // VRefIntegratorParams::VRefIntegratorParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:57
      const char* doc = R"""()""";

    } ctor;

    // VRefIntegratorParams::delta_max
    struct /* delta_max */ {

      // drake/systems/controllers/QPCommon.h:62
      const char* doc = R"""()""";

    } delta_max;

    // VRefIntegratorParams::eta
    struct /* eta */ {

      // drake/systems/controllers/QPCommon.h:61
      const char* doc = R"""()""";

    } eta;

    // VRefIntegratorParams::zero_ankles_on_contact
    struct /* zero_ankles_on_contact */ {

      // drake/systems/controllers/QPCommon.h:60
      const char* doc = R"""()""";

    } zero_ankles_on_contact;

  } VRefIntegratorParams;

  // WholeBodyParams
  struct /* WholeBodyParams */ {

    // drake/systems/controllers/QPCommon.h:135
    const char* doc = R"""()""";

    // WholeBodyParams::Kd
    struct /* Kd */ {

      // drake/systems/controllers/QPCommon.h:145
      const char* doc = R"""()""";

    } Kd;

    // WholeBodyParams::Kp
    struct /* Kp */ {

      // drake/systems/controllers/QPCommon.h:144
      const char* doc = R"""()""";

    } Kp;

    // WholeBodyParams::WholeBodyParams
    struct /* ctor */ {

      // drake/systems/controllers/QPCommon.h:136
      const char* doc = R"""()""";

    } ctor;

    // WholeBodyParams::integrator
    struct /* integrator */ {

      // drake/systems/controllers/QPCommon.h:149
      const char* doc = R"""()""";

    } integrator;

    // WholeBodyParams::qdd_bounds
    struct /* qdd_bounds */ {

      // drake/systems/controllers/QPCommon.h:150
      const char* doc = R"""()""";

    } qdd_bounds;

    // WholeBodyParams::w_qdd
    struct /* w_qdd */ {

      // drake/systems/controllers/QPCommon.h:146
      const char* doc = R"""()""";

    } w_qdd;

  } WholeBodyParams;

  // WorldCoMConstraint
  struct /* WorldCoMConstraint */ {

    // drake/multibody/rigid_body_constraint.h:404
    const char* doc = R"""()""";

    // WorldCoMConstraint::WorldCoMConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:406
      const char* doc = R"""()""";

    } ctor;

    // WorldCoMConstraint::evalNames
    struct /* evalNames */ {

      // drake/multibody/rigid_body_constraint.h:417
      const char* doc = R"""()""";

    } evalNames;

    // WorldCoMConstraint::evalPositions
    struct /* evalPositions */ {

      // drake/multibody/rigid_body_constraint.h:415
      const char* doc = R"""()""";

    } evalPositions;

    // WorldCoMConstraint::updateRobotnum
    struct /* updateRobotnum */ {

      // drake/multibody/rigid_body_constraint.h:412
      const char* doc = R"""()""";

    } updateRobotnum;

  } WorldCoMConstraint;

  // WorldEulerConstraint
  struct /* WorldEulerConstraint */ {

    // drake/multibody/rigid_body_constraint.h:543
    const char* doc = R"""()""";

    // WorldEulerConstraint::WorldEulerConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:545
      const char* doc = R"""()""";

    } ctor;

    // WorldEulerConstraint::evalrpy
    struct /* evalrpy */ {

      // drake/multibody/rigid_body_constraint.h:553
      const char* doc = R"""()""";

    } evalrpy;

    // WorldEulerConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:550
      const char* doc = R"""()""";

    } name;

  } WorldEulerConstraint;

  // WorldFixedBodyPoseConstraint
  struct /* WorldFixedBodyPoseConstraint */ {

    // drake/multibody/rigid_body_constraint.h:829
    const char* doc = R"""()""";

    // WorldFixedBodyPoseConstraint::WorldFixedBodyPoseConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:831
      const char* doc = R"""()""";

    } ctor;

    // WorldFixedBodyPoseConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:839
      const char* doc = R"""()""";

    } bounds;

    // WorldFixedBodyPoseConstraint::eval_valid
    struct /* eval_valid */ {

      // drake/multibody/rigid_body_constraint.h:836
      const char* doc = R"""()""";

    } eval_valid;

    // WorldFixedBodyPoseConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:835
      const char* doc = R"""()""";

    } getNumConstraint;

    // WorldFixedBodyPoseConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:841
      const char* doc = R"""()""";

    } name;

  } WorldFixedBodyPoseConstraint;

  // WorldFixedOrientConstraint
  struct /* WorldFixedOrientConstraint */ {

    // drake/multibody/rigid_body_constraint.h:809
    const char* doc = R"""()""";

    // WorldFixedOrientConstraint::WorldFixedOrientConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:811
      const char* doc = R"""()""";

    } ctor;

    // WorldFixedOrientConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:819
      const char* doc = R"""()""";

    } bounds;

    // WorldFixedOrientConstraint::eval_valid
    struct /* eval_valid */ {

      // drake/multibody/rigid_body_constraint.h:816
      const char* doc = R"""()""";

    } eval_valid;

    // WorldFixedOrientConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:814
      const char* doc = R"""()""";

    } getNumConstraint;

    // WorldFixedOrientConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:821
      const char* doc = R"""()""";

    } name;

  } WorldFixedOrientConstraint;

  // WorldFixedPositionConstraint
  struct /* WorldFixedPositionConstraint */ {

    // drake/multibody/rigid_body_constraint.h:788
    const char* doc = R"""()""";

    // WorldFixedPositionConstraint::WorldFixedPositionConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:790
      const char* doc = R"""()""";

    } ctor;

    // WorldFixedPositionConstraint::bounds
    struct /* bounds */ {

      // drake/multibody/rigid_body_constraint.h:798
      const char* doc = R"""()""";

    } bounds;

    // WorldFixedPositionConstraint::eval_valid
    struct /* eval_valid */ {

      // drake/multibody/rigid_body_constraint.h:795
      const char* doc = R"""()""";

    } eval_valid;

    // WorldFixedPositionConstraint::getNumConstraint
    struct /* getNumConstraint */ {

      // drake/multibody/rigid_body_constraint.h:794
      const char* doc = R"""()""";

    } getNumConstraint;

    // WorldFixedPositionConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:800
      const char* doc = R"""()""";

    } name;

  } WorldFixedPositionConstraint;

  // WorldGazeDirConstraint
  struct /* WorldGazeDirConstraint */ {

    // drake/multibody/rigid_body_constraint.h:645
    const char* doc = R"""()""";

    // WorldGazeDirConstraint::WorldGazeDirConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:647
      const char* doc = R"""()""";

    } ctor;

    // WorldGazeDirConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:652
      const char* doc = R"""()""";

    } eval;

    // WorldGazeDirConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:654
      const char* doc = R"""()""";

    } name;

  } WorldGazeDirConstraint;

  // WorldGazeOrientConstraint
  struct /* WorldGazeOrientConstraint */ {

    // drake/multibody/rigid_body_constraint.h:606
    const char* doc = R"""()""";

    // WorldGazeOrientConstraint::WorldGazeOrientConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:608
      const char* doc = R"""()""";

    } ctor;

    // WorldGazeOrientConstraint::evalOrientation
    struct /* evalOrientation */ {

      // drake/multibody/rigid_body_constraint.h:616
      const char* doc = R"""()""";

    } evalOrientation;

    // WorldGazeOrientConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:613
      const char* doc = R"""()""";

    } name;

  } WorldGazeOrientConstraint;

  // WorldGazeTargetConstraint
  struct /* WorldGazeTargetConstraint */ {

    // drake/multibody/rigid_body_constraint.h:684
    const char* doc = R"""()""";

    // WorldGazeTargetConstraint::WorldGazeTargetConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:686
      const char* doc = R"""()""";

    } ctor;

    // WorldGazeTargetConstraint::eval
    struct /* eval */ {

      // drake/multibody/rigid_body_constraint.h:692
      const char* doc = R"""()""";

    } eval;

    // WorldGazeTargetConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:694
      const char* doc = R"""()""";

    } name;

  } WorldGazeTargetConstraint;

  // WorldPositionConstraint
  struct /* WorldPositionConstraint */ {

    // drake/multibody/rigid_body_constraint.h:383
    const char* doc = R"""()""";

    // WorldPositionConstraint::WorldPositionConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:385
      const char* doc = R"""()""";

    } ctor;

    // WorldPositionConstraint::evalNames
    struct /* evalNames */ {

      // drake/multibody/rigid_body_constraint.h:394
      const char* doc = R"""()""";

    } evalNames;

    // WorldPositionConstraint::evalPositions
    struct /* evalPositions */ {

      // drake/multibody/rigid_body_constraint.h:392
      const char* doc = R"""()""";

    } evalPositions;

    // WorldPositionConstraint::get_body
    struct /* get_body */ {

      // drake/multibody/rigid_body_constraint.h:396
      const char* doc = R"""()""";

    } get_body;

    // WorldPositionConstraint::get_body_name
    struct /* get_body_name */ {

      // drake/multibody/rigid_body_constraint.h:397
      const char* doc = R"""()""";

    } get_body_name;

  } WorldPositionConstraint;

  // WorldPositionInFrameConstraint
  struct /* WorldPositionInFrameConstraint */ {

    // drake/multibody/rigid_body_constraint.h:914
    const char* doc =
R"""(Constrains the points Q on a body to be within a bounding box
specified in a fixed frame F. Namely lb ≤ p_FQ ≤ ub.)""";

    // WorldPositionInFrameConstraint::WorldPositionInFrameConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:928
      const char* doc =
R"""(Constrains the points Q on a body to be within a bounding box
specified in a fixed frame F.

Parameter ``model``:
    The kinematics model of the whole robot.

Parameter ``body``:
    The points Q are rigidly fixed to this body.

Parameter ``pts``:
    The coordinates of Q in the body frame.

Parameter ``T_frame_to_world``:
    The homogeneous transform from the frame F to the world frame.

Parameter ``lb``:
    The lower bound of the bounding box.

Parameter ``ub``:
    The upper bound of the bounding box.

Parameter ``tspan``:
    The time span of the constraint.)""";

    } ctor;

    // WorldPositionInFrameConstraint::evalNames
    struct /* evalNames */ {

      // drake/multibody/rigid_body_constraint.h:938
      const char* doc = R"""()""";

    } evalNames;

    // WorldPositionInFrameConstraint::evalPositions
    struct /* evalPositions */ {

      // drake/multibody/rigid_body_constraint.h:936
      const char* doc = R"""()""";

    } evalPositions;

  } WorldPositionInFrameConstraint;

  // WorldQuatConstraint
  struct /* WorldQuatConstraint */ {

    // drake/multibody/rigid_body_constraint.h:471
    const char* doc = R"""()""";

    // WorldQuatConstraint::WorldQuatConstraint
    struct /* ctor */ {

      // drake/multibody/rigid_body_constraint.h:473
      const char* doc = R"""()""";

    } ctor;

    // WorldQuatConstraint::evalOrientationProduct
    struct /* evalOrientationProduct */ {

      // drake/multibody/rigid_body_constraint.h:481
      const char* doc = R"""()""";

    } evalOrientationProduct;

    // WorldQuatConstraint::name
    struct /* name */ {

      // drake/multibody/rigid_body_constraint.h:478
      const char* doc = R"""()""";

    } name;

  } WorldQuatConstraint;

  // _support_state_element
  struct /* _support_state_element */ {

    // drake/systems/controllers/controlUtil.h:22
    const char* doc = R"""()""";

    // _support_state_element::body_idx
    struct /* body_idx */ {

      // drake/systems/controllers/controlUtil.h:23
      const char* doc = R"""()""";

    } body_idx;

    // _support_state_element::contact_pts
    struct /* contact_pts */ {

      // drake/systems/controllers/controlUtil.h:24
      const char* doc = R"""()""";

    } contact_pts;

    // _support_state_element::support_logic_map
    struct /* support_logic_map */ {

      // drake/systems/controllers/controlUtil.h:25
      const char* doc = R"""()""";

    } support_logic_map;

    // _support_state_element::support_surface
    struct /* support_surface */ {

      // drake/systems/controllers/controlUtil.h:26
      const char* doc = R"""()""";

    } support_surface;

  } _support_state_element;

  // angleDiff
  struct /* angleDiff */ {

    // drake/systems/controllers/controlUtil.h:76
    const char* doc = R"""()""";

  } angleDiff;

  // applyDefaults
  struct /* applyDefaults */ {

    // drake/systems/controllers/yaml_util.h:13
    const char* doc = R"""()""";

  } applyDefaults;

  // approximateIK
  struct /* approximateIK */ {

    // drake/multibody/rigid_body_ik.h:98
    const char* doc =
R"""(approximateIK solves the same problem as inverseKin. But for speed
reason, it linearizes all constraints around q_seed, and solve a
quadratic problem instead of a nonlinear problem.

Parameter ``q_seed``:
    an nq x 1 double vector. The initial guess. Also where to
    linearize the constraints

Parameter ``q_nom``:
    Same as in inverseKin

Parameter ``num_constraints``:
    Same as in inverseKin

Parameter ``constraint_array``:
    Same as in inverseKin, but do not accept
    SingleTimeLinearPostureConstraint for the moment

Returns:
    q_sol Same as in inverseKin

Returns:
    info = 0 Success = 1 Fail

Parameter ``ikoptions``:
    Same as in inverseKin)""";

  } approximateIK;

  // bodySpatialMotionPD
  struct /* bodySpatialMotionPD */ {

    // drake/systems/controllers/controlUtil.h:111
    const char* doc = R"""()""";

  } bodySpatialMotionPD;

  // computeBodyOrFrameNameToIdMap
  struct /* computeBodyOrFrameNameToIdMap */ {

    // drake/systems/controllers/QPCommon.h:288
    const char* doc = R"""()""";

  } computeBodyOrFrameNameToIdMap;

  // contactConstraintsBV
  struct /* contactConstraintsBV */ {

    // drake/systems/controllers/controlUtil.h:96
    const char* doc = R"""()""";

  } contactConstraintsBV;

  // contactPhi
  struct /* contactPhi */ {

    // drake/systems/controllers/controlUtil.h:89
    const char* doc = R"""()""";

  } contactPhi;

  // decodePiecewisePolynomial
  struct /* decodePiecewisePolynomial */ {

    // drake/systems/controllers/polynomial_encode_decode.h:54
    const char* doc = R"""()""";

  } decodePiecewisePolynomial;

  // decodePolynomial
  struct /* decodePolynomial */ {

    // drake/systems/controllers/polynomial_encode_decode.h:14
    const char* doc = R"""()""";

  } decodePolynomial;

  // decodePolynomialMatrix
  struct /* decodePolynomialMatrix */ {

    // drake/systems/controllers/polynomial_encode_decode.h:38
    const char* doc = R"""()""";

  } decodePolynomialMatrix;

  // drake
  struct /* drake */ {

    // drake::AddResourceSearchPath
    struct /* AddResourceSearchPath */ {

      // drake/common/find_resource.h:81
      const char* doc =
R"""(Adds a path in which resources are searched in a persistent variable.
Paths are accumulated each time this function is called. It is
searched after the path given by the environment variable but before
the path that can be found with the sentinel `.drake-resource-
sentinel`. This can be used to find data in installed distributions of
drake (or in `pydrake`). The given path must be absolute or else
throws runtime_error.)""";

    } AddResourceSearchPath;

    // drake::DelegatingHasher
    struct /* DelegatingHasher */ {

      // drake/common/hash.h:250
      const char* doc =
R"""(An adapter that forwards the HashAlgorithm::operator(data, length)
function concept into a runtime-provided std::function of the same
signature. This is useful for passing a concrete HashAlgorithm
implementation through into non-templated code, such as with an Impl
or Cell pattern.)""";

      // drake::DelegatingHasher::DelegatingHasher
      struct /* ctor */ {

        // drake/common/hash.h:255
        const char* doc =
R"""(Create a delegating hasher that calls the given ``func``.)""";

      } ctor;

      // drake::DelegatingHasher::operator()
      struct /* operator_call */ {

        // drake/common/hash.h:261
        const char* doc =
R"""(Append [data, data + length) bytes into the wrapped algorithm.)""";

      } operator_call;

    } DelegatingHasher;

    // drake::EigenPtr
    struct /* EigenPtr */ {

      // drake/common/eigen_types.h:312
      const char* doc =
R"""(This wrapper class provides a way to write non-template functions
taking raw pointers to Eigen objects as parameters while limiting the
number of copies, similar to `Eigen::Ref`. Internally, it keeps an
instance of `Eigen::Ref<T>` and provides access to it via `operator*`
and `operator->`.

The motivation of this class is to follow <a href="https://google.gith
ub.io/styleguide/cppguide.html#Reference_Arguments">GSG's "output
arguments should be pointers" rule</a> while taking advantage of using
`Eigen::Ref`. Here is an example.

```
// This function is taking an Eigen::Ref of a matrix and modifies it in
// the body. This violates GSG's rule on output parameters.
void foo(Eigen::Ref<Eigen::MatrixXd> M) {
   M(0, 0) = 0;
}
// At Call-site, we have:
foo(M);
foo(M.block(0, 0, 2, 2));

// We can rewrite the above function into the following using EigenPtr.
void foo(EigenPtr<Eigen::MatrixXd> M) {
   (*M)(0, 0) = 0;
}
// Note that, call sites should be changed to:
foo(&M);

// We need tmp to avoid taking the address of a temporary object such as the
// return value of .block().
auto tmp = M.block(0, 0, 2, 2);
foo(&tmp);
```

Notice that methods taking an EigenPtr can mutate the entries of a
matrix as in method `foo()` in the example code above, but cannot
change its size. This is because `operator*` and `operator->` return
an `Eigen::Ref<T>` object and only plain matrices/arrays can be
resized and not expressions. This **is** the desired behavior, since
resizing the block of a matrix or even a more general expression
should not be allowed. If you do want to be able to resize a mutable
matrix argument, then you must pass it as a `Matrix<T>*`, like so:

```
void bar(Eigen::MatrixXd* M) {
  DRAKE_THROW_UNLESS(M != nullptr);
  // In this case this method only works with 4x3 matrices.
  if (M->rows() != 4 && M->cols() != 3) {
    M->resize(4, 3);
  }
  (*M)(0, 0) = 0;
}
```

Note:
    This class provides a way to avoid the `const_cast` hack
    introduced in <a href="https://eigen.tuxfamily.org/dox/TopicFuncti
    onTakingEigenTypes.html#TopicPlainFunctionsFailing">Eigen's
    documentation</a>.)""";

      // drake::EigenPtr::EigenPtr<PlainObjectType>
      struct /* ctor */ {

        // drake/common/eigen_types.h:316
        const char* doc = R"""()""";

        // drake/common/eigen_types.h:320
        const char* doc_2 = R"""(Overload for `nullptr`.)""";

        // drake/common/eigen_types.h:324
        const char* doc_3 =
R"""(Constructs with a reference to the given matrix type.)""";

        // drake/common/eigen_types.h:330
        const char* doc_4 =
R"""(Constructs with a reference to another matrix type. May be `nullptr`.)""";

        // drake/common/eigen_types.h:339
        const char* doc_5 = R"""(Constructs from another EigenPtr.)""";

      } ctor;

      // drake::EigenPtr::operator bool
      struct /* operator_bool */ {

        // drake/common/eigen_types.h:362
        const char* doc =
R"""(Returns whether or not this contains a valid reference.)""";

      } operator_bool;

      // drake::EigenPtr::operator!=
      struct /* operator_ne */ {

        // drake/common/eigen_types.h:366
        const char* doc = R"""()""";

      } operator_ne;

      // drake::EigenPtr::operator*
      struct /* operator_mul */ {

        // drake/common/eigen_types.h:356
        const char* doc =
R"""(Throws:
    s std::runtime_error if this is a null dereference.)""";

      } operator_mul;

    } EigenPtr;

    // drake::EigenSizeMinPreferDynamic
    struct /* EigenSizeMinPreferDynamic */ {

      // drake/common/eigen_types.h:166
      const char* doc =
R"""(EigenSizeMinPreferDynamic<a, b>::value gives the min between compile-
time sizes ``a`` and ``b``. 0 has absolute priority, followed by 1,
followed by Dynamic, followed by other finite values.

Note that this is a type-trait version of
EIGEN_SIZE_MIN_PREFER_DYNAMIC macro in "Eigen/Core/util/Macros.h".)""";

    } EigenSizeMinPreferDynamic;

    // drake::EigenSizeMinPreferFixed
    struct /* EigenSizeMinPreferFixed */ {

      // drake/common/eigen_types.h:182
      const char* doc =
R"""(EigenSizeMinPreferFixed is a variant of EigenSizeMinPreferDynamic. The
difference is that finite values now have priority over Dynamic, so
that EigenSizeMinPreferFixed<3, Dynamic>::value gives 3.

Note that this is a type-trait version of EIGEN_SIZE_MIN_PREFER_FIXED
macro in "Eigen/Core/util/Macros.h".)""";

    } EigenSizeMinPreferFixed;

    // drake::ExtractDoubleOrThrow
    struct /* ExtractDoubleOrThrow */ {

      // drake/common/autodiff_overloads.h:145
      const char* doc =
R"""(Returns the autodiff scalar's value() as a double. Never throws.
Overloads ExtractDoubleOrThrow from common/extract_double.h.)""";

    } ExtractDoubleOrThrow;

    // drake::FindResource
    struct /* FindResource */ {

      // drake/common/find_resource.h:98
      const char* doc =
R"""(Attempts to locate a Drake resource named by the given
``resource_path``. The ``resource_path`` refers to the relative path
within the Drake source repository, prepended with `drake/`. For
example, to find the source file `examples/pendulum/Pendulum.urdf`,
the ``resource_path`` would be
`drake/examples/pendulum/Pendulum.urdf`. Paths that do not start with
`drake/` will return a failed result.

The search scans for the resource in the following places and in the
following order: 1) in the DRAKE_RESOURCE_ROOT environment variable 2)
in the directories specified by `AddResourceSearchPath()` and 3) in
the drake source workspace. If all of these are unavailable, or do not
have the resource, then it will return a failed result.)""";

    } FindResource;

    // drake::FindResourceOrThrow
    struct /* FindResourceOrThrow */ {

      // drake/common/find_resource.h:102
      const char* doc =
R"""(Convenient wrapper for querying FindResource(resource_path) followed
by FindResourceResult::get_absolute_path_or_throw().)""";

    } FindResourceOrThrow;

    // drake::FindResourceResult
    struct /* FindResourceResult */ {

      // drake/common/find_resource.h:21
      const char* doc =
R"""(Models the outcome of drake::FindResource. After a call to
FindResource, typical calling code would use
get_absolute_path_or_throw(). Alternatively, get_absolute_path() will
return an `optional<string>`, which can be manually checked to contain
a value before using the path. If the resource was not found,
get_error_message() will contain an error message.

For a given FindResourceResult instance, exactly one of
get_absolute_path() or get_error_message() will contain a value.
(Similarly, exactly one of them will not contain a value.))""";

      // drake::FindResourceResult::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
      struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

        // drake/common/find_resource.h:23
        const char* doc = R"""()""";

      } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

      // drake::FindResourceResult::FindResourceResult
      struct /* ctor */ {

        // drake/common/find_resource.h:23
        const char* doc = R"""()""";

        // drake/common/find_resource.h:23
        const char* doc_2 = R"""()""";

      } ctor;

      // drake::FindResourceResult::get_absolute_path
      struct /* get_absolute_path */ {

        // drake/common/find_resource.h:26
        const char* doc =
R"""(Returns the absolute path to the resource, iff the resource was found.)""";

      } get_absolute_path;

      // drake::FindResourceResult::get_absolute_path_or_throw
      struct /* get_absolute_path_or_throw */ {

        // drake/common/find_resource.h:30
        const char* doc =
R"""(Either returns the get_absolute_path() iff the resource was found, or
else throws runtime_error.)""";

      } get_absolute_path_or_throw;

      // drake::FindResourceResult::get_error_message
      struct /* get_error_message */ {

        // drake/common/find_resource.h:34
        const char* doc =
R"""(Returns the error message, iff the resource was not found. The string
will never be empty; only the optional can be empty.)""";

      } get_error_message;

      // drake::FindResourceResult::get_resource_path
      struct /* get_resource_path */ {

        // drake/common/find_resource.h:38
        const char* doc =
R"""(Returns the resource_path asked of FindResource. (This may be empty
only in the make_empty() case.))""";

      } get_resource_path;

      // drake::FindResourceResult::make_empty
      struct /* make_empty */ {

        // drake/common/find_resource.h:54
        const char* doc =
R"""(Returns an empty error result (no requested resource).)""";

      } make_empty;

      // drake::FindResourceResult::make_error
      struct /* make_error */ {

        // drake/common/find_resource.h:50
        const char* doc =
R"""(Returns an error result (the requested resource was NOT found). @pre
neither string parameter is empty

Parameter ``resource_path``:
    the value passed to FindResource)""";

      } make_error;

      // drake::FindResourceResult::make_success
      struct /* make_success */ {

        // drake/common/find_resource.h:44
        const char* doc =
R"""(Returns a success result (the requested resource was found). @pre
neither string parameter is empty

Parameter ``resource_path``:
    the value passed to FindResource

Parameter ``base_path``:
    an absolute base path that precedes resource_path)""";

      } make_success;

    } FindResourceResult;

    // drake::GetResourceSearchPaths
    struct /* GetResourceSearchPaths */ {

      // drake/common/find_resource.h:84
      const char* doc =
R"""(Gets current root directory value from a persistent variable.)""";

    } GetResourceSearchPaths;

    // drake::LoadedLibraryPath
    struct /* LoadedLibraryPath */ {

      // drake/common/find_loaded_library.h:12
      const char* doc =
R"""(This function returns the absolute path of the library with the name
`library_name` if that library was loaded in the current running
process. Otherwise it returns an empty optional.)""";

    } LoadedLibraryPath;

    // drake::MultiplyEigenSizes
    struct /* MultiplyEigenSizes */ {

      // drake/common/eigen_types.h:196
      const char* doc =
R"""(MultiplyEigenSizes<a, b> gives a * b if both of a and b are fixed
sizes. Otherwise it gives Eigen::Dynamic.)""";

    } MultiplyEigenSizes;

    // drake::NiceTypeName
    struct /* NiceTypeName */ {

      // drake/common/nice_type_name.h:44
      const char* doc =
R"""(Obtains canonicalized, platform-independent, human-readable names for
arbitrarily-complicated C++ types.

Usage:

```
// For types:
using std::pair; using std::string;
using MyVectorType = pair<int,string>;
std::cout << "Type MyVectorType was: "
<< drake::NiceTypeName::Get<MyVectorType>() << std::endl;
// Output: std::pair<int,std::string>

// For expressions:
std::unique_ptr<AbstractThing> thing;  // Assume actual type is ConcreteThing.
std::cout << "Actual type of 'thing' was: "
<< drake::NiceTypeName::Get(*thing) << std::endl;
// Output: ConcreteThing
```

We demangle and attempt to canonicalize the compiler-generated type
names as reported by `typeid(T).name()` so that the same string is
returned by all supported compilers and platforms. The output of
NiceTypeName::Get<T>() is useful in error and log messages and
testing. It also provides a persistent, platform-independent
identifier for types; `std::type_info` cannot provide that.

@warning Don't expect usable names for types that are defined in an
anonymous namespace or for function-local types. Names will still be
produced but they won't be unique, pretty, or compiler-independent.

This class exists only to group type name-related static methods;
don't try to construct an object of this type.)""";

      // drake::NiceTypeName::Canonicalize
      struct /* Canonicalize */ {

        // drake/common/nice_type_name.h:82
        const char* doc =
R"""(Given a compiler-dependent demangled type name string as returned by
Demangle(), attempts to form a canonicalized representation that will
be the same for any compiler. Unnecessary spaces and superfluous
keywords like "class" and "struct" are removed. The
NiceTypeName::Get<T>() method uses this function to produce a human-
friendly type name that is the same on any platform.)""";

      } Canonicalize;

      // drake::NiceTypeName::Demangle
      struct /* Demangle */ {

        // drake/common/nice_type_name.h:74
        const char* doc =
R"""(Using the algorithm appropriate to the current compiler, demangles a
type name as returned by `typeid(T).name()`, with the result hopefully
suitable for meaningful display to a human. The result is compiler-
dependent.

See also:
    Canonicalize())""";

      } Demangle;

      // drake::NiceTypeName::Get
      struct /* Get */ {

        // drake/common/nice_type_name.h:53
        const char* doc =
R"""(Attempts to return a nicely demangled and canonicalized type name that
is the same on all platforms, using Canonicalize(). This is an
expensive operation but is only done once per instantiation of
NiceTypeName::Get<T>() for a given type `T`. The returned reference
will not be deleted even at program termination, so feel free to use
it in error messages even in destructors that may be invoked during
program tear-down.)""";

        // drake/common/nice_type_name.h:66
        const char* doc_2 =
R"""(Returns the type name of the most-derived type of an object of type T,
typically but not necessarily polymorphic. This must be calculated on
the fly so is expensive whenever called, though very reasonable for
use in error messages. For non-polymorphic types this produces the
same result as would `Get<decltype(thing)>()` but for polymorphic
types the results will differ.)""";

      } Get;

      // drake::NiceTypeName::RemoveNamespaces
      struct /* RemoveNamespaces */ {

        // drake/common/nice_type_name.h:92
        const char* doc =
R"""(Given a canonical type name that may include leading namespaces,
attempts to remove those namespaces. For example,
`drake::systems::MyThing<internal::type>` becomes
`MyThing<internal::type>`. If the last segment ends in `::`, the
original string is returned unprocessed. Note that this is just string
processing -- a segment that looks like a namespace textually will be
treated as one, even if it is really a class. So
`drake::MyClass::Impl` will be reduced to `Impl` while
`drake::MyClass<T>::Impl` is reduced to `MyClass<T>::Impl`.)""";

      } RemoveNamespaces;

    } NiceTypeName;

    // drake::RandomDistribution
    struct /* RandomDistribution */ {

      // drake/common/constants.h:21
      const char* doc =
R"""(Drake supports explicit reasoning about a few carefully chosen random
distributions.)""";

      // drake::RandomDistribution::kExponential
      struct /* kExponential */ {

        // drake/common/constants.h:26
        const char* doc =
R"""(< Vector elements are independent and drawn from an)""";

      } kExponential;

      // drake::RandomDistribution::kGaussian
      struct /* kGaussian */ {

        // drake/common/constants.h:24
        const char* doc =
R"""(< Vector elements are independent and drawn from a)""";

      } kGaussian;

      // drake::RandomDistribution::kUniform
      struct /* kUniform */ {

        // drake/common/constants.h:22
        const char* doc =
R"""(< Vector elements are independent and uniformly distributed)""";

      } kUniform;

    } RandomDistribution;

    // drake::TypeSafeIndex
    struct /* TypeSafeIndex */ {

      // drake/common/type_safe_index.h:129
      const char* doc =
R"""(A type-safe non-negative index class.

Note:
    This is *purposely* a separate class from geometry::Identifier.
    For more information, see TypeSafeIndexVsIndentifier "this
    section".

This class serves as an upgrade to the standard practice of passing
`int`s around as indices. In the common practice, a method that takes
indices into multiple collections would have an interface like:

```
void foo(int bar_index, int thing_index);
```

It is possible for a programmer to accidentally switch the two index
values in an invocation. This mistake would still be _syntactically_
correct; it will successfully compile but lead to inscrutable run-time
errors. The type-safe index provides the same speed and efficiency of
passing `int`s, but provides compile-time checking. The function would
now look like:

```
void foo(BarIndex bar_index, ThingIndex thing_index);
```

and the compiler will catch instances where the order is reversed.

The type-safe index is a _stripped down_ `int`. Each uniquely declared
index type has the following properties:

- Valid index values are _explicitly_ constructed from `int` values. -
The index is implicitly convertible to an `int` (to serve as an
index). - The index supports increment, decrement, and in-place
addition and subtraction to support standard index-like operations. -
An index _cannot_ be constructed or compared to an index of another
type. - In general, indices of different types are _not_
interconvertible. - Binary integer operators (e.g., +, -, |, *, etc.)
_always_ produce `int` return values. One can even use operands of
different index types in such a binary expression. It is the
_programmer's_ responsibility to confirm that the resultant `int`
value has meaning.

While there _is_ the concept of an "invalid" index, this only exists
to support default construction _where appropriate_ (e.g., using
indices in STL containers). Using an invalid index in _any_ operation
is considered an error. In Debug build, attempts to compare,
increment, decrement, etc. an invalid index will throw an exception.

A function that returns TypeSafeIndex values which need to communicate
failure should _not_ use an invalid index. It should return an
`std::optional<Index>` instead.

It is the designed intent of this class, that indices derived from
this class can be passed and returned by value. Passing indices by
const reference should be considered a misuse.

This is the recommended method to create a unique index type
associated with class `Foo`:

```
using FooIndex = TypeSafeIndex<class FooTag>;
```

This references a non-existent, and ultimately anonymous, class
`FooTag`. This is sufficient to create a unique index type. It is
certainly possible to use an existing class (e.g., `Foo`). But this
provides no functional benefit.

__Construction from integral types__

C++ will do [implict integer conversions](https://en.cppreference.com/
w/cpp/language/implicit_conversion#Integral_conversions). This allows
construction of TypeSafeIndex values with arbitrary integral types.
Index values must lie in the range of [0, 2³¹). The constructor will
validate the input value (in Debug mode). Ultimately, the caller is
responsible for confirming that the values provided lie in the valid
range.

__Examples of valid and invalid operations__

The TypeSafeIndex guarantees that index instances of different types
can't be compared or combined. Efforts to do so will cause a compile-
time failure. However, comparisons or operations on _other_ types that
are convertible to an int will succeed. For example:

```
using AIndex = TypeSafeIndex<class A>;
   using BIndex = TypeSafeIndex<class B>;
   AIndex a(1);
   BIndex b(1);
   if (a == 2) { ... }      // Ok.
   size_t sz = 7;
   if (a == sz) { ... }     // Ok.
   if (a == b) { ... }      // <-- Compiler error.
   AIndex invalid;          // Creates an invalid index.
   ++invalid;               // Runtime error in Debug build.
```

As previously stated, the intent of this class is to seamlessly serve
as an index into indexed objects (e.g., vector, array, etc.). At the
same time, we want to avoid implicit conversions _from_ int to an
index. These two design constraints combined lead to a limitation in
how TypeSafeIndex instances can be used. Specifically, we've lost a
common index pattern:

```
for (MyIndex a = 0; a < N; ++a) { ... }
```

This pattern no longer works because it requires implicit conversion
of int to TypeSafeIndex. Instead, the following pattern needs to be
used:

```
for (MyIndex a(0); a < N; ++a) { ... }
```

See also:
    drake::geometry::Identifier

Template parameter ``Tag``:
    The name of the tag associated with a class type. The class need
    not be a defined class.)""";

      // drake::TypeSafeIndex::TypeSafeIndex<Tag>
      struct /* ctor */ {

        // drake/common/type_safe_index.h:136
        const char* doc =
R"""(Default constructor; the result is an _invalid_ index. This only
exists to serve applications which require a default constructor.)""";

        // drake/common/type_safe_index.h:141
        const char* doc_2 =
R"""(Construction from a non-negative `int` value. The value must lie in
the range of [0, 2³¹). Constructor only promises to test validity in
Debug build.)""";

        // drake/common/type_safe_index.h:150
        const char* doc_3 =
R"""(Disallow construction from another index type.)""";

        // drake/common/type_safe_index.h:152
        const char* doc_4 = R"""()""";

        // drake/common/type_safe_index.h:154
        const char* doc_5 = R"""()""";

      } ctor;

      // drake::TypeSafeIndex::is_valid
      struct /* is_valid */ {

        // drake/common/type_safe_index.h:183
        const char* doc =
R"""(Reports if the index is valid--the only operation on an invalid index
that doesn't throw an exception in Debug builds.)""";

      } is_valid;

      // drake::TypeSafeIndex::operator int
      struct /* operator_int */ {

        // drake/common/type_safe_index.h:176
        const char* doc = R"""(Implicit conversion-to-int operator.)""";

      } operator_int;

      // drake::TypeSafeIndex::operator!=
      struct /* operator_ne */ {

        // drake/common/type_safe_index.h:357
        const char* doc =
R"""(Whitelist inequality test with indices of this tag.)""";

        // drake/common/type_safe_index.h:368
        const char* doc_2 =
R"""(Whitelist inequality test with unsigned integers.)""";

        // drake/common/type_safe_index.h:376
        const char* doc_3 =
R"""(Blacklist inequality test with indices of other tags.)""";

      } operator_ne;

      // drake::TypeSafeIndex::operator++
      struct /* operator_inc */ {

        // drake/common/type_safe_index.h:197
        const char* doc = R"""(Prefix increment operator.)""";

        // drake/common/type_safe_index.h:207
        const char* doc_2 = R"""(Postfix increment operator.)""";

      } operator_inc;

      // drake::TypeSafeIndex::operator+=
      struct /* operator_iadd */ {

        // drake/common/type_safe_index.h:247
        const char* doc =
R"""(Addition assignment operator. In Debug builds, this method asserts
that the resulting index is non-negative.)""";

        // drake/common/type_safe_index.h:260
        const char* doc_2 =
R"""(Whitelist addition for indices with the same tag.)""";

        // drake/common/type_safe_index.h:277
        const char* doc_3 =
R"""(Blacklist addition for indices of different tags.)""";

      } operator_iadd;

      // drake::TypeSafeIndex::operator--
      struct /* operator_dec */ {

        // drake/common/type_safe_index.h:219
        const char* doc =
R"""(Prefix decrement operator. In Debug builds, this method asserts that
the resulting index is non-negative.)""";

        // drake/common/type_safe_index.h:231
        const char* doc_2 =
R"""(Postfix decrement operator. In Debug builds, this method asserts that
the resulting index is non-negative.)""";

      } operator_dec;

      // drake::TypeSafeIndex::operator-=
      struct /* operator_isub */ {

        // drake/common/type_safe_index.h:282
        const char* doc =
R"""(Subtraction assignment operator. In Debug builds, this method asserts
that the resulting index is non-negative.)""";

        // drake/common/type_safe_index.h:294
        const char* doc_2 =
R"""(Whitelist subtraction for indices with the same tag.)""";

        // drake/common/type_safe_index.h:311
        const char* doc_3 =
R"""(Blacklist subtraction for indices of different tags.)""";

      } operator_isub;

      // drake::TypeSafeIndex::operator<
      struct /* operator_lt */ {

        // drake/common/type_safe_index.h:379
        const char* doc =
R"""(Whitelist less than test with indices of this tag.)""";

        // drake/common/type_safe_index.h:390
        const char* doc_2 =
R"""(Whitelist less than test with unsigned integers.)""";

        // drake/common/type_safe_index.h:398
        const char* doc_3 =
R"""(Blacklist less than test with indices of other tags.)""";

      } operator_lt;

      // drake::TypeSafeIndex::operator<=
      struct /* operator_le */ {

        // drake/common/type_safe_index.h:401
        const char* doc =
R"""(Whitelist less than or equals test with indices of this tag.)""";

        // drake/common/type_safe_index.h:412
        const char* doc_2 =
R"""(Whitelist less than or equals test test with unsigned integers.)""";

        // drake/common/type_safe_index.h:420
        const char* doc_3 =
R"""(Blacklist less than or equals test with indices of other tags.)""";

      } operator_le;

      // drake::TypeSafeIndex::operator>
      struct /* operator_gt */ {

        // drake/common/type_safe_index.h:423
        const char* doc =
R"""(Whitelist greater than test with indices of this tag.)""";

        // drake/common/type_safe_index.h:434
        const char* doc_2 =
R"""(Whitelist greater than test with unsigned integers.)""";

        // drake/common/type_safe_index.h:442
        const char* doc_3 =
R"""(Blacklist greater than test with indices of other tags.)""";

      } operator_gt;

      // drake::TypeSafeIndex::operator>=
      struct /* operator_ge */ {

        // drake/common/type_safe_index.h:445
        const char* doc =
R"""(Whitelist greater than or equals test with indices of this tag.)""";

        // drake/common/type_safe_index.h:456
        const char* doc_2 =
R"""(Whitelist greater than or equals test with unsigned integers.)""";

        // drake/common/type_safe_index.h:464
        const char* doc_3 =
R"""(Blacklist greater than or equals test with indices of other tags.)""";

      } operator_ge;

    } TypeSafeIndex;

    // assert
    struct /* assert */ {

      // drake::assert::ConditionTraits
      struct /* ConditionTraits */ {

        // drake/common/drake_assert.h:90
        const char* doc = R"""()""";

        // drake::assert::ConditionTraits::Evaluate
        struct /* Evaluate */ {

          // drake/common/drake_assert.h:92
          const char* doc = R"""()""";

        } Evaluate;

      } ConditionTraits;

    } assert;

    // automotive
    struct /* automotive */ {

      // drake::automotive::AheadOrBehind
      struct /* AheadOrBehind */ {

        // drake/automotive/pose_selector.h:40
        const char* doc =
R"""(Specifies whether to assess the cars ahead or behind the ego car at
its current orientation with respect to its lane.)""";

        // drake::automotive::AheadOrBehind::kAhead
        struct /* kAhead */ {

          // drake/automotive/pose_selector.h:40
          const char* doc = R"""()""";

        } kAhead;

        // drake::automotive::AheadOrBehind::kBehind
        struct /* kBehind */ {

          // drake/automotive/pose_selector.h:40
          const char* doc = R"""()""";

        } kBehind;

      } AheadOrBehind;

      // drake::automotive::AutomotiveSimulator
      struct /* AutomotiveSimulator */ {

        // drake/automotive/automotive_simulator.h:46
        const char* doc =
R"""(AutomotiveSimulator is a helper class for constructing and running
automotive-related simulations.

Template parameter ``T``:
    must be a valid Eigen ScalarType.

Instantiated templates for the following ScalarTypes are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::AutomotiveSimulator::AddIdmControlledCar
        struct /* AddIdmControlledCar */ {

          // drake/automotive/automotive_simulator.h:170
          const char* doc =
R"""(Adds a lane-following SimpleCar with IdmController and
PurePursuitController to this simulation that takes as input a
constant source that contains the ``goal_lane`` as the destination
lane for the car. The car is visualized as a Toyota Prius. This
includes its EulerFloatingJoint output.

@pre Start() has NOT been called.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``initial_with_s``:
    Initial travel direction in the lane. True means that the car is
    initially oriented in the positive-s direction.

Parameter ``initial_state``:
    The SimpleCar's initial state.

Parameter ``goal_lane``:
    The goal lane for the car. If goal_lane is nullptr or not a member
    of the road supplied via SetRoadGeometry(), a std::runtime_error
    will be thrown.

Parameter ``path_or_branches``:
    If ScanStrategy::kBranches, performs IDM computations using
    vehicles detected in confluent branches; if ScanStrategy::kPath,
    limits to vehicles on the default path.

Parameter ``road_position_strategy``:
    Determines whether or not to memorize RoadPosition. See
    `calc_ongoing_road_position.h`.

Parameter ``period_sec``:
    The update period to use if road_position_strategy ==
    RoadPositionStrategy::kCache.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddIdmControlledCar;

        // drake::automotive::AutomotiveSimulator::AddIdmControlledPriusMaliputRailcar
        struct /* AddIdmControlledPriusMaliputRailcar */ {

          // drake/automotive/automotive_simulator.h:238
          const char* doc =
R"""(Adds a MaliputRailcar to this simulation visualized as a Toyota Prius
that is controlled via an IdmController.

@pre Start() has NOT been called.

@pre SetRoadGeometry() was called. Otherwise, a std::runtime_error
will be thrown.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``initial_lane_direction``:
    The MaliputRailcar's initial lane and direction on the lane. The
    lane in this parameter must be part of the
    maliput::api::RoadGeometry that is added via SetRoadGeometry().
    Otherwise a std::runtime_error will be thrown.

Parameter ``path_or_branches``:
    If ScanStrategy::kBranches, performs IDM computations using
    vehicles detected in confluent branches; if ScanStrategy::kPath,
    limits to vehicles on the default path.

Parameter ``road_position_strategy``:
    Determines whether or not to memorize RoadPosition. See
    `calc_ongoing_road_position.h`.

Parameter ``period_sec``:
    The update period to use if road_position_strategy ==
    RoadPositionStrategy::kCache.

Parameter ``params``:
    The MaliputRailcar's parameters. This is an optional parameter.
    Defaults are used if this parameter is not provided.

Parameter ``initial_state``:
    The MaliputRailcar's initial state. This is an optional parameter.
    Defaults are used if this parameter is not provided.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddIdmControlledPriusMaliputRailcar;

        // drake::automotive::AutomotiveSimulator::AddMobilControlledSimpleCar
        struct /* AddMobilControlledSimpleCar */ {

          // drake/automotive/automotive_simulator.h:115
          const char* doc =
R"""(Adds a SimpleCar to this simulation controlled by a MOBIL planner
coupled with a PurePursuitController to perform lateral control of the
vehicle, along with an IDM longitudinal controller. The car is
visualized as a Toyota Prius.

@pre Start() has NOT been called.

@pre SetRoadGeometry() was called. Otherwise, a std::runtime_error
will be thrown.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``initial_with_s``:
    Initial travel direction in the lane. (See MobilPlanner
    documentation.)

Parameter ``path_or_branches``:
    If ScanStrategy::kBranches, performs IDM computations using
    vehicles detected in confluent branches; if ScanStrategy::kPath,
    limits to vehicles on the default path.

Parameter ``road_position_strategy``:
    Determines whether or not to memorize RoadPosition. See
    `calc_ongoing_road_position.h`.

Parameter ``period_sec``:
    The update period to use if road_position_strategy ==
    RoadPositionStrategy::kCache.

Parameter ``initial_state``:
    The SimpleCar's initial state.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddMobilControlledSimpleCar;

        // drake::automotive::AutomotiveSimulator::AddPriusMaliputRailcar
        struct /* AddPriusMaliputRailcar */ {

          // drake/automotive/automotive_simulator.h:200
          const char* doc =
R"""(Adds a MaliputRailcar to this simulation visualized as a Toyota Prius.

@pre Start() has NOT been called.

@pre SetRoadGeometry() was called. Otherwise, a std::runtime_error
will be thrown.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``initial_lane_direction``:
    The MaliputRailcar's initial lane and direction on the lane. The
    lane in this parameter must be part of the
    maliput::api::RoadGeometry that is added via SetRoadGeometry().
    Otherwise a std::runtime_error will be thrown.

Parameter ``params``:
    The MaliputRailcar's parameters. This is an optional parameter.
    Defaults are used if this parameter is not provided.

Parameter ``initial_state``:
    The MaliputRailcar's initial state. This is an optional parameter.
    Defaults are used if this parameter is not provided.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddPriusMaliputRailcar;

        // drake::automotive::AutomotiveSimulator::AddPriusSimpleCar
        struct /* AddPriusSimpleCar */ {

          // drake/automotive/automotive_simulator.h:82
          const char* doc =
R"""(Adds a SimpleCar to this simulation visualized as a Toyota Prius. This
includes its DrivingCommand LCM input.

@pre Start() has NOT been called.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``channel_name``:
    The SimpleCar will subscribe to an LCM channel of this name to
    receive commands. If empty, then the input port is fixed to a
    DrivingCommand created using its default constructor.

Parameter ``initial_state``:
    The SimpleCar's initial state.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddPriusSimpleCar;

        // drake::automotive::AutomotiveSimulator::AddPriusTrajectoryCar
        struct /* AddPriusTrajectoryCar */ {

          // drake/automotive/automotive_simulator.h:135
          const char* doc =
R"""(Adds a TrajectoryCar to this simulation visualized as a Toyota Prius.

@pre Start() has NOT been called.

Parameter ``name``:
    The car's name, which must be unique among all cars. Otherwise a
    std::runtime_error will be thrown.

Parameter ``curve``:
    See documentation of TrajectoryCar::TrajectoryCar.

Parameter ``speed``:
    See documentation of TrajectoryCar::TrajectoryCar.

Parameter ``start_time``:
    See documentation of TrajectoryCar::TrajectoryCar.

Returns:
    The ID of the car that was just added to the simulation.)""";

        } AddPriusTrajectoryCar;

        // drake::automotive::AutomotiveSimulator::AutomotiveSimulator<T>
        struct /* ctor */ {

          // drake/automotive/automotive_simulator.h:48
          const char* doc = R"""()""";

          // drake/automotive/automotive_simulator.h:48
          const char* doc_2 = R"""()""";

          // drake/automotive/automotive_simulator.h:52
          const char* doc_3 =
R"""(The default constructor that configures this object with a default-
constructed DrakeLcm instance.)""";

          // drake/automotive/automotive_simulator.h:56
          const char* doc_4 =
R"""(A constructor that configures this object to use a DrakeLcmInterface
instance. If nullptr, no visualization is produced.)""";

        } ctor;

        // drake::automotive::AutomotiveSimulator::Build
        struct /* Build */ {

          // drake/automotive/automotive_simulator.h:292
          const char* doc =
R"""(Builds the Diagram. No further changes to the diagram may occur after
this has been called.

@pre Build() and BuildandInitialize() have NOT been called.)""";

        } Build;

        // drake::automotive::AutomotiveSimulator::BuildAndInitialize
        struct /* BuildAndInitialize */ {

          // drake/automotive/automotive_simulator.h:298
          const char* doc =
R"""(Builds the Diagram and initializes the Diagram Context to the
predefined initial states.

@pre Build() and BuildandInitialize() have NOT been called.)""";

        } BuildAndInitialize;

        // drake::automotive::AutomotiveSimulator::FindLane
        struct /* FindLane */ {

          // drake/automotive/automotive_simulator.h:268
          const char* doc =
R"""(Finds and returns a pointer to a lane with the specified name. This
method throws a std::runtime_error if no such lane exists.

@pre SetRoadGeometry() was called.)""";

        } FindLane;

        // drake::automotive::AutomotiveSimulator::GetBuilderSystemByName
        struct /* GetBuilderSystemByName */ {

          // drake/automotive/automotive_simulator.h:277
          const char* doc =
R"""(This is the builder variant of the method. It can only be used prior
to Start() being called.

@pre Start() has NOT been called.)""";

        } GetBuilderSystemByName;

        // drake::automotive::AutomotiveSimulator::GetCurrentPoses
        struct /* GetCurrentPoses */ {

          // drake/automotive/automotive_simulator.h:333
          const char* doc =
R"""(Returns the current poses of all vehicles in the simulation.

@pre Start() has been called.)""";

        } GetCurrentPoses;

        // drake::automotive::AutomotiveSimulator::GetDiagram
        struct /* GetDiagram */ {

          // drake/automotive/automotive_simulator.h:304
          const char* doc =
R"""(Returns the System containing the entire AutomotiveSimulator diagram.

@pre either Build() or BuildandInitialize() have been called.)""";

        } GetDiagram;

        // drake::automotive::AutomotiveSimulator::GetDiagramSystemByName
        struct /* GetDiagramSystemByName */ {

          // drake/automotive/automotive_simulator.h:286
          const char* doc =
R"""(Returns the System whose name matches ``name``. Throws an exception if
no such system has been added, or multiple such systems have been
added.

This is the diagram variant of the method, which can only be used
after Start() is called.

@pre Start() has been called.)""";

        } GetDiagramSystemByName;

        // drake::automotive::AutomotiveSimulator::SetMaliputRailcarAccelerationCommand
        struct /* SetMaliputRailcarAccelerationCommand */ {

          // drake/automotive/automotive_simulator.h:255
          const char* doc =
R"""(Sets the acceleration command of a particular MaliputRailcar.

Parameter ``id``:
    The ID of the MaliputRailcar. This is the ID that was returned by
    the method that added the MaliputRailcar to the simulation. If no
    MaliputRailcar with such an ID exists, a std::runtime_error is
    thrown.

Parameter ``acceleration``:
    The acceleration command to issue to the MaliputRailcar.

@pre Start() has been called.)""";

        } SetMaliputRailcarAccelerationCommand;

        // drake::automotive::AutomotiveSimulator::SetRoadGeometry
        struct /* SetRoadGeometry */ {

          // drake/automotive/automotive_simulator.h:260
          const char* doc =
R"""(Sets the RoadGeometry for this simulation.

@pre Start() has NOT been called.)""";

        } SetRoadGeometry;

        // drake::automotive::AutomotiveSimulator::Start
        struct /* Start */ {

          // drake/automotive/automotive_simulator.h:320
          const char* doc =
R"""(Calls BuildAndInitialize() on the diagram (if it has not been build
already) and initializes the Simulator. No further changes to the
diagram may occur after this has been called.

@pre Start() has NOT been called.

Parameter ``target_realtime_rate``:
    This value is passed to
    systems::Simulator::set_target_realtime_rate().)""";

        } Start;

        // drake::automotive::AutomotiveSimulator::StepBy
        struct /* StepBy */ {

          // drake/automotive/automotive_simulator.h:328
          const char* doc =
R"""(Advances simulated time by the given ``time_step`` increment in
seconds.)""";

        } StepBy;

        // drake::automotive::AutomotiveSimulator::get_builder
        struct /* get_builder */ {

          // drake/automotive/automotive_simulator.h:65
          const char* doc =
R"""(Returns the DiagramBuilder. @pre Start() has NOT been called.)""";

        } get_builder;

        // drake::automotive::AutomotiveSimulator::get_lcm
        struct /* get_lcm */ {

          // drake/automotive/automotive_simulator.h:61
          const char* doc =
R"""(Returns the LCM object used by this AutomotiveSimulator.)""";

        } get_lcm;

        // drake::automotive::AutomotiveSimulator::has_started
        struct /* has_started */ {

          // drake/automotive/automotive_simulator.h:325
          const char* doc =
R"""(Returns whether the automotive simulator has started.)""";

        } has_started;

      } AutomotiveSimulator;

      // drake::automotive::BicycleCar
      struct /* BicycleCar */ {

        // drake/automotive/bicycle_car.h:65
        const char* doc =
R"""(BicycleCar implements a nonlinear rigid body bicycle model from
Althoff & Dolan (2014) [1]. The three-DOF model captures the rigid-
body dynamics in the lateral, longitudinal, and yaw directions but not
in the roll and pitch directions. The model assumes a vehicle that has
two wheels: one at the front and one at the rear. It has been
demonstrated (e.g. [2]) that the representation reasonably
approximates the dynamics of a four-wheeled vehicle; hence the model
is useful as a simplified abstraction of car dynamics.

The states of the model are: - yaw angle Ψ [rad] - yaw rate Ψ_dot
[rad/s] - slip angle at the center of mass β [rad] - velocity
magnitude (vector magnitude at the slip angle) vel [m/s] - x-position
of the center of mass sx [m] - y-position of the center of mass sy [m]

N.B. "slip angle" (β) is the angle made between the body and the
velocity vector. Thus, the velocity vector can be resolved into the
body-relative componenets `vx_body = cos(β)` and `vy_body = sin(β)`.
`β = 0` means the velocity vector is pointing along the bicycle's
longitudinal axis.

Inputs: - Angle of the front wheel of the bicycle δ [rad] (InputPort
getter: get_steering_input_port()) - Force acting on the rigid body
F_in [N] (InputPort getter: get_force_input_port())

Output: - A BicycleCarState containing the 6-dimensional state vector
of the bicycle. (OutputPort getter: get_state_output_port())

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in libdrakeAutomotive.

[1] M. Althoff and J.M. Dolan, Online verification of automated road
vehicles using reachability analysis, IEEE Transactions on Robotics,
30(4), 2014, pp. 903-908. DOI: 10.1109/TRO.2014.2312453.

[2] M. Althoff and J. M. Dolan, Reachability computation of low-order
models for the safety verification of high-order road vehicle models,
in Proc. of the American Control Conference, 2012, pp. 3559–3566.)""";

        // drake::automotive::BicycleCar::BicycleCar<T>
        struct /* ctor */ {

          // drake/automotive/bicycle_car.h:67
          const char* doc = R"""()""";

          // drake/automotive/bicycle_car.h:67
          const char* doc_2 = R"""()""";

          // drake/automotive/bicycle_car.h:70
          const char* doc_3 = R"""(Default constructor.)""";

          // drake/automotive/bicycle_car.h:74
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::BicycleCar::get_force_input_port
        struct /* get_force_input_port */ {

          // drake/automotive/bicycle_car.h:82
          const char* doc =
R"""(Returns the input port that contains the applied powertrain force.)""";

        } get_force_input_port;

        // drake::automotive::BicycleCar::get_state_output_port
        struct /* get_state_output_port */ {

          // drake/automotive/bicycle_car.h:85
          const char* doc =
R"""(Returns the output port that contains the bicycle states.)""";

        } get_state_output_port;

        // drake::automotive::BicycleCar::get_steering_input_port
        struct /* get_steering_input_port */ {

          // drake/automotive/bicycle_car.h:79
          const char* doc =
R"""(Returns the input port that contains the steering angle.)""";

        } get_steering_input_port;

      } BicycleCar;

      // drake::automotive::BicycleCarParameters
      struct /* BicycleCarParameters */ {

        // drake/automotive/gen/bicycle_car_parameters.h:44
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::BicycleCarParameters::BicycleCarParameters<T>
        struct /* ctor */ {

          // drake/automotive/gen/bicycle_car_parameters.h:56
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``mass`` defaults to 2278.0 kg. @arg ``lf`` defaults to 1.292 m. @arg
``lr`` defaults to 1.515 m. @arg ``Iz`` defaults to 3210.0 kg m^2.
@arg ``Cf`` defaults to 10.8e4 N / rad. @arg ``Cr`` defaults to 10.8e4
N / rad.)""";

        } ctor;

        // drake::automotive::BicycleCarParameters::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/bicycle_car_parameters.h:141
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::BicycleCarParameters::Cf
        struct /* Cf */ {

          // drake/automotive/gen/bicycle_car_parameters.h:107
          const char* doc =
R"""(cornering stiffness (front)

Note:
    ``Cf`` is expressed in units of N / rad.

Note:
    ``Cf`` has a limited domain of [0.0, +Inf].)""";

        } Cf;

        // drake::automotive::BicycleCarParameters::Cr
        struct /* Cr */ {

          // drake/automotive/gen/bicycle_car_parameters.h:112
          const char* doc =
R"""(cornering stiffness (rear)

Note:
    ``Cr`` is expressed in units of N / rad.

Note:
    ``Cr`` has a limited domain of [0.0, +Inf].)""";

        } Cr;

        // drake::automotive::BicycleCarParameters::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/bicycle_car_parameters.h:78
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::BicycleCarParameters::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/bicycle_car_parameters.h:117
          const char* doc =
R"""(See BicycleCarParametersIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::BicycleCarParameters::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/bicycle_car_parameters.h:122
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::BicycleCarParameters::Iz
        struct /* Iz */ {

          // drake/automotive/gen/bicycle_car_parameters.h:102
          const char* doc =
R"""(moment of inertia about the yaw-axis

Note:
    ``Iz`` is expressed in units of kg m^2.

Note:
    ``Iz`` has a limited domain of [0.0, +Inf].)""";

        } Iz;

        // drake::automotive::BicycleCarParameters::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/bicycle_car_parameters.h:69
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::BicycleCarParameters::lf
        struct /* lf */ {

          // drake/automotive/gen/bicycle_car_parameters.h:92
          const char* doc =
R"""(distance from the center of mass to the front axle

Note:
    ``lf`` is expressed in units of m.

Note:
    ``lf`` has a limited domain of [0.0, +Inf].)""";

        } lf;

        // drake::automotive::BicycleCarParameters::lr
        struct /* lr */ {

          // drake/automotive/gen/bicycle_car_parameters.h:97
          const char* doc =
R"""(distance from the center of mass to the rear axle

Note:
    ``lr`` is expressed in units of m.

Note:
    ``lr`` has a limited domain of [0.0, +Inf].)""";

        } lr;

        // drake::automotive::BicycleCarParameters::mass
        struct /* mass */ {

          // drake/automotive/gen/bicycle_car_parameters.h:87
          const char* doc =
R"""(mass

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";

        } mass;

        // drake::automotive::BicycleCarParameters::set_Cf
        struct /* set_Cf */ {

          // drake/automotive/gen/bicycle_car_parameters.h:108
          const char* doc = R"""()""";

        } set_Cf;

        // drake::automotive::BicycleCarParameters::set_Cr
        struct /* set_Cr */ {

          // drake/automotive/gen/bicycle_car_parameters.h:113
          const char* doc = R"""()""";

        } set_Cr;

        // drake::automotive::BicycleCarParameters::set_Iz
        struct /* set_Iz */ {

          // drake/automotive/gen/bicycle_car_parameters.h:103
          const char* doc = R"""()""";

        } set_Iz;

        // drake::automotive::BicycleCarParameters::set_lf
        struct /* set_lf */ {

          // drake/automotive/gen/bicycle_car_parameters.h:93
          const char* doc = R"""()""";

        } set_lf;

        // drake::automotive::BicycleCarParameters::set_lr
        struct /* set_lr */ {

          // drake/automotive/gen/bicycle_car_parameters.h:98
          const char* doc = R"""()""";

        } set_lr;

        // drake::automotive::BicycleCarParameters::set_mass
        struct /* set_mass */ {

          // drake/automotive/gen/bicycle_car_parameters.h:88
          const char* doc = R"""()""";

        } set_mass;

      } BicycleCarParameters;

      // drake::automotive::BicycleCarParametersIndices
      struct /* BicycleCarParametersIndices */ {

        // drake/automotive/gen/bicycle_car_parameters.h:23
        const char* doc =
R"""(Describes the row indices of a BicycleCarParameters.)""";

        // drake::automotive::BicycleCarParametersIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/bicycle_car_parameters.h:39
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`BicycleCarParametersIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } BicycleCarParametersIndices;

      // drake::automotive::BicycleCarState
      struct /* BicycleCarState */ {

        // drake/automotive/gen/bicycle_car_state.h:44
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::BicycleCarState::BicycleCarState<T>
        struct /* ctor */ {

          // drake/automotive/gen/bicycle_car_state.h:56
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``Psi`` defaults to 0.0 with unknown units. @arg ``Psi_dot`` defaults
to 0.0 with unknown units. @arg ``beta`` defaults to 0.0 with unknown
units. @arg ``vel`` defaults to 0.0 with unknown units. @arg ``sx``
defaults to 0.0 with unknown units. @arg ``sy`` defaults to 0.0 with
unknown units.)""";

        } ctor;

        // drake::automotive::BicycleCarState::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/bicycle_car_state.h:78
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::BicycleCarState::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/bicycle_car_state.h:103
          const char* doc =
R"""(See BicycleCarStateIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::BicycleCarState::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/bicycle_car_state.h:108
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::BicycleCarState::Psi
        struct /* Psi */ {

          // drake/automotive/gen/bicycle_car_state.h:83
          const char* doc = R"""(yaw angle)""";

        } Psi;

        // drake::automotive::BicycleCarState::Psi_dot
        struct /* Psi_dot */ {

          // drake/automotive/gen/bicycle_car_state.h:86
          const char* doc = R"""(yaw angular rate)""";

        } Psi_dot;

        // drake::automotive::BicycleCarState::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/bicycle_car_state.h:69
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::BicycleCarState::beta
        struct /* beta */ {

          // drake/automotive/gen/bicycle_car_state.h:89
          const char* doc = R"""(slip angle at the center of mass)""";

        } beta;

        // drake::automotive::BicycleCarState::set_Psi
        struct /* set_Psi */ {

          // drake/automotive/gen/bicycle_car_state.h:84
          const char* doc = R"""()""";

        } set_Psi;

        // drake::automotive::BicycleCarState::set_Psi_dot
        struct /* set_Psi_dot */ {

          // drake/automotive/gen/bicycle_car_state.h:87
          const char* doc = R"""()""";

        } set_Psi_dot;

        // drake::automotive::BicycleCarState::set_beta
        struct /* set_beta */ {

          // drake/automotive/gen/bicycle_car_state.h:90
          const char* doc = R"""()""";

        } set_beta;

        // drake::automotive::BicycleCarState::set_sx
        struct /* set_sx */ {

          // drake/automotive/gen/bicycle_car_state.h:96
          const char* doc = R"""()""";

        } set_sx;

        // drake::automotive::BicycleCarState::set_sy
        struct /* set_sy */ {

          // drake/automotive/gen/bicycle_car_state.h:99
          const char* doc = R"""()""";

        } set_sy;

        // drake::automotive::BicycleCarState::set_vel
        struct /* set_vel */ {

          // drake/automotive/gen/bicycle_car_state.h:93
          const char* doc = R"""()""";

        } set_vel;

        // drake::automotive::BicycleCarState::sx
        struct /* sx */ {

          // drake/automotive/gen/bicycle_car_state.h:95
          const char* doc = R"""(x-position at the center of mass)""";

        } sx;

        // drake::automotive::BicycleCarState::sy
        struct /* sy */ {

          // drake/automotive/gen/bicycle_car_state.h:98
          const char* doc = R"""(y-position at the center of mass)""";

        } sy;

        // drake::automotive::BicycleCarState::vel
        struct /* vel */ {

          // drake/automotive/gen/bicycle_car_state.h:92
          const char* doc = R"""(velocity magnitude)""";

        } vel;

      } BicycleCarState;

      // drake::automotive::BicycleCarStateIndices
      struct /* BicycleCarStateIndices */ {

        // drake/automotive/gen/bicycle_car_state.h:23
        const char* doc =
R"""(Describes the row indices of a BicycleCarState.)""";

        // drake::automotive::BicycleCarStateIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/bicycle_car_state.h:39
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`BicycleCarStateIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } BicycleCarStateIndices;

      // drake::automotive::BicycleCarStateTranslator
      struct /* BicycleCarStateTranslator */ {

        // drake/automotive/gen/bicycle_car_state_translator.h:20
        const char* doc =
R"""(Translates between LCM message objects and VectorBase objects for the
BicycleCarState type.)""";

        // drake::automotive::BicycleCarStateTranslator::AllocateOutputVector
        struct /* AllocateOutputVector */ {

          // drake/automotive/gen/bicycle_car_state_translator.h:25
          const char* doc = R"""()""";

        } AllocateOutputVector;

        // drake::automotive::BicycleCarStateTranslator::BicycleCarStateTranslator
        struct /* ctor */ {

          // drake/automotive/gen/bicycle_car_state_translator.h:23
          const char* doc = R"""()""";

        } ctor;

        // drake::automotive::BicycleCarStateTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/automotive/gen/bicycle_car_state_translator.h:27
          const char* doc = R"""()""";

        } Deserialize;

        // drake::automotive::BicycleCarStateTranslator::Serialize
        struct /* Serialize */ {

          // drake/automotive/gen/bicycle_car_state_translator.h:29
          const char* doc = R"""()""";

        } Serialize;

      } BicycleCarStateTranslator;

      // drake::automotive::BoxCarVis
      struct /* BoxCarVis */ {

        // drake/automotive/box_car_vis.h:21
        const char* doc =
R"""(BoxCarVis displays a box as the visual representation of a vehicle.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::BoxCarVis::BoxCarVis<T>
        struct /* ctor */ {

          // drake/automotive/box_car_vis.h:23
          const char* doc = R"""()""";

        } ctor;

        // drake::automotive::BoxCarVis::CalcPoses
        struct /* CalcPoses */ {

          // drake/automotive/box_car_vis.h:27
          const char* doc = R"""()""";

        } CalcPoses;

        // drake::automotive::BoxCarVis::GetVisElements
        struct /* GetVisElements */ {

          // drake/automotive/box_car_vis.h:25
          const char* doc = R"""()""";

        } GetVisElements;

      } BoxCarVis;

      // drake::automotive::CalcOngoingRoadPosition
      struct /* CalcOngoingRoadPosition */ {

        // drake/automotive/calc_ongoing_road_position.h:28
        const char* doc =
R"""(Given a PoseVector ``pose``, find a car's current RoadGeometry via a
search of immediate ongoing lanes, starting with the current one. Uses
the provided FrameVelocity ``velocity`` to determine which side of the
lane (provided in ``rp``) to check. Updates ``rp`` with the result, if
one is found; otherwise updates ``rp`` using the result of a global
search of the ``road``.

Instantiated templates for the following scalar types `T` are
provided: - double - drake::AutoDiffXd

They are already available to link against in the containing library.)""";

      } CalcOngoingRoadPosition;

      // drake::automotive::CarVis
      struct /* CarVis */ {

        // drake/automotive/car_vis.h:21
        const char* doc =
R"""(CarVis is a base class that provides visualization geometries and
their poses.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::CarVis::CalcPoses
        struct /* CalcPoses */ {

          // drake/automotive/car_vis.h:46
          const char* doc =
R"""(Computes and returns the poses of the bodies that constitute the
vehicle's visualization. The provided `X_WM` is the pose of the
vehicle model in the world frame. The origin of the model's frame is
assumed to be in the middle of the vehicle's rear axle. The poses in
the returned PoseBundle are for the visualization's elements, and are
also in the world frame. The size of this bundle is the value returned
by num_poses().)""";

        } CalcPoses;

        // drake::automotive::CarVis::CarVis<T>
        struct /* ctor */ {

          // drake/automotive/car_vis.h:23
          const char* doc = R"""()""";

          // drake/automotive/car_vis.h:23
          const char* doc_2 = R"""()""";

          // drake/automotive/car_vis.h:33
          const char* doc_3 =
R"""(The constructor.

Parameter ``id``:
    The ID of the vehicle being visualized. This must be unique per
    vehicle in the same simulation.

Parameter ``name``:
    The name of the vehicle being visualized. This can be any user-
    defined value.)""";

        } ctor;

        // drake::automotive::CarVis::GetVisElements
        struct /* GetVisElements */ {

          // drake/automotive/car_vis.h:38
          const char* doc = R"""(Returns the visualization elements.)""";

        } GetVisElements;

        // drake::automotive::CarVis::id
        struct /* id */ {

          // drake/automotive/car_vis.h:50
          const char* doc =
R"""(Returns the ID that was supplied to the constructor.)""";

        } id;

        // drake::automotive::CarVis::name
        struct /* name */ {

          // drake/automotive/car_vis.h:53
          const char* doc =
R"""(Returns the name that was supplied to the constructor.)""";

        } name;

        // drake::automotive::CarVis::num_poses
        struct /* num_poses */ {

          // drake/automotive/car_vis.h:56
          const char* doc =
R"""(Returns the number of visualization geometry poses.)""";

        } num_poses;

      } CarVis;

      // drake::automotive::CarVisApplicator
      struct /* CarVisApplicator */ {

        // drake/automotive/car_vis_applicator.h:42
        const char* doc =
R"""(CarVisApplicator takes as input a PoseVector containing vehicle poses.
For each vehicle, it outputs the poses of all visual geometries
associated with the vehicle's visualization.

Prior to instantiating this system's systems::Context and
systems::SystemOutput, a CarVis object must be provided for each
vehicle in the simulation using AddCarVis().

This system is stateless and is direct feed-through.

Input port getters: - get_car_poses_input_port() - Contains a
PoseBundle of every vehicle's pose in the world frame (i.e., `X_WM_W`
where `W` stands for "world" and `M` stands for "Model"). The vehicle
IDs and names contained within this PoseBundle must match the IDs and
names contained within the CarVis objects that were supplied via calls
to AddCarVis().

Output port getters: - get_visual_geometry_poses_output_port() -
Contains a PoseBundle of visual geometry poses in the world frame.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::CarVisApplicator::AddCarVis
        struct /* AddCarVis */ {

          // drake/automotive/car_vis_applicator.h:63
          const char* doc =
R"""(Adds a CarVis object for a vehicle. The ID returned by CarVis::id()
must be unique among the CarVis objects added to this method. A
std::runtime_error is thrown if the provided CarVis object's ID is a
duplicate of a previously provided CarVis object's ID.

@pre The context for this system has not been created.)""";

        } AddCarVis;

        // drake::automotive::CarVisApplicator::CarVisApplicator<T>
        struct /* ctor */ {

          // drake/automotive/car_vis_applicator.h:44
          const char* doc = R"""()""";

          // drake/automotive/car_vis_applicator.h:44
          const char* doc_2 = R"""()""";

          // drake/automotive/car_vis_applicator.h:46
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::automotive::CarVisApplicator::get_car_poses_input_port
        struct /* get_car_poses_input_port */ {

          // drake/automotive/car_vis_applicator.h:51
          const char* doc =
R"""(Returns the input port that contains the vehicle poses in the form of
a PoseBundle.)""";

        } get_car_poses_input_port;

        // drake::automotive::CarVisApplicator::get_load_robot_message
        struct /* get_load_robot_message */ {

          // drake/automotive/car_vis_applicator.h:67
          const char* doc =
R"""(Returns an lcmt_viewer_load_robot message containing the geometries of
the bodies being visualized.)""";

        } get_load_robot_message;

        // drake::automotive::CarVisApplicator::get_visual_geometry_poses_output_port
        struct /* get_visual_geometry_poses_output_port */ {

          // drake/automotive/car_vis_applicator.h:55
          const char* doc =
R"""(Returns the output port that contains the visual geometry poses of all
vehicle visualizations.)""";

        } get_visual_geometry_poses_output_port;

        // drake::automotive::CarVisApplicator::num_cars
        struct /* num_cars */ {

          // drake/automotive/car_vis_applicator.h:70
          const char* doc =
R"""(Returns the number vehicles being visualized.)""";

        } num_cars;

        // drake::automotive::CarVisApplicator::num_vis_poses
        struct /* num_vis_poses */ {

          // drake/automotive/car_vis_applicator.h:73
          const char* doc =
R"""(Returns the total number of poses of bodies being visualized.)""";

        } num_vis_poses;

      } CarVisApplicator;

      // drake::automotive::ClosestPose
      struct /* ClosestPose */ {

        // drake/automotive/pose_selector.h:25
        const char* doc =
R"""(ClosestPose bundles together the RoadOdometry of a particular target
along with its distance measure relative to the ego vehicle. Its
intended use is as the return argument for PoseSelector member
functions.)""";

        // drake::automotive::ClosestPose::ClosestPose<T>
        struct /* ctor */ {

          // drake/automotive/pose_selector.h:28
          const char* doc = R"""(Default constructor.)""";

          // drake/automotive/pose_selector.h:31
          const char* doc_2 =
R"""(Constructs the ClosestPose via a full parameterization.)""";

        } ctor;

        // drake::automotive::ClosestPose::distance
        struct /* distance */ {

          // drake/automotive/pose_selector.h:35
          const char* doc = R"""()""";

        } distance;

        // drake::automotive::ClosestPose::odometry
        struct /* odometry */ {

          // drake/automotive/pose_selector.h:34
          const char* doc = R"""()""";

        } odometry;

      } ClosestPose;

      // drake::automotive::CreateTrajectoryParams
      struct /* CreateTrajectoryParams */ {

        // drake/automotive/create_trajectory_params.h:25
        const char* doc =
R"""(Creates TrajectoryCar constructor demo arguments. The details of the
trajectory are not documented / promised by this API.

Parameter ``index``:
    Selects which pre-programmed trajectory to use.

Returns:
    tuple of curve, speed, start_time)""";

      } CreateTrajectoryParams;

      // drake::automotive::CreateTrajectoryParamsForDragway
      struct /* CreateTrajectoryParamsForDragway */ {

        // drake/automotive/create_trajectory_params.h:41
        const char* doc =
R"""(Creates TrajectoryCar constructor demo arguments for a vehicle on a
dragway. The details of the trajectory are not documented / promised
by this API.

Parameter ``road_geometry``:
    The dragway upon which the TrajectoryCar will travel.

Parameter ``index``:
    The lane index within the provided `road_geometry`.

Parameter ``speed``:
    The speed of the vehicle.

Parameter ``start_time``:
    The time when the vehicle should start driving.

Returns:
    tuple of curve, speed, start_time)""";

      } CreateTrajectoryParamsForDragway;

      // drake::automotive::Curve2
      struct /* Curve2 */ {

        // drake/automotive/curve2.h:31
        const char* doc =
R"""(Curve2 represents a path through two-dimensional Cartesian space.
Given a list of waypoints, it traces a path between them.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd

They are already available to link against in the containing library.

TODO(jwnimmer-tri) We will soon trace the path using a spline, but for
now it's easiest to just interpolate straight segments, as a starting
point. Callers should not yet rely on *how* we are traversing between
the waypoints.)""";

        // drake::automotive::Curve2::Curve2<T>
        struct /* ctor */ {

          // drake/automotive/curve2.h:33
          const char* doc = R"""()""";

          // drake/automotive/curve2.h:33
          const char* doc_2 = R"""()""";

          // drake/automotive/curve2.h:41
          const char* doc_3 =
R"""(Constructor that traces through the given ``waypoints`` in order.
Throws an error if ``waypoints``.size() == 1.)""";

        } ctor;

        // drake::automotive::Curve2::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/automotive/curve2.h:33
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::automotive::Curve2::GetPosition
        struct /* GetPosition */ {

          // drake/automotive/curve2.h:75
          const char* doc =
R"""(Returns the Curve's ``PositionResult::position`` at ``path_distance``,
as well as its first derivative ``PositionResult::position_dot`` with
respect to ``path_distance``.

The ``path_distance`` is clipped to the ends of the curve: - A
negative ``path_distance`` is interpreted as a ``path_distance`` of
zero. - A ``path_distance`` that exceeds the ``path_length``() of the
curve is interpreted as a ``path_distance`` equal to the
``path_length``().

The ``position_dot`` derivative, when evaluated exactly at a waypoint,
will be congruent with the direction of one of the (max two) segments
that neighbor the waypoint. (At the first and last waypoints, there is
only one neighboring segment.) TODO(jwnimmer-tri) This will no longer
be true once this class uses a spline.)""";

        } GetPosition;

        // drake::automotive::Curve2::PositionResult
        struct /* PositionResult */ {

          // drake/automotive/curve2.h:55
          const char* doc =
R"""(A result type for the GetPosition method.)""";

          // drake::automotive::Curve2::PositionResult::position
          struct /* position */ {

            // drake/automotive/curve2.h:56
            const char* doc = R"""()""";

          } position;

          // drake::automotive::Curve2::PositionResult::position_dot
          struct /* position_dot */ {

            // drake/automotive/curve2.h:57
            const char* doc = R"""()""";

          } position_dot;

        } PositionResult;

        // drake::automotive::Curve2::path_length
        struct /* path_length */ {

          // drake/automotive/curve2.h:52
          const char* doc =
R"""(Returns:
    the length of this curve (the total distance traced).)""";

        } path_length;

        // drake::automotive::Curve2::waypoints
        struct /* waypoints */ {

          // drake/automotive/curve2.h:49
          const char* doc =
R"""(Returns:
    the waypoints associated with this curve.)""";

        } waypoints;

      } Curve2;

      // drake::automotive::DrivingCommand
      struct /* DrivingCommand */ {

        // drake/automotive/gen/driving_command.h:40
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::DrivingCommand::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/driving_command.h:62
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::DrivingCommand::DrivingCommand<T>
        struct /* ctor */ {

          // drake/automotive/gen/driving_command.h:48
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``steering_angle`` defaults to 0.0 rad. @arg ``acceleration`` defaults
to 0.0 m/s^2.)""";

        } ctor;

        // drake::automotive::DrivingCommand::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/driving_command.h:85
          const char* doc =
R"""(See DrivingCommandIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::DrivingCommand::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/driving_command.h:90
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::DrivingCommand::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/driving_command.h:57
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::DrivingCommand::acceleration
        struct /* acceleration */ {

          // drake/automotive/gen/driving_command.h:78
          const char* doc =
R"""(The signed acceleration, positive means speed up; negative means slow
down, but should not move in reverse.

Note:
    ``acceleration`` is expressed in units of m/s^2.)""";

        } acceleration;

        // drake::automotive::DrivingCommand::set_acceleration
        struct /* set_acceleration */ {

          // drake/automotive/gen/driving_command.h:79
          const char* doc = R"""()""";

        } set_acceleration;

        // drake::automotive::DrivingCommand::set_steering_angle
        struct /* set_steering_angle */ {

          // drake/automotive/gen/driving_command.h:72
          const char* doc = R"""()""";

        } set_steering_angle;

        // drake::automotive::DrivingCommand::steering_angle
        struct /* steering_angle */ {

          // drake/automotive/gen/driving_command.h:69
          const char* doc =
R"""(The desired steering angle of a virtual center wheel, positive results
in the vehicle turning left.

Note:
    ``steering_angle`` is expressed in units of rad.)""";

        } steering_angle;

      } DrivingCommand;

      // drake::automotive::DrivingCommandIndices
      struct /* DrivingCommandIndices */ {

        // drake/automotive/gen/driving_command.h:23
        const char* doc =
R"""(Describes the row indices of a DrivingCommand.)""";

        // drake::automotive::DrivingCommandIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/driving_command.h:35
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`DrivingCommandIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } DrivingCommandIndices;

      // drake::automotive::DrivingCommandMux
      struct /* DrivingCommandMux */ {

        // drake/automotive/driving_command_mux.h:32
        const char* doc =
R"""(A special-purpose multiplexer that packs two scalar inputs, steering
angle (in units rad) and acceleration (in units m/s^2), into a vector-
valued output of type DrivingCommand<T>, where the inputs feed
directly through to the output.

This class differs from systems::Multiplexer<T> constructed with a
DrivingCommand<T> model vector because a BasicVector (and notably any
of its subclasses) stored as T=double cannot yet be converted to
another type. See #8921.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following `T` values are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
Currently, no other values for `T` are supported.)""";

        // drake::automotive::DrivingCommandMux::DrivingCommandMux<T>
        struct /* ctor */ {

          // drake/automotive/driving_command_mux.h:34
          const char* doc = R"""()""";

          // drake/automotive/driving_command_mux.h:34
          const char* doc_2 = R"""()""";

          // drake/automotive/driving_command_mux.h:38
          const char* doc_3 =
R"""(Constructs a DrivingCommandMux with two scalar-valued input ports, and
one output port containing a DrivingCommand<T>.)""";

          // drake/automotive/driving_command_mux.h:42
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::DrivingCommandMux::acceleration_input
        struct /* acceleration_input */ {

          // drake/automotive/driving_command_mux.h:47
          const char* doc = R"""()""";

        } acceleration_input;

        // drake::automotive::DrivingCommandMux::steering_input
        struct /* steering_input */ {

          // drake/automotive/driving_command_mux.h:46
          const char* doc =
R"""(See the class description for details on the following input ports. @{)""";

        } steering_input;

      } DrivingCommandMux;

      // drake::automotive::DrivingCommandTranslator
      struct /* DrivingCommandTranslator */ {

        // drake/automotive/gen/driving_command_translator.h:20
        const char* doc =
R"""(Translates between LCM message objects and VectorBase objects for the
DrivingCommand type.)""";

        // drake::automotive::DrivingCommandTranslator::AllocateOutputVector
        struct /* AllocateOutputVector */ {

          // drake/automotive/gen/driving_command_translator.h:25
          const char* doc = R"""()""";

        } AllocateOutputVector;

        // drake::automotive::DrivingCommandTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/automotive/gen/driving_command_translator.h:27
          const char* doc = R"""()""";

        } Deserialize;

        // drake::automotive::DrivingCommandTranslator::DrivingCommandTranslator
        struct /* ctor */ {

          // drake/automotive/gen/driving_command_translator.h:23
          const char* doc = R"""()""";

        } ctor;

        // drake::automotive::DrivingCommandTranslator::Serialize
        struct /* Serialize */ {

          // drake/automotive/gen/driving_command_translator.h:29
          const char* doc = R"""()""";

        } Serialize;

      } DrivingCommandTranslator;

      // drake::automotive::DynamicBicycleCar
      struct /* DynamicBicycleCar */ {

        // drake/automotive/dynamic_bicycle_car.h:68
        const char* doc =
R"""(DynamicBicycleCar implements a planar rigid body bicycle model of an
automobile with a non-linear brush tire model from Bobier (2012) [1].
This is a simplified model that assumes a vehicle that has two wheels:
one at the front, and one at the rear. Also, this three-DOF model
captures the dynamics in the lateral (Cy), longitudinal (Cx), and yaw
(about Cz) directions but not the roll (about Cx) and pitch (about Cy)
directions.

There are three coordinate frames of interest in this model: a local
frame L fixed on earth with origin Lo, a frame attached to the
vehicle's chassis C with the origin of C being Co located at a
distance of Lf from the front axle along the center line of the
vehicle, and a steering frame D with the origin Do located at the
front axle along the center line of the vehicle. Note that the point
Co is also referred to as the control point Cp, and although the
location of the vehicle's center of mass Ccm can move depending on
weight transfer dynamics, it is assumed that the location of Ccm is
coincident with Co and Ccp. L is a cartesian, right handed coordinate
system with Lz being gravity aligned (gravity acts in the negative Lz
direction).

The states of the model are: - Lx measure of the location of Cp from
Lo `p_LoCp_x` [m] - Ly measure of the location of Cp from Lo
`p_LoCp_y` [m] - Yaw angle from Lx to Cx with positive Lz sense
`yaw_LC` [rad] - Cx measure of Cp's velocity in L `v_LCp_x` [m/s] - Cy
measure of Cp's velocity in L `v_LCp_y` [m/s] - C's angular velocity
in frame L `yawDt_LC` [rad/s]

Inputs to this system: - Steer angle from Cx to Dx with positive Cz
sense `steer_CD` [rad] - The Cx measure of the Longitudinal force on
body C at Cp `f_Cp_x` [N]

Outputs of this system: - A DynamicBicycleCarState containing the
6-dimensional state vector of the vehicle.

Note that the vehicle's angular velocity in L `yawDt_LC` is sometimes
referred to as the yaw rate `r`, and the tire angle is sometimes
referred to as δ.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

[1] C. Bobier. A Phase Portrait Approach to Vehicle Stability and
Envelope Control. Ph. D. thesis (Stanford University), 2012. pp. 22 -
25, pp. 35.

[2] H. Pacejka, Tire and vehicle dynamics, 3rd ed. Society of
Automotive Engineers and Butterworth-Heinemann, 2012.

[3] G. Heydinger, R. Bixel, W. Garrott, M. Pyne, J. Howe and D.
Guenther, "Measured Vehicle Inertial Parameters-NHTSA’s Data Through
November 1998", SAE Technical Paper Series, 1999. p. 24.)""";

        // drake::automotive::DynamicBicycleCar::CalcLateralTireForce
        struct /* CalcLateralTireForce */ {

          // drake/automotive/dynamic_bicycle_car.h:109
          const char* doc =
R"""(Lateral tire forces on the front or rear tires.)""";

        } CalcLateralTireForce;

        // drake::automotive::DynamicBicycleCar::CalcNormalTireForce
        struct /* CalcNormalTireForce */ {

          // drake/automotive/dynamic_bicycle_car.h:105
          const char* doc =
R"""(Normal forces on the front or rear tires.)""";

        } CalcNormalTireForce;

        // drake::automotive::DynamicBicycleCar::CalcTireSlip
        struct /* CalcTireSlip */ {

          // drake/automotive/dynamic_bicycle_car.h:100
          const char* doc = R"""(Slip angle of front or rear tires.)""";

        } CalcTireSlip;

        // drake::automotive::DynamicBicycleCar::DynamicBicycleCar<T>
        struct /* ctor */ {

          // drake/automotive/dynamic_bicycle_car.h:70
          const char* doc = R"""()""";

          // drake/automotive/dynamic_bicycle_car.h:70
          const char* doc_2 = R"""()""";

          // drake/automotive/dynamic_bicycle_car.h:73
          const char* doc_3 = R"""(Default constructor.)""";

          // drake/automotive/dynamic_bicycle_car.h:77
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::DynamicBicycleCar::Tire
        struct /* Tire */ {

          // drake/automotive/dynamic_bicycle_car.h:82
          const char* doc =
R"""(Specifies whether to use the front or rear tire for calculating
various parameters.)""";

          // drake::automotive::DynamicBicycleCar::Tire::kFrontTire
          struct /* kFrontTire */ {

            // drake/automotive/dynamic_bicycle_car.h:83
            const char* doc = R"""()""";

          } kFrontTire;

          // drake::automotive::DynamicBicycleCar::Tire::kRearTire
          struct /* kRearTire */ {

            // drake/automotive/dynamic_bicycle_car.h:84
            const char* doc = R"""()""";

          } kRearTire;

        } Tire;

        // drake::automotive::DynamicBicycleCar::get_input_port
        struct /* get_input_port */ {

          // drake/automotive/dynamic_bicycle_car.h:91
          const char* doc =
R"""(Returns the input port to the tire angle and applied longitudinal
force.)""";

        } get_input_port;

        // drake::automotive::DynamicBicycleCar::get_mutable_state
        struct /* get_mutable_state */ {

          // drake/automotive/dynamic_bicycle_car.h:96
          const char* doc = R"""()""";

        } get_mutable_state;

        // drake::automotive::DynamicBicycleCar::get_output_port
        struct /* get_output_port */ {

          // drake/automotive/dynamic_bicycle_car.h:88
          const char* doc = R"""(Returns the port to output the state.)""";

        } get_output_port;

        // drake::automotive::DynamicBicycleCar::get_state
        struct /* get_state */ {

          // drake/automotive/dynamic_bicycle_car.h:93
          const char* doc = R"""()""";

        } get_state;

      } DynamicBicycleCar;

      // drake::automotive::DynamicBicycleCarInput
      struct /* DynamicBicycleCarInput */ {

        // drake/automotive/gen/dynamic_bicycle_car_input.h:40
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::DynamicBicycleCarInput::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:63
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::DynamicBicycleCarInput::DynamicBicycleCarInput<T>
        struct /* ctor */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:48
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``steer_CD`` defaults to 0.0 rad. @arg ``f_Cp_x`` defaults to 0.0 N.)""";

        } ctor;

        // drake::automotive::DynamicBicycleCarInput::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:82
          const char* doc =
R"""(See DynamicBicycleCarInputIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::DynamicBicycleCarInput::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:87
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::DynamicBicycleCarInput::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:58
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::DynamicBicycleCarInput::f_Cp_x
        struct /* f_Cp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:77
          const char* doc =
R"""(The Cx measure of the Longitudinal force on body C at Cp.

Note:
    ``f_Cp_x`` is expressed in units of N.)""";

        } f_Cp_x;

        // drake::automotive::DynamicBicycleCarInput::set_f_Cp_x
        struct /* set_f_Cp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:78
          const char* doc = R"""()""";

        } set_f_Cp_x;

        // drake::automotive::DynamicBicycleCarInput::set_steer_CD
        struct /* set_steer_CD */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:72
          const char* doc = R"""()""";

        } set_steer_CD;

        // drake::automotive::DynamicBicycleCarInput::steer_CD
        struct /* steer_CD */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:71
          const char* doc =
R"""(Steer angle from Cx to Dx with positive Cz sense.

Note:
    ``steer_CD`` is expressed in units of rad.)""";

        } steer_CD;

      } DynamicBicycleCarInput;

      // drake::automotive::DynamicBicycleCarInputIndices
      struct /* DynamicBicycleCarInputIndices */ {

        // drake/automotive/gen/dynamic_bicycle_car_input.h:23
        const char* doc =
R"""(Describes the row indices of a DynamicBicycleCarInput.)""";

        // drake::automotive::DynamicBicycleCarInputIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_input.h:35
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`DynamicBicycleCarInputIndices::GetCoordinateNames()[i]` is the name
for `BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } DynamicBicycleCarInputIndices;

      // drake::automotive::DynamicBicycleCarParams
      struct /* DynamicBicycleCarParams */ {

        // drake/automotive/gen/dynamic_bicycle_car_params.h:47
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::DynamicBicycleCarParams::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:181
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::DynamicBicycleCarParams::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:91
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::DynamicBicycleCarParams::DynamicBicycleCarParams<T>
        struct /* ctor */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:62
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``mass`` defaults to 1823.0 kg. @arg ``izz`` defaults to 2000.0 kgm^2.
@arg ``c_alpha_f`` defaults to 115000 N/rad. @arg ``c_alpha_r``
defaults to 155000 N/rad. @arg ``mu`` defaults to 0.55 dimensionless.
@arg ``Lf`` defaults to 1.54 m. @arg ``Lb`` defaults to 1.21 m. @arg
``p_LoCp_z`` defaults to 0.508 m. @arg ``gravity`` defaults to 9.81
m/s^2.)""";

        } ctor;

        // drake::automotive::DynamicBicycleCarParams::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:151
          const char* doc =
R"""(See DynamicBicycleCarParamsIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::DynamicBicycleCarParams::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:156
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::DynamicBicycleCarParams::Lb
        struct /* Lb */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:134
          const char* doc =
R"""(Distance from rear axle to control point (referred to as 'b' in
Bobier).

Note:
    ``Lb`` is expressed in units of m.

Note:
    ``Lb`` has a limited domain of [0.0, +Inf].)""";

        } Lb;

        // drake::automotive::DynamicBicycleCarParams::Lf
        struct /* Lf */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:129
          const char* doc =
R"""(Distance from control point to front axle (referred to as 'a' in
Bobier).

Note:
    ``Lf`` is expressed in units of m.

Note:
    ``Lf`` has a limited domain of [0.0, +Inf].)""";

        } Lf;

        // drake::automotive::DynamicBicycleCarParams::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:79
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::DynamicBicycleCarParams::c_alpha_f
        struct /* c_alpha_f */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:110
          const char* doc =
R"""(Front cornering stiffness.

Note:
    ``c_alpha_f`` is expressed in units of N/rad.

Note:
    ``c_alpha_f`` has a limited domain of [0.0, +Inf].)""";

        } c_alpha_f;

        // drake::automotive::DynamicBicycleCarParams::c_alpha_r
        struct /* c_alpha_r */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:117
          const char* doc =
R"""(Rear cornering stiffness.

Note:
    ``c_alpha_r`` is expressed in units of N/rad.

Note:
    ``c_alpha_r`` has a limited domain of [0.0, +Inf].)""";

        } c_alpha_r;

        // drake::automotive::DynamicBicycleCarParams::gravity
        struct /* gravity */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:146
          const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";

        } gravity;

        // drake::automotive::DynamicBicycleCarParams::izz
        struct /* izz */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:105
          const char* doc =
R"""(moment of inertia.

Note:
    ``izz`` is expressed in units of kgm^2.

Note:
    ``izz`` has a limited domain of [0.0, +Inf].)""";

        } izz;

        // drake::automotive::DynamicBicycleCarParams::mass
        struct /* mass */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:100
          const char* doc =
R"""(Mass of X1 vehicle.

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";

        } mass;

        // drake::automotive::DynamicBicycleCarParams::mu
        struct /* mu */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:124
          const char* doc =
R"""(Coefficient of friction between tire and road surface.

Note:
    ``mu`` is expressed in units of dimensionless.

Note:
    ``mu`` has a limited domain of [0.0, +Inf].)""";

        } mu;

        // drake::automotive::DynamicBicycleCarParams::p_LoCp_z
        struct /* p_LoCp_z */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:139
          const char* doc =
R"""(Height of vehicle's control point Cp.

Note:
    ``p_LoCp_z`` is expressed in units of m.

Note:
    ``p_LoCp_z`` has a limited domain of [0.0, +Inf].)""";

        } p_LoCp_z;

        // drake::automotive::DynamicBicycleCarParams::set_Lb
        struct /* set_Lb */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:135
          const char* doc = R"""()""";

        } set_Lb;

        // drake::automotive::DynamicBicycleCarParams::set_Lf
        struct /* set_Lf */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:130
          const char* doc = R"""()""";

        } set_Lf;

        // drake::automotive::DynamicBicycleCarParams::set_c_alpha_f
        struct /* set_c_alpha_f */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:111
          const char* doc = R"""()""";

        } set_c_alpha_f;

        // drake::automotive::DynamicBicycleCarParams::set_c_alpha_r
        struct /* set_c_alpha_r */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:118
          const char* doc = R"""()""";

        } set_c_alpha_r;

        // drake::automotive::DynamicBicycleCarParams::set_gravity
        struct /* set_gravity */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:147
          const char* doc = R"""()""";

        } set_gravity;

        // drake::automotive::DynamicBicycleCarParams::set_izz
        struct /* set_izz */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:106
          const char* doc = R"""()""";

        } set_izz;

        // drake::automotive::DynamicBicycleCarParams::set_mass
        struct /* set_mass */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:101
          const char* doc = R"""()""";

        } set_mass;

        // drake::automotive::DynamicBicycleCarParams::set_mu
        struct /* set_mu */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:125
          const char* doc = R"""()""";

        } set_mu;

        // drake::automotive::DynamicBicycleCarParams::set_p_LoCp_z
        struct /* set_p_LoCp_z */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:140
          const char* doc = R"""()""";

        } set_p_LoCp_z;

      } DynamicBicycleCarParams;

      // drake::automotive::DynamicBicycleCarParamsIndices
      struct /* DynamicBicycleCarParamsIndices */ {

        // drake/automotive/gen/dynamic_bicycle_car_params.h:23
        const char* doc =
R"""(Describes the row indices of a DynamicBicycleCarParams.)""";

        // drake::automotive::DynamicBicycleCarParamsIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_params.h:42
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`DynamicBicycleCarParamsIndices::GetCoordinateNames()[i]` is the name
for `BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } DynamicBicycleCarParamsIndices;

      // drake::automotive::DynamicBicycleCarState
      struct /* DynamicBicycleCarState */ {

        // drake/automotive/gen/dynamic_bicycle_car_state.h:44
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::DynamicBicycleCarState::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:79
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::DynamicBicycleCarState::DynamicBicycleCarState<T>
        struct /* ctor */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:56
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``p_LoCp_x`` defaults to 0.0 m. @arg ``p_LoCp_y`` defaults to 0.0 m.
@arg ``yaw_LC`` defaults to 0.0 rad. @arg ``v_LCp_x`` defaults to 0.0
m/s. @arg ``v_LCp_y`` defaults to 0.0 m/s. @arg ``yawDt_LC`` defaults
to 0.0 rad/s.)""";

        } ctor;

        // drake::automotive::DynamicBicycleCarState::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:118
          const char* doc =
R"""(See DynamicBicycleCarStateIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::DynamicBicycleCarState::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:123
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::DynamicBicycleCarState::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:70
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::DynamicBicycleCarState::p_LoCp_x
        struct /* p_LoCp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:87
          const char* doc =
R"""(Lx measure of the location of Cp from Lo.

Note:
    ``p_LoCp_x`` is expressed in units of m.)""";

        } p_LoCp_x;

        // drake::automotive::DynamicBicycleCarState::p_LoCp_y
        struct /* p_LoCp_y */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:93
          const char* doc =
R"""(Ly measure of the location of Cp from Lo.

Note:
    ``p_LoCp_y`` is expressed in units of m.)""";

        } p_LoCp_y;

        // drake::automotive::DynamicBicycleCarState::set_p_LoCp_x
        struct /* set_p_LoCp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:88
          const char* doc = R"""()""";

        } set_p_LoCp_x;

        // drake::automotive::DynamicBicycleCarState::set_p_LoCp_y
        struct /* set_p_LoCp_y */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:94
          const char* doc = R"""()""";

        } set_p_LoCp_y;

        // drake::automotive::DynamicBicycleCarState::set_v_LCp_x
        struct /* set_v_LCp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:104
          const char* doc = R"""()""";

        } set_v_LCp_x;

        // drake::automotive::DynamicBicycleCarState::set_v_LCp_y
        struct /* set_v_LCp_y */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:108
          const char* doc = R"""()""";

        } set_v_LCp_y;

        // drake::automotive::DynamicBicycleCarState::set_yawDt_LC
        struct /* set_yawDt_LC */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:112
          const char* doc = R"""()""";

        } set_yawDt_LC;

        // drake::automotive::DynamicBicycleCarState::set_yaw_LC
        struct /* set_yaw_LC */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:100
          const char* doc = R"""()""";

        } set_yaw_LC;

        // drake::automotive::DynamicBicycleCarState::v_LCp_x
        struct /* v_LCp_x */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:103
          const char* doc =
R"""(Cx measure of Cp's velocity in L.

Note:
    ``v_LCp_x`` is expressed in units of m/s.)""";

        } v_LCp_x;

        // drake::automotive::DynamicBicycleCarState::v_LCp_y
        struct /* v_LCp_y */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:107
          const char* doc =
R"""(Cy measure of Cp's velocity in L.

Note:
    ``v_LCp_y`` is expressed in units of m/s.)""";

        } v_LCp_y;

        // drake::automotive::DynamicBicycleCarState::yawDt_LC
        struct /* yawDt_LC */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:111
          const char* doc =
R"""(C's angular velocity in frame L.

Note:
    ``yawDt_LC`` is expressed in units of rad/s.)""";

        } yawDt_LC;

        // drake::automotive::DynamicBicycleCarState::yaw_LC
        struct /* yaw_LC */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:99
          const char* doc =
R"""(Yaw angle from Lx to Cx with positive Lz sense.

Note:
    ``yaw_LC`` is expressed in units of rad.)""";

        } yaw_LC;

      } DynamicBicycleCarState;

      // drake::automotive::DynamicBicycleCarStateIndices
      struct /* DynamicBicycleCarStateIndices */ {

        // drake/automotive/gen/dynamic_bicycle_car_state.h:23
        const char* doc =
R"""(Describes the row indices of a DynamicBicycleCarState.)""";

        // drake::automotive::DynamicBicycleCarStateIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/dynamic_bicycle_car_state.h:39
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`DynamicBicycleCarStateIndices::GetCoordinateNames()[i]` is the name
for `BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } DynamicBicycleCarStateIndices;

      // drake::automotive::IdmController
      struct /* IdmController */ {

        // drake/automotive/idm_controller.h:54
        const char* doc =
R"""(IdmController implements the IDM (Intelligent Driver Model) planner,
computed based only on the nearest car ahead. See IdmPlanner and
PoseSelector for details. The output of this block is an acceleration
value passed as a command to the vehicle.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.

Input Port 0: PoseVector for the ego car. (InputPort getter:
ego_pose_input())

Input Port 1: FrameVelocity of the ego car. (InputPort getter:
ego_velocity_input())

Input Port 2: PoseBundle for the traffic cars, possibly inclusive of
the ego car's pose. (InputPort getter: traffic_input())

Output Port 0: A BasicVector containing the acceleration request.
(OutputPort getter: acceleration_output())

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::automotive::IdmController::DoCalcUnrestrictedUpdate
        struct /* DoCalcUnrestrictedUpdate */ {

          // drake/automotive/idm_controller.h:105
          const char* doc = R"""()""";

        } DoCalcUnrestrictedUpdate;

        // drake::automotive::IdmController::IdmController<T>
        struct /* ctor */ {

          // drake/automotive/idm_controller.h:56
          const char* doc = R"""()""";

          // drake/automotive/idm_controller.h:56
          const char* doc_2 = R"""()""";

          // drake/automotive/idm_controller.h:68
          const char* doc_3 =
R"""(Constructor.

Parameter ``road``:
    The pre-defined RoadGeometry.

Parameter ``path_or_branches``:
    If ScanStrategy::kBranches, performs IDM computations using
    vehicles detected in confluent branches; if ScanStrategy::kPath,
    limits to vehicles on the default path. See documentation for
    PoseSelector::FindSingleClosestPose().

Parameter ``road_position_strategy``:
    Determines whether or not to cache RoadPosition. See
    `calc_ongoing_road_position.h`.

Parameter ``period_sec``:
    The update period to use if road_position_strategy ==
    RoadPositionStrategy::kCache.)""";

          // drake/automotive/idm_controller.h:75
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::IdmController::ImplCalcAcceleration
        struct /* ImplCalcAcceleration */ {

          // drake/automotive/idm_controller.h:97
          const char* doc = R"""()""";

        } ImplCalcAcceleration;

        // drake::automotive::IdmController::acceleration_index
        struct /* acceleration_index */ {

          // drake/automotive/idm_controller.h:95
          const char* doc = R"""()""";

        } acceleration_index;

        // drake::automotive::IdmController::acceleration_output
        struct /* acceleration_output */ {

          // drake/automotive/idm_controller.h:87
          const char* doc = R"""()""";

        } acceleration_output;

        // drake::automotive::IdmController::ego_pose_index
        struct /* ego_pose_index */ {

          // drake/automotive/idm_controller.h:92
          const char* doc = R"""()""";

        } ego_pose_index;

        // drake::automotive::IdmController::ego_pose_input
        struct /* ego_pose_input */ {

          // drake/automotive/idm_controller.h:84
          const char* doc =
R"""(See the class description for details on the following input ports. @{)""";

        } ego_pose_input;

        // drake::automotive::IdmController::ego_velocity_index
        struct /* ego_velocity_index */ {

          // drake/automotive/idm_controller.h:93
          const char* doc = R"""()""";

        } ego_velocity_index;

        // drake::automotive::IdmController::ego_velocity_input
        struct /* ego_velocity_input */ {

          // drake/automotive/idm_controller.h:85
          const char* doc = R"""()""";

        } ego_velocity_input;

        // drake::automotive::IdmController::road
        struct /* road */ {

          // drake/automotive/idm_controller.h:91
          const char* doc = R"""(@})""";

        } road;

        // drake::automotive::IdmController::traffic_index
        struct /* traffic_index */ {

          // drake/automotive/idm_controller.h:94
          const char* doc = R"""()""";

        } traffic_index;

        // drake::automotive::IdmController::traffic_input
        struct /* traffic_input */ {

          // drake/automotive/idm_controller.h:86
          const char* doc = R"""()""";

        } traffic_input;

      } IdmController;

      // drake::automotive::IdmPlanner
      struct /* IdmPlanner */ {

        // drake/automotive/idm_planner.h:40
        const char* doc =
R"""(IdmPlanner implements the IDM (Intelligent Driver Model) equation
governing longitudinal accelerations of a vehicle in single-lane
traffic [1, 2]. It is derived based on qualitative observations of
actual driving behavior and captures objectives such as keeping a safe
distance behind a lead vehicle, maintaining a desired speed, and
accelerating and decelerating within comfortable limits.

The IDM equation produces accelerations that realize smooth
transitions between the following three modes: - Free-road behavior:
when the distance to the leading car is large, the IDM regulates
acceleration to match the desired speed `v_0`. - Fast-closing-speed
behavior: when the target distance decreases, an interaction term
compensates for the velocity difference, while keeping deceleration
comfortable according to parameter `b`. - Small-distance behavior:
within small net distances to the lead vehicle, comfort is ignored in
favor of increasing this distance to `s_0`.

See the corresponding .cc file for details about the IDM equation.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.

[1] Martin Treiber and Arne Kesting. Traffic Flow Dynamics, Data,
Models, and Simulation. Springer, 2013.

[2] https://en.wikipedia.org/wiki/Intelligent_driver_model.)""";

        // drake::automotive::IdmPlanner::Evaluate
        struct /* Evaluate */ {

          // drake/automotive/idm_planner.h:49
          const char* doc =
R"""(Evaluates the IDM equation for the chosen planner parameters
``params``, given the current velocity ``ego_velocity``, distance to
the lead car ``target_distance``, and the closing velocity
``target_distance_dot``. The returned value is a longitudinal
acceleration.)""";

        } Evaluate;

        // drake::automotive::IdmPlanner::IdmPlanner<T>
        struct /* ctor */ {

          // drake/automotive/idm_planner.h:42
          const char* doc = R"""()""";

          // drake/automotive/idm_planner.h:42
          const char* doc_2 = R"""()""";

          // drake/automotive/idm_planner.h:43
          const char* doc_3 = R"""()""";

        } ctor;

      } IdmPlanner;

      // drake::automotive::IdmPlannerParameters
      struct /* IdmPlannerParameters */ {

        // drake/automotive/gen/idm_planner_parameters.h:47
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::IdmPlannerParameters::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/idm_planner_parameters.h:190
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::IdmPlannerParameters::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/idm_planner_parameters.h:90
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::IdmPlannerParameters::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/idm_planner_parameters.h:160
          const char* doc =
R"""(See IdmPlannerParametersIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::IdmPlannerParameters::IdmPlannerParameters<T>
        struct /* ctor */ {

          // drake/automotive/gen/idm_planner_parameters.h:62
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``v_ref`` defaults to 10.0 m/s. @arg ``a`` defaults to 1.0 m/s^2. @arg
``b`` defaults to 3.0 m/s^2. @arg ``s_0`` defaults to 1.0 m. @arg
``time_headway`` defaults to 0.1 s. @arg ``delta`` defaults to 4.0
dimensionless. @arg ``bloat_diameter`` defaults to 4.5 m. @arg
``distance_lower_limit`` defaults to 1e-2 m. @arg
``scan_ahead_distance`` defaults to 100.0 m.)""";

        } ctor;

        // drake::automotive::IdmPlannerParameters::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/idm_planner_parameters.h:165
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::IdmPlannerParameters::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/idm_planner_parameters.h:78
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::IdmPlannerParameters::a
        struct /* a */ {

          // drake/automotive/gen/idm_planner_parameters.h:104
          const char* doc =
R"""(max acceleration

Note:
    ``a`` is expressed in units of m/s^2.

Note:
    ``a`` has a limited domain of [0.0, +Inf].)""";

        } a;

        // drake::automotive::IdmPlannerParameters::b
        struct /* b */ {

          // drake/automotive/gen/idm_planner_parameters.h:109
          const char* doc =
R"""(comfortable braking deceleration

Note:
    ``b`` is expressed in units of m/s^2.

Note:
    ``b`` has a limited domain of [0.0, +Inf].)""";

        } b;

        // drake::automotive::IdmPlannerParameters::bloat_diameter
        struct /* bloat_diameter */ {

          // drake/automotive/gen/idm_planner_parameters.h:132
          const char* doc =
R"""(diameter of circle about the vehicle's pose that encloses its physical
footprint

Note:
    ``bloat_diameter`` is expressed in units of m.

Note:
    ``bloat_diameter`` has a limited domain of [0.0, +Inf].)""";

        } bloat_diameter;

        // drake::automotive::IdmPlannerParameters::delta
        struct /* delta */ {

          // drake/automotive/gen/idm_planner_parameters.h:126
          const char* doc =
R"""(free-road exponent

Note:
    ``delta`` is expressed in units of dimensionless.

Note:
    ``delta`` has a limited domain of [0.0, +Inf].)""";

        } delta;

        // drake::automotive::IdmPlannerParameters::distance_lower_limit
        struct /* distance_lower_limit */ {

          // drake/automotive/gen/idm_planner_parameters.h:142
          const char* doc =
R"""(lower saturation bound on net distance to prevent near-singular IDM
solutions

Note:
    ``distance_lower_limit`` is expressed in units of m.

Note:
    ``distance_lower_limit`` has a limited domain of [0.0, +Inf].)""";

        } distance_lower_limit;

        // drake::automotive::IdmPlannerParameters::s_0
        struct /* s_0 */ {

          // drake/automotive/gen/idm_planner_parameters.h:114
          const char* doc =
R"""(minimum desired net distance

Note:
    ``s_0`` is expressed in units of m.

Note:
    ``s_0`` has a limited domain of [0.0, +Inf].)""";

        } s_0;

        // drake::automotive::IdmPlannerParameters::scan_ahead_distance
        struct /* scan_ahead_distance */ {

          // drake/automotive/gen/idm_planner_parameters.h:151
          const char* doc =
R"""(distance to scan ahead on road for a leading vehicle

Note:
    ``scan_ahead_distance`` is expressed in units of m.

Note:
    ``scan_ahead_distance`` has a limited domain of [0.0, +Inf].)""";

        } scan_ahead_distance;

        // drake::automotive::IdmPlannerParameters::set_a
        struct /* set_a */ {

          // drake/automotive/gen/idm_planner_parameters.h:105
          const char* doc = R"""()""";

        } set_a;

        // drake::automotive::IdmPlannerParameters::set_b
        struct /* set_b */ {

          // drake/automotive/gen/idm_planner_parameters.h:110
          const char* doc = R"""()""";

        } set_b;

        // drake::automotive::IdmPlannerParameters::set_bloat_diameter
        struct /* set_bloat_diameter */ {

          // drake/automotive/gen/idm_planner_parameters.h:135
          const char* doc = R"""()""";

        } set_bloat_diameter;

        // drake::automotive::IdmPlannerParameters::set_delta
        struct /* set_delta */ {

          // drake/automotive/gen/idm_planner_parameters.h:127
          const char* doc = R"""()""";

        } set_delta;

        // drake::automotive::IdmPlannerParameters::set_distance_lower_limit
        struct /* set_distance_lower_limit */ {

          // drake/automotive/gen/idm_planner_parameters.h:145
          const char* doc = R"""()""";

        } set_distance_lower_limit;

        // drake::automotive::IdmPlannerParameters::set_s_0
        struct /* set_s_0 */ {

          // drake/automotive/gen/idm_planner_parameters.h:115
          const char* doc = R"""()""";

        } set_s_0;

        // drake::automotive::IdmPlannerParameters::set_scan_ahead_distance
        struct /* set_scan_ahead_distance */ {

          // drake/automotive/gen/idm_planner_parameters.h:154
          const char* doc = R"""()""";

        } set_scan_ahead_distance;

        // drake::automotive::IdmPlannerParameters::set_time_headway
        struct /* set_time_headway */ {

          // drake/automotive/gen/idm_planner_parameters.h:120
          const char* doc = R"""()""";

        } set_time_headway;

        // drake::automotive::IdmPlannerParameters::set_v_ref
        struct /* set_v_ref */ {

          // drake/automotive/gen/idm_planner_parameters.h:100
          const char* doc = R"""()""";

        } set_v_ref;

        // drake::automotive::IdmPlannerParameters::time_headway
        struct /* time_headway */ {

          // drake/automotive/gen/idm_planner_parameters.h:119
          const char* doc =
R"""(desired time headway to vehicle in front

Note:
    ``time_headway`` is expressed in units of s.

Note:
    ``time_headway`` has a limited domain of [0.0, +Inf].)""";

        } time_headway;

        // drake::automotive::IdmPlannerParameters::v_ref
        struct /* v_ref */ {

          // drake/automotive/gen/idm_planner_parameters.h:99
          const char* doc =
R"""(desired velocity in free traffic

Note:
    ``v_ref`` is expressed in units of m/s.

Note:
    ``v_ref`` has a limited domain of [0.0, +Inf].)""";

        } v_ref;

      } IdmPlannerParameters;

      // drake::automotive::IdmPlannerParametersIndices
      struct /* IdmPlannerParametersIndices */ {

        // drake/automotive/gen/idm_planner_parameters.h:23
        const char* doc =
R"""(Describes the row indices of a IdmPlannerParameters.)""";

        // drake::automotive::IdmPlannerParametersIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/idm_planner_parameters.h:42
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`IdmPlannerParametersIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } IdmPlannerParametersIndices;

      // drake::automotive::LaneDirection
      struct /* LaneDirection */ {

        // drake/automotive/lane_direction.h:13
        const char* doc =
R"""(LaneDirection holds the lane that a MaliputRailcar is traversing and
the direction in which it is moving. A MaliputRailcar can either
travel in the increasing-`s` direction or in the decreasing-`s`
direction.)""";

        // drake::automotive::LaneDirection::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/automotive/lane_direction.h:14
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::automotive::LaneDirection::LaneDirection
        struct /* ctor */ {

          // drake/automotive/lane_direction.h:14
          const char* doc = R"""()""";

          // drake/automotive/lane_direction.h:14
          const char* doc_2 = R"""()""";

          // drake/automotive/lane_direction.h:17
          const char* doc_3 = R"""(Default constructor.)""";

          // drake/automotive/lane_direction.h:20
          const char* doc_4 =
R"""(A constructor that sets `with_s` to be `true`.)""";

          // drake/automotive/lane_direction.h:24
          const char* doc_5 = R"""(Fully parameterized constructor.)""";

        } ctor;

        // drake::automotive::LaneDirection::lane
        struct /* lane */ {

          // drake/automotive/lane_direction.h:27
          const char* doc = R"""()""";

        } lane;

        // drake::automotive::LaneDirection::with_s
        struct /* with_s */ {

          // drake/automotive/lane_direction.h:31
          const char* doc =
R"""(True means that the MaliputRailcar's `s` coordinate increases when the
vehicle has positive speed. False means the opposite.)""";

        } with_s;

      } LaneDirection;

      // drake::automotive::MaliputRailcar
      struct /* MaliputRailcar */ {

        // drake/automotive/maliput_railcar.h:63
        const char* doc =
R"""(MaliputRailcar models a vehicle that follows a maliput::api::Lane as
if it were on rails and neglecting all physics.

Parameters: * See MaliputRailcarParams.

State vector: * See MaliputRailcarState.

Abstract state: * See LaneDirection.

<B>Input Port Accessors:</B>

- command_input(): Contains the desired acceleration. This port
contains a systems::BasicVector of size 1. It is optional in that it
need not be connected. When it is unconnected, the railcar will travel
at its initial velocity, which is specified in MaliputRailcarParams.

<B>Output Port Accessors:</B>

- state_output(): Contains this system's state vector. See
MaliputRailcarState.

- lane_state_output(): Contains this system's lane direction state.
See LaneDirection.

- pose_output(): Contains PoseVector `X_WC`, where `C` is the car
frame and `W` is the world frame.

- velocity_output(): Contains FrameVelocity `V_WC_W`, where `C` is the
car frame and `W` is the world frame. Currently the rotational
component is always zero, see #5751.

Template parameter ``T``:
    must support certain arithmetic operations; for details, see
    drake::symbolic::Expression.

Instantiated templates for the following ScalarTypes are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::MaliputRailcar::MaliputRailcar<T>
        struct /* ctor */ {

          // drake/automotive/maliput_railcar.h:65
          const char* doc = R"""()""";

          // drake/automotive/maliput_railcar.h:65
          const char* doc_2 = R"""()""";

          // drake/automotive/maliput_railcar.h:95
          const char* doc_3 =
R"""(The constructor.

Parameter ``initial_lane_direction``:
    The initial lane and direction of travel.)""";

        } ctor;

        // drake::automotive::MaliputRailcar::command_input
        struct /* command_input */ {

          // drake/automotive/maliput_railcar.h:103
          const char* doc =
R"""(Getter methods for input and output ports. @{)""";

        } command_input;

        // drake::automotive::MaliputRailcar::get_mutable_parameters
        struct /* get_mutable_parameters */ {

          // drake/automotive/maliput_railcar.h:98
          const char* doc =
R"""(Returns a mutable reference to the parameters in the given
``context``.)""";

        } get_mutable_parameters;

        // drake::automotive::MaliputRailcar::lane_state_output
        struct /* lane_state_output */ {

          // drake/automotive/maliput_railcar.h:105
          const char* doc = R"""()""";

        } lane_state_output;

        // drake::automotive::MaliputRailcar::pose_output
        struct /* pose_output */ {

          // drake/automotive/maliput_railcar.h:106
          const char* doc = R"""()""";

        } pose_output;

        // drake::automotive::MaliputRailcar::state_output
        struct /* state_output */ {

          // drake/automotive/maliput_railcar.h:104
          const char* doc = R"""()""";

        } state_output;

        // drake::automotive::MaliputRailcar::velocity_output
        struct /* velocity_output */ {

          // drake/automotive/maliput_railcar.h:107
          const char* doc = R"""()""";

        } velocity_output;

      } MaliputRailcar;

      // drake::automotive::MaliputRailcarParams
      struct /* MaliputRailcarParams */ {

        // drake/automotive/gen/maliput_railcar_params.h:42
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::MaliputRailcarParams::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/maliput_railcar_params.h:70
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::MaliputRailcarParams::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/maliput_railcar_params.h:103
          const char* doc =
R"""(See MaliputRailcarParamsIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::MaliputRailcarParams::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/maliput_railcar_params.h:108
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::MaliputRailcarParams::MaliputRailcarParams<T>
        struct /* ctor */ {

          // drake/automotive/gen/maliput_railcar_params.h:52
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg ``r``
defaults to 0.0 m. @arg ``h`` defaults to 0.0 m. @arg ``max_speed``
defaults to 45.0 m/s. @arg ``velocity_limit_kp`` defaults to 10.0 Hz.)""";

        } ctor;

        // drake::automotive::MaliputRailcarParams::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/maliput_railcar_params.h:63
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::MaliputRailcarParams::h
        struct /* h */ {

          // drake/automotive/gen/maliput_railcar_params.h:82
          const char* doc =
R"""(The vehicle's height above the lane's surface.

Note:
    ``h`` is expressed in units of m.)""";

        } h;

        // drake::automotive::MaliputRailcarParams::max_speed
        struct /* max_speed */ {

          // drake/automotive/gen/maliput_railcar_params.h:87
          const char* doc =
R"""(The limit on the vehicle's forward speed, in meters per second; this
element must be positive.

Note:
    ``max_speed`` is expressed in units of m/s.)""";

        } max_speed;

        // drake::automotive::MaliputRailcarParams::r
        struct /* r */ {

          // drake/automotive/gen/maliput_railcar_params.h:78
          const char* doc =
R"""(The vehicle's position on the lane's r-axis.

Note:
    ``r`` is expressed in units of m.)""";

        } r;

        // drake::automotive::MaliputRailcarParams::set_h
        struct /* set_h */ {

          // drake/automotive/gen/maliput_railcar_params.h:83
          const char* doc = R"""()""";

        } set_h;

        // drake::automotive::MaliputRailcarParams::set_max_speed
        struct /* set_max_speed */ {

          // drake/automotive/gen/maliput_railcar_params.h:88
          const char* doc = R"""()""";

        } set_max_speed;

        // drake::automotive::MaliputRailcarParams::set_r
        struct /* set_r */ {

          // drake/automotive/gen/maliput_railcar_params.h:79
          const char* doc = R"""()""";

        } set_r;

        // drake::automotive::MaliputRailcarParams::set_velocity_limit_kp
        struct /* set_velocity_limit_kp */ {

          // drake/automotive/gen/maliput_railcar_params.h:97
          const char* doc = R"""()""";

        } set_velocity_limit_kp;

        // drake::automotive::MaliputRailcarParams::velocity_limit_kp
        struct /* velocity_limit_kp */ {

          // drake/automotive/gen/maliput_railcar_params.h:94
          const char* doc =
R"""(The smoothing constant for min/max velocity limits; this element must
be positive.

Note:
    ``velocity_limit_kp`` is expressed in units of Hz.)""";

        } velocity_limit_kp;

      } MaliputRailcarParams;

      // drake::automotive::MaliputRailcarParamsIndices
      struct /* MaliputRailcarParamsIndices */ {

        // drake/automotive/gen/maliput_railcar_params.h:23
        const char* doc =
R"""(Describes the row indices of a MaliputRailcarParams.)""";

        // drake::automotive::MaliputRailcarParamsIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/maliput_railcar_params.h:37
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`MaliputRailcarParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } MaliputRailcarParamsIndices;

      // drake::automotive::MaliputRailcarState
      struct /* MaliputRailcarState */ {

        // drake/automotive/gen/maliput_railcar_state.h:40
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::MaliputRailcarState::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/maliput_railcar_state.h:62
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::MaliputRailcarState::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/maliput_railcar_state.h:77
          const char* doc =
R"""(See MaliputRailcarStateIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::MaliputRailcarState::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/maliput_railcar_state.h:82
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::MaliputRailcarState::MaliputRailcarState<T>
        struct /* ctor */ {

          // drake/automotive/gen/maliput_railcar_state.h:48
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg ``s``
defaults to 0.0 with unknown units. @arg ``speed`` defaults to 0.0
with unknown units.)""";

        } ctor;

        // drake::automotive::MaliputRailcarState::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/maliput_railcar_state.h:57
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::MaliputRailcarState::s
        struct /* s */ {

          // drake/automotive/gen/maliput_railcar_state.h:69
          const char* doc =
R"""(The s-coordinate of the vehicle in a `Lane`-frame.)""";

        } s;

        // drake::automotive::MaliputRailcarState::set_s
        struct /* set_s */ {

          // drake/automotive/gen/maliput_railcar_state.h:70
          const char* doc = R"""()""";

        } set_s;

        // drake::automotive::MaliputRailcarState::set_speed
        struct /* set_speed */ {

          // drake/automotive/gen/maliput_railcar_state.h:73
          const char* doc = R"""()""";

        } set_speed;

        // drake::automotive::MaliputRailcarState::speed
        struct /* speed */ {

          // drake/automotive/gen/maliput_railcar_state.h:72
          const char* doc =
R"""(The speed of the vehicle in physical space.)""";

        } speed;

      } MaliputRailcarState;

      // drake::automotive::MaliputRailcarStateIndices
      struct /* MaliputRailcarStateIndices */ {

        // drake/automotive/gen/maliput_railcar_state.h:23
        const char* doc =
R"""(Describes the row indices of a MaliputRailcarState.)""";

        // drake::automotive::MaliputRailcarStateIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/maliput_railcar_state.h:35
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`MaliputRailcarStateIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } MaliputRailcarStateIndices;

      // drake::automotive::MaliputRailcarStateTranslator
      struct /* MaliputRailcarStateTranslator */ {

        // drake/automotive/gen/maliput_railcar_state_translator.h:20
        const char* doc =
R"""(Translates between LCM message objects and VectorBase objects for the
MaliputRailcarState type.)""";

        // drake::automotive::MaliputRailcarStateTranslator::AllocateOutputVector
        struct /* AllocateOutputVector */ {

          // drake/automotive/gen/maliput_railcar_state_translator.h:26
          const char* doc = R"""()""";

        } AllocateOutputVector;

        // drake::automotive::MaliputRailcarStateTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/automotive/gen/maliput_railcar_state_translator.h:28
          const char* doc = R"""()""";

        } Deserialize;

        // drake::automotive::MaliputRailcarStateTranslator::MaliputRailcarStateTranslator
        struct /* ctor */ {

          // drake/automotive/gen/maliput_railcar_state_translator.h:23
          const char* doc = R"""()""";

        } ctor;

        // drake::automotive::MaliputRailcarStateTranslator::Serialize
        struct /* Serialize */ {

          // drake/automotive/gen/maliput_railcar_state_translator.h:30
          const char* doc = R"""()""";

        } Serialize;

      } MaliputRailcarStateTranslator;

      // drake::automotive::MobilPlanner
      struct /* MobilPlanner */ {

        // drake/automotive/mobil_planner.h:85
        const char* doc =
R"""(MOBIL (Minimizing Overall Braking Induced by Lane Changes) [1] is a
planner that minimizes braking requirement for the ego car while also
minimizing (per a weighting factor) the braking requirements of any
trailing cars within the ego car's immediate neighborhood. The
weighting factor encapsulates the politeness of the ego car to the
surrounding traffic. Neighboring cars are defined as those cars
immediately ahead and behind the ego, in the current lane and any
adjacent lanes; these are determined from the PoseSelector logic
applied to a multi-lane Maliput road.

The induced braking by the ego car and the car following immediately
behind it is compared with the induced braking by the ego and its new
follower if the ego were to move to any of the neighboring lanes. The
choice that minimizes the induced braking - alternatively maximizes
the ego car's "incentive" (the weighted sum of accelerations that the
ego car and its neighbors gain by changing lanes) - is chosen as the
new lane request. The request is expressed as a LaneDirection, that
references a valid lane in the provided RoadGeometry and the direction
of travel.

Assumptions: 1) The planner supports only symmetric lane change rules,
without giving preference to lanes to the left or right. 2) The
planner assumes all traffic behaves according to the Intelligent
Driver Model (IDM). 3) All neighboring lanes are confluent (i.e.
with_s points in the same direction).

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.

Input Port 0: A PoseVector for the ego car. (InputPort getter:
ego_pose_input())

Input Port 1: A FrameVelocity for the ego car. (InputPort getter:
ego_velocity_input())

Input Port 2: A BasicVector containing the ego car's commanded
acceleration value intercepted from the vehicle's controller (e.g.
IdmController). (InputPort getter: ego_acceleration_input())

Input Port 3: A PoseBundle for the traffic cars, possibly including
the ego car's pose. (InputPort getter: traffic_input())

Output Port 0: A LaneDirection containing a lane that the ego vehicle
must move into and the direction of travel with respect to the lane's
canonical direction of travel. LaneDirection must be consistent with
the provided road. (OutputPort getter: lane_output())

[1] Arne Kesting, Martin Treiber and Dirk Helbing, MOBIL: General
Lane-Changing Model for Car-Following Models, Journal of the
Transportation Research Board, v1999, 2007, pp 86-94.
http://trrjournalonline.trb.org/doi/abs/10.3141/1999-10.)""";

        // drake::automotive::MobilPlanner::DoCalcUnrestrictedUpdate
        struct /* DoCalcUnrestrictedUpdate */ {

          // drake/automotive/mobil_planner.h:128
          const char* doc = R"""(@})""";

        } DoCalcUnrestrictedUpdate;

        // drake::automotive::MobilPlanner::MobilPlanner<T>
        struct /* ctor */ {

          // drake/automotive/mobil_planner.h:89
          const char* doc = R"""()""";

          // drake/automotive/mobil_planner.h:89
          const char* doc_2 = R"""()""";

          // drake/automotive/mobil_planner.h:99
          const char* doc_3 =
R"""(A constructor that initializes the MOBIL planner.

Parameter ``road``:
    The pre-defined RoadGeometry.

Parameter ``initial_with_s``:
    The initial direction of travel in the lane corresponding to the
    ego vehicle's initial state.

Parameter ``road_position_strategy``:
    Determines whether or not to memorize RoadPosition. See
    `calc_ongoing_road_position.h`.

Parameter ``period_sec``:
    The update period to use if road_position_strategy ==
    RoadPositionStrategy::kCache.)""";

        } ctor;

        // drake::automotive::MobilPlanner::ego_acceleration_input
        struct /* ego_acceleration_input */ {

          // drake/automotive/mobil_planner.h:107
          const char* doc = R"""()""";

        } ego_acceleration_input;

        // drake::automotive::MobilPlanner::ego_pose_input
        struct /* ego_pose_input */ {

          // drake/automotive/mobil_planner.h:105
          const char* doc =
R"""(See the class description for details on the following input ports. @{)""";

        } ego_pose_input;

        // drake::automotive::MobilPlanner::ego_velocity_input
        struct /* ego_velocity_input */ {

          // drake/automotive/mobil_planner.h:106
          const char* doc = R"""()""";

        } ego_velocity_input;

        // drake::automotive::MobilPlanner::get_mutable_idm_params
        struct /* get_mutable_idm_params */ {

          // drake/automotive/mobil_planner.h:115
          const char* doc =
R"""(Getters to mutable named-vector references associated with
MobilPlanner's Parameters groups. @{)""";

        } get_mutable_idm_params;

        // drake::automotive::MobilPlanner::get_mutable_mobil_params
        struct /* get_mutable_mobil_params */ {

          // drake/automotive/mobil_planner.h:120
          const char* doc = R"""()""";

        } get_mutable_mobil_params;

        // drake::automotive::MobilPlanner::lane_output
        struct /* lane_output */ {

          // drake/automotive/mobil_planner.h:109
          const char* doc = R"""()""";

        } lane_output;

        // drake::automotive::MobilPlanner::traffic_input
        struct /* traffic_input */ {

          // drake/automotive/mobil_planner.h:108
          const char* doc = R"""()""";

        } traffic_input;

      } MobilPlanner;

      // drake::automotive::MobilPlannerParameters
      struct /* MobilPlannerParameters */ {

        // drake/automotive/gen/mobil_planner_parameters.h:41
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::MobilPlannerParameters::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/mobil_planner_parameters.h:117
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::MobilPlannerParameters::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/mobil_planner_parameters.h:67
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::MobilPlannerParameters::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/mobil_planner_parameters.h:98
          const char* doc =
R"""(See MobilPlannerParametersIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::MobilPlannerParameters::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/mobil_planner_parameters.h:103
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::MobilPlannerParameters::MobilPlannerParameters<T>
        struct /* ctor */ {

          // drake/automotive/gen/mobil_planner_parameters.h:50
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg ``p``
defaults to 0.5 dimensionless. @arg ``threshold`` defaults to 0.1
m/s^2. @arg ``max_deceleration`` defaults to 4.0 m/s^2.)""";

        } ctor;

        // drake::automotive::MobilPlannerParameters::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/mobil_planner_parameters.h:61
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::MobilPlannerParameters::max_deceleration
        struct /* max_deceleration */ {

          // drake/automotive/gen/mobil_planner_parameters.h:89
          const char* doc =
R"""(maximum safe deceleration (b_safe)

Note:
    ``max_deceleration`` is expressed in units of m/s^2.

Note:
    ``max_deceleration`` has a limited domain of [0.0, +Inf].)""";

        } max_deceleration;

        // drake::automotive::MobilPlannerParameters::p
        struct /* p */ {

          // drake/automotive/gen/mobil_planner_parameters.h:77
          const char* doc =
R"""(politeness factor (0.0 is purely egoistic, higher values increase
politeness)

Note:
    ``p`` is expressed in units of dimensionless.

Note:
    ``p`` has a limited domain of [0.0, 1.0].)""";

        } p;

        // drake::automotive::MobilPlannerParameters::set_max_deceleration
        struct /* set_max_deceleration */ {

          // drake/automotive/gen/mobil_planner_parameters.h:92
          const char* doc = R"""()""";

        } set_max_deceleration;

        // drake::automotive::MobilPlannerParameters::set_p
        struct /* set_p */ {

          // drake/automotive/gen/mobil_planner_parameters.h:78
          const char* doc = R"""()""";

        } set_p;

        // drake::automotive::MobilPlannerParameters::set_threshold
        struct /* set_threshold */ {

          // drake/automotive/gen/mobil_planner_parameters.h:83
          const char* doc = R"""()""";

        } set_threshold;

        // drake::automotive::MobilPlannerParameters::threshold
        struct /* threshold */ {

          // drake/automotive/gen/mobil_planner_parameters.h:82
          const char* doc =
R"""(acceleration threshold for changing lanes (Delta_a_th)

Note:
    ``threshold`` is expressed in units of m/s^2.

Note:
    ``threshold`` has a limited domain of [0.0, +Inf].)""";

        } threshold;

      } MobilPlannerParameters;

      // drake::automotive::MobilPlannerParametersIndices
      struct /* MobilPlannerParametersIndices */ {

        // drake/automotive/gen/mobil_planner_parameters.h:23
        const char* doc =
R"""(Describes the row indices of a MobilPlannerParameters.)""";

        // drake::automotive::MobilPlannerParametersIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/mobil_planner_parameters.h:36
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`MobilPlannerParametersIndices::GetCoordinateNames()[i]` is the name
for `BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } MobilPlannerParametersIndices;

      // drake::automotive::MonolaneOnrampMerge
      struct /* MonolaneOnrampMerge */ {

        // drake/automotive/monolane_onramp_merge.h:52
        const char* doc =
R"""(MonolaneOnrampMerge contains an example lane-merge scenario expressed
as a maliput monolane road geometry. The intent of this class is to
enable easy creation and modification of road geometries for
simulating/analyzing such scenarios.

Implements the following onramp example, where each road section is
composed of sequences of linear and arc primitives:

```
pre-merge      post-merge
            road           road
       |------>-------+------>-------|
                     /
                    /
           onramp  /
                  ^
                  |
                  |
                  _
```)""";

        // drake::automotive::MonolaneOnrampMerge::BuildOnramp
        struct /* BuildOnramp */ {

          // drake/automotive/monolane_onramp_merge.h:64
          const char* doc = R"""(Implements the onramp example.)""";

        } BuildOnramp;

        // drake::automotive::MonolaneOnrampMerge::MonolaneOnrampMerge
        struct /* ctor */ {

          // drake/automotive/monolane_onramp_merge.h:54
          const char* doc = R"""()""";

          // drake/automotive/monolane_onramp_merge.h:54
          const char* doc_2 = R"""()""";

          // drake/automotive/monolane_onramp_merge.h:58
          const char* doc_3 =
R"""(Constructor for the example. The user supplies ``rc``, a
RoadCharacteristics structure that aggregates the road boundary data.)""";

          // drake/automotive/monolane_onramp_merge.h:61
          const char* doc_4 =
R"""(Constructor for the example, using default RoadCharacteristics
settings.)""";

        } ctor;

      } MonolaneOnrampMerge;

      // drake::automotive::MultilaneOnrampMerge
      struct /* MultilaneOnrampMerge */ {

        // drake/automotive/multilane_onramp_merge.h:78
        const char* doc =
R"""(MultilaneOnrampMerge contains an example lane-merge scenario expressed
as a maliput mulitilane road geometry. The intent of this class is to
enable easy creation and modification of road geometries for
simulating/analyzing such scenarios.

Implements the following onramp example, where each road section is
composed of sequences of linear and arc primitives:

```
pre-merge           post-merge
            road                 road
       |------>------------+------>-------|
       |------>------------+------>-------|
                          /+------>-------|
                         //
                        //
                       //   onramp
                      ^^
                      ||
                      ||
                      __
```

The number of lanes of each road depends on the properties the
MultilaneRoadCharacteristics. `post` roads will have the full number
of lanes. `pre` and `onramp` roads will have half plus one lanes (note
the integer division) and will be placed to the left and right sides
of `post` road respectively. When the full lane number is even, two
lanes from `pre` and `onramp` will overlap. Otherwise, only one lane
will overlap.

For the special case of a single lane, the output RoadGeometry will be
identical to a `monolane::RoadGeometry`.

Note that this factory sets some constants to the `multilane::Builder`
when creating the RoadGeometry. Linear and angular tolerances, the
scale length and the ComputationPolicy are set to appropriate values
to build this RoadGeometry.)""";

        // drake::automotive::MultilaneOnrampMerge::BuildOnramp
        struct /* BuildOnramp */ {

          // drake/automotive/multilane_onramp_merge.h:95
          const char* doc =
R"""(Returns:
    A std::unique_ptr<const maliput::api::RoadGeometry> with the
    onramp example.)""";

        } BuildOnramp;

        // drake::automotive::MultilaneOnrampMerge::MultilaneOnrampMerge
        struct /* ctor */ {

          // drake/automotive/multilane_onramp_merge.h:80
          const char* doc = R"""()""";

          // drake/automotive/multilane_onramp_merge.h:80
          const char* doc_2 = R"""()""";

          // drake/automotive/multilane_onramp_merge.h:85
          const char* doc_3 =
R"""(Constructor for the factory.

Parameter ``rc``:
    A structure that aggregates the road boundary data.)""";

          // drake/automotive/multilane_onramp_merge.h:90
          const char* doc_4 =
R"""(Constructor for the example, using default
MultilaneRoadCharacteristics settings.)""";

        } ctor;

      } MultilaneOnrampMerge;

      // drake::automotive::MultilaneRoadCharacteristics
      struct /* MultilaneRoadCharacteristics */ {

        // drake/automotive/multilane_onramp_merge.h:16
        const char* doc =
R"""(MultilaneRoadCharacteristics computes and stores characteristics of a
multilane road network; i.e. bounds on the lane width and shoulders
width. Default settings are taken if no others are specified.)""";

        // drake::automotive::MultilaneRoadCharacteristics::MultilaneRoadCharacteristics
        struct /* ctor */ {

          // drake/automotive/multilane_onramp_merge.h:18
          const char* doc =
R"""(Constructor for using default road geometries.)""";

          // drake/automotive/multilane_onramp_merge.h:26
          const char* doc_2 =
R"""(Constructor for custom road geometries.

Parameter ``lw``:
    Lane's width.

Parameter ``lshoulder``:
    The left shoulder width.

Parameter ``rshoulder``:
    The right shoulder width.

Parameter ``lnumber``:
    The number of lanes.)""";

        } ctor;

        // drake::automotive::MultilaneRoadCharacteristics::elevation_bounds
        struct /* elevation_bounds */ {

          // drake/automotive/multilane_onramp_merge.h:38
          const char* doc = R"""()""";

        } elevation_bounds;

        // drake::automotive::MultilaneRoadCharacteristics::lane_number
        struct /* lane_number */ {

          // drake/automotive/multilane_onramp_merge.h:36
          const char* doc = R"""()""";

        } lane_number;

        // drake::automotive::MultilaneRoadCharacteristics::lane_width
        struct /* lane_width */ {

          // drake/automotive/multilane_onramp_merge.h:33
          const char* doc = R"""()""";

        } lane_width;

        // drake::automotive::MultilaneRoadCharacteristics::left_shoulder
        struct /* left_shoulder */ {

          // drake/automotive/multilane_onramp_merge.h:34
          const char* doc = R"""()""";

        } left_shoulder;

        // drake::automotive::MultilaneRoadCharacteristics::right_shoulder
        struct /* right_shoulder */ {

          // drake/automotive/multilane_onramp_merge.h:35
          const char* doc = R"""()""";

        } right_shoulder;

      } MultilaneRoadCharacteristics;

      // drake::automotive::PoseSelector
      struct /* PoseSelector */ {

        // drake/automotive/pose_selector.h:65
        const char* doc =
R"""(PoseSelector is a class that provides the relevant pose or poses with
respect to a given ego vehicle driving within a given maliput road
geometry.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.

TODO(jadecastro): Enable AutoDiffXd support, and add unit tests.)""";

        // drake::automotive::PoseSelector::FindClosestPair
        struct /* FindClosestPair */ {

          // drake/automotive/pose_selector.h:114
          const char* doc =
R"""(Returns the leading and trailing vehicles in a given ``lane`` or
``road`` that are closest to an ego vehicle along its path, as
measured along the `s`-coordinate of the ego vehicle's lane. If
``path_or_branches`` is ScanStrategy::kPath, only poses in the same
path as the ego (ahead or behind) are tracked; if
ScanStrategy::kBranches, poses in lanes that eventually merge
(converge to the same branch point that is on the default path of
``lane``) are considered in addition to those along the ego car's
default path.

Users should take heed to the fact that ScanStrategy::kBranches does
_not_ assess the relationship between traffic and ego vehicle velocity
when selecting poses. Thus, cars within the same lane as the ego but
with negative net-velocity (approaching the ego car, from the ego's
point-of-view) could be ignored in favor of a car in a branch with
positive net-velocity.

The ego vehicle must be within the `driveable_bounds` of ``lane``
(i.e. the road is contiguous with ``lane`` along the `r`-direction).
This function is used, for instance, as logic for lane-change planners
(e.g. MOBIL). The ego car's pose (``ego_pose``) and the poses of the
traffic cars (``traffic_poses``) are provided. The parameter
``scan_distance`` determines the distance along the sequence of lanes
to scan before declaring that no traffic car is ahead (resp. behind)
the ego car.

Returns:
    A map of AheadOrBehind values to vehicle ClosestPoses (containing
    RoadOdometries and closest relative distances). Relative distances
    are always positive, and a distance of positive infinity is
    returned if no traffic cars are found. Note that when no vehicle
    is detected in front of (resp. behind) the ego vehicle, the
    respective RoadPosition within ClosestPoses will contain an
    `s`-value of positive (resp. negative) infinity. Any traffic poses
    that are redundant with `ego_pose` (i.e. have the same
    RoadPosition as the ego car and thus the same `s` and `r` value)
    are discarded. If no leading/trailing vehicles are seen within
    scan-distance of the ego car, `s`-positions are taken to be at
    infinite distances away from the ego car. Note also that traffic
    vehicles having exactly the same `s`-position as the ego vehicle
    but with different `r`-value or are directly perpendicular in a
    Lane::to_left(), Lane::to_right() lane are taken to be *behind*
    the ego vehicle. Note that this implementation is greatly
    simplified by considering poses as points (i.e. vehicle geometries
    are ignored).

The RoadGeometry from which ``lane`` is drawn is required to have
default branches set for all branches in the road network.)""";

        } FindClosestPair;

        // drake::automotive::PoseSelector::FindSingleClosestPose
        struct /* FindSingleClosestPose */ {

          // drake/automotive/pose_selector.h:133
          const char* doc =
R"""(Same as PoseSelector::FindClosestPair() except that it returns a
single ClosestPose for either the vehicle ahead
(AheadOrBehind::kAhead) or behind (AheadOrBehind::kBehind).

Cars in other lanes are only tracked if they are in confluent lanes to
a given branch point within the `scan_distance`; i.e. cars in two
side-by-side lanes that never enter a branch point will not be
selected. This assumes that the ego car has knowledge of the traffic
cars' default lane.

Note that when no car is detected in front of the ego car, the
returned RoadOdometry within ClosestPose will contain an `s`-value of
`std::numeric_limits<double>::infinity()`.)""";

        } FindSingleClosestPose;

        // drake::automotive::PoseSelector::GetSigmaVelocity
        struct /* GetSigmaVelocity */ {

          // drake/automotive/pose_selector.h:151
          const char* doc =
R"""(Extracts the vehicle's `s`-direction velocity based on its
RoadOdometry ``road_odometry`` in the Lane coordinate frame. Assumes
the road has zero elevation and superelevation. Throws if any element
of `road_odometry.pos` is not within the respective bounds of
`road_odometry.lane`.

N.B. This function currently only provides exact derivatives for
velocity in the `s` direction when the road is straight (no yaw angle
variations).)""";

        } GetSigmaVelocity;

        // drake::automotive::PoseSelector::PoseSelector<T>
        struct /* ctor */ {

          // drake/automotive/pose_selector.h:67
          const char* doc = R"""()""";

          // drake/automotive/pose_selector.h:67
          const char* doc_2 = R"""()""";

          // drake/automotive/pose_selector.h:69
          const char* doc_3 = R"""()""";

        } ctor;

      } PoseSelector;

      // drake::automotive::PoseVelocity
      struct /* PoseVelocity */ {

        // drake/automotive/trajectory.h:23
        const char* doc =
R"""(Wraps the raw data contained in a trajectory expressed in terms of
pose and velocity values. Represents a translational and rotational
transformation of a reference frame A with respect to world frame W,
expressed in x-y-z coordinates, and translational and rotational
velocities of frame A with respect to W.)""";

        // drake::automotive::PoseVelocity::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/automotive/trajectory.h:25
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::automotive::PoseVelocity::PoseVelocity
        struct /* ctor */ {

          // drake/automotive/trajectory.h:25
          const char* doc = R"""()""";

          // drake/automotive/trajectory.h:25
          const char* doc_2 = R"""()""";

          // drake/automotive/trajectory.h:29
          const char* doc_3 =
R"""(Default constructor. Sets rotation to an identity transform and all
translation and velocity components to zero.)""";

          // drake/automotive/trajectory.h:39
          const char* doc_4 =
R"""(Fully-parameterized constructor.

Parameter ``rotation``:
    the orientation R_WA of frame A with respect to the world frame W,
    and can be either normalized or unnormalized.

Parameter ``translation``:
    the x, y, z position p_WA of frame A measured from W's origin.

Parameter ``velocity``:
    the (rotational/translational) spatial velocity Xdot_WA of the
    frame A with respect to frame W.)""";

        } ctor;

        // drake::automotive::PoseVelocity::pose3
        struct /* pose3 */ {

          // drake/automotive/trajectory.h:53
          const char* doc =
R"""(Accesses the projection of the pose of frame A to the x-y components
of translation and the z-component of rotation.)""";

        } pose3;

        // drake::automotive::PoseVelocity::rotation
        struct /* rotation */ {

          // drake/automotive/trajectory.h:49
          const char* doc =
R"""(Accesses R_WA, the rotation component of the pose of A, expressed in
world-frame coordinates W.)""";

        } rotation;

        // drake::automotive::PoseVelocity::speed
        struct /* speed */ {

          // drake/automotive/trajectory.h:67
          const char* doc =
R"""(Gets the speed ‖pdot_WA‖₂, the 2-norm of the world-frame translational
velocities.)""";

        } speed;

        // drake::automotive::PoseVelocity::translation
        struct /* translation */ {

          // drake/automotive/trajectory.h:45
          const char* doc =
R"""(Accesses p_WA, the translation component of the pose of A, expressed
in world-frame coordinates W.)""";

        } translation;

        // drake::automotive::PoseVelocity::velocity
        struct /* velocity */ {

          // drake/automotive/trajectory.h:61
          const char* doc =
R"""(Accesses Xdot_WA, a SpatialVelocity of frame A, expressed in world-
frame coordinates W.)""";

        } velocity;

      } PoseVelocity;

      // drake::automotive::PriusVis
      struct /* PriusVis */ {

        // drake/automotive/prius_vis.h:28
        const char* doc =
R"""(PriusVis displays a visualization of a 2015 Toyota Prius. It relies on
`drake/automotive/models/prius/prius_with_lidar.sdf` and requires that
this SDF file only contain one model instance that is not connected to
the world (i.e., the root body of the SDF model must not be named
RigidBodyTreeConstants::kWorldName).

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::automotive::PriusVis::CalcPoses
        struct /* CalcPoses */ {

          // drake/automotive/prius_vis.h:40
          const char* doc = R"""()""";

        } CalcPoses;

        // drake::automotive::PriusVis::GetVisElements
        struct /* GetVisElements */ {

          // drake/automotive/prius_vis.h:38
          const char* doc = R"""()""";

        } GetVisElements;

        // drake::automotive::PriusVis::PriusVis<T>
        struct /* ctor */ {

          // drake/automotive/prius_vis.h:30
          const char* doc = R"""()""";

          // drake/automotive/prius_vis.h:30
          const char* doc_2 = R"""()""";

          // drake/automotive/prius_vis.h:36
          const char* doc_3 = R"""()""";

        } ctor;

      } PriusVis;

      // drake::automotive::PurePursuit
      struct /* PurePursuit */ {

        // drake/automotive/pure_pursuit.h:33
        const char* doc =
R"""(PurePursuit computes the required steering angle to achieve a goal
point on an continuous planar path. The path represents as the set of
`r = 0` positions along a Maliput lane, and a goal point is selected
as a pre-defined lookahead distance along the path in the intended
direction of travel. The algorithm outputs the steering angle required
to guide the vehicle toward the goal point based on its current
position in global coordinates.

See [1] and the corresponding .cc file for details on the algorithm.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.

[1] Coulter, R. Implementation of the Pure Pursuit Path Tracking
Algorithm. Carnegie Mellon University, Pittsburgh, Pennsylvania, Jan
1990.)""";

        // drake::automotive::PurePursuit::ComputeGoalPoint
        struct /* ComputeGoalPoint */ {

          // drake/automotive/pure_pursuit.h:59
          const char* doc =
R"""(Computes the goal point at a distance `s_lookahead` from the closest
position on the curve in the intended direction of travel, and
`with_s` and `pose` are the direction of travel and PoseVector for the
ego vehicle.)""";

        } ComputeGoalPoint;

        // drake::automotive::PurePursuit::Evaluate
        struct /* Evaluate */ {

          // drake/automotive/pure_pursuit.h:51
          const char* doc =
R"""(Evaluates the required steering angle in radians using the pure-
pursuit method. Assumes zero elevation and superelevation.

Parameter ``pp_params``:
    contains the `lookahead_distance`, the distance along the path
    based on the closest position on the path to the vehicle.

Parameter ``car_params``:
    contains the `wheelbase` of the vehicle.

Parameter ``lane_direction``:
    is a LaneDirection containing a reference lane and the direction
    of travel along the positive-s coordinate.

Parameter ``pose``:
    is the PoseVector for the ego vehicle.)""";

        } Evaluate;

        // drake::automotive::PurePursuit::PurePursuit<T>
        struct /* ctor */ {

          // drake/automotive/pure_pursuit.h:35
          const char* doc = R"""()""";

          // drake/automotive/pure_pursuit.h:35
          const char* doc_2 = R"""()""";

          // drake/automotive/pure_pursuit.h:36
          const char* doc_3 = R"""()""";

        } ctor;

      } PurePursuit;

      // drake::automotive::PurePursuitController
      struct /* PurePursuitController */ {

        // drake/automotive/pure_pursuit_controller.h:38
        const char* doc =
R"""(PurePursuitController implements a pure pursuit controller. See
PurePursuit for details on the approach.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.

Input Port 0: a LaneDirection representing the requested lane and
direction of travel. (InputPort getter: lane_input())

Input Port 1: PoseVector for the ego car. (InputPort getter:
ego_pose_input())

Output Port 0: A BasicVector of size one with the commanded steering
angle. (OutputPort getter: steering_command_output()))""";

        // drake::automotive::PurePursuitController::PurePursuitController<T>
        struct /* ctor */ {

          // drake/automotive/pure_pursuit_controller.h:40
          const char* doc = R"""()""";

          // drake/automotive/pure_pursuit_controller.h:40
          const char* doc_2 = R"""()""";

          // drake/automotive/pure_pursuit_controller.h:43
          const char* doc_3 = R"""(Constructor.)""";

          // drake/automotive/pure_pursuit_controller.h:47
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::PurePursuitController::ego_pose_input
        struct /* ego_pose_input */ {

          // drake/automotive/pure_pursuit_controller.h:54
          const char* doc = R"""()""";

        } ego_pose_input;

        // drake::automotive::PurePursuitController::lane_input
        struct /* lane_input */ {

          // drake/automotive/pure_pursuit_controller.h:53
          const char* doc =
R"""(Returns the port to the individual input/output ports.)""";

        } lane_input;

        // drake::automotive::PurePursuitController::steering_command_output
        struct /* steering_command_output */ {

          // drake/automotive/pure_pursuit_controller.h:55
          const char* doc = R"""()""";

        } steering_command_output;

      } PurePursuitController;

      // drake::automotive::PurePursuitParams
      struct /* PurePursuitParams */ {

        // drake/automotive/gen/pure_pursuit_params.h:39
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::PurePursuitParams::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/pure_pursuit_params.h:86
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::PurePursuitParams::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/pure_pursuit_params.h:58
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::PurePursuitParams::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/pure_pursuit_params.h:72
          const char* doc =
R"""(See PurePursuitParamsIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::PurePursuitParams::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/pure_pursuit_params.h:77
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::PurePursuitParams::PurePursuitParams<T>
        struct /* ctor */ {

          // drake/automotive/gen/pure_pursuit_params.h:46
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``s_lookahead`` defaults to 15.0 m.)""";

        } ctor;

        // drake::automotive::PurePursuitParams::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/pure_pursuit_params.h:54
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::PurePursuitParams::s_lookahead
        struct /* s_lookahead */ {

          // drake/automotive/gen/pure_pursuit_params.h:65
          const char* doc =
R"""(distance along the s-direction to place the reference point

Note:
    ``s_lookahead`` is expressed in units of m.

Note:
    ``s_lookahead`` has a limited domain of [0.0, +Inf].)""";

        } s_lookahead;

        // drake::automotive::PurePursuitParams::set_s_lookahead
        struct /* set_s_lookahead */ {

          // drake/automotive/gen/pure_pursuit_params.h:66
          const char* doc = R"""()""";

        } set_s_lookahead;

      } PurePursuitParams;

      // drake::automotive::PurePursuitParamsIndices
      struct /* PurePursuitParamsIndices */ {

        // drake/automotive/gen/pure_pursuit_params.h:23
        const char* doc =
R"""(Describes the row indices of a PurePursuitParams.)""";

        // drake::automotive::PurePursuitParamsIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/pure_pursuit_params.h:34
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`PurePursuitParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } PurePursuitParamsIndices;

      // drake::automotive::RoadCharacteristics
      struct /* RoadCharacteristics */ {

        // drake/automotive/monolane_onramp_merge.h:15
        const char* doc =
R"""(RoadCharacteristics computes and stores characteristics of a road
network; i.e. bounds on the lane width and driveable width. Default
settings are taken if no others are specified.)""";

        // drake::automotive::RoadCharacteristics::RoadCharacteristics
        struct /* ctor */ {

          // drake/automotive/monolane_onramp_merge.h:17
          const char* doc =
R"""(Constructor for using default road geometries.)""";

          // drake/automotive/monolane_onramp_merge.h:20
          const char* doc_2 = R"""(Constructor for custom road geometries.)""";

        } ctor;

        // drake::automotive::RoadCharacteristics::driveable_bounds
        struct /* driveable_bounds */ {

          // drake/automotive/monolane_onramp_merge.h:27
          const char* doc = R"""()""";

        } driveable_bounds;

        // drake::automotive::RoadCharacteristics::driveable_width
        struct /* driveable_width */ {

          // drake/automotive/monolane_onramp_merge.h:24
          const char* doc = R"""()""";

        } driveable_width;

        // drake::automotive::RoadCharacteristics::elevation_bounds
        struct /* elevation_bounds */ {

          // drake/automotive/monolane_onramp_merge.h:29
          const char* doc = R"""()""";

        } elevation_bounds;

        // drake::automotive::RoadCharacteristics::lane_bounds
        struct /* lane_bounds */ {

          // drake/automotive/monolane_onramp_merge.h:26
          const char* doc = R"""()""";

        } lane_bounds;

        // drake::automotive::RoadCharacteristics::lane_width
        struct /* lane_width */ {

          // drake/automotive/monolane_onramp_merge.h:23
          const char* doc = R"""()""";

        } lane_width;

      } RoadCharacteristics;

      // drake::automotive::RoadOdometry
      struct /* RoadOdometry */ {

        // drake/automotive/road_odometry.h:13
        const char* doc =
R"""(RoadOdometry contains the position of the vehicle with respect to a
lane in a road, along with its velocity vector in the world frame.)""";

        // drake::automotive::RoadOdometry::RoadOdometry<T>
        struct /* ctor */ {

          // drake/automotive/road_odometry.h:15
          const char* doc = R"""(Default constructor.)""";

          // drake/automotive/road_odometry.h:17
          const char* doc_2 = R"""(Fully-parameterized constructor.)""";

          // drake/automotive/road_odometry.h:21
          const char* doc_3 =
R"""(Fully-parameterized constructor that is T-supported.)""";

        } ctor;

        // drake::automotive::RoadOdometry::lane
        struct /* lane */ {

          // drake/automotive/road_odometry.h:26
          const char* doc = R"""()""";

        } lane;

        // drake::automotive::RoadOdometry::pos
        struct /* pos */ {

          // drake/automotive/road_odometry.h:27
          const char* doc = R"""()""";

        } pos;

        // drake::automotive::RoadOdometry::vel
        struct /* vel */ {

          // drake/automotive/road_odometry.h:28
          const char* doc = R"""()""";

        } vel;

      } RoadOdometry;

      // drake::automotive::RoadPath
      struct /* RoadPath */ {

        // drake/automotive/road_path.h:29
        const char* doc =
R"""(RoadPath converts a sequence of Maliput Lanes into a
PiecewisePolynomial for the purpose of generating a path for a car to
follow. The path is created from the start of a user-specified initial
lane and direction of travel, and proceeds in that direction until
either the end of the road is reached (there exist no ongoing lanes),
or the given number of specified breaks have been traversed. The
resulting path is a cubic spline that matches the `r = 0` coordinate
of the lanes at each specified break point. The resulting piecewise
curve is C2-continuous throughout with zero first and second
derivatives at the start and end of the path.

This class is explicitly instantiated for the following scalar types.
No other scalar types are supported. - double

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar. Only
    double is supported.)""";

        // drake::automotive::RoadPath::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/automotive/road_path.h:31
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::automotive::RoadPath::GetClosestPathPosition
        struct /* GetClosestPathPosition */ {

          // drake/automotive/road_path.h:50
          const char* doc =
R"""(Computes the closest `s`-position on the path to an arbitrary point in
the world frame of the provided Maliput Lanes. (Not yet implemented))""";

        } GetClosestPathPosition;

        // drake::automotive::RoadPath::RoadPath<T>
        struct /* ctor */ {

          // drake/automotive/road_path.h:31
          const char* doc = R"""()""";

          // drake/automotive/road_path.h:31
          const char* doc_2 = R"""()""";

          // drake/automotive/road_path.h:41
          const char* doc_3 =
R"""(Constructs a single RoadPath from a sequence of Maliput lanes based on
the following parameters:

Parameter ``initial_lane_direction``:
    contains the initial LaneDirection. This must be a valid ``road``
    Lane.

Parameter ``step_size``:
    is the size of each step (in the `s`-direction) between knot
    points.

Parameter ``num_breaks``:
    are the number of breaks at which the knot points will be
    evaluated.)""";

        } ctor;

        // drake::automotive::RoadPath::get_path
        struct /* get_path */ {

          // drake/automotive/road_path.h:45
          const char* doc = R"""()""";

        } get_path;

      } RoadPath;

      // drake::automotive::RoadPositionStrategy
      struct /* RoadPositionStrategy */ {

        // drake/automotive/pose_selector.h:52
        const char* doc =
R"""(If kCache, configures a planning system (e.g. IdmController,
MobilPlanner) to declare an abstract state that caches the last-
computed RoadPosition. If kExhaustiveSearch, then the system will
contain no abstract states. Note that the kCache option is for
performance speedup (at the expense of optimizer compatibility) by
preventing a potentially sizeable computation within
RoadGeometry::ToRoadPosition().)""";

        // drake::automotive::RoadPositionStrategy::kCache
        struct /* kCache */ {

          // drake/automotive/pose_selector.h:52
          const char* doc = R"""()""";

        } kCache;

        // drake::automotive::RoadPositionStrategy::kExhaustiveSearch
        struct /* kExhaustiveSearch */ {

          // drake/automotive/pose_selector.h:52
          const char* doc = R"""()""";

        } kExhaustiveSearch;

      } RoadPositionStrategy;

      // drake::automotive::ScanStrategy
      struct /* ScanStrategy */ {

        // drake/automotive/pose_selector.h:44
        const char* doc =
R"""(Specifies whether to check ongoing lanes or both ongoing lanes and
confluent branches for traffic.)""";

        // drake::automotive::ScanStrategy::kBranches
        struct /* kBranches */ {

          // drake/automotive/pose_selector.h:44
          const char* doc = R"""()""";

        } kBranches;

        // drake::automotive::ScanStrategy::kPath
        struct /* kPath */ {

          // drake/automotive/pose_selector.h:44
          const char* doc = R"""()""";

        } kPath;

      } ScanStrategy;

      // drake::automotive::SimpleCar
      struct /* SimpleCar */ {

        // drake/automotive/simple_car.h:52
        const char* doc =
R"""(* velocity

input vector: * steering angle (virtual center wheel angle); a
positive angle means a positive change in heading (left turn); the
value must lie within (-pi, +pi). * throttle (0-1) * brake (0-1)

output port 0: same as state vector. output port 1: A PoseVector
containing X_WC, where C is the car frame. output port 2: A
FrameVelocity containing Xdot_WC, where C is the car frame.

Template parameter ``T``:
    must support certain arithmetic operations; for details, see
    drake::symbolic::Expression.

Instantiated templates for the following ScalarTypes are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::automotive::SimpleCar::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/automotive/simple_car.h:63
          const char* doc = R"""()""";

        } DoCalcTimeDerivatives;

        // drake::automotive::SimpleCar::SimpleCar<T>
        struct /* ctor */ {

          // drake/automotive/simple_car.h:54
          const char* doc = R"""()""";

          // drake/automotive/simple_car.h:54
          const char* doc_2 = R"""()""";

          // drake/automotive/simple_car.h:56
          const char* doc_3 = R"""()""";

          // drake/automotive/simple_car.h:60
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::SimpleCar::pose_output
        struct /* pose_output */ {

          // drake/automotive/simple_car.h:68
          const char* doc = R"""()""";

        } pose_output;

        // drake::automotive::SimpleCar::state_output
        struct /* state_output */ {

          // drake/automotive/simple_car.h:67
          const char* doc = R"""()""";

        } state_output;

        // drake::automotive::SimpleCar::velocity_output
        struct /* velocity_output */ {

          // drake/automotive/simple_car.h:69
          const char* doc = R"""()""";

        } velocity_output;

      } SimpleCar;

      // drake::automotive::SimpleCarParams
      struct /* SimpleCarParams */ {

        // drake/automotive/gen/simple_car_params.h:44
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::SimpleCarParams::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/simple_car_params.h:158
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::SimpleCarParams::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/simple_car_params.h:79
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::SimpleCarParams::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/simple_car_params.h:134
          const char* doc =
R"""(See SimpleCarParamsIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::SimpleCarParams::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/simple_car_params.h:139
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::SimpleCarParams::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/simple_car_params.h:69
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::SimpleCarParams::SimpleCarParams<T>
        struct /* ctor */ {

          // drake/automotive/gen/simple_car_params.h:56
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``wheelbase`` defaults to 2.700 m. @arg ``track`` defaults to 1.521 m.
@arg ``max_abs_steering_angle`` defaults to 0.471 rad. @arg
``max_velocity`` defaults to 45.0 m/s. @arg ``max_acceleration``
defaults to 4.0 m/s^2. @arg ``velocity_limit_kp`` defaults to 10.0 Hz.)""";

        } ctor;

        // drake::automotive::SimpleCarParams::max_abs_steering_angle
        struct /* max_abs_steering_angle */ {

          // drake/automotive/gen/simple_car_params.h:100
          const char* doc =
R"""(The limit on the driving_command.steering angle input (the desired
steering angle of a virtual center wheel); this element is applied
symmetrically to both left- and right-turn limits.

Note:
    ``max_abs_steering_angle`` is expressed in units of rad.

Note:
    ``max_abs_steering_angle`` has a limited domain of [0.0, +Inf].)""";

        } max_abs_steering_angle;

        // drake::automotive::SimpleCarParams::max_acceleration
        struct /* max_acceleration */ {

          // drake/automotive/gen/simple_car_params.h:116
          const char* doc =
R"""(The limit on the car's acceleration and deceleration.

Note:
    ``max_acceleration`` is expressed in units of m/s^2.

Note:
    ``max_acceleration`` has a limited domain of [0.0, +Inf].)""";

        } max_acceleration;

        // drake::automotive::SimpleCarParams::max_velocity
        struct /* max_velocity */ {

          // drake/automotive/gen/simple_car_params.h:109
          const char* doc =
R"""(The limit on the car's forward speed.

Note:
    ``max_velocity`` is expressed in units of m/s.

Note:
    ``max_velocity`` has a limited domain of [0.0, +Inf].)""";

        } max_velocity;

        // drake::automotive::SimpleCarParams::set_max_abs_steering_angle
        struct /* set_max_abs_steering_angle */ {

          // drake/automotive/gen/simple_car_params.h:103
          const char* doc = R"""()""";

        } set_max_abs_steering_angle;

        // drake::automotive::SimpleCarParams::set_max_acceleration
        struct /* set_max_acceleration */ {

          // drake/automotive/gen/simple_car_params.h:119
          const char* doc = R"""()""";

        } set_max_acceleration;

        // drake::automotive::SimpleCarParams::set_max_velocity
        struct /* set_max_velocity */ {

          // drake/automotive/gen/simple_car_params.h:110
          const char* doc = R"""()""";

        } set_max_velocity;

        // drake::automotive::SimpleCarParams::set_track
        struct /* set_track */ {

          // drake/automotive/gen/simple_car_params.h:94
          const char* doc = R"""()""";

        } set_track;

        // drake::automotive::SimpleCarParams::set_velocity_limit_kp
        struct /* set_velocity_limit_kp */ {

          // drake/automotive/gen/simple_car_params.h:128
          const char* doc = R"""()""";

        } set_velocity_limit_kp;

        // drake::automotive::SimpleCarParams::set_wheelbase
        struct /* set_wheelbase */ {

          // drake/automotive/gen/simple_car_params.h:87
          const char* doc = R"""()""";

        } set_wheelbase;

        // drake::automotive::SimpleCarParams::track
        struct /* track */ {

          // drake/automotive/gen/simple_car_params.h:93
          const char* doc =
R"""(The distance between the center of two wheels on the same axle.

Note:
    ``track`` is expressed in units of m.

Note:
    ``track`` has a limited domain of [0.0, +Inf].)""";

        } track;

        // drake::automotive::SimpleCarParams::velocity_limit_kp
        struct /* velocity_limit_kp */ {

          // drake/automotive/gen/simple_car_params.h:125
          const char* doc =
R"""(The smoothing constant for min/max velocity limits.

Note:
    ``velocity_limit_kp`` is expressed in units of Hz.

Note:
    ``velocity_limit_kp`` has a limited domain of [0.0, +Inf].)""";

        } velocity_limit_kp;

        // drake::automotive::SimpleCarParams::wheelbase
        struct /* wheelbase */ {

          // drake/automotive/gen/simple_car_params.h:86
          const char* doc =
R"""(The distance between the front and rear axles of the vehicle.

Note:
    ``wheelbase`` is expressed in units of m.

Note:
    ``wheelbase`` has a limited domain of [0.0, +Inf].)""";

        } wheelbase;

      } SimpleCarParams;

      // drake::automotive::SimpleCarParamsIndices
      struct /* SimpleCarParamsIndices */ {

        // drake/automotive/gen/simple_car_params.h:23
        const char* doc =
R"""(Describes the row indices of a SimpleCarParams.)""";

        // drake::automotive::SimpleCarParamsIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/simple_car_params.h:39
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`SimpleCarParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } SimpleCarParamsIndices;

      // drake::automotive::SimpleCarState
      struct /* SimpleCarState */ {

        // drake/automotive/gen/simple_car_state.h:42
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::SimpleCarState::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/simple_car_state.h:70
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::SimpleCarState::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/simple_car_state.h:91
          const char* doc =
R"""(See SimpleCarStateIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::SimpleCarState::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/simple_car_state.h:96
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::SimpleCarState::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/simple_car_state.h:63
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::SimpleCarState::SimpleCarState<T>
        struct /* ctor */ {

          // drake/automotive/gen/simple_car_state.h:52
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg ``x``
defaults to 0.0 with unknown units. @arg ``y`` defaults to 0.0 with
unknown units. @arg ``heading`` defaults to 0.0 with unknown units.
@arg ``velocity`` defaults to 0.0 with unknown units.)""";

        } ctor;

        // drake::automotive::SimpleCarState::heading
        struct /* heading */ {

          // drake/automotive/gen/simple_car_state.h:81
          const char* doc = R"""(heading)""";

        } heading;

        // drake::automotive::SimpleCarState::set_heading
        struct /* set_heading */ {

          // drake/automotive/gen/simple_car_state.h:82
          const char* doc = R"""()""";

        } set_heading;

        // drake::automotive::SimpleCarState::set_velocity
        struct /* set_velocity */ {

          // drake/automotive/gen/simple_car_state.h:85
          const char* doc = R"""()""";

        } set_velocity;

        // drake::automotive::SimpleCarState::set_x
        struct /* set_x */ {

          // drake/automotive/gen/simple_car_state.h:76
          const char* doc = R"""()""";

        } set_x;

        // drake::automotive::SimpleCarState::set_y
        struct /* set_y */ {

          // drake/automotive/gen/simple_car_state.h:79
          const char* doc = R"""()""";

        } set_y;

        // drake::automotive::SimpleCarState::velocity
        struct /* velocity */ {

          // drake/automotive/gen/simple_car_state.h:84
          const char* doc = R"""(velocity)""";

        } velocity;

        // drake::automotive::SimpleCarState::x
        struct /* x */ {

          // drake/automotive/gen/simple_car_state.h:75
          const char* doc = R"""(x)""";

        } x;

        // drake::automotive::SimpleCarState::y
        struct /* y */ {

          // drake/automotive/gen/simple_car_state.h:78
          const char* doc = R"""(y)""";

        } y;

      } SimpleCarState;

      // drake::automotive::SimpleCarStateIndices
      struct /* SimpleCarStateIndices */ {

        // drake/automotive/gen/simple_car_state.h:23
        const char* doc =
R"""(Describes the row indices of a SimpleCarState.)""";

        // drake::automotive::SimpleCarStateIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/simple_car_state.h:37
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`SimpleCarStateIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } SimpleCarStateIndices;

      // drake::automotive::SimpleCarStateTranslator
      struct /* SimpleCarStateTranslator */ {

        // drake/automotive/gen/simple_car_state_translator.h:20
        const char* doc =
R"""(Translates between LCM message objects and VectorBase objects for the
SimpleCarState type.)""";

        // drake::automotive::SimpleCarStateTranslator::AllocateOutputVector
        struct /* AllocateOutputVector */ {

          // drake/automotive/gen/simple_car_state_translator.h:25
          const char* doc = R"""()""";

        } AllocateOutputVector;

        // drake::automotive::SimpleCarStateTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/automotive/gen/simple_car_state_translator.h:27
          const char* doc = R"""()""";

        } Deserialize;

        // drake::automotive::SimpleCarStateTranslator::Serialize
        struct /* Serialize */ {

          // drake/automotive/gen/simple_car_state_translator.h:29
          const char* doc = R"""()""";

        } Serialize;

        // drake::automotive::SimpleCarStateTranslator::SimpleCarStateTranslator
        struct /* ctor */ {

          // drake/automotive/gen/simple_car_state_translator.h:23
          const char* doc = R"""()""";

        } ctor;

      } SimpleCarStateTranslator;

      // drake::automotive::SimplePowertrain
      struct /* SimplePowertrain */ {

        // drake/automotive/simple_powertrain.h:30
        const char* doc =
R"""(SimplePowertrain models a powertrain with first-order lag. It accepts
throttle as the input and outputs the applied lumped force from the
vehicle to the road.

Input: - A unitless scalar value representing the throttle input to
the power system.

Output: - The force transmitted from the vehicle to the road [N].

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::automotive::SimplePowertrain::SimplePowertrain<T>
        struct /* ctor */ {

          // drake/automotive/simple_powertrain.h:32
          const char* doc = R"""()""";

          // drake/automotive/simple_powertrain.h:32
          const char* doc_2 = R"""()""";

          // drake/automotive/simple_powertrain.h:38
          const char* doc_3 =
R"""(Constructs a simple powertrain model, specified via a fixed time-
constant and scalar gain. The inputs are as follows:

Parameter ``time_constant``:
    is the rise time of the first-order lag [s].

Parameter ``gain``:
    is the gain converting throttle input to force output [N].)""";

          // drake/automotive/simple_powertrain.h:51
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::SimplePowertrain::get_force_output_port
        struct /* get_force_output_port */ {

          // drake/automotive/simple_powertrain.h:60
          const char* doc = R"""()""";

        } get_force_output_port;

        // drake::automotive::SimplePowertrain::get_gain
        struct /* get_gain */ {

          // drake/automotive/simple_powertrain.h:67
          const char* doc = R"""()""";

        } get_gain;

        // drake::automotive::SimplePowertrain::get_throttle_input_port
        struct /* get_throttle_input_port */ {

          // drake/automotive/simple_powertrain.h:56
          const char* doc = R"""()""";

        } get_throttle_input_port;

        // drake::automotive::SimplePowertrain::get_time_constant
        struct /* get_time_constant */ {

          // drake/automotive/simple_powertrain.h:66
          const char* doc = R"""(Accessors for the system constants. @{)""";

        } get_time_constant;

      } SimplePowertrain;

      // drake::automotive::Trajectory
      struct /* Trajectory */ {

        // drake/automotive/trajectory.h:85
        const char* doc =
R"""(A class that wraps a piecewise trajectory instantiated from pose data.
The underlying pose data is represented internally as a configurable
PiecewisePolynomial for translation and a PiecewiseQuaternionSlerp for
the rotation. The rotational/translational velocity of the pose is
then computed from time-differentiation of the PiecewisePolynomial and
an angular velocity conversion within PiecewiseQuaternionSlerp (see
piecewise_polynomial.h and piecewise_quaternion.h for details). A
PoseVelocity instance is therefore well-defined when evaluated at a
given time and, additionally, the translaton and rotation components
of PoseVector match the input pose data exactly.)""";

        // drake::automotive::Trajectory::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/automotive/trajectory.h:87
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::automotive::Trajectory::InterpolationType
        struct /* InterpolationType */ {

          // drake/automotive/trajectory.h:93
          const char* doc =
R"""(An identifier for the type of valid types of interpolation used in
evaluating the translational component of a Trajectory. These types
mirror the associated constructors for PiecewisePolynomial (see
common/trajectories/piecewise_polynomial.h for further details).)""";

          // drake::automotive::Trajectory::InterpolationType::kCubic
          struct /* kCubic */ {

            // drake/automotive/trajectory.h:93
            const char* doc = R"""()""";

          } kCubic;

          // drake::automotive::Trajectory::InterpolationType::kFirstOrderHold
          struct /* kFirstOrderHold */ {

            // drake/automotive/trajectory.h:93
            const char* doc = R"""()""";

          } kFirstOrderHold;

          // drake::automotive::Trajectory::InterpolationType::kPchip
          struct /* kPchip */ {

            // drake/automotive/trajectory.h:93
            const char* doc = R"""()""";

          } kPchip;

        } InterpolationType;

        // drake::automotive::Trajectory::Make
        struct /* Make */ {

          // drake/automotive/trajectory.h:112
          const char* doc =
R"""(Makes a Trajectory from a discrete set of time-indexed pose data under
the specified interpolation scheme.

Parameter ``times``:
    a vector of time indices representing the break points of the
    trajectory.

Parameter ``knots_rotation``:
    a vector of time-indexed rotation data, whose length must match
    that of ``times``.

Parameter ``knots_translation``:
    a vector of time-indexed translation data, whose length must match
    that of ``times``.

Parameter ``interp_type``:
    an InterpolationType with the interpolation scheme used for
    building a piecewise polynomial trajectory for the translational
    component. @default InterpolationType::kFirstOrderHold.

Throws:
    s std::logic_error if ``interp_type`` is not supported.

Throws:
    s std::runtime_error if `times` and `knots` have different
    lengths, `times` is not strictly increasing, and the inputs are
    otherwise inconsistent with the given `interp_type` (see
    piecewise_polynomial.h).)""";

        } Make;

        // drake::automotive::Trajectory::MakeCubicFromWaypoints
        struct /* MakeCubicFromWaypoints */ {

          // drake/automotive/trajectory.h:145
          const char* doc =
R"""(Makes a Trajectory from a discrete set of (time-independent) waypoints
and a vector of speeds. The resulting trajectory is assumed to start
at time time t = 0 and follow a cubic-spline profile
(InterpolationType::kCubic) for the translation elements, rendering
speed as a piecewise-quadratic function. For now, we determine the
break points (time vector) from the time required to travel a
Euclidean distance between consecutive waypoints at the average speed
between each. We apply this "average-speed" approach in order not to
impose assumptions about the accelerations at the knot points.
Velocities at each break point are computed by taking into account
both the translation and rotation of A with respect to W.

Parameter ``waypoints_rotation``:
    a vector of rotations, whose length must match that of ``speeds``.

Parameter ``waypoints_translation``:
    a vector of translations, whose length must match that of
    ``speeds``.

Parameter ``speeds``:
    a vector of speeds to be applied at knot points and linearly
    interpolated between waypoints. All entries of ``speeds`` must be
    non-negative, with some zero entries allowed, so long as they are
    not consecutive.

Throws:
    s RuntimeError if `waypoints_*` and `speeds` have different
    lengths, any are empty, or if any element of `speeds` violates any
    of the conditions enumerated above.)""";

          // drake/automotive/trajectory.h:162
          const char* doc_2 =
R"""(Makes a Trajectory from a discrete set of (time-independent)
waypoints, based on a constant speed, using cubic-polynomial
interpolation.

Parameter ``waypoints_rotation``:
    a vector of rotations, whose length must match that of ``speeds``.

Parameter ``waypoints_translation``:
    a vector of translations, whose length must match that of
    ``speeds``.

Parameter ``speed``:
    a positive speed to be applied over the entirety of the
    trajectory.

Throws:
    s RuntimeError if `speed` is non-positive or if either of the
    input vectors is empty.)""";

        } MakeCubicFromWaypoints;

        // drake::automotive::Trajectory::Trajectory
        struct /* ctor */ {

          // drake/automotive/trajectory.h:87
          const char* doc = R"""()""";

          // drake/automotive/trajectory.h:87
          const char* doc_2 = R"""()""";

        } ctor;

        // drake::automotive::Trajectory::value
        struct /* value */ {

          // drake/automotive/trajectory.h:168
          const char* doc =
R"""(Evaluates the Trajectory at a given ``time``, returning a packed
PoseVelocity.)""";

        } value;

      } Trajectory;

      // drake::automotive::TrajectoryCar
      struct /* TrajectoryCar */ {

        // drake/automotive/trajectory_car.h:62
        const char* doc =
R"""(TrajectoryCar models a car that follows a pre-established trajectory.
Note that TrajectoryCar can move forward (up to a given "soft" speed
limit) but cannot travel in reverse.

parameters: * uses systems::Parameters wrapping a TrajectoryCarParams

state vector: * A TrajectoryCarState, consisting of a position and
speed along the given curve, provided as the constructor parameter.

input vector: * desired acceleration, a systems::BasicVector of size 1
(optional input). If left unconnected, the trajectory car will travel
at a constant speed specified in the TrajectoryCarState.

output port 0: * position: x, y, heading; heading is 0 rad when
pointed +x, pi/2 rad when pointed +y; heading is defined around the +z
axis, so positive-turn-left * velocity (OutputPort getter:
raw_pose_output())

output port 1: A PoseVector containing X_WC, where C is the car frame.
(OutputPort getter: pose_output())

output port 2: A FrameVelocity containing Xdot_WC, where C is the car
frame. (OutputPort getter: velocity_output())

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::automotive::TrajectoryCar::TrajectoryCar<T>
        struct /* ctor */ {

          // drake/automotive/trajectory_car.h:66
          const char* doc = R"""()""";

          // drake/automotive/trajectory_car.h:66
          const char* doc_2 = R"""()""";

          // drake/automotive/trajectory_car.h:70
          const char* doc_3 =
R"""(Constructs a TrajectoryCar system that traces a given two-dimensional
``curve``. Throws an error if the curve is empty (has a zero
``path_length``).)""";

          // drake/automotive/trajectory_car.h:87
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::TrajectoryCar::command_input
        struct /* command_input */ {

          // drake/automotive/trajectory_car.h:91
          const char* doc = R"""(The command input port (optional).)""";

        } command_input;

        // drake::automotive::TrajectoryCar::pose_output
        struct /* pose_output */ {

          // drake/automotive/trajectory_car.h:99
          const char* doc = R"""()""";

        } pose_output;

        // drake::automotive::TrajectoryCar::raw_pose_output
        struct /* raw_pose_output */ {

          // drake/automotive/trajectory_car.h:96
          const char* doc =
R"""(See class description for details about the following ports. @{)""";

        } raw_pose_output;

        // drake::automotive::TrajectoryCar::velocity_output
        struct /* velocity_output */ {

          // drake/automotive/trajectory_car.h:102
          const char* doc = R"""()""";

        } velocity_output;

      } TrajectoryCar;

      // drake::automotive::TrajectoryCarParams
      struct /* TrajectoryCarParams */ {

        // drake/automotive/gen/trajectory_car_params.h:40
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::TrajectoryCarParams::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/automotive/gen/trajectory_car_params.h:101
          const char* doc = R"""()""";

        } CalcInequalityConstraint;

        // drake::automotive::TrajectoryCarParams::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/trajectory_car_params.h:62
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::TrajectoryCarParams::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/trajectory_car_params.h:85
          const char* doc =
R"""(See TrajectoryCarParamsIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::TrajectoryCarParams::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/trajectory_car_params.h:90
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::TrajectoryCarParams::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/trajectory_car_params.h:57
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::TrajectoryCarParams::TrajectoryCarParams<T>
        struct /* ctor */ {

          // drake/automotive/gen/trajectory_car_params.h:48
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``max_speed`` defaults to 45.0 m/s. @arg ``speed_limit_kp`` defaults
to 10.0 Hz.)""";

        } ctor;

        // drake::automotive::TrajectoryCarParams::max_speed
        struct /* max_speed */ {

          // drake/automotive/gen/trajectory_car_params.h:71
          const char* doc =
R"""(The limit on the car's forward speed.

Note:
    ``max_speed`` is expressed in units of m/s.

Note:
    ``max_speed`` has a limited domain of [0.0, +Inf].)""";

        } max_speed;

        // drake::automotive::TrajectoryCarParams::set_max_speed
        struct /* set_max_speed */ {

          // drake/automotive/gen/trajectory_car_params.h:72
          const char* doc = R"""()""";

        } set_max_speed;

        // drake::automotive::TrajectoryCarParams::set_speed_limit_kp
        struct /* set_speed_limit_kp */ {

          // drake/automotive/gen/trajectory_car_params.h:79
          const char* doc = R"""()""";

        } set_speed_limit_kp;

        // drake::automotive::TrajectoryCarParams::speed_limit_kp
        struct /* speed_limit_kp */ {

          // drake/automotive/gen/trajectory_car_params.h:78
          const char* doc =
R"""(The smoothing constant for min/max speed limits.

Note:
    ``speed_limit_kp`` is expressed in units of Hz.

Note:
    ``speed_limit_kp`` has a limited domain of [0.0, +Inf].)""";

        } speed_limit_kp;

      } TrajectoryCarParams;

      // drake::automotive::TrajectoryCarParamsIndices
      struct /* TrajectoryCarParamsIndices */ {

        // drake/automotive/gen/trajectory_car_params.h:23
        const char* doc =
R"""(Describes the row indices of a TrajectoryCarParams.)""";

        // drake::automotive::TrajectoryCarParamsIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/trajectory_car_params.h:35
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`TrajectoryCarParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } TrajectoryCarParamsIndices;

      // drake::automotive::TrajectoryCarState
      struct /* TrajectoryCarState */ {

        // drake/automotive/gen/trajectory_car_state.h:40
        const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

        // drake::automotive::TrajectoryCarState::DoClone
        struct /* DoClone */ {

          // drake/automotive/gen/trajectory_car_state.h:62
          const char* doc = R"""()""";

        } DoClone;

        // drake::automotive::TrajectoryCarState::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/trajectory_car_state.h:79
          const char* doc =
R"""(See TrajectoryCarStateIndices::GetCoordinateNames().)""";

        } GetCoordinateNames;

        // drake::automotive::TrajectoryCarState::IsValid
        struct /* IsValid */ {

          // drake/automotive/gen/trajectory_car_state.h:84
          const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

        } IsValid;

        // drake::automotive::TrajectoryCarState::SetToNamedVariables
        struct /* SetToNamedVariables */ {

          // drake/automotive/gen/trajectory_car_state.h:57
          const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

        } SetToNamedVariables;

        // drake::automotive::TrajectoryCarState::TrajectoryCarState<T>
        struct /* ctor */ {

          // drake/automotive/gen/trajectory_car_state.h:48
          const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``position`` defaults to 0.0 with unknown units. @arg ``speed``
defaults to 0.0 with unknown units.)""";

        } ctor;

        // drake::automotive::TrajectoryCarState::position
        struct /* position */ {

          // drake/automotive/gen/trajectory_car_state.h:69
          const char* doc =
R"""(The along-curve position of the vehicle.)""";

        } position;

        // drake::automotive::TrajectoryCarState::set_position
        struct /* set_position */ {

          // drake/automotive/gen/trajectory_car_state.h:70
          const char* doc = R"""()""";

        } set_position;

        // drake::automotive::TrajectoryCarState::set_speed
        struct /* set_speed */ {

          // drake/automotive/gen/trajectory_car_state.h:75
          const char* doc = R"""()""";

        } set_speed;

        // drake::automotive::TrajectoryCarState::speed
        struct /* speed */ {

          // drake/automotive/gen/trajectory_car_state.h:74
          const char* doc = R"""(The along-curve speed of the vehicle.)""";

        } speed;

      } TrajectoryCarState;

      // drake::automotive::TrajectoryCarStateIndices
      struct /* TrajectoryCarStateIndices */ {

        // drake/automotive/gen/trajectory_car_state.h:23
        const char* doc =
R"""(Describes the row indices of a TrajectoryCarState.)""";

        // drake::automotive::TrajectoryCarStateIndices::GetCoordinateNames
        struct /* GetCoordinateNames */ {

          // drake/automotive/gen/trajectory_car_state.h:35
          const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`TrajectoryCarStateIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

        } GetCoordinateNames;

      } TrajectoryCarStateIndices;

      // drake::automotive::TrajectoryCarStateTranslator
      struct /* TrajectoryCarStateTranslator */ {

        // drake/automotive/gen/trajectory_car_state_translator.h:20
        const char* doc =
R"""(Translates between LCM message objects and VectorBase objects for the
TrajectoryCarState type.)""";

        // drake::automotive::TrajectoryCarStateTranslator::AllocateOutputVector
        struct /* AllocateOutputVector */ {

          // drake/automotive/gen/trajectory_car_state_translator.h:26
          const char* doc = R"""()""";

        } AllocateOutputVector;

        // drake::automotive::TrajectoryCarStateTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/automotive/gen/trajectory_car_state_translator.h:28
          const char* doc = R"""()""";

        } Deserialize;

        // drake::automotive::TrajectoryCarStateTranslator::Serialize
        struct /* Serialize */ {

          // drake/automotive/gen/trajectory_car_state_translator.h:30
          const char* doc = R"""()""";

        } Serialize;

        // drake::automotive::TrajectoryCarStateTranslator::TrajectoryCarStateTranslator
        struct /* ctor */ {

          // drake/automotive/gen/trajectory_car_state_translator.h:23
          const char* doc = R"""()""";

        } ctor;

      } TrajectoryCarStateTranslator;

      // drake::automotive::TrajectoryFollower
      struct /* TrajectoryFollower */ {

        // drake/automotive/trajectory_follower.h:45
        const char* doc =
R"""(TrajectoryFollower simply moves along a pre-established trajectory.

Note that, when T = AutoDiffXd, the AutoDiffXd derivatives for each
element of the the outputs are empty.

output port 0: A SimpleCarState containing: * position: x, y, heading;
heading is 0 rad when pointed +x, pi/2 rad when pointed +y; heading is
defined around the +z axis, positive-left-turn. * speed: s = √{ẋ² +
ẏ²} (OutputPort getter: state_output())

output port 1: A PoseVector containing X_WA, where A is the agent's
reference frame. (OutputPort getter: pose_output())

output port 2: A FrameVelocity containing the spatial velocity V_WA,
where A is the agent's reference frame. (OutputPort getter:
velocity_output())

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::automotive::TrajectoryFollower::TrajectoryFollower<T>
        struct /* ctor */ {

          // drake/automotive/trajectory_follower.h:47
          const char* doc = R"""()""";

          // drake/automotive/trajectory_follower.h:47
          const char* doc_2 = R"""()""";

          // drake/automotive/trajectory_follower.h:54
          const char* doc_3 =
R"""(Constructs a TrajectoryFollower system that traces a given Trajectory.

Parameter ``trajectory``:
    a Trajectory containing the trajectory.

Parameter ``sampling_time_sec``:
    the requested sampling time (in sec) for this system. @default
    0.01.)""";

          // drake/automotive/trajectory_follower.h:59
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::automotive::TrajectoryFollower::pose_output
        struct /* pose_output */ {

          // drake/automotive/trajectory_follower.h:67
          const char* doc = R"""()""";

        } pose_output;

        // drake::automotive::TrajectoryFollower::state_output
        struct /* state_output */ {

          // drake/automotive/trajectory_follower.h:64
          const char* doc =
R"""(@name Accessors for the outputs, as enumerated in the class
documentation. @{)""";

        } state_output;

        // drake::automotive::TrajectoryFollower::velocity_output
        struct /* velocity_output */ {

          // drake/automotive/trajectory_follower.h:70
          const char* doc = R"""()""";

        } velocity_output;

      } TrajectoryFollower;

      // drake::automotive::TrivialRightOfWayStateProvider
      struct /* TrivialRightOfWayStateProvider */ {

        // drake/automotive/trivial_right_of_way_state_provider.h:12
        const char* doc =
R"""(A trivial implementation of an api::rules::RightOfWayStateProvider.)""";

        // drake::automotive::TrivialRightOfWayStateProvider::AddState
        struct /* AddState */ {

          // drake/automotive/trivial_right_of_way_state_provider.h:28
          const char* doc =
R"""(Adds a dynamic state to this provider.

Throws std::logic_error if a RightOfWayRule with an ID of ``id``
already exists in this provider.

Throws std::runtime_error if the dynamic state failed to be added.)""";

        } AddState;

        // drake::automotive::TrivialRightOfWayStateProvider::SetState
        struct /* SetState */ {

          // drake/automotive/trivial_right_of_way_state_provider.h:36
          const char* doc =
R"""(Sets the dynamic state of a RightOfWayRule within this provider.

Throws ValueError if no dynamic state with ``id`` exists in this
provider.)""";

        } SetState;

        // drake::automotive::TrivialRightOfWayStateProvider::TrivialRightOfWayStateProvider
        struct /* ctor */ {

          // drake/automotive/trivial_right_of_way_state_provider.h:15
          const char* doc = R"""()""";

          // drake/automotive/trivial_right_of_way_state_provider.h:15
          const char* doc_2 = R"""()""";

          // drake/automotive/trivial_right_of_way_state_provider.h:18
          const char* doc_3 = R"""(Default constructor.)""";

        } ctor;

      } TrivialRightOfWayStateProvider;

      // drake::automotive::calc_smooth_acceleration
      struct /* calc_smooth_acceleration */ {

        // drake/automotive/calc_smooth_acceleration.h:21
        const char* doc =
R"""(Computes and returns an acceleration command that results in a smooth
acceleration profile. It is smooth in the sense that it looks pleasant
and realistic, though it may not reflect the actual acceleration
behavior of real vehicles.

For a given acceleration plan, all of the input parameters typically
remain constant except for ``current_velocity``.

Instantiated templates for the following ScalarTypes are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.)""";

      } calc_smooth_acceleration;

    } automotive;

    // drake::cond
    struct /* cond */ {

      // drake/common/autodiff_overloads.h:185
      const char* doc =
R"""(Provides special case of cond expression for Eigen::AutoDiffScalar
type.)""";

      // drake/common/cond.h:34
      const char* doc_2 =
R"""(@name cond Constructs conditional expression (similar to Lisp's cond).

@verbatim cond(cond_1, expr_1, cond_2, expr_2, ..., ..., cond_n,
expr_n, expr_{n+1}) @endverbatim

The value returned by the above cond expression is ``expr_1`` if
``cond_1`` is true; else if ``cond_2`` is true then ``expr_2``; ... ;
else if ``cond_n`` is true then ``expr_n``. If none of the conditions
are true, it returns ``expr_``{n+1}.

Note:
    This functions assumes that ``ScalarType`` provides ``operator``<
    and the type of ``f_cond`` is the type of the return type of
    ``operator<(ScalarType, ScalarType)``. For example,
    ``symbolic::Expression`` can be used as a ``ScalarType`` because
    it provides ``symbolic::Formula operator<(symbolic::Expression,
    symbolic::Expression)``.

@{)""";

      // drake/common/cond.h:38
      const char* doc_3 = R"""()""";

    } cond;

    // drake::dummy_value
    struct /* dummy_value */ {

      // drake/common/dummy_value.h:17
      const char* doc =
R"""(Provides a "dummy" value for a ScalarType -- a value that is unlikely
to be mistaken for a purposefully-computed value, useful for
initializing a value before the true result is available.

Defaults to using std::numeric_limits::quiet_NaN when available; it is
a compile-time error to call the unspecialized dummy_value::get() when
quiet_NaN is unavailable.

See autodiff_overloads.h to use this with Eigen's AutoDiffScalar.)""";

      // drake/common/dummy_value.h:26
      const char* doc_2 = R"""()""";

      // drake::dummy_value::get
      struct /* get */ {

        // drake/common/dummy_value.h:18
        const char* doc = R"""()""";

        // drake/common/dummy_value.h:27
        const char* doc_2 = R"""()""";

      } get;

    } dummy_value;

    // examples
    struct /* examples */ {

      // acrobot
      struct /* acrobot */ {

        // drake::examples::acrobot::AcrobotInput
        struct /* AcrobotInput */ {

          // drake/examples/acrobot/gen/acrobot_input.h:40
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::acrobot::AcrobotInput::AcrobotInput<T>
          struct /* ctor */ {

            // drake/examples/acrobot/gen/acrobot_input.h:47
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``tau`` defaults to 0.0 Nm.)""";

          } ctor;

          // drake::examples::acrobot::AcrobotInput::DoClone
          struct /* DoClone */ {

            // drake/examples/acrobot/gen/acrobot_input.h:59
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::acrobot::AcrobotInput::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_input.h:70
            const char* doc =
R"""(See AcrobotInputIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::acrobot::AcrobotInput::IsValid
          struct /* IsValid */ {

            // drake/examples/acrobot/gen/acrobot_input.h:75
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::acrobot::AcrobotInput::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/acrobot/gen/acrobot_input.h:55
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::acrobot::AcrobotInput::set_tau
          struct /* set_tau */ {

            // drake/examples/acrobot/gen/acrobot_input.h:66
            const char* doc = R"""()""";

          } set_tau;

          // drake::examples::acrobot::AcrobotInput::tau
          struct /* tau */ {

            // drake/examples/acrobot/gen/acrobot_input.h:65
            const char* doc =
R"""(Torque at the elbow

Note:
    ``tau`` is expressed in units of Nm.)""";

          } tau;

        } AcrobotInput;

        // drake::examples::acrobot::AcrobotInputIndices
        struct /* AcrobotInputIndices */ {

          // drake/examples/acrobot/gen/acrobot_input.h:24
          const char* doc =
R"""(Describes the row indices of a AcrobotInput.)""";

          // drake::examples::acrobot::AcrobotInputIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_input.h:35
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words, `AcrobotInputIndices::GetCoordinateNames()[i]`
is the name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } AcrobotInputIndices;

        // drake::examples::acrobot::AcrobotParams
        struct /* AcrobotParams */ {

          // drake/examples/acrobot/gen/acrobot_params.h:49
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::acrobot::AcrobotParams::AcrobotParams<T>
          struct /* ctor */ {

            // drake/examples/acrobot/gen/acrobot_params.h:65
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg ``m1``
defaults to 1.0 kg. @arg ``m2`` defaults to 1.0 kg. @arg ``l1``
defaults to 1.0 m. @arg ``lc1`` defaults to 0.5 m. @arg ``lc2``
defaults to 1.0 m. @arg ``Ic1`` defaults to 0.083 kg*m^2. @arg ``Ic2``
defaults to 0.33 kg*m^2. @arg ``b1`` defaults to 0.1 kg*m^2/s. @arg
``b2`` defaults to 0.1 kg*m^2/s. @arg ``gravity`` defaults to 9.81
m/s^2.)""";

          } ctor;

          // drake::examples::acrobot::AcrobotParams::CalcInequalityConstraint
          struct /* CalcInequalityConstraint */ {

            // drake/examples/acrobot/gen/acrobot_params.h:184
            const char* doc = R"""()""";

          } CalcInequalityConstraint;

          // drake::examples::acrobot::AcrobotParams::DoClone
          struct /* DoClone */ {

            // drake/examples/acrobot/gen/acrobot_params.h:95
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::acrobot::AcrobotParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_params.h:152
            const char* doc =
R"""(See AcrobotParamsIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::acrobot::AcrobotParams::Ic1
          struct /* Ic1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:127
            const char* doc =
R"""(Inertia of link 1 about the center of mass of link 1.

Note:
    ``Ic1`` is expressed in units of kg*m^2.

Note:
    ``Ic1`` has a limited domain of [0.0, +Inf].)""";

          } Ic1;

          // drake::examples::acrobot::AcrobotParams::Ic2
          struct /* Ic2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:132
            const char* doc =
R"""(Inertia of link 2 about the center of mass of link 2.

Note:
    ``Ic2`` is expressed in units of kg*m^2.

Note:
    ``Ic2`` has a limited domain of [0.0, +Inf].)""";

          } Ic2;

          // drake::examples::acrobot::AcrobotParams::IsValid
          struct /* IsValid */ {

            // drake/examples/acrobot/gen/acrobot_params.h:157
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::acrobot::AcrobotParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/acrobot/gen/acrobot_params.h:82
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::acrobot::AcrobotParams::b1
          struct /* b1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:137
            const char* doc =
R"""(Damping coefficient of the shoulder joint.

Note:
    ``b1`` is expressed in units of kg*m^2/s.

Note:
    ``b1`` has a limited domain of [0.0, +Inf].)""";

          } b1;

          // drake::examples::acrobot::AcrobotParams::b2
          struct /* b2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:142
            const char* doc =
R"""(Damping coefficient of the elbow joint.

Note:
    ``b2`` is expressed in units of kg*m^2/s.

Note:
    ``b2`` has a limited domain of [0.0, +Inf].)""";

          } b2;

          // drake::examples::acrobot::AcrobotParams::gravity
          struct /* gravity */ {

            // drake/examples/acrobot/gen/acrobot_params.h:147
            const char* doc =
R"""(Gravitational constant.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";

          } gravity;

          // drake::examples::acrobot::AcrobotParams::l1
          struct /* l1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:112
            const char* doc =
R"""(Length of link 1.

Note:
    ``l1`` is expressed in units of m.

Note:
    ``l1`` has a limited domain of [0.0, +Inf].)""";

          } l1;

          // drake::examples::acrobot::AcrobotParams::lc1
          struct /* lc1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:117
            const char* doc =
R"""(Vertical distance from shoulder joint to center of mass of link 1.

Note:
    ``lc1`` is expressed in units of m.

Note:
    ``lc1`` has a limited domain of [0.0, +Inf].)""";

          } lc1;

          // drake::examples::acrobot::AcrobotParams::lc2
          struct /* lc2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:122
            const char* doc =
R"""(Vertical distance from elbow joint to center of mass of link 1.

Note:
    ``lc2`` is expressed in units of m.

Note:
    ``lc2`` has a limited domain of [0.0, +Inf].)""";

          } lc2;

          // drake::examples::acrobot::AcrobotParams::m1
          struct /* m1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:102
            const char* doc =
R"""(Mass of link 1.

Note:
    ``m1`` is expressed in units of kg.

Note:
    ``m1`` has a limited domain of [0.0, +Inf].)""";

          } m1;

          // drake::examples::acrobot::AcrobotParams::m2
          struct /* m2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:107
            const char* doc =
R"""(Mass of link 2.

Note:
    ``m2`` is expressed in units of kg.

Note:
    ``m2`` has a limited domain of [0.0, +Inf].)""";

          } m2;

          // drake::examples::acrobot::AcrobotParams::set_Ic1
          struct /* set_Ic1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:128
            const char* doc = R"""()""";

          } set_Ic1;

          // drake::examples::acrobot::AcrobotParams::set_Ic2
          struct /* set_Ic2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:133
            const char* doc = R"""()""";

          } set_Ic2;

          // drake::examples::acrobot::AcrobotParams::set_b1
          struct /* set_b1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:138
            const char* doc = R"""()""";

          } set_b1;

          // drake::examples::acrobot::AcrobotParams::set_b2
          struct /* set_b2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:143
            const char* doc = R"""()""";

          } set_b2;

          // drake::examples::acrobot::AcrobotParams::set_gravity
          struct /* set_gravity */ {

            // drake/examples/acrobot/gen/acrobot_params.h:148
            const char* doc = R"""()""";

          } set_gravity;

          // drake::examples::acrobot::AcrobotParams::set_l1
          struct /* set_l1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:113
            const char* doc = R"""()""";

          } set_l1;

          // drake::examples::acrobot::AcrobotParams::set_lc1
          struct /* set_lc1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:118
            const char* doc = R"""()""";

          } set_lc1;

          // drake::examples::acrobot::AcrobotParams::set_lc2
          struct /* set_lc2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:123
            const char* doc = R"""()""";

          } set_lc2;

          // drake::examples::acrobot::AcrobotParams::set_m1
          struct /* set_m1 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:103
            const char* doc = R"""()""";

          } set_m1;

          // drake::examples::acrobot::AcrobotParams::set_m2
          struct /* set_m2 */ {

            // drake/examples/acrobot/gen/acrobot_params.h:108
            const char* doc = R"""()""";

          } set_m2;

        } AcrobotParams;

        // drake::examples::acrobot::AcrobotParamsIndices
        struct /* AcrobotParamsIndices */ {

          // drake/examples/acrobot/gen/acrobot_params.h:24
          const char* doc =
R"""(Describes the row indices of a AcrobotParams.)""";

          // drake::examples::acrobot::AcrobotParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_params.h:44
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words, `AcrobotParamsIndices::GetCoordinateNames()[i]`
is the name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } AcrobotParamsIndices;

        // drake::examples::acrobot::AcrobotPlant
        struct /* AcrobotPlant */ {

          // drake/examples/acrobot/acrobot_plant.h:28
          const char* doc =
R"""(The Acrobot - a canonical underactuated system as described in <a href
="http://underactuated.mit.edu/underactuated.html?chapter=3">Chapter 3
of Underactuated Robotics</a>.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - symbolic::Expression)""";

          // drake::examples::acrobot::AcrobotPlant::AcrobotPlant<T>
          struct /* ctor */ {

            // drake/examples/acrobot/acrobot_plant.h:30
            const char* doc = R"""()""";

            // drake/examples/acrobot/acrobot_plant.h:30
            const char* doc_2 = R"""()""";

            // drake/examples/acrobot/acrobot_plant.h:34
            const char* doc_3 =
R"""(Constructs the plant. The parameters of the system are stored as
Parameters in the Context (see acrobot_params.named_vector).)""";

            // drake/examples/acrobot/acrobot_plant.h:38
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::examples::acrobot::AcrobotPlant::DoCalcKineticEnergy
          struct /* DoCalcKineticEnergy */ {

            // drake/examples/acrobot/acrobot_plant.h:84
            const char* doc = R"""()""";

          } DoCalcKineticEnergy;

          // drake::examples::acrobot::AcrobotPlant::DoCalcPotentialEnergy
          struct /* DoCalcPotentialEnergy */ {

            // drake/examples/acrobot/acrobot_plant.h:85
            const char* doc = R"""()""";

          } DoCalcPotentialEnergy;

          // drake::examples::acrobot::AcrobotPlant::DynamicsBiasTerm
          struct /* DynamicsBiasTerm */ {

            // drake/examples/acrobot/acrobot_plant.h:50
            const char* doc =
R"""(@{ Manipulator equation of Acrobot: M(q)q̈ + bias(q,q̇) = B*u. -
M[2x2] is the mass matrix. - bias[2x1] includes the Coriolis term,
gravity term and the damping term, i.e. bias[2x1] = C(q,v)*v - τ_g(q)
+ [b1*q̇₁;b2*q̇₂].)""";

          } DynamicsBiasTerm;

          // drake::examples::acrobot::AcrobotPlant::MassMatrix
          struct /* MassMatrix */ {

            // drake/examples/acrobot/acrobot_plant.h:51
            const char* doc = R"""()""";

          } MassMatrix;

          // drake::examples::acrobot::AcrobotPlant::SetMITAcrobotParameters
          struct /* SetMITAcrobotParameters */ {

            // drake/examples/acrobot/acrobot_plant.h:42
            const char* doc =
R"""(Sets the parameters to describe MIT Robot Locomotion Group's hardware
acrobot.)""";

          } SetMITAcrobotParameters;

          // drake::examples::acrobot::AcrobotPlant::get_mutable_state
          struct /* get_mutable_state */ {

            // drake/examples/acrobot/acrobot_plant.h:69
            const char* doc = R"""()""";

            // drake/examples/acrobot/acrobot_plant.h:74
            const char* doc_2 = R"""()""";

          } get_mutable_state;

          // drake::examples::acrobot::AcrobotPlant::get_parameters
          struct /* get_parameters */ {

            // drake/examples/acrobot/acrobot_plant.h:78
            const char* doc = R"""()""";

          } get_parameters;

          // drake::examples::acrobot::AcrobotPlant::get_state
          struct /* get_state */ {

            // drake/examples/acrobot/acrobot_plant.h:60
            const char* doc = R"""()""";

            // drake/examples/acrobot/acrobot_plant.h:65
            const char* doc_2 = R"""()""";

          } get_state;

          // drake::examples::acrobot::AcrobotPlant::get_tau
          struct /* get_tau */ {

            // drake/examples/acrobot/acrobot_plant.h:56
            const char* doc =
R"""(Evaluates the input port and returns the scalar value of the commanded
torque.)""";

          } get_tau;

        } AcrobotPlant;

        // drake::examples::acrobot::AcrobotState
        struct /* AcrobotState */ {

          // drake/examples/acrobot/gen/acrobot_state.h:43
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::acrobot::AcrobotState::AcrobotState<T>
          struct /* ctor */ {

            // drake/examples/acrobot/gen/acrobot_state.h:53
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``theta1`` defaults to 0.0 rad. @arg ``theta2`` defaults to 0.0 rad.
@arg ``theta1dot`` defaults to 0.0 rad/s. @arg ``theta2dot`` defaults
to 0.0 rad/s.)""";

          } ctor;

          // drake::examples::acrobot::AcrobotState::DoClone
          struct /* DoClone */ {

            // drake/examples/acrobot/gen/acrobot_state.h:71
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::acrobot::AcrobotState::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_state.h:98
            const char* doc =
R"""(See AcrobotStateIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::acrobot::AcrobotState::IsValid
          struct /* IsValid */ {

            // drake/examples/acrobot/gen/acrobot_state.h:103
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::acrobot::AcrobotState::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/acrobot/gen/acrobot_state.h:64
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::acrobot::AcrobotState::set_theta1
          struct /* set_theta1 */ {

            // drake/examples/acrobot/gen/acrobot_state.h:78
            const char* doc = R"""()""";

          } set_theta1;

          // drake::examples::acrobot::AcrobotState::set_theta1dot
          struct /* set_theta1dot */ {

            // drake/examples/acrobot/gen/acrobot_state.h:86
            const char* doc = R"""()""";

          } set_theta1dot;

          // drake::examples::acrobot::AcrobotState::set_theta2
          struct /* set_theta2 */ {

            // drake/examples/acrobot/gen/acrobot_state.h:82
            const char* doc = R"""()""";

          } set_theta2;

          // drake::examples::acrobot::AcrobotState::set_theta2dot
          struct /* set_theta2dot */ {

            // drake/examples/acrobot/gen/acrobot_state.h:92
            const char* doc = R"""()""";

          } set_theta2dot;

          // drake::examples::acrobot::AcrobotState::theta1
          struct /* theta1 */ {

            // drake/examples/acrobot/gen/acrobot_state.h:77
            const char* doc =
R"""(The shoulder joint angle

Note:
    ``theta1`` is expressed in units of rad.)""";

          } theta1;

          // drake::examples::acrobot::AcrobotState::theta1dot
          struct /* theta1dot */ {

            // drake/examples/acrobot/gen/acrobot_state.h:85
            const char* doc =
R"""(The shoulder joint velocity

Note:
    ``theta1dot`` is expressed in units of rad/s.)""";

          } theta1dot;

          // drake::examples::acrobot::AcrobotState::theta2
          struct /* theta2 */ {

            // drake/examples/acrobot/gen/acrobot_state.h:81
            const char* doc =
R"""(The elbow joint angle

Note:
    ``theta2`` is expressed in units of rad.)""";

          } theta2;

          // drake::examples::acrobot::AcrobotState::theta2dot
          struct /* theta2dot */ {

            // drake/examples/acrobot/gen/acrobot_state.h:91
            const char* doc =
R"""(The elbow joint velocity

Note:
    ``theta2dot`` is expressed in units of rad/s.)""";

          } theta2dot;

        } AcrobotState;

        // drake::examples::acrobot::AcrobotStateIndices
        struct /* AcrobotStateIndices */ {

          // drake/examples/acrobot/gen/acrobot_state.h:24
          const char* doc =
R"""(Describes the row indices of a AcrobotState.)""";

          // drake::examples::acrobot::AcrobotStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/acrobot/gen/acrobot_state.h:38
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words, `AcrobotStateIndices::GetCoordinateNames()[i]`
is the name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } AcrobotStateIndices;

        // drake::examples::acrobot::AcrobotWEncoder
        struct /* AcrobotWEncoder */ {

          // drake/examples/acrobot/acrobot_plant.h:98
          const char* doc =
R"""(Constructs the Acrobot with (only) encoder outputs.)""";

          // drake::examples::acrobot::AcrobotWEncoder::AcrobotWEncoder<T>
          struct /* ctor */ {

            // drake/examples/acrobot/acrobot_plant.h:100
            const char* doc = R"""()""";

          } ctor;

          // drake::examples::acrobot::AcrobotWEncoder::acrobot_plant
          struct /* acrobot_plant */ {

            // drake/examples/acrobot/acrobot_plant.h:102
            const char* doc = R"""()""";

          } acrobot_plant;

          // drake::examples::acrobot::AcrobotWEncoder::get_mutable_acrobot_state
          struct /* get_mutable_acrobot_state */ {

            // drake/examples/acrobot/acrobot_plant.h:104
            const char* doc = R"""()""";

          } get_mutable_acrobot_state;

        } AcrobotWEncoder;

        // drake::examples::acrobot::BalancingLQRController
        struct /* BalancingLQRController */ {

          // drake/examples/acrobot/acrobot_plant.h:113
          const char* doc =
R"""(Constructs the LQR controller for stabilizing the upright fixed point
using default LQR cost matrices which have been tested for this
system.)""";

        } BalancingLQRController;

      } acrobot;

      // compass_gait
      struct /* compass_gait */ {

        // drake::examples::compass_gait::CompassGait
        struct /* CompassGait */ {

          // drake/examples/compass_gait/compass_gait.h:51
          const char* doc =
R"""(Dynamical representation of the idealized hybrid dynamics of a
"compass gait", as described in
http://underactuated.mit.edu/underactuated.html?chapter=simple_legs
with a few small differences. The implementation here has no torque
input (yet). In addition, this implementation has two additional state
variables that are not required in the mathematical model: - a
discrete state for the position of the stance toe along the ramp - a
Boolean indicator for "left support" (true when the stance leg is the
left leg). These are helpful for outputting the floating-base model
coordinate, e.g. for visualization.

Note: This model only supports walking downhill on the ramp, because
that restriction enables a clean / numerically robust implementation
of the foot collision witness function that avoids falls detections on
the "foot scuffing" collision.

Inputs: None.<br/> Continuous States: stance, swing, stancedot,
swingdot.<br/> Discrete State: stance toe position.<br/> Abstract
State: left support indicator.<br/> Outputs: <ol start=0>

* continuous (minimal coordinates) state output

* floating-base state output

</ol>

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression)""";

          // drake::examples::compass_gait::CompassGait::CompassGait<T>
          struct /* ctor */ {

            // drake/examples/compass_gait/compass_gait.h:53
            const char* doc = R"""()""";

            // drake/examples/compass_gait/compass_gait.h:53
            const char* doc_2 = R"""()""";

            // drake/examples/compass_gait/compass_gait.h:56
            const char* doc_3 = R"""(Constructs the plant.)""";

            // drake/examples/compass_gait/compass_gait.h:60
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::examples::compass_gait::CompassGait::DynamicsBiasTerm
          struct /* DynamicsBiasTerm */ {

            // drake/examples/compass_gait/compass_gait.h:116
            const char* doc =
R"""(@{ Manipulator equation of CompassGait: M(q)v̇ + bias(q,v) = 0. - M is
the 2x2 mass matrix. - bias is a 2x1 vector that includes the Coriolis
term and gravity term, i.e. bias = C(q,v)*v - τ_g(q).)""";

          } DynamicsBiasTerm;

          // drake::examples::compass_gait::CompassGait::MassMatrix
          struct /* MassMatrix */ {

            // drake/examples/compass_gait/compass_gait.h:117
            const char* doc = R"""()""";

          } MassMatrix;

          // drake::examples::compass_gait::CompassGait::get_continuous_state
          struct /* get_continuous_state */ {

            // drake/examples/compass_gait/compass_gait.h:76
            const char* doc = R"""(Returns the CompassGaitContinuousState.)""";

          } get_continuous_state;

          // drake::examples::compass_gait::CompassGait::get_floating_base_state_output_port
          struct /* get_floating_base_state_output_port */ {

            // drake/examples/compass_gait/compass_gait.h:71
            const char* doc =
R"""(Returns reference to the output port that provides the state required
by a RigidBodyTree loaded from CompassGait.urdf (as instantiated with
FloatingBaseType::kRollPitchYaw).)""";

          } get_floating_base_state_output_port;

          // drake::examples::compass_gait::CompassGait::get_minimal_state_output_port
          struct /* get_minimal_state_output_port */ {

            // drake/examples/compass_gait/compass_gait.h:64
            const char* doc =
R"""(Returns reference to the output port that publishes only
[theta_stance, theta_swing, thetatdot_stance, thetadot_swing].)""";

          } get_minimal_state_output_port;

          // drake::examples::compass_gait::CompassGait::get_mutable_continuous_state
          struct /* get_mutable_continuous_state */ {

            // drake/examples/compass_gait/compass_gait.h:82
            const char* doc =
R"""(Returns the mutable CompassGaitContinuousState.)""";

          } get_mutable_continuous_state;

          // drake::examples::compass_gait::CompassGait::get_parameters
          struct /* get_parameters */ {

            // drake/examples/compass_gait/compass_gait.h:106
            const char* doc = R"""(Access the CompassGaitParams.)""";

          } get_parameters;

          // drake::examples::compass_gait::CompassGait::get_toe_position
          struct /* get_toe_position */ {

            // drake/examples/compass_gait/compass_gait.h:88
            const char* doc = R"""()""";

          } get_toe_position;

          // drake::examples::compass_gait::CompassGait::left_leg_is_stance
          struct /* left_leg_is_stance */ {

            // drake/examples/compass_gait/compass_gait.h:97
            const char* doc = R"""()""";

          } left_leg_is_stance;

          // drake::examples::compass_gait::CompassGait::set_left_leg_is_stance
          struct /* set_left_leg_is_stance */ {

            // drake/examples/compass_gait/compass_gait.h:101
            const char* doc = R"""()""";

          } set_left_leg_is_stance;

          // drake::examples::compass_gait::CompassGait::set_toe_position
          struct /* set_toe_position */ {

            // drake/examples/compass_gait/compass_gait.h:92
            const char* doc = R"""()""";

          } set_toe_position;

        } CompassGait;

        // drake::examples::compass_gait::CompassGaitContinuousState
        struct /* CompassGaitContinuousState */ {

          // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:44
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::compass_gait::CompassGaitContinuousState::CompassGaitContinuousState<T>
          struct /* ctor */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:54
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``stance`` defaults to 0.0 radians. @arg ``swing`` defaults to 0.0
radians. @arg ``stancedot`` defaults to 0.0 rad/sec. @arg ``swingdot``
defaults to 0.0 rad/sec.)""";

          } ctor;

          // drake::examples::compass_gait::CompassGaitContinuousState::DoClone
          struct /* DoClone */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:73
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::compass_gait::CompassGaitContinuousState::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:104
            const char* doc =
R"""(See CompassGaitContinuousStateIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::compass_gait::CompassGaitContinuousState::IsValid
          struct /* IsValid */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:109
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::compass_gait::CompassGaitContinuousState::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:66
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::compass_gait::CompassGaitContinuousState::set_stance
          struct /* set_stance */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:83
            const char* doc = R"""()""";

          } set_stance;

          // drake::examples::compass_gait::CompassGaitContinuousState::set_stancedot
          struct /* set_stancedot */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:92
            const char* doc = R"""()""";

          } set_stancedot;

          // drake::examples::compass_gait::CompassGaitContinuousState::set_swing
          struct /* set_swing */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:88
            const char* doc = R"""()""";

          } set_swing;

          // drake::examples::compass_gait::CompassGaitContinuousState::set_swingdot
          struct /* set_swingdot */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:98
            const char* doc = R"""()""";

          } set_swingdot;

          // drake::examples::compass_gait::CompassGaitContinuousState::stance
          struct /* stance */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:82
            const char* doc =
R"""(The orientation of the stance leg, measured clockwise from the
vertical axis.

Note:
    ``stance`` is expressed in units of radians.)""";

          } stance;

          // drake::examples::compass_gait::CompassGaitContinuousState::stancedot
          struct /* stancedot */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:91
            const char* doc =
R"""(The angular velocity of the stance leg.

Note:
    ``stancedot`` is expressed in units of rad/sec.)""";

          } stancedot;

          // drake::examples::compass_gait::CompassGaitContinuousState::swing
          struct /* swing */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:87
            const char* doc =
R"""(The orientation of the swing leg, measured clockwise from the vertical
axis.

Note:
    ``swing`` is expressed in units of radians.)""";

          } swing;

          // drake::examples::compass_gait::CompassGaitContinuousState::swingdot
          struct /* swingdot */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:97
            const char* doc =
R"""(The angular velocity of the swing leg.

Note:
    ``swingdot`` is expressed in units of rad/sec.)""";

          } swingdot;

        } CompassGaitContinuousState;

        // drake::examples::compass_gait::CompassGaitContinuousStateIndices
        struct /* CompassGaitContinuousStateIndices */ {

          // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:24
          const char* doc =
R"""(Describes the row indices of a CompassGaitContinuousState.)""";

          // drake::examples::compass_gait::CompassGaitContinuousStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/compass_gait/gen/compass_gait_continuous_state.h:39
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`CompassGaitContinuousStateIndices::GetCoordinateNames()[i]` is the
name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } CompassGaitContinuousStateIndices;

        // drake::examples::compass_gait::CompassGaitParams
        struct /* CompassGaitParams */ {

          // drake/examples/compass_gait/gen/compass_gait_params.h:45
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::compass_gait::CompassGaitParams::CalcInequalityConstraint
          struct /* CalcInequalityConstraint */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:153
            const char* doc = R"""()""";

          } CalcInequalityConstraint;

          // drake::examples::compass_gait::CompassGaitParams::CompassGaitParams<T>
          struct /* ctor */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:57
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``mass_hip`` defaults to 10.0 kg. @arg ``mass_leg`` defaults to 5.0
kg. @arg ``length_leg`` defaults to 1.0 m. @arg ``center_of_mass_leg``
defaults to .5 m. @arg ``gravity`` defaults to 9.81 m/s^2. @arg
``slope`` defaults to 0.0525 radians.)""";

          } ctor;

          // drake::examples::compass_gait::CompassGaitParams::DoClone
          struct /* DoClone */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:79
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::compass_gait::CompassGaitParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:128
            const char* doc =
R"""(See CompassGaitParamsIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::compass_gait::CompassGaitParams::IsValid
          struct /* IsValid */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:133
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::compass_gait::CompassGaitParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:70
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::compass_gait::CompassGaitParams::center_of_mass_leg
          struct /* center_of_mass_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:107
            const char* doc =
R"""(Distance from the hip to the center of mass of each leg.

Note:
    ``center_of_mass_leg`` is expressed in units of m.

Note:
    ``center_of_mass_leg`` has a limited domain of [0.0, +Inf].)""";

          } center_of_mass_leg;

          // drake::examples::compass_gait::CompassGaitParams::gravity
          struct /* gravity */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:116
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";

          } gravity;

          // drake::examples::compass_gait::CompassGaitParams::length_leg
          struct /* length_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:100
            const char* doc =
R"""(The length of each leg.

Note:
    ``length_leg`` is expressed in units of m.

Note:
    ``length_leg`` has a limited domain of [0.0, +Inf].)""";

          } length_leg;

          // drake::examples::compass_gait::CompassGaitParams::mass_hip
          struct /* mass_hip */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:86
            const char* doc =
R"""(Point mass at the hip.

Note:
    ``mass_hip`` is expressed in units of kg.

Note:
    ``mass_hip`` has a limited domain of [0.0, +Inf].)""";

          } mass_hip;

          // drake::examples::compass_gait::CompassGaitParams::mass_leg
          struct /* mass_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:93
            const char* doc =
R"""(Mass of each leg (modeled as a point mass at the center of mass).

Note:
    ``mass_leg`` is expressed in units of kg.

Note:
    ``mass_leg`` has a limited domain of [0.0, +Inf].)""";

          } mass_leg;

          // drake::examples::compass_gait::CompassGaitParams::set_center_of_mass_leg
          struct /* set_center_of_mass_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:110
            const char* doc = R"""()""";

          } set_center_of_mass_leg;

          // drake::examples::compass_gait::CompassGaitParams::set_gravity
          struct /* set_gravity */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:117
            const char* doc = R"""()""";

          } set_gravity;

          // drake::examples::compass_gait::CompassGaitParams::set_length_leg
          struct /* set_length_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:101
            const char* doc = R"""()""";

          } set_length_leg;

          // drake::examples::compass_gait::CompassGaitParams::set_mass_hip
          struct /* set_mass_hip */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:87
            const char* doc = R"""()""";

          } set_mass_hip;

          // drake::examples::compass_gait::CompassGaitParams::set_mass_leg
          struct /* set_mass_leg */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:94
            const char* doc = R"""()""";

          } set_mass_leg;

          // drake::examples::compass_gait::CompassGaitParams::set_slope
          struct /* set_slope */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:124
            const char* doc = R"""()""";

          } set_slope;

          // drake::examples::compass_gait::CompassGaitParams::slope
          struct /* slope */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:123
            const char* doc =
R"""(The angle of the ramp on which the compass gait is walking. Must have
0 <= slope < PI/2 so that forward == downhill (an assumption used in
the foot collision witness function).

Note:
    ``slope`` is expressed in units of radians.

Note:
    ``slope`` has a limited domain of [0.0, 1.5707].)""";

          } slope;

        } CompassGaitParams;

        // drake::examples::compass_gait::CompassGaitParamsIndices
        struct /* CompassGaitParamsIndices */ {

          // drake/examples/compass_gait/gen/compass_gait_params.h:24
          const char* doc =
R"""(Describes the row indices of a CompassGaitParams.)""";

          // drake::examples::compass_gait::CompassGaitParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/compass_gait/gen/compass_gait_params.h:40
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`CompassGaitParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } CompassGaitParamsIndices;

      } compass_gait;

      // pendulum
      struct /* pendulum */ {

        // drake::examples::pendulum::PendulumInput
        struct /* PendulumInput */ {

          // drake/examples/pendulum/gen/pendulum_input.h:40
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::pendulum::PendulumInput::DoClone
          struct /* DoClone */ {

            // drake/examples/pendulum/gen/pendulum_input.h:59
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::pendulum::PendulumInput::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_input.h:70
            const char* doc =
R"""(See PendulumInputIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::pendulum::PendulumInput::IsValid
          struct /* IsValid */ {

            // drake/examples/pendulum/gen/pendulum_input.h:75
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::pendulum::PendulumInput::PendulumInput<T>
          struct /* ctor */ {

            // drake/examples/pendulum/gen/pendulum_input.h:47
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``tau`` defaults to 0.0 Newton-meters.)""";

          } ctor;

          // drake::examples::pendulum::PendulumInput::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/pendulum/gen/pendulum_input.h:55
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::pendulum::PendulumInput::set_tau
          struct /* set_tau */ {

            // drake/examples/pendulum/gen/pendulum_input.h:66
            const char* doc = R"""()""";

          } set_tau;

          // drake::examples::pendulum::PendulumInput::tau
          struct /* tau */ {

            // drake/examples/pendulum/gen/pendulum_input.h:65
            const char* doc =
R"""(Torque at the joint.

Note:
    ``tau`` is expressed in units of Newton-meters.)""";

          } tau;

        } PendulumInput;

        // drake::examples::pendulum::PendulumInputIndices
        struct /* PendulumInputIndices */ {

          // drake/examples/pendulum/gen/pendulum_input.h:24
          const char* doc =
R"""(Describes the row indices of a PendulumInput.)""";

          // drake::examples::pendulum::PendulumInputIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_input.h:35
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words, `PendulumInputIndices::GetCoordinateNames()[i]`
is the name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } PendulumInputIndices;

        // drake::examples::pendulum::PendulumParams
        struct /* PendulumParams */ {

          // drake/examples/pendulum/gen/pendulum_params.h:43
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::pendulum::PendulumParams::CalcInequalityConstraint
          struct /* CalcInequalityConstraint */ {

            // drake/examples/pendulum/gen/pendulum_params.h:118
            const char* doc = R"""()""";

          } CalcInequalityConstraint;

          // drake::examples::pendulum::PendulumParams::DoClone
          struct /* DoClone */ {

            // drake/examples/pendulum/gen/pendulum_params.h:71
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::pendulum::PendulumParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_params.h:98
            const char* doc =
R"""(See PendulumParamsIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::pendulum::PendulumParams::IsValid
          struct /* IsValid */ {

            // drake/examples/pendulum/gen/pendulum_params.h:103
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::pendulum::PendulumParams::PendulumParams<T>
          struct /* ctor */ {

            // drake/examples/pendulum/gen/pendulum_params.h:53
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``mass`` defaults to 1.0 kg. @arg ``length`` defaults to 0.5 m. @arg
``damping`` defaults to 0.1 kg m^2/s. @arg ``gravity`` defaults to
9.81 m/s^2.)""";

          } ctor;

          // drake::examples::pendulum::PendulumParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/pendulum/gen/pendulum_params.h:64
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::pendulum::PendulumParams::damping
          struct /* damping */ {

            // drake/examples/pendulum/gen/pendulum_params.h:88
            const char* doc =
R"""(The damping friction coefficient relating angular velocity to torque.

Note:
    ``damping`` is expressed in units of kg m^2/s.

Note:
    ``damping`` has a limited domain of [0.0, +Inf].)""";

          } damping;

          // drake::examples::pendulum::PendulumParams::gravity
          struct /* gravity */ {

            // drake/examples/pendulum/gen/pendulum_params.h:93
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";

          } gravity;

          // drake::examples::pendulum::PendulumParams::length
          struct /* length */ {

            // drake/examples/pendulum/gen/pendulum_params.h:83
            const char* doc =
R"""(The length of the pendulum arm.

Note:
    ``length`` is expressed in units of m.

Note:
    ``length`` has a limited domain of [0.0, +Inf].)""";

          } length;

          // drake::examples::pendulum::PendulumParams::mass
          struct /* mass */ {

            // drake/examples/pendulum/gen/pendulum_params.h:78
            const char* doc =
R"""(The simple pendulum has a single point mass at the end of the arm.

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";

          } mass;

          // drake::examples::pendulum::PendulumParams::set_damping
          struct /* set_damping */ {

            // drake/examples/pendulum/gen/pendulum_params.h:89
            const char* doc = R"""()""";

          } set_damping;

          // drake::examples::pendulum::PendulumParams::set_gravity
          struct /* set_gravity */ {

            // drake/examples/pendulum/gen/pendulum_params.h:94
            const char* doc = R"""()""";

          } set_gravity;

          // drake::examples::pendulum::PendulumParams::set_length
          struct /* set_length */ {

            // drake/examples/pendulum/gen/pendulum_params.h:84
            const char* doc = R"""()""";

          } set_length;

          // drake::examples::pendulum::PendulumParams::set_mass
          struct /* set_mass */ {

            // drake/examples/pendulum/gen/pendulum_params.h:79
            const char* doc = R"""()""";

          } set_mass;

        } PendulumParams;

        // drake::examples::pendulum::PendulumParamsIndices
        struct /* PendulumParamsIndices */ {

          // drake/examples/pendulum/gen/pendulum_params.h:24
          const char* doc =
R"""(Describes the row indices of a PendulumParams.)""";

          // drake::examples::pendulum::PendulumParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_params.h:38
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`PendulumParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } PendulumParamsIndices;

        // drake::examples::pendulum::PendulumPlant
        struct /* PendulumPlant */ {

          // drake/examples/pendulum/pendulum_plant.h:32
          const char* doc =
R"""(A model of a simple pendulum @f[ ml^2 \ddot\theta + b\dot\theta +
mgl\sin\theta = \tau @f]

@system{PendulumPlant, @input_port{tau}, @output_port{state}
@output_port{geometry pose} }

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

          // drake::examples::pendulum::PendulumPlant::CalcTotalEnergy
          struct /* CalcTotalEnergy */ {

            // drake/examples/pendulum/pendulum_plant.h:67
            const char* doc =
R"""(Calculates the kinetic + potential energy.)""";

          } CalcTotalEnergy;

          // drake::examples::pendulum::PendulumPlant::PendulumPlant<T>
          struct /* ctor */ {

            // drake/examples/pendulum/pendulum_plant.h:34
            const char* doc = R"""()""";

            // drake/examples/pendulum/pendulum_plant.h:34
            const char* doc_2 = R"""()""";

            // drake/examples/pendulum/pendulum_plant.h:36
            const char* doc_3 = R"""()""";

            // drake/examples/pendulum/pendulum_plant.h:40
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::examples::pendulum::PendulumPlant::RegisterGeometry
          struct /* RegisterGeometry */ {

            // drake/examples/pendulum/pendulum_plant.h:59
            const char* doc =
R"""(Registers this system as a source for the SceneGraph, adds the
pendulum geometry, and creates the geometry_pose_output_port for this
system. This must be called before the a SceneGraph's Context is
allocated. It can only be called once.)""";

          } RegisterGeometry;

          // drake::examples::pendulum::PendulumPlant::frame_id
          struct /* frame_id */ {

            // drake/examples/pendulum/pendulum_plant.h:51
            const char* doc = R"""()""";

          } frame_id;

          // drake::examples::pendulum::PendulumPlant::get_geometry_pose_output_port
          struct /* get_geometry_pose_output_port */ {

            // drake/examples/pendulum/pendulum_plant.h:64
            const char* doc =
R"""(Returns the port to output the pose to SceneGraph. Users must call
RegisterGeometry() first to enable this port.)""";

          } get_geometry_pose_output_port;

          // drake::examples::pendulum::PendulumPlant::get_input_port
          struct /* get_input_port */ {

            // drake/examples/pendulum/pendulum_plant.h:45
            const char* doc =
R"""(Returns the input port to the externally applied force.)""";

          } get_input_port;

          // drake::examples::pendulum::PendulumPlant::get_mutable_parameters
          struct /* get_mutable_parameters */ {

            // drake/examples/pendulum/pendulum_plant.h:99
            const char* doc = R"""()""";

          } get_mutable_parameters;

          // drake::examples::pendulum::PendulumPlant::get_mutable_state
          struct /* get_mutable_state */ {

            // drake/examples/pendulum/pendulum_plant.h:84
            const char* doc = R"""()""";

            // drake/examples/pendulum/pendulum_plant.h:89
            const char* doc_2 = R"""()""";

          } get_mutable_state;

          // drake::examples::pendulum::PendulumPlant::get_parameters
          struct /* get_parameters */ {

            // drake/examples/pendulum/pendulum_plant.h:94
            const char* doc = R"""()""";

          } get_parameters;

          // drake::examples::pendulum::PendulumPlant::get_state
          struct /* get_state */ {

            // drake/examples/pendulum/pendulum_plant.h:75
            const char* doc = R"""()""";

            // drake/examples/pendulum/pendulum_plant.h:80
            const char* doc_2 = R"""()""";

          } get_state;

          // drake::examples::pendulum::PendulumPlant::get_state_output_port
          struct /* get_state_output_port */ {

            // drake/examples/pendulum/pendulum_plant.h:48
            const char* doc = R"""(Returns the port to output state.)""";

          } get_state_output_port;

          // drake::examples::pendulum::PendulumPlant::get_tau
          struct /* get_tau */ {

            // drake/examples/pendulum/pendulum_plant.h:71
            const char* doc =
R"""(Evaluates the input port and returns the scalar value of the commanded
torque.)""";

          } get_tau;

          // drake::examples::pendulum::PendulumPlant::source_id
          struct /* source_id */ {

            // drake/examples/pendulum/pendulum_plant.h:50
            const char* doc = R"""()""";

          } source_id;

        } PendulumPlant;

        // drake::examples::pendulum::PendulumState
        struct /* PendulumState */ {

          // drake/examples/pendulum/gen/pendulum_state.h:41
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::pendulum::PendulumState::DoClone
          struct /* DoClone */ {

            // drake/examples/pendulum/gen/pendulum_state.h:63
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::pendulum::PendulumState::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_state.h:80
            const char* doc =
R"""(See PendulumStateIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::pendulum::PendulumState::IsValid
          struct /* IsValid */ {

            // drake/examples/pendulum/gen/pendulum_state.h:85
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::pendulum::PendulumState::PendulumState<T>
          struct /* ctor */ {

            // drake/examples/pendulum/gen/pendulum_state.h:49
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``theta`` defaults to 0.0 radians. @arg ``thetadot`` defaults to 0.0
radians/sec.)""";

          } ctor;

          // drake::examples::pendulum::PendulumState::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/pendulum/gen/pendulum_state.h:58
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::pendulum::PendulumState::set_theta
          struct /* set_theta */ {

            // drake/examples/pendulum/gen/pendulum_state.h:70
            const char* doc = R"""()""";

          } set_theta;

          // drake::examples::pendulum::PendulumState::set_thetadot
          struct /* set_thetadot */ {

            // drake/examples/pendulum/gen/pendulum_state.h:74
            const char* doc = R"""()""";

          } set_thetadot;

          // drake::examples::pendulum::PendulumState::theta
          struct /* theta */ {

            // drake/examples/pendulum/gen/pendulum_state.h:69
            const char* doc =
R"""(The angle of the pendulum.

Note:
    ``theta`` is expressed in units of radians.)""";

          } theta;

          // drake::examples::pendulum::PendulumState::thetadot
          struct /* thetadot */ {

            // drake/examples/pendulum/gen/pendulum_state.h:73
            const char* doc =
R"""(The angular velocity of the pendulum.

Note:
    ``thetadot`` is expressed in units of radians/sec.)""";

          } thetadot;

        } PendulumState;

        // drake::examples::pendulum::PendulumStateIndices
        struct /* PendulumStateIndices */ {

          // drake/examples/pendulum/gen/pendulum_state.h:24
          const char* doc =
R"""(Describes the row indices of a PendulumState.)""";

          // drake::examples::pendulum::PendulumStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/pendulum/gen/pendulum_state.h:36
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words, `PendulumStateIndices::GetCoordinateNames()[i]`
is the name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } PendulumStateIndices;

      } pendulum;

      // rimless_wheel
      struct /* rimless_wheel */ {

        // drake::examples::rimless_wheel::RimlessWheel
        struct /* RimlessWheel */ {

          // drake/examples/rimless_wheel/rimless_wheel.h:43
          const char* doc =
R"""(Dynamical representation of the idealized hybrid dynamics of a
"rimless wheel", as described in
http://underactuated.mit.edu/underactuated.html?chapter=simple_legs In
addition, this model has two additional (discrete) state variables
that are not required in the mathematical model: - the position of the
stance toe along the ramp (helpful for outputting a floating-base
model coordinate, e.g. for visualization), - a boolean indicator for
"double support" (to avoid the numerical challenges of simulation
around the Zeno phenomenon at the standing fixed point).

Inputs: None. Continuous States: theta, thetadot. Discrete States:
stance toe position, double support indicator. Outputs: 0) continuous
(minimal coordinates) state output (theta and thetadot only) 1)
floating-base state output Parameters: mass, length, number of spokes,
etc, are all set as Context parameters using RimlessWheelParams.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.
    Instantiated templates for the following scalar types ``T`` are
    provided: - double - AutoDiffXd)""";

          // drake::examples::rimless_wheel::RimlessWheel::CalcTotalEnergy
          struct /* CalcTotalEnergy */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:126
            const char* doc =
R"""(Calculates the kinetic + potential energy.)""";

          } CalcTotalEnergy;

          // drake::examples::rimless_wheel::RimlessWheel::RimlessWheel<T>
          struct /* ctor */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:45
            const char* doc = R"""()""";

            // drake/examples/rimless_wheel/rimless_wheel.h:45
            const char* doc_2 = R"""()""";

            // drake/examples/rimless_wheel/rimless_wheel.h:48
            const char* doc_3 = R"""(Constructs the plant.)""";

            // drake/examples/rimless_wheel/rimless_wheel.h:52
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::examples::rimless_wheel::RimlessWheel::calc_alpha
          struct /* calc_alpha */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:121
            const char* doc =
R"""(Alpha is half the interleg angle, and is used frequently.)""";

          } calc_alpha;

          // drake::examples::rimless_wheel::RimlessWheel::get_continuous_state
          struct /* get_continuous_state */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:71
            const char* doc = R"""(Access the RimlessWheelContinuousState.)""";

            // drake/examples/rimless_wheel/rimless_wheel.h:78
            const char* doc_2 = R"""(Access the RimlessWheelContinuousState.)""";

          } get_continuous_state;

          // drake::examples::rimless_wheel::RimlessWheel::get_double_support
          struct /* get_double_support */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:106
            const char* doc = R"""()""";

          } get_double_support;

          // drake::examples::rimless_wheel::RimlessWheel::get_floating_base_state_output_port
          struct /* get_floating_base_state_output_port */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:66
            const char* doc =
R"""(Returns reference to the output port that provides a 12 dimensional
state (FloatingBaseType::kRollPitchYaw positions then velocities).
This is useful, e.g., for visualization. θ of the rimless wheel is the
pitch of the floating base (rotation around global y), and downhill
moves toward positive x. As always, we use vehicle coordinates (x-y on
the ground, z is up).)""";

          } get_floating_base_state_output_port;

          // drake::examples::rimless_wheel::RimlessWheel::get_minimal_state_output_port
          struct /* get_minimal_state_output_port */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:56
            const char* doc =
R"""(Return reference to the output port that publishes only [theta,
thetatdot].)""";

          } get_minimal_state_output_port;

          // drake::examples::rimless_wheel::RimlessWheel::get_mutable_continuous_state
          struct /* get_mutable_continuous_state */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:84
            const char* doc =
R"""(Access the mutable RimlessWheelContinuousState.)""";

            // drake/examples/rimless_wheel/rimless_wheel.h:91
            const char* doc_2 =
R"""(Access the mutable RimlessWheelContinuousState.)""";

          } get_mutable_continuous_state;

          // drake::examples::rimless_wheel::RimlessWheel::get_mutable_double_support
          struct /* get_mutable_double_support */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:110
            const char* doc = R"""()""";

          } get_mutable_double_support;

          // drake::examples::rimless_wheel::RimlessWheel::get_mutable_toe_position
          struct /* get_mutable_toe_position */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:101
            const char* doc = R"""()""";

          } get_mutable_toe_position;

          // drake::examples::rimless_wheel::RimlessWheel::get_parameters
          struct /* get_parameters */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:115
            const char* doc = R"""(Access the RimlessWheelParams.)""";

          } get_parameters;

          // drake::examples::rimless_wheel::RimlessWheel::get_toe_position
          struct /* get_toe_position */ {

            // drake/examples/rimless_wheel/rimless_wheel.h:97
            const char* doc = R"""()""";

          } get_toe_position;

        } RimlessWheel;

        // drake::examples::rimless_wheel::RimlessWheelContinuousState
        struct /* RimlessWheelContinuousState */ {

          // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:42
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::DoClone
          struct /* DoClone */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:66
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:86
            const char* doc =
R"""(See RimlessWheelContinuousStateIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::IsValid
          struct /* IsValid */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:91
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::RimlessWheelContinuousState<T>
          struct /* ctor */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:51
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``theta`` defaults to 0.0 radians. @arg ``thetadot`` defaults to 0.0
rad/sec.)""";

          } ctor;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:61
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::set_theta
          struct /* set_theta */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:76
            const char* doc = R"""()""";

          } set_theta;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::set_thetadot
          struct /* set_thetadot */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:80
            const char* doc = R"""()""";

          } set_thetadot;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::theta
          struct /* theta */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:75
            const char* doc =
R"""(The orientation of the stance leg, measured clockwise from the
vertical axis.

Note:
    ``theta`` is expressed in units of radians.)""";

          } theta;

          // drake::examples::rimless_wheel::RimlessWheelContinuousState::thetadot
          struct /* thetadot */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:79
            const char* doc =
R"""(The angular velocity of the stance leg.

Note:
    ``thetadot`` is expressed in units of rad/sec.)""";

          } thetadot;

        } RimlessWheelContinuousState;

        // drake::examples::rimless_wheel::RimlessWheelContinuousStateIndices
        struct /* RimlessWheelContinuousStateIndices */ {

          // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:24
          const char* doc =
R"""(Describes the row indices of a RimlessWheelContinuousState.)""";

          // drake::examples::rimless_wheel::RimlessWheelContinuousStateIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_continuous_state.h:37
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`RimlessWheelContinuousStateIndices::GetCoordinateNames()[i]` is the
name for `BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } RimlessWheelContinuousStateIndices;

        // drake::examples::rimless_wheel::RimlessWheelParams
        struct /* RimlessWheelParams */ {

          // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:44
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::examples::rimless_wheel::RimlessWheelParams::CalcInequalityConstraint
          struct /* CalcInequalityConstraint */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:133
            const char* doc = R"""()""";

          } CalcInequalityConstraint;

          // drake::examples::rimless_wheel::RimlessWheelParams::DoClone
          struct /* DoClone */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:75
            const char* doc = R"""()""";

          } DoClone;

          // drake::examples::rimless_wheel::RimlessWheelParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:112
            const char* doc =
R"""(See RimlessWheelParamsIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::examples::rimless_wheel::RimlessWheelParams::IsValid
          struct /* IsValid */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:117
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::examples::rimless_wheel::RimlessWheelParams::RimlessWheelParams<T>
          struct /* ctor */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:55
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``mass`` defaults to 1.0 kg. @arg ``length`` defaults to 1.0 m. @arg
``gravity`` defaults to 9.81 m/s^2. @arg ``number_of_spokes`` defaults
to 8 integer. @arg ``slope`` defaults to 0.08 radians.)""";

          } ctor;

          // drake::examples::rimless_wheel::RimlessWheelParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:67
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::examples::rimless_wheel::RimlessWheelParams::gravity
          struct /* gravity */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:94
            const char* doc =
R"""(An approximate value for gravitational acceleration.

Note:
    ``gravity`` is expressed in units of m/s^2.

Note:
    ``gravity`` has a limited domain of [0.0, +Inf].)""";

          } gravity;

          // drake::examples::rimless_wheel::RimlessWheelParams::length
          struct /* length */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:89
            const char* doc =
R"""(The length of each spoke.

Note:
    ``length`` is expressed in units of m.

Note:
    ``length`` has a limited domain of [0.0, +Inf].)""";

          } length;

          // drake::examples::rimless_wheel::RimlessWheelParams::mass
          struct /* mass */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:84
            const char* doc =
R"""(The rimless wheel has a single point mass at the hub.

Note:
    ``mass`` is expressed in units of kg.

Note:
    ``mass`` has a limited domain of [0.0, +Inf].)""";

          } mass;

          // drake::examples::rimless_wheel::RimlessWheelParams::number_of_spokes
          struct /* number_of_spokes */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:99
            const char* doc =
R"""(Total number of spokes on the wheel

Note:
    ``number_of_spokes`` is expressed in units of integer.

Note:
    ``number_of_spokes`` has a limited domain of [4, +Inf].)""";

          } number_of_spokes;

          // drake::examples::rimless_wheel::RimlessWheelParams::set_gravity
          struct /* set_gravity */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:95
            const char* doc = R"""()""";

          } set_gravity;

          // drake::examples::rimless_wheel::RimlessWheelParams::set_length
          struct /* set_length */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:90
            const char* doc = R"""()""";

          } set_length;

          // drake::examples::rimless_wheel::RimlessWheelParams::set_mass
          struct /* set_mass */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:85
            const char* doc = R"""()""";

          } set_mass;

          // drake::examples::rimless_wheel::RimlessWheelParams::set_number_of_spokes
          struct /* set_number_of_spokes */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:102
            const char* doc = R"""()""";

          } set_number_of_spokes;

          // drake::examples::rimless_wheel::RimlessWheelParams::set_slope
          struct /* set_slope */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:108
            const char* doc = R"""()""";

          } set_slope;

          // drake::examples::rimless_wheel::RimlessWheelParams::slope
          struct /* slope */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:107
            const char* doc =
R"""(The angle of the ramp on which the rimless wheel is walking.

Note:
    ``slope`` is expressed in units of radians.)""";

          } slope;

        } RimlessWheelParams;

        // drake::examples::rimless_wheel::RimlessWheelParamsIndices
        struct /* RimlessWheelParamsIndices */ {

          // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:24
          const char* doc =
R"""(Describes the row indices of a RimlessWheelParams.)""";

          // drake::examples::rimless_wheel::RimlessWheelParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/examples/rimless_wheel/gen/rimless_wheel_params.h:39
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`RimlessWheelParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } RimlessWheelParamsIndices;

      } rimless_wheel;

      // van_der_pol
      struct /* van_der_pol */ {

        // drake::examples::van_der_pol::VanDerPolOscillator
        struct /* VanDerPolOscillator */ {

          // drake/examples/van_der_pol/van_der_pol.h:30
          const char* doc =
R"""(van der Pol oscillator

The van der Pol oscillator, governed by the following equations: q̈ +
μ(q² - 1)q̇ + q = 0, μ > 0 y₁ = q y₂ = [q,q̇]' is a canonical example
of a nonlinear system that exhibits a limit cycle stability. As such
it serves as an important for examining nonlinear stability and
stochastic stability.

(Examples involving region of attraction analysis and analyzing the
stationary distribution of the oscillator under process noise are
coming soon).

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

          // drake::examples::van_der_pol::VanDerPolOscillator::VanDerPolOscillator<T>
          struct /* ctor */ {

            // drake/examples/van_der_pol/van_der_pol.h:32
            const char* doc = R"""()""";

            // drake/examples/van_der_pol/van_der_pol.h:32
            const char* doc_2 = R"""()""";

            // drake/examples/van_der_pol/van_der_pol.h:34
            const char* doc_3 = R"""()""";

            // drake/examples/van_der_pol/van_der_pol.h:38
            const char* doc_4 = R"""(Scalar-converting copy constructor.)""";

          } ctor;

          // drake::examples::van_der_pol::VanDerPolOscillator::get_full_state_output_port
          struct /* get_full_state_output_port */ {

            // drake/examples/van_der_pol/van_der_pol.h:48
            const char* doc =
R"""(Returns the output port containing the full state. This is provided
primarily as a tool for debugging/visualization.)""";

          } get_full_state_output_port;

          // drake::examples::van_der_pol::VanDerPolOscillator::get_position_output_port
          struct /* get_position_output_port */ {

            // drake/examples/van_der_pol/van_der_pol.h:42
            const char* doc =
R"""(Returns the output port containing the output configuration (only).)""";

          } get_position_output_port;

        } VanDerPolOscillator;

      } van_der_pol;

    } examples;

    // geometry
    struct /* geometry */ {

      // drake::geometry::AnchoredGeometryTag
      struct /* AnchoredGeometryTag */ {

        // drake/geometry/geometry_index.h:12
        const char* doc = R"""()""";

      } AnchoredGeometryTag;

      // drake::geometry::Box
      struct /* Box */ {

        // drake/geometry/shape_specification.h:117
        const char* doc =
R"""(Definition of a box. The box is centered on the origin of its
canonical frame with its dimensions aligned with the frame's axes. The
size of the box is given by three sizes.)""";

        // drake::geometry::Box::Box
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:119
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:119
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:124
          const char* doc_3 =
R"""(Constructs a box with the given `width`, `depth`, and `height`, which
specify the box's dimension along the canonical x-, y-, and z-axes,
respectively.)""";

        } ctor;

        // drake::geometry::Box::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:119
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Box::depth
        struct /* depth */ {

          // drake/geometry/shape_specification.h:130
          const char* doc =
R"""(Returns the box's dimension along the y axis. */)""";

        } depth;

        // drake::geometry::Box::height
        struct /* height */ {

          // drake/geometry/shape_specification.h:133
          const char* doc =
R"""(Returns the box's dimension along the z axis. */)""";

        } height;

        // drake::geometry::Box::size
        struct /* size */ {

          // drake/geometry/shape_specification.h:136
          const char* doc = R"""(Returns the box's dimensions. */)""";

        } size;

        // drake::geometry::Box::width
        struct /* width */ {

          // drake/geometry/shape_specification.h:127
          const char* doc =
R"""(Returns the box's dimension along the x axis. */)""";

        } width;

      } Box;

      // drake::geometry::ConnectDrakeVisualizer
      struct /* ConnectDrakeVisualizer */ {

        // drake/geometry/geometry_visualization.h:72
        const char* doc =
R"""(Extends a Diagram with the required components to interface with
drake_visualizer. This must be called _during_ Diagram building and
uses the given `builder` to add relevant subsystems and connections.

This is a convenience method to simplify some common boilerplate for
adding visualization capability to a Diagram. What it does is: - adds
an initialization event that sends the required load message to set up
the visualizer with the relevant geometry, - adds systems
PoseBundleToDrawMessage and LcmPublisherSystem to the Diagram and
connects the draw message output to the publisher input, - connects
the `scene_graph` pose bundle output to the PoseBundleToDrawMessage
system, and - sets the publishing rate to 1/60 of a second (simulated
time).

You can then connect source output ports for visualization like this:

```
builder->Connect(pose_output_port,
scene_graph.get_source_pose_port(source_id));
```

Note:
    The initialization event occurs when Simulator::Initialize() is
    called (explicitly or implicitly at the start of a simulation). If
    you aren't going to be using a Simulator, use
    DispatchLoadMessage() to send the message yourself.

Parameter ``builder``:
    The diagram builder being used to construct the Diagram.

Parameter ``scene_graph``:
    The System in `builder` containing the geometry to be visualized.

Parameter ``lcm``:
    An optional lcm interface through which lcm messages will be
    dispatched. Will be allocated internally if none is supplied.

@pre This method has not been previously called while building the
builder's current Diagram. @pre The given `scene_graph` must be
contained within the supplied DiagramBuilder.

See also:
    geometry::DispatchLoadMessage())""";

      } ConnectDrakeVisualizer;

      // drake::geometry::Cylinder
      struct /* Cylinder */ {

        // drake/geometry/shape_specification.h:100
        const char* doc =
R"""(Definition of a cylinder. It is centered in its canonical frame with
the length of the cylinder parallel with the frame's z-axis.)""";

        // drake::geometry::Cylinder::Cylinder
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:102
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:102
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:104
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::geometry::Cylinder::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:102
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Cylinder::get_length
        struct /* get_length */ {

          // drake/geometry/shape_specification.h:107
          const char* doc = R"""()""";

        } get_length;

        // drake::geometry::Cylinder::get_radius
        struct /* get_radius */ {

          // drake/geometry/shape_specification.h:106
          const char* doc = R"""()""";

        } get_radius;

      } Cylinder;

      // drake::geometry::DispatchLoadMessage
      struct /* DispatchLoadMessage */ {

        // drake/geometry/geometry_visualization.h:85
        const char* doc =
R"""((Advanced) Explicitly dispatches an LCM load message based on the
registered geometry. Normally this is done automatically at Simulator
initialization. But if you have to do it yourself (likely because you
are not using a Simulator), it should be invoked _after_ registration
is complete. Typically this is used after ConnectDrakeVisualizer() has
been used to add visualization to the Diagram that contains the given
`scene_graph`. The message goes to LCM channel
"DRAKE_VIEWER_LOAD_ROBOT".

See also:
    geometry::ConnectDrakeVisualizer())""";

      } DispatchLoadMessage;

      // drake::geometry::FrameKinematicsVector
      struct /* FrameKinematicsVector */ {

        // drake/geometry/frame_kinematics_vector.h:170
        const char* doc =
R"""(A FrameKinematicsVector is used to report kinematics data for
registered frames (identified by unique FrameId values) to SceneGraph.
It serves as the basis of FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector.

The FrameKinematicsVector must be constructed with the source's
SourceId and the ids of the frames *owned* by the source. Once
constructed, it cannot be resized. Typically, this will be done in the
allocation method of the LeafSystem which serves as a geometry source.

Populating the vector with values is a two-step process: clear and
set. Before writing any kinematics data the vector should be _cleared_
(see clear()). After clearing, each registered frame will have a
kinematics value assigned to it by calling set_value().

Only those frame ids provided in the constructor can be set.
Attempting to set the value for any other frame id is considered an
error. Attempting to write more frames than the vector was constructed
for is considered an error and will throw an exception. Failing to set
data for every registered frame will be considered an error when the
FrameKinematicsVector is consumed by SceneGraph.

<!-- TODO: The FrameVelocityVector and FrameAccelerationVector are
still to come. -->

The usage of this method would be in the allocation and calculation of
a LeafSystem's output port. The nature of the allocation depends on
whether the source id and number of frames are available at
construction or not. The first example shows the case where source id
and frame count are known. The second shows the alternate, deferred
case.

```
template <typename T>
class AllocInConstructorSystem : public LeafSystem<T> {
public:
explicit AllocInConstructorSystem(SourceId source_id)
: source_id_(source_id) {
...
// Register frames, storing ids in frame_ids_
this->DeclareAbstractOutputPort(
FramePoseVector<T>(source_id, frame_ids_),
&AllocInConstructorSystem::CalcFramePoseOutput);
...
}

private:
void CalcFramePoseOutput(const MyContext& context,
geometry::FramePoseVector<T>* poses) const {
DRAKE_DEMAND(poses->source_id() == source_id_);
DRAKE_DEMAND(poses->size() == static_cast<int>(frame_ids_.size()));

poses->clear();
for (int i = 0; i < static_cast<int>(frame_ids_.size()); ++i) {
poses->set_value(frame_ids_[i], poses_[i]);
}
}

SourceId source_id_;
std::vector<FrameId> frame_ids_;
std::vector<Isometry3<T>> poses_;
};
```

__Example 1: Known source id and frame count in constructor.__

```
Definition of FramePoseVector deferred to define number of frames. However,
 it must be defined prior to call to `AllocateContext()`.
template <typename T>
class DeferredAllocationSystem : public LeafSystem<T> {
public:
DeferredAllocationSystem() {
...
this->DeclareAbstractOutputPort(
&DeferredAllocationSystem::AllocateFramePoseOutput,
&DeferredAllocationSystem::CalcFramePoseOutput);
}

private:
geometry::FramePoseVector<T> AllocateFramePoseOutput() const {
// Assume that source_id_ has been assigned and the frames have been
// registered.
DRAKE_DEMAND(source_id_.is_valid());

return geometry::FramePoseVector<T>(source_id_, frame_ids_);
}

void CalcFramePoseOutput(const MyContext& context,
geometry::FramePoseVector<T>* poses) const {
DRAKE_DEMAND(poses->source_id() == source_id_);
DRAKE_DEMAND(poses->size() == static_cast<int>(frame_ids_.size()));

poses->clear();
for (int i = 0; i < static_cast<int>(frame_ids_.size()); ++i) {
poses->set_value(frame_ids_[i], poses_[i]);
}
}

SourceId source_id_;
std::vector<FrameId> frame_ids_;
std::vector<Isometry3<T>> poses_;
};
```

__Example 2: Deferred pose vector allocation.__

Template parameter ``KinematicsValue``:
    The underlying data type of for the order of kinematics data
    (e.g., pose, velocity, or acceleration).

One should never interact with the FrameKinematicsVector class
directly. Instead, the FramePoseVector, FrameVelocityVector, and
FrameAccelerationVector classes are aliases of the
FrameKinematicsVector instantiated on specific data types (Isometry3,
SpatialVector, and SpatialAcceleration, respectively). Each of these
data types are templated on Eigen scalars. All supported combinations
of data type and scalar type are already available to link against in
the containing library. No other values for KinematicsValue are
supported.

Currently, the following data types with the following scalar types
are supported:

Alias | Instantiation | Scalar types -----------------|---------------
---------------------------|-------------- FramePoseVector |
FrameKinematicsVector<Isometry3<Scalar>> | double FramePoseVector |
FrameKinematicsVector<Isometry3<Scalar>> | AutoDiffXd FramePoseVector
| FrameKinematicsVector<Isometry3<Scalar>> | Expression)""";

        // drake::geometry::FrameKinematicsVector::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/frame_kinematics_vector.h:172
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::FrameKinematicsVector::FrameKinematicsVector<KinematicsValue>
        struct /* ctor */ {

          // drake/geometry/frame_kinematics_vector.h:172
          const char* doc = R"""()""";

          // drake/geometry/frame_kinematics_vector.h:172
          const char* doc_2 = R"""()""";

          // drake/geometry/frame_kinematics_vector.h:181
          const char* doc_3 =
R"""(Initializes the vector on the owned ids.

Parameter ``source_id``:
    The source id of the owning geometry source.

Parameter ``ids``:
    The set of *all* frames owned by this geometry source. All of
    these ids must have values provided in the output port calculation
    and _only_ these ids. SceneGraph will validate the ids to confirm
    that they are all owned by the source with the given `source_id`.)""";

        } ctor;

        // drake::geometry::FrameKinematicsVector::clear
        struct /* clear */ {

          // drake/geometry/frame_kinematics_vector.h:184
          const char* doc =
R"""(Initializes the vector to start setting kinematics values. */)""";

        } clear;

        // drake::geometry::FrameKinematicsVector::has_id
        struct /* has_id */ {

          // drake/geometry/frame_kinematics_vector.h:210
          const char* doc =
R"""(Reports true if the given id is a member of this data. */)""";

        } has_id;

        // drake::geometry::FrameKinematicsVector::set_value
        struct /* set_value */ {

          // drake/geometry/frame_kinematics_vector.h:197
          const char* doc =
R"""(Sets the kinematics `value` for the frame indicated by the given `id`.
There are various error conditions which will lead to an exception
being thrown:

1. the id provided is not one of the frame ids provided in the
constructor. 2. clear() hasn't been called. 3. the value for a
particular id is set multiple times between clear() invocations.

If this isn't invoked for _every_ frame id provided at construction,
it will lead to a subsequent exception when SceneGraph consumes the
data.)""";

        } set_value;

        // drake::geometry::FrameKinematicsVector::size
        struct /* size */ {

          // drake/geometry/frame_kinematics_vector.h:203
          const char* doc =
R"""(Returns the constructed size of this vector -- the number of FrameId
values it was constructed with.)""";

        } size;

        // drake::geometry::FrameKinematicsVector::source_id
        struct /* source_id */ {

          // drake/geometry/frame_kinematics_vector.h:199
          const char* doc = R"""()""";

        } source_id;

        // drake::geometry::FrameKinematicsVector::value
        struct /* value */ {

          // drake/geometry/frame_kinematics_vector.h:207
          const char* doc =
R"""(Returns the value associated with the given `id`.

Throws:
    s std::runtime_error if `id` is not in the specified set of ids.)""";

        } value;

      } FrameKinematicsVector;

      // drake::geometry::FrameTag
      struct /* FrameTag */ {

        // drake/geometry/geometry_ids.h:12
        const char* doc = R"""()""";

      } FrameTag;

      // drake::geometry::GeometryContext
      struct /* GeometryContext */ {

        // drake/geometry/geometry_context.h:21
        const char* doc =
R"""(The custom leaf context type for SceneGraph.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/scene_graph.h:29
        const char* doc_2 =
R"""(The custom leaf context type for SceneGraph.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::geometry::GeometryContext::GeometryContext<T>
        struct /* ctor */ {

          // drake/geometry/geometry_context.h:23
          const char* doc = R"""()""";

          // drake/geometry/geometry_context.h:23
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_context.h:26
          const char* doc_3 =
R"""(Constructs the context with the given index for the geometry state. */)""";

        } ctor;

        // drake::geometry::GeometryContext::get_geometry_state
        struct /* get_geometry_state */ {

          // drake/geometry/geometry_context.h:32
          const char* doc =
R"""(Returns a const reference of the underlying geometry state. */)""";

        } get_geometry_state;

        // drake::geometry::GeometryContext::get_mutable_geometry_state
        struct /* get_mutable_geometry_state */ {

          // drake/geometry/geometry_context.h:29
          const char* doc =
R"""(Returns a mutable reference of the underlying geometry state. */)""";

        } get_mutable_geometry_state;

      } GeometryContext;

      // drake::geometry::GeometryFrame
      struct /* GeometryFrame */ {

        // drake/geometry/geometry_frame.h:31
        const char* doc =
R"""(This simple class carries the definition of a frame used in the
SceneGraph. To register moving frames with SceneGraph (see
SceneGraph::RegisterFrame()), a geometry source (see
SceneGraph::RegisterSource()) instantiates a frame and passes
ownership over to SceneGraph.

A frame is defined by three pieces of information: - the name, which
must be unique within a single geometry source, - the "frame group",
an integer identifier that can be used to group frames together within
a geometry source, and - the initial pose of the frame (measured and
expressed in its parent frame). The parent is defined at registration.
This is only the _initial_ pose; registered frames are expected to
move with time.

@internal The "frame group" is intended as a generic synonym for the
model instance id defined by the RigidBodyTree and used again in
automotive to serve as unique car identifiers.

See also:
    SceneGraph)""";

        // drake/geometry/geometry_state.h:70
        const char* doc_2 =
R"""(This simple class carries the definition of a frame used in the
SceneGraph. To register moving frames with SceneGraph (see
SceneGraph::RegisterFrame()), a geometry source (see
SceneGraph::RegisterSource()) instantiates a frame and passes
ownership over to SceneGraph.

A frame is defined by three pieces of information: - the name, which
must be unique within a single geometry source, - the "frame group",
an integer identifier that can be used to group frames together within
a geometry source, and - the initial pose of the frame (measured and
expressed in its parent frame). The parent is defined at registration.
This is only the _initial_ pose; registered frames are expected to
move with time.

@internal The "frame group" is intended as a generic synonym for the
model instance id defined by the RigidBodyTree and used again in
automotive to serve as unique car identifiers.

See also:
    SceneGraph)""";

        // drake::geometry::GeometryFrame::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/geometry_frame.h:33
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::GeometryFrame::GeometryFrame
        struct /* ctor */ {

          // drake/geometry/geometry_frame.h:33
          const char* doc = R"""()""";

          // drake/geometry/geometry_frame.h:33
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_frame.h:41
          const char* doc_3 =
R"""(Constructor.

Parameter ``frame_name``:
    The name of the frame.

Parameter ``X_PF``:
    The initial pose of this frame F, measured and expressed in the
    _intended_ parent frame P.

Parameter ``frame_group_id``:
    The optional frame group identifier. If unspecified, defaults to
    the common, 0 group.)""";

        } ctor;

        // drake::geometry::GeometryFrame::frame_group
        struct /* frame_group */ {

          // drake/geometry/geometry_frame.h:59
          const char* doc = R"""()""";

        } frame_group;

        // drake::geometry::GeometryFrame::id
        struct /* id */ {

          // drake/geometry/geometry_frame.h:53
          const char* doc =
R"""(Returns the globally unique id for this geometry specification. Every
instantiation of FrameInstance will contain a unique id value. The id
value is preserved across copies. After successfully registering this
FrameInstance, this id will serve as the identifier for the registered
representation as well.)""";

        } id;

        // drake::geometry::GeometryFrame::name
        struct /* name */ {

          // drake/geometry/geometry_frame.h:55
          const char* doc = R"""()""";

        } name;

        // drake::geometry::GeometryFrame::pose
        struct /* pose */ {

          // drake/geometry/geometry_frame.h:57
          const char* doc = R"""()""";

        } pose;

      } GeometryFrame;

      // drake::geometry::GeometryInstance
      struct /* GeometryInstance */ {

        // drake/geometry/geometry_instance.h:77
        const char* doc =
R"""(A geometry instance combines a geometry definition (i.e., a shape of
some sort), a pose (relative to a parent "frame" P), material
information, and an opaque collection of metadata. The parent frame
can be a registered frame or another registered geometry.

Every GeometryInstance must be named. The naming convention mirrors
that of valid names in SDF files. Specifically, any user-specified
name will have all leading and trailing space and tab characters
trimmed off. The trimmed name will have to satisfy the following
requirements: - cannot be empty, and - the name should be unique in
the scope of its frame and role. For example, two GeometryInstances
can both be called "ball" as long as they are affixed to different
frames or if one is a collision geometry and the other is a visual
geometry. This requirement is not *currently* enforced but will be
enforced in the future. <!-- TODO(SeanCurtis-TRI): When geometry roles
lands, change this to indicate that this is enforced. --> If valid,
the trimmed name will be assigned to the instance.

Names *can* have internal whitespace (e.g., "my geometry name").

@anchor canonicalized_geometry_names <h3>Canonicalized names</h3>

The silent transformation of a user-defined name to canonical name
mirrors that of specifying geometry names in an SDF file. Consider the
following SDF snippet:

```
{xml}
...
<visual name="  visual">
<geometry>
<sphere>
<radius>1.0</radius>
</sphere>
</geometry>
</visual>
...
```

The name has two leading whitespace characters. The parsing process
will consider this name as equivalent to "visual" and tests for
uniqueness and non-emptiness will be applied to that trimmed result.
The following code has an analogous effect:

```
scene_graph->RegisterGeometry(
source_id, frame_id,
make_unique<GeometryInstance>(pose, make_unique<Sphere>(1.0), "  visual"));
```

The specified name includes leading whitespace. That name will be
trimmed and the *result* will be stored in the GeometryInstance (to be
later validated by SceneGraph as part of geometry registration).
Querying the instance of its name will return this *canonicalized*
name.

<!-- Note to developers: The sdf requirements for naming are captured
in a unit test in `scene_graph_parser_detail_test.cc. See test
VisualGeometryNameRequirements and keep those tests and this list in
sync. -->)""";

        // drake/geometry/geometry_state.h:72
        const char* doc_2 =
R"""(A geometry instance combines a geometry definition (i.e., a shape of
some sort), a pose (relative to a parent "frame" P), material
information, and an opaque collection of metadata. The parent frame
can be a registered frame or another registered geometry.

Every GeometryInstance must be named. The naming convention mirrors
that of valid names in SDF files. Specifically, any user-specified
name will have all leading and trailing space and tab characters
trimmed off. The trimmed name will have to satisfy the following
requirements: - cannot be empty, and - the name should be unique in
the scope of its frame and role. For example, two GeometryInstances
can both be called "ball" as long as they are affixed to different
frames or if one is a collision geometry and the other is a visual
geometry. This requirement is not *currently* enforced but will be
enforced in the future. <!-- TODO(SeanCurtis-TRI): When geometry roles
lands, change this to indicate that this is enforced. --> If valid,
the trimmed name will be assigned to the instance.

Names *can* have internal whitespace (e.g., "my geometry name").

@anchor canonicalized_geometry_names <h3>Canonicalized names</h3>

The silent transformation of a user-defined name to canonical name
mirrors that of specifying geometry names in an SDF file. Consider the
following SDF snippet:

```
{xml}
...
<visual name="  visual">
<geometry>
<sphere>
<radius>1.0</radius>
</sphere>
</geometry>
</visual>
...
```

The name has two leading whitespace characters. The parsing process
will consider this name as equivalent to "visual" and tests for
uniqueness and non-emptiness will be applied to that trimmed result.
The following code has an analogous effect:

```
scene_graph->RegisterGeometry(
source_id, frame_id,
make_unique<GeometryInstance>(pose, make_unique<Sphere>(1.0), "  visual"));
```

The specified name includes leading whitespace. That name will be
trimmed and the *result* will be stored in the GeometryInstance (to be
later validated by SceneGraph as part of geometry registration).
Querying the instance of its name will return this *canonicalized*
name.

<!-- Note to developers: The sdf requirements for naming are captured
in a unit test in `scene_graph_parser_detail_test.cc. See test
VisualGeometryNameRequirements and keep those tests and this list in
sync. -->)""";

        // drake/geometry/scene_graph.h:26
        const char* doc_3 =
R"""(A geometry instance combines a geometry definition (i.e., a shape of
some sort), a pose (relative to a parent "frame" P), material
information, and an opaque collection of metadata. The parent frame
can be a registered frame or another registered geometry.

Every GeometryInstance must be named. The naming convention mirrors
that of valid names in SDF files. Specifically, any user-specified
name will have all leading and trailing space and tab characters
trimmed off. The trimmed name will have to satisfy the following
requirements: - cannot be empty, and - the name should be unique in
the scope of its frame and role. For example, two GeometryInstances
can both be called "ball" as long as they are affixed to different
frames or if one is a collision geometry and the other is a visual
geometry. This requirement is not *currently* enforced but will be
enforced in the future. <!-- TODO(SeanCurtis-TRI): When geometry roles
lands, change this to indicate that this is enforced. --> If valid,
the trimmed name will be assigned to the instance.

Names *can* have internal whitespace (e.g., "my geometry name").

@anchor canonicalized_geometry_names <h3>Canonicalized names</h3>

The silent transformation of a user-defined name to canonical name
mirrors that of specifying geometry names in an SDF file. Consider the
following SDF snippet:

```
{xml}
...
<visual name="  visual">
<geometry>
<sphere>
<radius>1.0</radius>
</sphere>
</geometry>
</visual>
...
```

The name has two leading whitespace characters. The parsing process
will consider this name as equivalent to "visual" and tests for
uniqueness and non-emptiness will be applied to that trimmed result.
The following code has an analogous effect:

```
scene_graph->RegisterGeometry(
source_id, frame_id,
make_unique<GeometryInstance>(pose, make_unique<Sphere>(1.0), "  visual"));
```

The specified name includes leading whitespace. That name will be
trimmed and the *result* will be stored in the GeometryInstance (to be
later validated by SceneGraph as part of geometry registration).
Querying the instance of its name will return this *canonicalized*
name.

<!-- Note to developers: The sdf requirements for naming are captured
in a unit test in `scene_graph_parser_detail_test.cc. See test
VisualGeometryNameRequirements and keep those tests and this list in
sync. -->)""";

        // drake::geometry::GeometryInstance::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/geometry_instance.h:79
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::GeometryInstance::GeometryInstance
        struct /* ctor */ {

          // drake/geometry/geometry_instance.h:79
          const char* doc = R"""()""";

          // drake/geometry/geometry_instance.h:79
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_instance.h:88
          const char* doc_3 =
R"""(Constructor with default visual material (see VisualMaterial default
constructor for details on what that color is).

Parameter ``X_PG``:
    The pose of this geometry (`G`) in its parent's frame (`P`).

Parameter ``shape``:
    The underlying shape for this geometry instance.

Parameter ``name``:
    The name of the geometry (must satisfy the name requirements).

Throws:
    s std::logic_error if the canonicalized version of `name` is
    empty.)""";

          // drake/geometry/geometry_instance.h:97
          const char* doc_4 =
R"""(Constructor.

Parameter ``X_PG``:
    The pose of this geometry (`G`) in its parent's frame (`P`).

Parameter ``shape``:
    The underlying shape for this geometry instance.

Parameter ``name``:
    The name of the geometry (must satisfy the name requirements).

Parameter ``vis_material``:
    The visual material to apply to this geometry.

Throws:
    s std::logic_error if the canonicalized version of `name` is
    empty.)""";

        } ctor;

        // drake::geometry::GeometryInstance::id
        struct /* id */ {

          // drake/geometry/geometry_instance.h:106
          const char* doc =
R"""(Returns the globally unique id for this geometry specification. Every
instantiation of GeometryInstance will contain a unique id value. The
id value is preserved across copies. After successfully registering
this GeometryInstance, this id will serve as the identifier for the
registered representation as well.)""";

        } id;

        // drake::geometry::GeometryInstance::name
        struct /* name */ {

          // drake/geometry/geometry_instance.h:122
          const char* doc =
R"""(Returns the *canonicalized* name for the instance. */)""";

        } name;

        // drake::geometry::GeometryInstance::pose
        struct /* pose */ {

          // drake/geometry/geometry_instance.h:108
          const char* doc = R"""()""";

        } pose;

        // drake::geometry::GeometryInstance::release_shape
        struct /* release_shape */ {

          // drake/geometry/geometry_instance.h:117
          const char* doc =
R"""(Releases the shape from the instance. */)""";

        } release_shape;

        // drake::geometry::GeometryInstance::set_pose
        struct /* set_pose */ {

          // drake/geometry/geometry_instance.h:109
          const char* doc = R"""()""";

        } set_pose;

        // drake::geometry::GeometryInstance::shape
        struct /* shape */ {

          // drake/geometry/geometry_instance.h:111
          const char* doc = R"""()""";

        } shape;

        // drake::geometry::GeometryInstance::visual_material
        struct /* visual_material */ {

          // drake/geometry/geometry_instance.h:119
          const char* doc = R"""()""";

        } visual_material;

      } GeometryInstance;

      // drake::geometry::GeometryPoseTag
      struct /* GeometryPoseTag */ {

        // drake/geometry/geometry_index.h:15
        const char* doc = R"""()""";

      } GeometryPoseTag;

      // drake::geometry::GeometrySet
      struct /* GeometrySet */ {

        // drake/geometry/geometry_set.h:32
        const char* doc =
R"""(The GeometrySet, as its name implies, is a convenience class for
defining a set of geometries. What makes it unique from a simple
`std::set<GeometryId>` instance is that membership doesn't require
explicit GeometryId enumeration; GeometryId values can be added to the
set by adding the `FrameId` for the frame to which the geometries are
rigidly affixed.

This class does no validation; it is a simple collection. Ultimately,
it serves as the operand of SceneGraph operations (e.g.,
SceneGraph::ExcludeCollisionsWithin()). If the _operation_ has a
particular prerequisite on the members of a GeometrySet, it is the
operation's responsibility to enforce that requirement.

More formally, the SceneGraph consists of a set of geometries, each
associated with a unique identifier. As such, we can consider the set
of all identifiers `SG = {g₀, g₁, ..., gₙ}` that belong to a
SceneGraph. A GeometrySet should represent a subset of those
identifiers, `Gₛ ⊆ SG`. The convenience of the GeometrySet class is
_how_ the subset is defined. Given a set of frame ids `F = {f₀, f₁,
..., fₙ}` and geometry ids `G = {g₀, g₁, ..., gₘ}`, `Gₛ = G ⋃
geometry(f₀) ⋃ ... ⋃ geometry(fₙ)` (where `geometry(f)` is the set of
geometries rigidly affixed to frame f).)""";

        // drake::geometry::GeometrySet::Add
        struct /* Add */ {

          // drake/geometry/geometry_set.h:183
          const char* doc = R"""()""";

          // drake/geometry/geometry_set.h:185
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_set.h:190
          const char* doc_3 = R"""()""";

          // drake/geometry/geometry_set.h:197
          const char* doc_4 = R"""()""";

          // drake/geometry/geometry_set.h:201
          const char* doc_5 = R"""()""";

          // drake/geometry/geometry_set.h:205
          const char* doc_6 = R"""()""";

          // drake/geometry/geometry_set.h:213
          const char* doc_7 = R"""()""";

          // drake/geometry/geometry_set.h:221
          const char* doc_8 = R"""()""";

          // drake/geometry/geometry_set.h:229
          const char* doc_9 = R"""()""";

        } Add;

        // drake::geometry::GeometrySet::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/geometry_set.h:34
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::GeometrySet::GeometrySet
        struct /* ctor */ {

          // drake/geometry/geometry_set.h:34
          const char* doc = R"""()""";

          // drake/geometry/geometry_set.h:34
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_set.h:36
          const char* doc_3 = R"""()""";

          // drake/geometry/geometry_set.h:108
          const char* doc_4 = R"""()""";

          // drake/geometry/geometry_set.h:110
          const char* doc_5 = R"""()""";

          // drake/geometry/geometry_set.h:113
          const char* doc_6 = R"""()""";

          // drake/geometry/geometry_set.h:120
          const char* doc_7 = R"""()""";

          // drake/geometry/geometry_set.h:125
          const char* doc_8 = R"""()""";

          // drake/geometry/geometry_set.h:132
          const char* doc_9 = R"""()""";

          // drake/geometry/geometry_set.h:138
          const char* doc_10 = R"""()""";

        } ctor;

        // drake::geometry::GeometrySet::contains
        struct /* contains */ {

          // drake/geometry/geometry_set.h:252
          const char* doc =
R"""(Reports if the given `frame_id` has been added to the group. */)""";

          // drake/geometry/geometry_set.h:256
          const char* doc_2 =
R"""(Reports if the given `geometry_id` has been *explicitly* added to the
group. It will *not* capture geometry ids affixed to added frames.)""";

        } contains;

        // drake::geometry::GeometrySet::frames
        struct /* frames */ {

          // drake/geometry/geometry_set.h:237
          const char* doc = R"""(Returns the frame ids in the set. */)""";

        } frames;

        // drake::geometry::GeometrySet::geometries
        struct /* geometries */ {

          // drake/geometry/geometry_set.h:243
          const char* doc = R"""(Returns the geometry ids in the set. */)""";

        } geometries;

        // drake::geometry::GeometrySet::num_frames
        struct /* num_frames */ {

          // drake/geometry/geometry_set.h:240
          const char* doc =
R"""(Reports the number of frames in the set. */)""";

        } num_frames;

        // drake::geometry::GeometrySet::num_geometries
        struct /* num_geometries */ {

          // drake/geometry/geometry_set.h:249
          const char* doc =
R"""(Reports the number of geometries _explicitly_ in the set. It does
_not_ count the geometries that belong to the added frames.)""";

        } num_geometries;

      } GeometrySet;

      // drake::geometry::GeometryState
      struct /* GeometryState */ {

        // drake/geometry/geometry_state.h:101
        const char* doc =
R"""(The context-dependent state of SceneGraph. This serves as an
AbstractValue in the context. SceneGraph's time-dependent state
includes more than just values; objects can be added to or removed
from the world over time. Therefore, SceneGraph's context-dependent
state includes values (the poses) and structure (the topology of the
world).

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/proximity_engine.h:17
        const char* doc_2 =
R"""(The context-dependent state of SceneGraph. This serves as an
AbstractValue in the context. SceneGraph's time-dependent state
includes more than just values; objects can be added to or removed
from the world over time. Therefore, SceneGraph's context-dependent
state includes values (the poses) and structure (the topology of the
world).

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::geometry::GeometryState::BelongsToSource
        struct /* BelongsToSource */ {

          // drake/geometry/geometry_state.h:387
          const char* doc =
R"""(Reports if the given frame id was registered to the given source id.

Parameter ``frame_id``:
    The query frame id.

Parameter ``source_id``:
    The query source id.

Returns:
    True if `frame_id` was registered on `source_id`.

Throws:
    s std::logic_error If the `frame_id` does _not_ map to a frame or
    the identified source is not registered.)""";

          // drake/geometry/geometry_state.h:397
          const char* doc_2 =
R"""(Reports if the given geometry id was ultimately registered to the
given source id.

Parameter ``geometry_id``:
    The query geometry id.

Parameter ``source_id``:
    The query source id.

Returns:
    True if `geometry_id` was registered on `source_id`.

Throws:
    s std::logic_error If the `geometry_id` does _not_ map to a valid
    geometry or the identified source is not registered)""";

        } BelongsToSource;

        // drake::geometry::GeometryState::ComputePointPairPenetration
        struct /* ComputePointPairPenetration */ {

          // drake/geometry/geometry_state.h:426
          const char* doc =
R"""(See QueryObject::ComputePointPairPenetration() for documentation. */)""";

        } ComputePointPairPenetration;

        // drake::geometry::GeometryState::ComputeSignedDistancePairwiseClosestPoints
        struct /* ComputeSignedDistancePairwiseClosestPoints */ {

          // drake/geometry/geometry_state.h:482
          const char* doc =
R"""(Computes the signed distance together with the witness points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries.

Returns ``witness_pairs``:
    A vector of reporting the signed distance characterized as witness
    point pairs. Notice that this is an O(N²) operation, where N is
    the number of geometries in the world. We report the distance
    between dynamic objects, or between a dynamic object and an
    anchored object. We DO NOT report the distance between two
    anchored objects.)""";

        } ComputeSignedDistancePairwiseClosestPoints;

        // drake::geometry::GeometryState::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/geometry_state.h:103
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::GeometryState::ExcludeCollisionsBetween
        struct /* ExcludeCollisionsBetween */ {

          // drake/geometry/geometry_state.h:459
          const char* doc =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set `C = C - P`, where `P = {(a, b)}, ∀ a ∈ A, b ∈ B`
and `A = {a₀, a₁, ..., aₘ}` and `B = {b₀, b₁, ..., bₙ}` are the input
sets of geometries `setA` and `setB`, respectively. This does _not_
preclude collisions between members of the _same_ set.

Throws:
    s std::logic_error if the groups include ids that don't exist in
    the scene graph.)""";

        } ExcludeCollisionsBetween;

        // drake::geometry::GeometryState::ExcludeCollisionsWithin
        struct /* ExcludeCollisionsWithin */ {

          // drake/geometry/geometry_state.h:449
          const char* doc =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set `C = C - P`, where `P = {(gᵢ, gⱼ)}, ∀ gᵢ, gⱼ ∈ G`
and `G = {g₀, g₁, ..., gₘ}` is the input `set` of geometries.

Throws:
    s std::logic_error if the set includes ids that don't exist in the
    scene graph.)""";

        } ExcludeCollisionsWithin;

        // drake::geometry::GeometryState::GeometryState<T>
        struct /* ctor */ {

          // drake/geometry/geometry_state.h:103
          const char* doc = R"""()""";

          // drake/geometry/geometry_state.h:103
          const char* doc_2 = R"""()""";

          // drake/geometry/geometry_state.h:111
          const char* doc_3 = R"""(Default constructor. */)""";

        } ctor;

        // drake::geometry::GeometryState::GetFrameId
        struct /* GetFrameId */ {

          // drake/geometry/geometry_state.h:404
          const char* doc =
R"""(Retrieves the frame id on which the given geometry id is registered.

Parameter ``geometry_id``:
    The query geometry id.

Returns:
    An optional FrameId based on a successful lookup.

Throws:
    s std::logic_error If the `geometry_id` does _not_ map to a
    geometry which belongs to an existing frame.)""";

        } GetFrameId;

        // drake::geometry::GeometryState::GetFramesForSource
        struct /* GetFramesForSource */ {

          // drake/geometry/geometry_state.h:411
          const char* doc =
R"""(Returns the set of frames registered to the given source.

Parameter ``source_id``:
    The identifier of the source to query.

Returns:
    The set of frames associated with the id.

Throws:
    s std::logic_error If the `source_id` does _not_ map to a
    registered source.)""";

        } GetFramesForSource;

        // drake::geometry::GeometryState::GetGeometryFromName
        struct /* GetGeometryFromName */ {

          // drake/geometry/geometry_state.h:205
          const char* doc =
R"""(Reports the id for the uniquely named geometry affixed to the
indicated frame.

Parameter ``frame_id``:
    The id of the parent frame.

Parameter ``name``:
    The name of the geometry to query for. The name will be
    canonicalized prior to lookup (see canonicalized_geometry_names
    "GeometryInstance" for details).

Returns:
    The id of the requested frame.

Throws:
    s std::logic_error if no such geometry exists, multiple geometries
    have that name, or if the frame doesn't exist.)""";

        } GetGeometryFromName;

        // drake::geometry::GeometryState::GetPoseInFrame
        struct /* GetPoseInFrame */ {

          // drake/geometry/geometry_state.h:240
          const char* doc =
R"""(Reports the pose, relative to the registered _frame_, for the geometry
the given identifier refers to.

Parameter ``geometry_id``:
    The id of the queried geometry.

Returns:
    The geometry's pose relative to its frame.

Throws:
    s std::logic_error If the `geometry_id` does _not_ map to a valid
    GeometryInstance.)""";

        } GetPoseInFrame;

        // drake::geometry::GeometryState::GetPoseInParent
        struct /* GetPoseInParent */ {

          // drake/geometry/geometry_state.h:249
          const char* doc =
R"""(Reports the pose of identified dynamic geometry, relative to its
registered parent. If the geometry was registered directly to a frame,
this _must_ produce the same pose as GetPoseInFrame().

Parameter ``geometry_id``:
    The id of the queried geometry.

Returns:
    The geometry's pose relative to its registered parent.

Throws:
    s std::logic_error If the `geometry_id` does _not_ map to a valid
    GeometryInstance.)""";

        } GetPoseInParent;

        // drake::geometry::GeometryState::IsValidGeometryName
        struct /* IsValidGeometryName */ {

          // drake/geometry/geometry_state.h:370
          const char* doc =
R"""(Reports whether the canonicalized version of the given candidate
geometry name is considered valid. This tests the requirements
described in the documentation of canonicalized_geometry_names
"GeometryInstance". When adding a geometry to a frame, if there is
doubt if a proposed name is valid, the name can be tested prior to
registering the geometry.

Parameter ``frame_id``:
    The id of the frame to which the geometry would be assigned.

Parameter ``candidate_name``:
    The name to validate.

Returns:
    true if the `candidate_name` can be given to a `GeometryInstance`
    assigned to the indicated frame.

Throws:
    s if `frame_id` does not refer to a valid frame.)""";

        } IsValidGeometryName;

        // drake::geometry::GeometryState::RegisterAnchoredGeometry
        struct /* RegisterAnchoredGeometry */ {

          // drake/geometry/geometry_state.h:355
          const char* doc =
R"""(Registers a GeometryInstance with the state as anchored geometry. This
registers geometry which "hangs" from the world frame and never moves.
The `geometry`'s pose value is relative to the world frame. The state
takes ownership of the geometry and associates it with the given
source. Returns the new identifier for the GeometryInstance.

Parameter ``source_id``:
    The id of the source on which the geometry is being declared.

Parameter ``geometry``:
    The geometry to get the id for. The state takes ownership of the
    geometry.

Returns:
    A newly allocated geometry id.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. `geometry` has a previously registered id,
    or 3. the geometry's name doesn't satisfy the requirements
    outlined in GeometryInstance.)""";

        } RegisterAnchoredGeometry;

        // drake::geometry::GeometryState::RegisterFrame
        struct /* RegisterFrame */ {

          // drake/geometry/geometry_state.h:280
          const char* doc =
R"""(Registers a new frame for the given source, the id of the new frame is
returned.

Parameter ``source_id``:
    The id of the source for which this frame is allocated.

Parameter ``frame``:
    The frame to register.

Returns:
    A newly allocated frame id.

Throws:
    s std::logic_error If the `source_id` does _not_ map to a
    registered source, or `frame` has an id that has already been
    registered.)""";

          // drake/geometry/geometry_state.h:294
          const char* doc_2 =
R"""(Registers a new frame for the given source as a child of a previously
registered frame. The id of the new frame is returned.

Parameter ``source_id``:
    The id of the source for which this frame is allocated.

Parameter ``parent_id``:
    The id of the parent frame.

Parameter ``frame``:
    The frame to register.

Returns:
    A newly allocated frame id.

Throws:
    s std::logic_error 1. If the `source_id` does _not_ map to a
    registered source, 2. If the `parent_id` does _not_ map to a known
    frame or does not belong to the source, or 3. `frame` has an id
    that has already been registered)""";

        } RegisterFrame;

        // drake::geometry::GeometryState::RegisterGeometry
        struct /* RegisterGeometry */ {

          // drake/geometry/geometry_state.h:313
          const char* doc =
R"""(Registers a GeometryInstance with the state. The state takes ownership
of the geometry and associates it with the given frame and source.
Returns the new identifier for the successfully registered
GeometryInstance.

Parameter ``source_id``:
    The id of the source to which the frame and geometry belongs.

Parameter ``frame_id``:
    The id of the frame on which the geometry is to hang.

Parameter ``geometry``:
    The geometry to get the id for. The state takes ownership of the
    geometry.

Returns:
    A newly allocated geometry id.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. the `frame_id` doesn't belong to the source,
    3. the `geometry` is equal to `nullptr`, 4. `geometry` has a
    previously registered id, or 5. the geometry's name doesn't
    satisfy the requirements outlined in GeometryInstance.)""";

        } RegisterGeometry;

        // drake::geometry::GeometryState::RegisterGeometryWithParent
        struct /* RegisterGeometryWithParent */ {

          // drake/geometry/geometry_state.h:336
          const char* doc =
R"""(Registers a GeometryInstance with the state. Rather than hanging
directly from a _frame_, the instance hangs on another geometry
instance. The input `geometry` instance's pose is assumed to be
relative to that parent geometry instance. The state takes ownership
of the geometry and associates it with the given geometry parent (and,
ultimately, the parent geometry's frame) and source. Returns the new
identifier for the successfully registered GeometryInstance.

Parameter ``source_id``:
    The id of the source on which the geometry is being declared.

Parameter ``geometry_id``:
    The parent geometry for this geometry.

Parameter ``geometry``:
    The geometry to get the id for. The state takes ownership of the
    geometry.

Returns:
    A newly allocated geometry id.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. the `geometry_id` doesn't belong to the
    source, 3. the `geometry` is equal to `nullptr`, 4. `geometry` has
    a previously registered id, or 5. the geometry's name doesn't
    satisfy the requirements outlined in GeometryInstance.)""";

        } RegisterGeometryWithParent;

        // drake::geometry::GeometryState::RegisterNewSource
        struct /* RegisterNewSource */ {

          // drake/geometry/geometry_state.h:270
          const char* doc =
R"""(Registers a new, named source into the state.

Parameter ``name``:
    The optional name of the source. If none or the empty string is
    provided it will be named "Source_##" where the number is the
    value of the returned SourceId.

Throws:
    s std::logic_error is thrown if the name is _not_ unique.)""";

        } RegisterNewSource;

        // drake::geometry::GeometryState::ToAutoDiffXd
        struct /* ToAutoDiffXd */ {

          // drake/geometry/geometry_state.h:495
          const char* doc =
R"""(Returns a deep copy of this state using the AutoDiffXd scalar with all
scalar values initialized from the current values. If this is invoked
on an instance already instantiated on AutoDiffXd, it is equivalent to
cloning the instance.)""";

        } ToAutoDiffXd;

        // drake::geometry::GeometryState::get_frame_group
        struct /* get_frame_group */ {

          // drake/geometry/geometry_state.h:179
          const char* doc =
R"""(Reports the frame group for the given frame.

Parameter ``frame_id``:
    The identifier of the queried frame.

Returns:
    The frame group of the identified frame.

Throws:
    s std::logic_error if the frame id is not valid. @internal This is
    equivalent to the old "model instance id".)""";

        } get_frame_group;

        // drake::geometry::GeometryState::get_frame_ids
        struct /* get_frame_ids */ {

          // drake/geometry/geometry_state.h:170
          const char* doc =
R"""(Provides a range object for all of the frame ids in the world. The
order is not generally guaranteed; but it will be consistent as long
as there are no changes to the topology. This is intended to be used
as:

```
for (FrameId id : state.get_frame_ids()) {
...
}
```)""";

        } get_frame_ids;

        // drake::geometry::GeometryState::get_frame_name
        struct /* get_frame_name */ {

          // drake/geometry/geometry_state.h:185
          const char* doc =
R"""(Reports the name of the frame.

Parameter ``frame_id``:
    The identifier of the queried frame.

Returns:
    The name of the identified frame.

Throws:
    s std::logic_error if the frame id is not valid.)""";

        } get_frame_name;

        // drake::geometry::GeometryState::get_geometry_ids
        struct /* get_geometry_ids */ {

          // drake/geometry/geometry_state.h:158
          const char* doc =
R"""(The set of all dynamic geometries registered to the world. The order
is _not_ guaranteed to have any particular semantic meaning. But the
order is guaranteed to remain fixed between topological changes (e.g.,
removal or addition of geometry/frames).)""";

        } get_geometry_ids;

        // drake::geometry::GeometryState::get_name
        struct /* get_name */ {

          // drake/geometry/geometry_state.h:192
          const char* doc =
R"""(Reports the stored, canonical name of the geometry (see
canonicalized_geometry_names "GeometryInstance" for details).

Parameter ``geometry_id``:
    The identifier of the queried geometry.

Returns:
    The name of the identified geometry.

Throws:
    s std::logic_error if the geometry id is not valid.)""";

        } get_name;

        // drake::geometry::GeometryState::get_num_anchored_geometries
        struct /* get_num_anchored_geometries */ {

          // drake/geometry/geometry_state.h:147
          const char* doc =
R"""(Reports the total number of _anchored_ geometries. */)""";

        } get_num_anchored_geometries;

        // drake::geometry::GeometryState::get_num_frames
        struct /* get_num_frames */ {

          // drake/geometry/geometry_state.h:139
          const char* doc =
R"""(Reports the total number of frames -- across all sources. */)""";

        } get_num_frames;

        // drake::geometry::GeometryState::get_num_geometries
        struct /* get_num_geometries */ {

          // drake/geometry/geometry_state.h:142
          const char* doc =
R"""(Reports the total number of _dynamic_ geometries. */)""";

        } get_num_geometries;

        // drake::geometry::GeometryState::get_num_sources
        struct /* get_num_sources */ {

          // drake/geometry/geometry_state.h:134
          const char* doc =
R"""(Reports the number of registered sources -- whether they have frames
or not.)""";

        } get_num_sources;

        // drake::geometry::GeometryState::get_pose_in_parent
        struct /* get_pose_in_parent */ {

          // drake/geometry/geometry_state.h:226
          const char* doc =
R"""(Reports the pose of the frame with the given id relative to its parent
frame. If the frame's parent is the world, the value should be the
same as a call to get_pose_in_world().

Parameter ``frame_id``:
    The identifier of the queried frame.

Returns:
    The pose in the _parent_ frame (X_PF) of the identified frame.

Throws:
    s std::logic_error if the frame id is not valid.)""";

        } get_pose_in_parent;

        // drake::geometry::GeometryState::get_pose_in_world
        struct /* get_pose_in_world */ {

          // drake/geometry/geometry_state.h:212
          const char* doc =
R"""(Reports the pose of the frame with the given id.

Parameter ``frame_id``:
    The identifier of the queried frame.

Returns:
    The pose in the world (X_WF) of the identified frame.

Throws:
    s std::logic_error if the frame id is not valid.)""";

          // drake/geometry/geometry_state.h:218
          const char* doc_2 =
R"""(Reports the pose of the geometry with the given id.

Parameter ``geometry_id``:
    The identifier of the queried geometry.

Returns:
    The pose in the world (X_WG) of the identified geometry.

Throws:
    s std::logic_error if the geometry id is not valid.)""";

        } get_pose_in_world;

        // drake::geometry::GeometryState::get_source_name
        struct /* get_source_name */ {

          // drake/geometry/geometry_state.h:232
          const char* doc =
R"""(Reports the source name for the given source id.

Parameter ``id``:
    The identifier of the source.

Returns:
    The name of the source.

Throws:
    s std::logic_error if the id does _not_ map to a registered
    source.)""";

        } get_source_name;

        // drake::geometry::GeometryState::get_visual_material
        struct /* get_visual_material */ {

          // drake/geometry/geometry_state.h:255
          const char* doc =
R"""(Returns the visual material defined for geometry indicated by the
given `geometry_id` (if defined).

Throws:
    s std::logic_error If the `geometry_id` does _not_ map to a valid
    GeometryInstance.)""";

        } get_visual_material;

        // drake::geometry::GeometryState::source_is_registered
        struct /* source_is_registered */ {

          // drake/geometry/geometry_state.h:152
          const char* doc =
R"""(Reports true if the given `source_id` references a registered source.
*/)""";

        } source_is_registered;

      } GeometryState;

      // drake::geometry::GeometryTag
      struct /* GeometryTag */ {

        // drake/geometry/geometry_ids.h:15
        const char* doc = R"""()""";

      } GeometryTag;

      // drake::geometry::HalfSpace
      struct /* HalfSpace */ {

        // drake/geometry/shape_specification.h:148
        const char* doc =
R"""(Definition of a half space. In its canonical frame, the plane defining
the boundary of the half space is that frame's z = 0 plane. By
implication, the plane's normal points in the +z direction and the
origin lies on the plane. Other shapes are considered to be
penetrating the half space if there exists a point on the test shape
that lies on the side of the plane opposite the normal.)""";

        // drake::geometry::HalfSpace::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:150
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::HalfSpace::HalfSpace
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:150
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:150
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:152
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::geometry::HalfSpace::MakePose
        struct /* MakePose */ {

          // drake/geometry/shape_specification.h:167
          const char* doc =
R"""(Creates the pose of a canonical half space in frame F. The half
space's normal is aligned to the positive z-axis of its canonical
frame C. Given the measure of that axis in frame F (Cz_F) and a
position vector to a point on the plane expressed in the same frame,
`p_FC`, creates the pose of the half space in frame F: `X_FC`.

Parameter ``Cz_F``:
    The positive z-axis of the canonical frame expressed in frame F.
    It must be a non-zero vector but need not be unit length.

Parameter ``p_FC``:
    A point lying on the half-space's boundary measured and expressed
    in frame F. @retval `X_FC` The pose of the canonical half-space in
    frame F.

Throws:
    s std::logic_error if the normal is _close_ to a zero-vector
    (e.g., ‖normal_F‖₂ < ε).)""";

        } MakePose;

      } HalfSpace;

      // drake::geometry::Identifier
      struct /* Identifier */ {

        // drake/geometry/identifier.h:137
        const char* doc =
R"""(A simple identifier class.

Note:
    This is *purposely* a separate class from TypeSafeIndex. For more
    explanatation, see TypeSafeIndexVsIndentifier "this section".

This class serves as an upgrade to the standard practice of passing
`int`s around as unique identifiers (or, as in this case, `int64_t`s).
In the common practice, a method that takes identifiers to different
types of objects would have an interface like:

```
void foo(int64_t bar_id, int64_t thing_id);
```

It is possible for a programmer to accidentally switch the two ids in
an invocation. This mistake would still be _syntactically_ correct; it
will successfully compile but lead to inscrutable run-time errors.
This identifier class provides the same speed and efficiency of
passing `int64_t`s, but enforces unique types and limits the valid
operations, providing compile-time checking. The function would now
look like:

```
void foo(BarId bar_id, ThingId thing_id)
```

and the compiler will catch instances where the order is reversed.

The identifier is a _stripped down_ 64-bit int. Each uniquely declared
identifier type has the following properties:

- The identifier's default constructor produces _invalid_ identifiers.
- Valid identifiers must be constructed via the copy constructor or
through Identifier::get_new_id(). - The identifier is immutable. - The
identifier can only be tested for equality/inequality with other
identifiers of the _same_ type. - Identifiers of different types are
_not_ interconvertible. - The identifier can be queried for its
underlying `int64_t` value. - The identifier can be written to an
output stream; its underlying `int64_t` value gets written. -
Identifiers are not guaranteed to possess _meaningful_ ordering. I.e.,
identifiers for two objects created sequentially may not have
sequential identifier values. - Identifiers can only be generated from
the static method get_new_id().

While there _is_ the concept of an invalid identifier, this only
exists to facilitate use with STL containers that require default
constructors. Using an invalid identifier in any operation is
considered an error. In Debug build, attempts to compare, get the
value of, hash, or write an invalid identifier to a stream will cause
program failure.

Functions that query for identifiers should not return invalid
identifiers. We prefer the practice of returning
std::optional<Identifier> instead.

It is the designed intent of this class, that ids derived from this
class can be passed and returned by value. Passing ids by const
reference should be considered a misuse.

The following alias will create a unique identifier type for class
`Foo`:

```
{.cpp}
using FooId = Identifier<class FooTag>;
```

__Examples of valid and invalid operations__

The Identifier guarantees that id instances of different types can't
be compared or combined. Efforts to do so will cause a compile-time
failure. For example:

```
using AId = Identifier<class ATag>;
using BId = Identifier<class BTag>;
AId a1;                              // Compiler error; there is no
//   default constructor.
AId a2 = AId::get_new_id();          // Ok.
AId a3(a2);                          // Ok.
AId a4 = AId::get_new_id();          // Ok.
BId b = BId::get_new_id();           // Ok.
if ( a2 == 1 ) { ... }               // Compiler error.
if ( a2 == a4 ) { ... }              // Ok, evaluates to false.
if ( a2 == a3 ) { ... }              // Ok, evaluates to true.
if ( a2 == b ) { ... }               // Compiler error.
a4 = a2;                             // Ok.
a3 = 7;                              // Compiler error.
```

@anchor TypeSafeIndexVsIndentifier __TypeSafeIndex vs Identifier__

In principle, the *identifier* is related to the TypeSafeIndex. In
some sense, both are "type-safe" `int`s. They differ in their
semantics. We can consider `ints`, indices, and identifiers as a list
of `int` types with _decreasing_ functionality.

- The int, obviously, has the full range of C++ ints. - The
TypeSafeIndex can be implicitly cast *to* an int, but there are a
limited number of operations _on_ the index that produce other
instances of the index (e.g., increment, in-place addition, etc.) They
can be compared with `int` and other indices of the same type. This
behavior arises from the intention of having them serve as an _index_
in an ordered set (e.g., `std::vector`). - The Identifier is the most
restricted. They exist solely to serve as a unique identifier. They
are immutable when created. Very few operations exist on them
(comparison for _equality_ with other identifiers of the same type,
hashing, writing to output stream). These *cannot* be used as indices.

Ultimately, indices _can_ serve as identifiers (within the scope of
the object they index into). Although, their mutability could make
this a dangerous practice for a public API. Identifiers are more
general in that they don't reflect an object's position in memory
(hence the inability to transform to or compare with an `int`). This
decouples details of implementation from the idea of the object.
Combined with its immutability, it would serve well as a element of a
public API.

See also:
    TypeSafeIndex

Template parameter ``Tag``:
    The name of the tag that uniquely segregates one instantiation
    from another.)""";

        // drake::geometry::Identifier::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/identifier.h:139
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Identifier::Identifier<Tag>
        struct /* ctor */ {

          // drake/geometry/identifier.h:139
          const char* doc = R"""()""";

          // drake/geometry/identifier.h:139
          const char* doc_2 = R"""()""";

          // drake/geometry/identifier.h:143
          const char* doc_3 =
R"""(Default constructor; the result is an _invalid_ identifier. This only
exists to satisfy demands of working with various container classes.)""";

        } ctor;

        // drake::geometry::Identifier::get_new_id
        struct /* get_new_id */ {

          // drake/geometry/identifier.h:184
          const char* doc =
R"""(Generates a new identifier for this id type. This new identifier will
be different from all previous identifiers created. This method does
_not_ make any guarantees about the values of ids from successive
invocations. This method is guaranteed to be thread safe.)""";

        } get_new_id;

        // drake::geometry::Identifier::get_value
        struct /* get_value */ {

          // drake/geometry/identifier.h:148
          const char* doc =
R"""(Extracts the underlying representation from the identifier. This is
considered invalid for invalid ids and is strictly enforced in Debug
builds.)""";

        } get_value;

        // drake::geometry::Identifier::is_valid
        struct /* is_valid */ {

          // drake/geometry/identifier.h:153
          const char* doc = R"""(Reports if the id is valid. */)""";

        } is_valid;

        // drake::geometry::Identifier::operator!=
        struct /* operator_ne */ {

          // drake/geometry/identifier.h:166
          const char* doc =
R"""(Compares one identifier with another of the same type for inequality.
This is considered invalid for invalid ids and is strictly enforced in
Debug builds.)""";

        } operator_ne;

        // drake::geometry::Identifier::operator<
        struct /* operator_lt */ {

          // drake/geometry/identifier.h:174
          const char* doc =
R"""(Compare two identifiers in order to define a total ordering among
identifiers. This makes identifiers compatible with data structures
which require total ordering (e.g., std::set).)""";

        } operator_lt;

      } Identifier;

      // drake::geometry::Mesh
      struct /* Mesh */ {

        // drake/geometry/shape_specification.h:177
        const char* doc =
R"""(Limited support for meshes. Meshes declared as such will _not_ serve
in proximity queries or rendering queries. However, they _will_ be
propagated to drake_visualizer. The mesh is dispatched to drake
visualizer via the filename. The mesh is _not_ parsed/loaded by Drake.)""";

        // drake::geometry::Mesh::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:179
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Mesh::Mesh
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:179
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:179
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:184
          const char* doc_3 =
R"""(Constructs a mesh specification from the mesh file located at the
given _absolute_ file path. Optionally uniformly scaled by the given
scale factor.)""";

        } ctor;

        // drake::geometry::Mesh::filename
        struct /* filename */ {

          // drake/geometry/shape_specification.h:186
          const char* doc = R"""()""";

        } filename;

        // drake::geometry::Mesh::scale
        struct /* scale */ {

          // drake/geometry/shape_specification.h:187
          const char* doc = R"""()""";

        } scale;

      } Mesh;

      // drake::geometry::QueryObject
      struct /* QueryObject */ {

        // drake/geometry/query_object.h:56
        const char* doc =
R"""(The QueryObject serves as a mechanism to perform geometry queries on
the world's geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).

To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a `const QueryObject&` in return,
and, finally, - invoke the appropriate method on the QueryObject.

The const reference returned by the input port is considered "live" -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should _never_ be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should re-
evaluate the input port. The underlying caching mechanism should make
the cost of this negligible.

In addition to not persisting the reference from the output port, the
QueryObject shouldn't be copied. Strictly speaking, it is an allowed
operation, but the result is not live, and any geometry query
performed on the copy will throw an exception.

A QueryObject _cannot_ be converted to a different scalar type. A
QueryObject of scalar type S can only be acquired from the output port
of a SceneGraph of type S evaluated on a corresponding
GeometryContext, also of type S.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/scene_graph.h:32
        const char* doc_2 =
R"""(The QueryObject serves as a mechanism to perform geometry queries on
the world's geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).

To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a `const QueryObject&` in return,
and, finally, - invoke the appropriate method on the QueryObject.

The const reference returned by the input port is considered "live" -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should _never_ be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should re-
evaluate the input port. The underlying caching mechanism should make
the cost of this negligible.

In addition to not persisting the reference from the output port, the
QueryObject shouldn't be copied. Strictly speaking, it is an allowed
operation, but the result is not live, and any geometry query
performed on the copy will throw an exception.

A QueryObject _cannot_ be converted to a different scalar type. A
QueryObject of scalar type S can only be acquired from the output port
of a SceneGraph of type S evaluated on a corresponding
GeometryContext, also of type S.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/scene_graph_inspector.h:13
        const char* doc_3 =
R"""(The QueryObject serves as a mechanism to perform geometry queries on
the world's geometry. The SceneGraph has an abstract-valued port that
contains a QueryObject (i.e., a QueryObject-valued output port).

To perform geometry queries on SceneGraph: - a LeafSystem must have a
QueryObject-valued input port and connect it to the corresponding
query output port on SceneGraph, - the querying LeafSystem can
evaluate the input port, retrieving a `const QueryObject&` in return,
and, finally, - invoke the appropriate method on the QueryObject.

The const reference returned by the input port is considered "live" -
it is linked to the context, system, and cache (making full use of all
of those mechanisms). This const reference should _never_ be
persisted; doing so can lead to erroneous query results. It is simpler
and more advisable to acquire it for evaluation in a limited scope
(e.g., CalcTimeDerivatives()) and then discard it. If a QueryObject is
needed for many separate functions in a LeafSystem, each should re-
evaluate the input port. The underlying caching mechanism should make
the cost of this negligible.

In addition to not persisting the reference from the output port, the
QueryObject shouldn't be copied. Strictly speaking, it is an allowed
operation, but the result is not live, and any geometry query
performed on the copy will throw an exception.

A QueryObject _cannot_ be converted to a different scalar type. A
QueryObject of scalar type S can only be acquired from the output port
of a SceneGraph of type S evaluated on a corresponding
GeometryContext, also of type S.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::geometry::QueryObject::ComputePointPairPenetration
        struct /* ComputePointPairPenetration */ {

          // drake/geometry/query_object.h:111
          const char* doc =
R"""(Computes the penetrations across all pairs of geometries in the world.
Only reports results for _penetrating_ geometries; if two geometries
are separated, there will be no result for that pair. Pairs of
_anchored_ geometry are also not reported. The penetration between two
geometries is characterized as a point pair (see
PenetrationAsPointPair).

For two penetrating geometries g₁ and g₂, it is guaranteed that they
will map to `id_A` and `id_B` in a fixed, repeatable manner.

This method is affected by collision filtering; element pairs that
have been filtered will not produce contacts, even if their collision
geometry is penetrating.

<!-- NOTE: This is currently declared as double because we haven't
exposed FCL's templated functionality yet. When that happens, double
-> T. -->

Returns:
    A vector populated with all detected penetrations characterized as
    point pairs.)""";

        } ComputePointPairPenetration;

        // drake::geometry::QueryObject::ComputeSignedDistancePairwiseClosestPoints
        struct /* ComputeSignedDistancePairwiseClosestPoints */ {

          // drake/geometry/query_object.h:166
          const char* doc =
R"""(Computes the signed distance together with the nearest points across
all pairs of geometries in the world. Reports both the separating
geometries and penetrating geometries. Notice that this is an O(N²)
operation, where N is the number of geometries remaining in the world
after applying collision filter. We report the distance between
dynamic objects, and between dynamic and anchored objects. We DO NOT
report the distance between two anchored objects.

Returns ``near_pairs``:
    The signed distance for all unfiltered geometry pairs.
    TODO(hongkai.dai): add a distance bound as an optional input, such
    that the function doesn't return the pairs whose signed distance
    is larger than the distance bound.)""";

        } ComputeSignedDistancePairwiseClosestPoints;

        // drake::geometry::QueryObject::QueryObject<T>
        struct /* ctor */ {

          // drake/geometry/query_object.h:64
          const char* doc = R"""()""";

        } ctor;

        // drake::geometry::QueryObject::inspector
        struct /* inspector */ {

          // drake/geometry/query_object.h:77
          const char* doc =
R"""(Provides an inspector for the topological structure of the underlying
scene graph data (see SceneGraphInspector for details).)""";

        } inspector;

      } QueryObject;

      // drake::geometry::SceneGraph
      struct /* SceneGraph */ {

        // drake/geometry/geometry_state.h:75
        const char* doc =
R"""(SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can _register_ that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.

Only registered "geometry sources" can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of _anchored_ (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems' geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph.

The basic workflow for interacting with SceneGraph is: - Register as a
geometry source, acquiring a unique SourceId. - Register geometry
(anchored and dynamic) with the system. - Connect source's geometry
output ports to the corresponding SceneGraph input ports. - Implement
appropriate `Calc*` methods on the geometry output ports to update
geometry pose values.

@section geom_sys_inputs Inputs @cond In future versions, this will
*also* include velocity and (possibly) acceleration ports. //
TODO(SeanCurtis-TRI): Modify this to reflect the number of actual port
// types. @endcond

For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.

__pose port__: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this "pose vector" maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to allocate and calculate this port.

@section geom_sys_outputs Outputs

SceneGraph has two output ports:

__query port__: An abstract-valued port containing an instance of
QueryObject. It provides a "ticket" for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph's output port and provide it as a
parameter to one of SceneGraph's query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.

__lcm visualization port__: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world's geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world's geometry.

@section geom_sys_workflow Working with SceneGraph

LeafSystem instances can relate to SceneGraph in one of two ways: as a
_consumer_ that performs queries, or as a _producer_ that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.

__Consumer__

Consumers perform geometric queries upon the world geometry.
SceneGraph _serves_ those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a QueryObject-
valued input port and connect it to SceneGraph's corresponding output
port, and 2. have a reference to the connected SceneGraph instance.

With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).

__Producer__

All producers introduce geometry into the shared geometric world. This
is called _registering_ geometry. Depending on what exactly has been
registered, a producer may also have to _update kinematics_. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
_geometry sources_). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer's identity is validated and its ownership
of its registered geometry is maintained.

_Registering Geometry_

SceneGraph cannot know what geometry _should_ be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called _registering_ the geometry. The source that registers the
geometry "owns" the geometry; the source's unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as _anchored_ or _dynamic_.

Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system's Context. Particularly, dynamic geometry is
_fixed_ to a _frame_ whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing up-to-
date kinematics values for those registered frames upon request (via
an appropriate output port on the source LeafSystem connecting to the
appropriate input port on SceneGraph). The work flow is as follows: 1.
A LeafSystem registers itself as a geometry source, acquiring a
SourceId (RegisterSource()). 2. The source registers a frame
(GeometrySource::RegisterFrame()). - A frame always has a "parent"
frame. It can implicitly be the world frame, _or_ another frame
registered by the source. 3. Register one or more geometries to a
frame (GeometrySource::RegisterGeometry()). - The registered geometry
is posed relative to the frame to which it is fixed. - The geometry
can also be posed relative to another registered geometry. It will be
affixed to _that_ geometry's frame.

Anchored geometry is _independent_ of the context (i.e., it doesn't
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is _not_ required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still "owns" the anchored geometry.

_Updating Kinematics_

Registering _dynamic_ geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the "id" port
and the "pose" port. - The id port must contain _all_ the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame's _parent_ frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.

Failure to meet these requirements will lead to a run-time error.

@cond // TODO(SeanCurtis-TRI): Future work which will require add'l
documentation: // - velocity kinematics. // - Finalizing API for
topology changes at discrete events. @endcond

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/query_object.h:16
        const char* doc_2 =
R"""(SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can _register_ that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.

Only registered "geometry sources" can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of _anchored_ (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems' geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph.

The basic workflow for interacting with SceneGraph is: - Register as a
geometry source, acquiring a unique SourceId. - Register geometry
(anchored and dynamic) with the system. - Connect source's geometry
output ports to the corresponding SceneGraph input ports. - Implement
appropriate `Calc*` methods on the geometry output ports to update
geometry pose values.

@section geom_sys_inputs Inputs @cond In future versions, this will
*also* include velocity and (possibly) acceleration ports. //
TODO(SeanCurtis-TRI): Modify this to reflect the number of actual port
// types. @endcond

For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.

__pose port__: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this "pose vector" maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to allocate and calculate this port.

@section geom_sys_outputs Outputs

SceneGraph has two output ports:

__query port__: An abstract-valued port containing an instance of
QueryObject. It provides a "ticket" for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph's output port and provide it as a
parameter to one of SceneGraph's query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.

__lcm visualization port__: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world's geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world's geometry.

@section geom_sys_workflow Working with SceneGraph

LeafSystem instances can relate to SceneGraph in one of two ways: as a
_consumer_ that performs queries, or as a _producer_ that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.

__Consumer__

Consumers perform geometric queries upon the world geometry.
SceneGraph _serves_ those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a QueryObject-
valued input port and connect it to SceneGraph's corresponding output
port, and 2. have a reference to the connected SceneGraph instance.

With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).

__Producer__

All producers introduce geometry into the shared geometric world. This
is called _registering_ geometry. Depending on what exactly has been
registered, a producer may also have to _update kinematics_. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
_geometry sources_). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer's identity is validated and its ownership
of its registered geometry is maintained.

_Registering Geometry_

SceneGraph cannot know what geometry _should_ be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called _registering_ the geometry. The source that registers the
geometry "owns" the geometry; the source's unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as _anchored_ or _dynamic_.

Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system's Context. Particularly, dynamic geometry is
_fixed_ to a _frame_ whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing up-to-
date kinematics values for those registered frames upon request (via
an appropriate output port on the source LeafSystem connecting to the
appropriate input port on SceneGraph). The work flow is as follows: 1.
A LeafSystem registers itself as a geometry source, acquiring a
SourceId (RegisterSource()). 2. The source registers a frame
(GeometrySource::RegisterFrame()). - A frame always has a "parent"
frame. It can implicitly be the world frame, _or_ another frame
registered by the source. 3. Register one or more geometries to a
frame (GeometrySource::RegisterGeometry()). - The registered geometry
is posed relative to the frame to which it is fixed. - The geometry
can also be posed relative to another registered geometry. It will be
affixed to _that_ geometry's frame.

Anchored geometry is _independent_ of the context (i.e., it doesn't
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is _not_ required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still "owns" the anchored geometry.

_Updating Kinematics_

Registering _dynamic_ geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the "id" port
and the "pose" port. - The id port must contain _all_ the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame's _parent_ frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.

Failure to meet these requirements will lead to a run-time error.

@cond // TODO(SeanCurtis-TRI): Future work which will require add'l
documentation: // - velocity kinematics. // - Finalizing API for
topology changes at discrete events. @endcond

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/scene_graph.h:201
        const char* doc_3 =
R"""(SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can _register_ that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.

Only registered "geometry sources" can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of _anchored_ (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems' geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph.

The basic workflow for interacting with SceneGraph is: - Register as a
geometry source, acquiring a unique SourceId. - Register geometry
(anchored and dynamic) with the system. - Connect source's geometry
output ports to the corresponding SceneGraph input ports. - Implement
appropriate `Calc*` methods on the geometry output ports to update
geometry pose values.

@section geom_sys_inputs Inputs @cond In future versions, this will
*also* include velocity and (possibly) acceleration ports. //
TODO(SeanCurtis-TRI): Modify this to reflect the number of actual port
// types. @endcond

For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.

__pose port__: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this "pose vector" maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to allocate and calculate this port.

@section geom_sys_outputs Outputs

SceneGraph has two output ports:

__query port__: An abstract-valued port containing an instance of
QueryObject. It provides a "ticket" for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph's output port and provide it as a
parameter to one of SceneGraph's query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.

__lcm visualization port__: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world's geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world's geometry.

@section geom_sys_workflow Working with SceneGraph

LeafSystem instances can relate to SceneGraph in one of two ways: as a
_consumer_ that performs queries, or as a _producer_ that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.

__Consumer__

Consumers perform geometric queries upon the world geometry.
SceneGraph _serves_ those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a QueryObject-
valued input port and connect it to SceneGraph's corresponding output
port, and 2. have a reference to the connected SceneGraph instance.

With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).

__Producer__

All producers introduce geometry into the shared geometric world. This
is called _registering_ geometry. Depending on what exactly has been
registered, a producer may also have to _update kinematics_. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
_geometry sources_). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer's identity is validated and its ownership
of its registered geometry is maintained.

_Registering Geometry_

SceneGraph cannot know what geometry _should_ be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called _registering_ the geometry. The source that registers the
geometry "owns" the geometry; the source's unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as _anchored_ or _dynamic_.

Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system's Context. Particularly, dynamic geometry is
_fixed_ to a _frame_ whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing up-to-
date kinematics values for those registered frames upon request (via
an appropriate output port on the source LeafSystem connecting to the
appropriate input port on SceneGraph). The work flow is as follows: 1.
A LeafSystem registers itself as a geometry source, acquiring a
SourceId (RegisterSource()). 2. The source registers a frame
(GeometrySource::RegisterFrame()). - A frame always has a "parent"
frame. It can implicitly be the world frame, _or_ another frame
registered by the source. 3. Register one or more geometries to a
frame (GeometrySource::RegisterGeometry()). - The registered geometry
is posed relative to the frame to which it is fixed. - The geometry
can also be posed relative to another registered geometry. It will be
affixed to _that_ geometry's frame.

Anchored geometry is _independent_ of the context (i.e., it doesn't
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is _not_ required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still "owns" the anchored geometry.

_Updating Kinematics_

Registering _dynamic_ geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the "id" port
and the "pose" port. - The id port must contain _all_ the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame's _parent_ frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.

Failure to meet these requirements will lead to a run-time error.

@cond // TODO(SeanCurtis-TRI): Future work which will require add'l
documentation: // - velocity kinematics. // - Finalizing API for
topology changes at discrete events. @endcond

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/geometry/scene_graph_inspector.h:11
        const char* doc_4 =
R"""(SceneGraph serves as the nexus for all geometry (and geometry-based
operations) in a Diagram. Through SceneGraph, other systems that
introduce geometry can _register_ that geometry as part of a common
global domain, including it in geometric queries (e.g., cars
controlled by one LeafSystem can be observed by a different sensor
system). SceneGraph provides the interface for registering the
geometry, updating its position based on the current context, and
performing geometric queries.

Only registered "geometry sources" can introduce geometry into
SceneGraph. Geometry sources will typically be other leaf systems,
but, in the case of _anchored_ (i.e., stationary) geometry, it could
also be some other block of code (e.g., adding a common ground plane
with which all systems' geometries interact). For dynamic geometry
(geometry whose pose depends on a Context), the geometry source must
also provide pose values for all of the geometries the source owns,
via a port connection on SceneGraph.

The basic workflow for interacting with SceneGraph is: - Register as a
geometry source, acquiring a unique SourceId. - Register geometry
(anchored and dynamic) with the system. - Connect source's geometry
output ports to the corresponding SceneGraph input ports. - Implement
appropriate `Calc*` methods on the geometry output ports to update
geometry pose values.

@section geom_sys_inputs Inputs @cond In future versions, this will
*also* include velocity and (possibly) acceleration ports. //
TODO(SeanCurtis-TRI): Modify this to reflect the number of actual port
// types. @endcond

For each registered geometry source, there is one input port for each
order of kinematics values (e.g., pose, velocity, and acceleration).
If a source registers a frame, it must connect to these ports
(although, in the current version, only pose is supported). Failure to
connect to the port (or to provide valid kinematics values) will lead
to runtime exceptions.

__pose port__: An abstract-valued port providing an instance of
FramePoseVector. For each registered frame, this "pose vector" maps
the registered FrameId to a pose value. All registered frames must be
accounted for and only frames registered by a source can be included
in its output port. See the details in FrameKinematicsVector for
details on how to allocate and calculate this port.

@section geom_sys_outputs Outputs

SceneGraph has two output ports:

__query port__: An abstract-valued port containing an instance of
QueryObject. It provides a "ticket" for downstream LeafSystem
instances to perform geometric queries on the SceneGraph. To perform
geometric queries, downstream LeafSystem instances acquire the
QueryObject from SceneGraph's output port and provide it as a
parameter to one of SceneGraph's query methods (e.g.,
SceneGraph::ComputeContact()). This assumes that the querying system
has access to a const pointer to the connected SceneGraph instance.
Use get_query_output_port() to acquire the output port for the query
handle.

__lcm visualization port__: An abstract-valued port containing an
instance of PoseBundle. This is a convenience port designed to feed
LCM update messages to drake_visualizer for the purpose of visualizing
the state of the world's geometry. Additional uses of this port are
strongly discouraged; instead, use an appropriate geometric query to
obtain the state of the world's geometry.

@section geom_sys_workflow Working with SceneGraph

LeafSystem instances can relate to SceneGraph in one of two ways: as a
_consumer_ that performs queries, or as a _producer_ that introduces
geometry into the shared world and defines its context-dependent
kinematics values. It is reasonable for systems to perform either role
singly, or both.

__Consumer__

Consumers perform geometric queries upon the world geometry.
SceneGraph _serves_ those queries. As indicated above, in order for a
LeafSystem to act as a consumer, it must: 1. define a QueryObject-
valued input port and connect it to SceneGraph's corresponding output
port, and 2. have a reference to the connected SceneGraph instance.

With those two requirements satisfied, a LeafSystem can perform
geometry queries by: 1. evaluating the QueryObject input port, and 2.
passing the returned query object into the appropriate query method on
SceneGraph (e.g., SceneGraph::ComputeContact()).

__Producer__

All producers introduce geometry into the shared geometric world. This
is called _registering_ geometry. Depending on what exactly has been
registered, a producer may also have to _update kinematics_. Producers
themselves must be registered with SceneGraph as producers (a.k.a.
_geometry sources_). They do this by acquiring a SourceId (via
SceneGraph::RegisterSource()). The SourceId serves as a unique handle
through which the producer's identity is validated and its ownership
of its registered geometry is maintained.

_Registering Geometry_

SceneGraph cannot know what geometry _should_ be part of the shared
world. Other systems are responsible for introducing geometry into the
world. This process (defining geometry and informing SceneGraph) is
called _registering_ the geometry. The source that registers the
geometry "owns" the geometry; the source's unique SourceId is required
to perform any operations on the geometry registered with that
SourceId. Geometry can be registered as _anchored_ or _dynamic_.

Dynamic geometry can move; more specifically, its kinematics (e.g.,
pose) depends on a system's Context. Particularly, dynamic geometry is
_fixed_ to a _frame_ whose kinematics values depend on a context. As
the frame moves, the geometries fixed to it move with it. Therefore,
to register dynamic geometry a frame must be registered first. These
registered frames serve as the basis for repositioning geometry in the
shared world. The geometry source is responsible for providing up-to-
date kinematics values for those registered frames upon request (via
an appropriate output port on the source LeafSystem connecting to the
appropriate input port on SceneGraph). The work flow is as follows: 1.
A LeafSystem registers itself as a geometry source, acquiring a
SourceId (RegisterSource()). 2. The source registers a frame
(GeometrySource::RegisterFrame()). - A frame always has a "parent"
frame. It can implicitly be the world frame, _or_ another frame
registered by the source. 3. Register one or more geometries to a
frame (GeometrySource::RegisterGeometry()). - The registered geometry
is posed relative to the frame to which it is fixed. - The geometry
can also be posed relative to another registered geometry. It will be
affixed to _that_ geometry's frame.

Anchored geometry is _independent_ of the context (i.e., it doesn't
move). Anchored geometries are always affixed to the immobile world
frame. As such, registering a frame is _not_ required for registering
anchored geometry (see GeometrySource::RegisterAnchoredGeometry()).
However, the source still "owns" the anchored geometry.

_Updating Kinematics_

Registering _dynamic_ geometry implies a contract between the geometry
source and SceneGraph. The geometry source must do the following: - It
must provide, populate, and connect two output ports: the "id" port
and the "pose" port. - The id port must contain _all_ the frame ids
returned as a result of frame registration. - The pose port must
contain one pose per registered frame; the pose value is expressed
relative to the registered frame's _parent_ frame. As mentioned above,
the iᵗʰ pose value should describe the frame indicated by the iᵗʰ id
in the id output port.

Failure to meet these requirements will lead to a run-time error.

@cond // TODO(SeanCurtis-TRI): Future work which will require add'l
documentation: // - velocity kinematics. // - Finalizing API for
topology changes at discrete events. @endcond

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::geometry::SceneGraph::ExcludeCollisionsBetween
        struct /* ExcludeCollisionsBetween */ {

          // drake/geometry/scene_graph.h:433
          const char* doc =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set `C = C - P`, where `P = {(a, b)}, ∀ a ∈ A, b ∈ B`
and `A = {a₀, a₁, ..., aₘ}` and `B = {b₀, b₁, ..., bₙ}` are the input
sets of geometries `setA` and `setB`, respectively. This does _not_
preclude collisions between members of the _same_ set.

Throws:
    s std::logic_error if the groups include ids that don't exist in
    the scene graph.)""";

        } ExcludeCollisionsBetween;

        // drake::geometry::SceneGraph::ExcludeCollisionsWithin
        struct /* ExcludeCollisionsWithin */ {

          // drake/geometry/scene_graph.h:423
          const char* doc =
R"""(Excludes geometry pairs from collision evaluation by updating the
candidate pair set `C = C - P`, where `P = {(gᵢ, gⱼ)}, ∀ gᵢ, gⱼ ∈ G`
and `G = {g₀, g₁, ..., gₘ}` is the input `set` of geometries.

Throws:
    s std::logic_error if the set includes ids that don't exist in the
    scene graph.)""";

        } ExcludeCollisionsWithin;

        // drake::geometry::SceneGraph::RegisterAnchoredGeometry
        struct /* RegisterAnchoredGeometry */ {

          // drake/geometry/scene_graph.h:374
          const char* doc =
R"""(Registers a new _anchored_ geometry G for this source. This hangs
geometry G from the world frame (W). Its pose is defined in that frame
(i.e., `X_WG`). Returns the corresponding unique geometry id.

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``geometry``:
    The anchored geometry G to add to the world.

Returns:
    The index for the added geometry.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. a context has been allocated, or 3. the
    geometry's name doesn't satisfy the requirements outlined in
    GeometryInstance.)""";

        } RegisterAnchoredGeometry;

        // drake::geometry::SceneGraph::RegisterFrame
        struct /* RegisterFrame */ {

          // drake/geometry/scene_graph.h:306
          const char* doc =
R"""(Registers a new frame F on for this source. This hangs frame F on the
world frame (W). Its pose is defined relative to the world frame (i.e,
`X_WF`). Returns the corresponding unique frame id.

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``frame``:
    The definition of the frame to add.

Returns:
    A newly allocated frame id.

Throws:
    s std::logic_error If the `source_id` does _not_ map to a
    registered source or if a context has been allocated.)""";

          // drake/geometry/scene_graph.h:321
          const char* doc_2 =
R"""(Registers a new frame F for this source. This hangs frame F on another
previously registered frame P (indicated by `parent_id`). The pose of
the new frame is defined relative to the parent frame (i.e., `X_PF`).
Returns the corresponding unique frame id.

Parameter ``source_id``:
    The id for the source registering the frame.

Parameter ``parent_id``:
    The id of the parent frame P.

Parameter ``frame``:
    The frame to register.

Returns:
    A newly allocated frame id.

Throws:
    s std::logic_error 1. If the `source_id` does _not_ map to a
    registered source, 2. If the `parent_id` does _not_ map to a known
    frame or does not belong to the source, or 3. a context has been
    allocated.)""";

        } RegisterFrame;

        // drake::geometry::SceneGraph::RegisterGeometry
        struct /* RegisterGeometry */ {

          // drake/geometry/scene_graph.h:340
          const char* doc =
R"""(Registers a new geometry G for this source. This hangs geometry G on a
previously registered frame F (indicated by `frame_id`). The pose of
the geometry is defined in a fixed pose relative to F (i.e., `X_FG`).
Returns the corresponding unique geometry id.

Parameter ``source_id``:
    The id for the source registering the geometry.

Parameter ``frame_id``:
    The id for the frame F to hang the geometry on.

Parameter ``geometry``:
    The geometry G to affix to frame F.

Returns:
    A unique identifier for the added geometry.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. the `frame_id` doesn't belong to the source,
    3. the `geometry` is equal to `nullptr`, 4. a context has been
    allocated, or 5. the geometry's name doesn't satisfy the
    requirements outlined in GeometryInstance.)""";

          // drake/geometry/scene_graph.h:360
          const char* doc_2 =
R"""(Registers a new geometry G for this source. This hangs geometry G on a
previously registered geometry P (indicated by `geometry_id`). The
pose of the geometry is defined in a fixed pose relative to geometry P
(i.e., `X_PG`). By induction, this geometry is effectively rigidly
affixed to the frame that P is affixed to. Returns the corresponding
unique geometry id.

Parameter ``source_id``:
    The id for the source registering the geometry.

Parameter ``geometry_id``:
    The id for the parent geometry P.

Parameter ``geometry``:
    The geometry G to add.

Returns:
    A unique identifier for the added geometry.

Throws:
    s std::logic_error 1. the `source_id` does _not_ map to a
    registered source, 2. the `geometry_id` doesn't belong to the
    source, 3. the `geometry` is equal to `nullptr`, 4. a context has
    been allocated, or 5. the geometry's name doesn't satisfy the
    requirements outlined in GeometryInstance.)""";

        } RegisterGeometry;

        // drake::geometry::SceneGraph::RegisterSource
        struct /* RegisterSource */ {

          // drake/geometry/scene_graph.h:240
          const char* doc =
R"""(Registers a new source to the geometry system. The caller must save
the returned SourceId; it is the token by which all other operations
on the geometry world are conducted.

This source id can be used to register arbitrary _anchored_ geometry.
But if dynamic geometry is registered (via
RegisterGeometry/RegisterFrame), then the context-dependent pose
values must be provided on an input port. See get_source_pose_port().

Parameter ``name``:
    The optional name of the source. If none is provided (or the empty
    string) a unique name will be defined by SceneGraph's logic.

Throws:
    s std::logic_error if a context has already been allocated for
    this SceneGraph.

See also:
    GeometryState::RegisterNewSource())""";

        } RegisterSource;

        // drake::geometry::SceneGraph::SceneGraph<T>
        struct /* ctor */ {

          // drake/geometry/scene_graph.h:203
          const char* doc = R"""()""";

          // drake/geometry/scene_graph.h:203
          const char* doc_2 = R"""()""";

          // drake/geometry/scene_graph.h:205
          const char* doc_3 = R"""()""";

          // drake/geometry/scene_graph.h:210
          const char* doc_4 =
R"""(Constructor used for scalar conversions. It should only be used to
convert _from_ double _to_ other scalar types.)""";

        } ctor;

        // drake::geometry::SceneGraph::SourceIsRegistered
        struct /* SourceIsRegistered */ {

          // drake/geometry/scene_graph.h:244
          const char* doc =
R"""(Reports if the given source id is registered.

Parameter ``id``:
    The id of the source to query.)""";

        } SourceIsRegistered;

        // drake::geometry::SceneGraph::get_pose_bundle_output_port
        struct /* get_pose_bundle_output_port */ {

          // drake/geometry/scene_graph.h:254
          const char* doc =
R"""(Returns the output port which produces the PoseBundle for LCM
communication to drake visualizer.)""";

        } get_pose_bundle_output_port;

        // drake::geometry::SceneGraph::get_query_output_port
        struct /* get_query_output_port */ {

          // drake/geometry/scene_graph.h:260
          const char* doc =
R"""(Returns the output port which produces the QueryObject for performing
geometric queries.)""";

        } get_query_output_port;

        // drake::geometry::SceneGraph::get_source_pose_port
        struct /* get_source_pose_port */ {

          // drake/geometry/scene_graph.h:250
          const char* doc =
R"""(Given a valid source `id`, returns a _pose_ input port associated with
that `id`. This port is used to communicate _pose_ data for registered
frames.

Throws:
    s std::logic_error if the source_id is _not_ recognized.)""";

        } get_source_pose_port;

        // drake::geometry::SceneGraph::model_inspector
        struct /* model_inspector */ {

          // drake/geometry/scene_graph.h:386
          const char* doc =
R"""(Returns an inspector on the system's *model* scene graph data.

Throws:
    std::logic_error If a context has been allocated.)""";

        } model_inspector;

        // drake::geometry::SceneGraph::world_frame_id
        struct /* world_frame_id */ {

          // drake/geometry/scene_graph.h:380
          const char* doc =
R"""(Reports the identifier for the world frame. */)""";

        } world_frame_id;

      } SceneGraph;

      // drake::geometry::SceneGraphInspector
      struct /* SceneGraphInspector */ {

        // drake/geometry/scene_graph_inspector.h:48
        const char* doc =
R"""(The SceneGraphInspector serves as a mechanism to query the topological
structure of a SceneGraph instance. The topological structure consists
of all of the SceneGraph data that does *not* depend on input pose
data. Including, but not limited to:

- names of frames and geometries - hierarchies (parents of geometries,
parents of frames, etc.) - geometry parameters (e.g., contact,
rendering, visualization) - fixed poses of geometries relative to
frames

In contrast, the following pieces of data *do* depend on input pose
data and cannot* be performed with the SceneGraphInspector (see the
QueryObject instead):

- world pose of frames or geometry - collision queries - proximity
queries

A SceneGraphInspector cannot be instantiated explicitly. Nor can it be
copied or moved. A *reference* to a SceneGraphInspector instance can
be acquired from - a SceneGraph instance (to inspect the state of the
system's _model_), or - a QueryObject instance (to inspect the state
of the scene graph data stored in the context).

The reference should not be persisted (and, as previously indicated,
cannot be copied). SceneGraphInspector instances are cheap; they can
be created, queried, and thrown out. If there is any doubt about the
valid lifespan of a SceneGraphInspector, throw out the old instance
and request a new instance.

Template parameter ``T``:
    The scalar of the associated SceneGraph instance. The template
    parameter is provided for the sake of compatibility, although no
    queries (or their results) depend on the scalar.)""";

        // drake::geometry::SceneGraphInspector::GetFrameId
        struct /* GetFrameId */ {

          // drake/geometry/scene_graph_inspector.h:69
          const char* doc =
R"""(Reports the id of the frame to which the given geometry id is
registered.

Throws:
    s std::logic_error if the geometry id is invalid.)""";

        } GetFrameId;

        // drake::geometry::SceneGraphInspector::GetGeometryIdByName
        struct /* GetGeometryIdByName */ {

          // drake/geometry/scene_graph_inspector.h:108
          const char* doc =
R"""(Reports the id of the geometry with the given name, attached to the
indicated frame.

Parameter ``frame_id``:
    The frame whose geometry is being queried.

Parameter ``name``:
    The name of the geometry to query for. The name will be
    canonicalized prior to lookup (see canonicalized_geometry_names
    "GeometryInstance" for details).

Returns:
    The id of the queried geometry.

Throws:
    s std::logic_error if no such geometry exists, multiple geometries
    have that name, or if the frame doesn't exist.)""";

        } GetGeometryIdByName;

        // drake::geometry::SceneGraphInspector::GetName
        struct /* GetName */ {

          // drake/geometry/scene_graph_inspector.h:84
          const char* doc =
R"""(Reports the name of the frame indicated by the given id.

Throws:
    s std::logic_error if `frame_id` doesn't refer to a valid frame.)""";

          // drake/geometry/scene_graph_inspector.h:92
          const char* doc_2 =
R"""(Reports the name of the geometry indicated by the given id.

Throws:
    s std::logic_error if `geometry_id` doesn't refer to a valid
    geometry.)""";

        } GetName;

        // drake::geometry::SceneGraphInspector::GetSourceName
        struct /* GetSourceName */ {

          // drake/geometry/scene_graph_inspector.h:62
          const char* doc =
R"""(Reports the name for the given source id.

Throws:
    s std::logic_error if the identifier is invalid.)""";

        } GetSourceName;

        // drake::geometry::SceneGraphInspector::GetVisualMaterial
        struct /* GetVisualMaterial */ {

          // drake/geometry/scene_graph_inspector.h:77
          const char* doc =
R"""(Returns the visual material of the geometry indicated by the given
`geometry_id` (if it exists).

Throws:
    s std::logic_error if the geometry id is invalid.)""";

        } GetVisualMaterial;

        // drake::geometry::SceneGraphInspector::SceneGraphInspector<T>
        struct /* ctor */ {

          // drake/geometry/scene_graph_inspector.h:50
          const char* doc = R"""()""";

          // drake/geometry/scene_graph_inspector.h:50
          const char* doc_2 = R"""()""";

        } ctor;

      } SceneGraphInspector;

      // drake::geometry::Shape
      struct /* Shape */ {

        // drake/geometry/shape_specification.h:34
        const char* doc =
R"""(The base interface for all shape specifications. It has no public
constructor and cannot be instantiated directly. The Shape class has
two key properties: - it is cloneable, and - it can be "reified" (see
ShapeReifier).)""";

        // drake::geometry::Shape::Clone
        struct /* Clone */ {

          // drake/geometry/shape_specification.h:44
          const char* doc =
R"""(Creates a unique copy of this shape. Invokes the protected DoClone().
*/)""";

        } Clone;

        // drake::geometry::Shape::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:50
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Shape::Reify
        struct /* Reify */ {

          // drake/geometry/shape_specification.h:41
          const char* doc =
R"""(Causes this description to be reified in the given `reifier`. Each
concrete subclass must invoke the single, matching method on the
reifier. Provides optional user-data (cast as a void*) for the reifier
to consume.)""";

        } Reify;

        // drake::geometry::Shape::Shape
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:50
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:50
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:77
          const char* doc_3 =
R"""(Constructor available for derived class construction. A derived class
should invoke this in its initialization list, passing a ShapeTag
instantiated on its derived type, e.g.:

```
class MyShape final : public Shape {
public:
MyShape() : Shape(ShapeTag<MyShape>()) {}
...
};
```

The base class provides infrastructure for cloning and reification. To
work and to maintain sanity, we place the following requirements on
derived classes:

1. they must have a public copy constructor, 2. they must be marked as
final, and 3. their constructors must invoke the parent constructor
with a ShapeTag instance (as noted above), and 4. The ShapeReifier
class must be extended to include an invocation of
ShapeReifier::ImplementGeometry() on the derived Shape class.

Template parameter ``S``:
    The derived shape class. It must derive from Shape.)""";

          // drake/geometry/shape_specification.h:256
          const char* doc_4 =
R"""(Constructor available for derived class construction. A derived class
should invoke this in its initialization list, passing a ShapeTag
instantiated on its derived type, e.g.:

```
class MyShape final : public Shape {
public:
MyShape() : Shape(ShapeTag<MyShape>()) {}
...
};
```

The base class provides infrastructure for cloning and reification. To
work and to maintain sanity, we place the following requirements on
derived classes:

1. they must have a public copy constructor, 2. they must be marked as
final, and 3. their constructors must invoke the parent constructor
with a ShapeTag instance (as noted above), and 4. The ShapeReifier
class must be extended to include an invocation of
ShapeReifier::ImplementGeometry() on the derived Shape class.

Template parameter ``S``:
    The derived shape class. It must derive from Shape.)""";

        } ctor;

      } Shape;

      // drake::geometry::ShapeReifier
      struct /* ShapeReifier */ {

        // drake/geometry/shape_specification.h:21
        const char* doc =
R"""(The interface for converting shape descriptions to real shapes. Any
entity that consumes shape descriptions _must_ implement this
interface.

This class explicitly enumerates all concrete shapes in its methods.
The addition of a new concrete shape class requires the addition of a
new corresponding method. There should *never* be a method that
accepts the Shape base class as an argument; it should _only_ operate
on concrete derived classes.

The expected workflow is for a class that needs to turn shape
specifications into concrete geometry instances to implement the
ShapeReifier interface _and_ invoke the Shape::Reify() method. For
example, a simple reifier that requires no user data would look like:

```
class SimpleReifier : public ShapeReifier {
void ProcessShape(const Shape& shape) {
// Requires no user data.
shape.Reify(this);
}
...
void ImplementGeometry(const Sphere& sphere, void*) override {
// Do work to create a sphere.
}
};
```

Or a complex reifier that requires user data would look like:

```
class ComplexReifier : public ShapeReifier {
void ProcessShape(const Shape& shape) {
ImportantData data{...};
shape.Reify(this, &data);
}
...
void ImplementGeometry(const Sphere& sphere, void* data) override {
DRAKE_ASSERT(data);
ImportantData& data = *reinterpret_cast<ImportantData*>(data);
// Do work to create a sphere using the provided user data.
}
};
```

Implementing a particular shape may require more data than is strictly
encapsulated in the Shape. The Implement* interface supports passing
user data through a type-erased `void*`. Because a single class
invoked Shape::Reify() it is in a position to provide exactly the data
the shape implementations require.)""";

        // drake/geometry/shape_specification.h:244
        const char* doc_2 =
R"""(The interface for converting shape descriptions to real shapes. Any
entity that consumes shape descriptions _must_ implement this
interface.

This class explicitly enumerates all concrete shapes in its methods.
The addition of a new concrete shape class requires the addition of a
new corresponding method. There should *never* be a method that
accepts the Shape base class as an argument; it should _only_ operate
on concrete derived classes.

The expected workflow is for a class that needs to turn shape
specifications into concrete geometry instances to implement the
ShapeReifier interface _and_ invoke the Shape::Reify() method. For
example, a simple reifier that requires no user data would look like:

```
class SimpleReifier : public ShapeReifier {
void ProcessShape(const Shape& shape) {
// Requires no user data.
shape.Reify(this);
}
...
void ImplementGeometry(const Sphere& sphere, void*) override {
// Do work to create a sphere.
}
};
```

Or a complex reifier that requires user data would look like:

```
class ComplexReifier : public ShapeReifier {
void ProcessShape(const Shape& shape) {
ImportantData data{...};
shape.Reify(this, &data);
}
...
void ImplementGeometry(const Sphere& sphere, void* data) override {
DRAKE_ASSERT(data);
ImportantData& data = *reinterpret_cast<ImportantData*>(data);
// Do work to create a sphere using the provided user data.
}
};
```

Implementing a particular shape may require more data than is strictly
encapsulated in the Shape. The Implement* interface supports passing
user data through a type-erased `void*`. Because a single class
invoked Shape::Reify() it is in a position to provide exactly the data
the shape implementations require.)""";

        // drake::geometry::ShapeReifier::ImplementGeometry
        struct /* ImplementGeometry */ {

          // drake/geometry/shape_specification.h:247
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:248
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:249
          const char* doc_3 = R"""()""";

          // drake/geometry/shape_specification.h:251
          const char* doc_4 = R"""()""";

          // drake/geometry/shape_specification.h:252
          const char* doc_5 = R"""()""";

        } ImplementGeometry;

      } ShapeReifier;

      // drake::geometry::ShapeTag
      struct /* ShapeTag */ {

        // drake/geometry/shape_specification.h:27
        const char* doc =
R"""(Simple struct for instantiating the type-specific Shape functionality.
A class derived from the Shape class will invoke the parent's
constructor as Shape(ShapeTag<DerivedShape>()).)""";

      } ShapeTag;

      // drake::geometry::SourceTag
      struct /* SourceTag */ {

        // drake/geometry/geometry_ids.h:9
        const char* doc = R"""()""";

      } SourceTag;

      // drake::geometry::Sphere
      struct /* Sphere */ {

        // drake/geometry/shape_specification.h:86
        const char* doc =
R"""(Definition of sphere. It is centered in its canonical frame with the
given radius.)""";

        // drake::geometry::Sphere::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/shape_specification.h:88
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::Sphere::Sphere
        struct /* ctor */ {

          // drake/geometry/shape_specification.h:88
          const char* doc = R"""()""";

          // drake/geometry/shape_specification.h:88
          const char* doc_2 = R"""()""";

          // drake/geometry/shape_specification.h:90
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::geometry::Sphere::get_radius
        struct /* get_radius */ {

          // drake/geometry/shape_specification.h:92
          const char* doc = R"""()""";

        } get_radius;

      } Sphere;

      // drake::geometry::VisualMaterial
      struct /* VisualMaterial */ {

        // drake/geometry/visual_material.h:12
        const char* doc =
R"""(Definition of material for simple visualization. Default materials are
a light grey.)""";

        // drake::geometry::VisualMaterial::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/geometry/visual_material.h:14
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::geometry::VisualMaterial::VisualMaterial
        struct /* ctor */ {

          // drake/geometry/visual_material.h:14
          const char* doc = R"""()""";

          // drake/geometry/visual_material.h:14
          const char* doc_2 = R"""()""";

          // drake/geometry/visual_material.h:17
          const char* doc_3 =
R"""(Constructs a material with the default grey color. */)""";

          // drake/geometry/visual_material.h:21
          const char* doc_4 =
R"""(Constructs a material with the given diffuse color.

Parameter ``diffuse``:
    A vector of [r, g, b, a] values, each in the range [0, 1].)""";

        } ctor;

        // drake::geometry::VisualMaterial::diffuse
        struct /* diffuse */ {

          // drake/geometry/visual_material.h:24
          const char* doc =
R"""(Returns the material's diffuse color. */)""";

        } diffuse;

      } VisualMaterial;

      // drake::geometry::operator<<
      struct /* operator_lshift */ {

        // drake/geometry/identifier.h:205
        const char* doc =
R"""(Streaming output operator. This is considered invalid for invalid ids
and is strictly enforced in Debug builds. @relates Identifier)""";

      } operator_lshift;

      // drake::geometry::to_string
      struct /* to_string */ {

        // drake/geometry/identifier.h:215
        const char* doc =
R"""(Enables use of identifiers with to_string. It requires ADL to work.
So, it should be invoked as: `to_string(id);` and should be preceded
by `using std::to_string`.)""";

      } to_string;

    } geometry;

    // drake::hash_append
    struct /* hash_append */ {

      // drake/common/hash.h:78
      const char* doc =
R"""(Provides hash_append for integral constants.)""";

      // drake/common/hash.h:86
      const char* doc_2 = R"""(Provides hash_append for enumerations.)""";

      // drake/common/hash.h:94
      const char* doc_3 =
R"""(Provides hash_append for floating point values.)""";

      // drake/common/hash.h:110
      const char* doc_4 =
R"""(Provides hash_append for std::string. (Technically, any string based
on `CharT = char`.))""";

      // drake/common/hash.h:122
      const char* doc_5 = R"""(Provides hash_append for std::pair.)""";

      // drake/common/hash.h:144
      const char* doc_6 =
R"""(Provides hash_append for drake::optional.

Note that `std::hash<std::optional<T>>` provides the peculiar
invariant that the hash of an `optional` bearing a value `v` shall
evaluate to the same hash as that of the value `v` itself. Hash
operations implemented with this `hash_append` do *not* provide that
invariant.)""";

      // drake/common/hash.h:177
      const char* doc_7 =
R"""(Provides hash_append for std::map.

Note that there is no `hash_append` overload for `std::unordered_map`,
and such an overload must never appear. See n3980.html#unordered for
details.)""";

      // drake/common/hash.h:192
      const char* doc_8 =
R"""(Provides hash_append for std::set.

Note that there is no `hash_append` overload for `std::unordered_set`,
and such an overload must never appear. See n3980.html#unordered for
details.)""";

    } hash_append;

    // drake::hash_append_range
    struct /* hash_append_range */ {

      // drake/common/hash.h:154
      const char* doc =
R"""(Provides hash_append for a range, as given by two iterators.)""";

    } hash_append_range;

    // drake::if_then_else
    struct /* if_then_else */ {

      // drake/common/autodiff_overloads.h:168
      const char* doc =
R"""(Provides if-then-else expression for Eigen::AutoDiffScalar type. To
support Eigen's generic expressions, we use casting to the plain
object after applying Eigen::internal::remove_all. It is based on the
Eigen's implementation of min/max function for AutoDiffScalar type (ht
tps://bitbucket.org/eigen/eigen/src/10a1de58614569c9250df88bdfc6402024
687bc6/unsupported/Eigen/src/AutoDiff/AutoDiffScalar.h?at=default&file
viewer=file-view-default#AutoDiffScalar.h-546).)""";

      // drake/common/double_overloads.h:17
      const char* doc_2 =
R"""(The semantics is similar but not exactly the same as C++'s conditional
expression constructed by its ternary operator, @c ?:. In
``if_then_else(f_cond, v_then, v_else)``, both of ``v_then`` and
``v_else`` are evaluated regardless of the evaluation of ``f_cond``.
In contrast, only one of ``v_then`` or ``v_else`` is evaluated in
C++'s conditional expression ``f_cond ? v_then : v_else``.)""";

    } if_then_else;

    // drake::is_eigen_nonvector_of
    struct /* is_eigen_nonvector_of */ {

      // drake/common/eigen_types.h:247
      const char* doc = R"""()""";

    } is_eigen_nonvector_of;

    // drake::is_eigen_scalar_same
    struct /* is_eigen_scalar_same */ {

      // drake/common/eigen_types.h:212
      const char* doc = R"""()""";

    } is_eigen_scalar_same;

    // drake::is_eigen_type
    struct /* is_eigen_type */ {

      // drake/common/eigen_types.h:206
      const char* doc = R"""()""";

    } is_eigen_type;

    // drake::is_eigen_vector
    struct /* is_eigen_vector */ {

      // drake/common/eigen_types.h:222
      const char* doc = R"""()""";

    } is_eigen_vector;

    // drake::is_eigen_vector_of
    struct /* is_eigen_vector_of */ {

      // drake/common/eigen_types.h:231
      const char* doc = R"""()""";

    } is_eigen_vector_of;

    // lcm
    struct /* lcm */ {

      // drake::lcm::DrakeLcm
      struct /* DrakeLcm */ {

        // drake/lcm/drake_lcm.h:20
        const char* doc = R"""(A wrapper around a *real* LCM instance.)""";

        // drake/systems/lcm/lcm_publisher_system.h:20
        const char* doc_2 = R"""(A wrapper around a *real* LCM instance.)""";

        // drake::lcm::DrakeLcm::DrakeLcm
        struct /* ctor */ {

          // drake/lcm/drake_lcm.h:22
          const char* doc = R"""()""";

          // drake/lcm/drake_lcm.h:22
          const char* doc_2 = R"""()""";

          // drake/lcm/drake_lcm.h:28
          const char* doc_3 =
R"""(Constructs using LCM's default URL (either the default hard-coded URL,
or else LCM_DEFAULT_URL environment variable if it is set).)""";

          // drake/lcm/drake_lcm.h:34
          const char* doc_4 =
R"""(Constructs using the given URL. If empty, it will use the default URL
as per the no-argument constructor.)""";

        } ctor;

        // drake::lcm::DrakeLcm::IsReceiveThreadRunning
        struct /* IsReceiveThreadRunning */ {

          // drake/lcm/drake_lcm.h:65
          const char* doc =
R"""(Indicates that the receiving thread is running.)""";

        } IsReceiveThreadRunning;

        // drake::lcm::DrakeLcm::Publish
        struct /* Publish */ {

          // drake/lcm/drake_lcm.h:81
          const char* doc = R"""()""";

        } Publish;

        // drake::lcm::DrakeLcm::StartReceiveThread
        struct /* StartReceiveThread */ {

          // drake/lcm/drake_lcm.h:47
          const char* doc =
R"""(Starts the receive thread. This must be called for subscribers to
receive any messages.

@pre StartReceiveThread() was not called.)""";

        } StartReceiveThread;

        // drake::lcm::DrakeLcm::StopReceiveThread
        struct /* StopReceiveThread */ {

          // drake/lcm/drake_lcm.h:60
          const char* doc =
R"""(Stops the receive thread. This must be called prior to any subscribers
being destroyed. Note that the receive thread will be automatically
stopped by this class's destructor, so usage of this method will be
extremely rare. It will only be needed if this class's instance and
the subscribers to LCM channels are owned by different classes. In
such a scenario, this method can be used to ensure the receive thread
is destroyed before the subscribers are destroyed.

@pre StartReceiveThread() was called.)""";

        } StopReceiveThread;

        // drake::lcm::DrakeLcm::Subscribe
        struct /* Subscribe */ {

          // drake/lcm/drake_lcm.h:84
          const char* doc = R"""()""";

          // drake/lcm/drake_lcm.h:88
          const char* doc_2 = R"""()""";

        } Subscribe;

        // drake::lcm::DrakeLcm::get_lcm_instance
        struct /* get_lcm_instance */ {

          // drake/lcm/drake_lcm.h:74
          const char* doc =
R"""(An accessor to the real LCM instance encapsulated by this object. The
returned pointer is guaranteed to be valid for the duration of this
object's lifetime.)""";

        } get_lcm_instance;

        // drake::lcm::DrakeLcm::get_requested_lcm_url
        struct /* get_requested_lcm_url */ {

          // drake/lcm/drake_lcm.h:79
          const char* doc =
R"""(Returns the LCM URL passed into the constructor; this can be empty.)""";

        } get_requested_lcm_url;

      } DrakeLcm;

      // drake::lcm::DrakeLcmInterface
      struct /* DrakeLcmInterface */ {

        // drake/geometry/scene_graph.h:21
        const char* doc =
R"""(A pure virtual interface that enables LCM to be mocked.)""";

        // drake/lcm/drake_lcm_interface.h:22
        const char* doc_2 =
R"""(A pure virtual interface that enables LCM to be mocked.)""";

        // drake::lcm::DrakeLcmInterface::DrakeLcmInterface
        struct /* ctor */ {

          // drake/lcm/drake_lcm_interface.h:24
          const char* doc = R"""()""";

          // drake/lcm/drake_lcm_interface.h:24
          const char* doc_2 = R"""()""";

          // drake/lcm/drake_lcm_interface.h:71
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::lcm::DrakeLcmInterface::Publish
        struct /* Publish */ {

          // drake/lcm/drake_lcm_interface.h:49
          const char* doc =
R"""(Publishes an LCM message on channel ``channel``.

Parameter ``channel``:
    The channel on which to publish the message. Must not be the empty
    string.

Parameter ``data``:
    A buffer containing the serialized bytes of the message to
    publish.

Parameter ``data_size``:
    The length of @data in bytes.

Parameter ``time_sec``:
    Time in seconds when the publish event occurred. If unknown, use
    drake::nullopt or a default-constructed optional.)""";

        } Publish;

        // drake::lcm::DrakeLcmInterface::Subscribe
        struct /* Subscribe */ {

          // drake/lcm/drake_lcm_interface.h:59
          const char* doc =
R"""(Subscribes to an LCM channel without automatic message decoding. The
handler will be invoked when a message arrives on channel ``channel``.

Parameter ``channel``:
    The channel to subscribe to. Must not be the empty string.)""";

          // drake/lcm/drake_lcm_interface.h:66
          const char* doc_2 = R"""(A deprecated overload of Subscribe. */)""";

        } Subscribe;

      } DrakeLcmInterface;

      // drake::lcm::DrakeLcmLog
      struct /* DrakeLcmLog */ {

        // drake/lcm/drake_lcm_log.h:27
        const char* doc =
R"""(A LCM interface for logging LCM messages to a file or playing back
from a existing log. Note the user is responsible for offsetting the
clock used to generate the log and the clock used for playback. For
example, if the log is generated by some external logger (the lcm-
logger binary), which uses the unix epoch time clock to record message
arrival time, the user needs to offset those timestamps properly to
match and the clock used for playback.)""";

        // drake::lcm::DrakeLcmLog::DispatchMessageAndAdvanceLog
        struct /* DispatchMessageAndAdvanceLog */ {

          // drake/lcm/drake_lcm_log.h:101
          const char* doc =
R"""(Let `MSG` be the next message event in the log, if ``current_time``
matches `MSG`'s timestamp, for every DrakeLcmMessageHandlerInterface
`sub` that's subscribed to `MSG`'s channel, invoke `sub`'s
HandleMessage method. Then, this function advances the log by exactly
one message. This function does nothing if `MSG` is null (end of log)
or ``current_time`` does not match `MSG`'s timestamp.

Throws:
    s std::logic_error if this instance is not constructed in read-
    only mode.)""";

        } DispatchMessageAndAdvanceLog;

        // drake::lcm::DrakeLcmLog::DrakeLcmLog
        struct /* ctor */ {

          // drake/lcm/drake_lcm_log.h:29
          const char* doc = R"""()""";

          // drake/lcm/drake_lcm_log.h:29
          const char* doc_2 = R"""()""";

          // drake/lcm/drake_lcm_log.h:46
          const char* doc_3 =
R"""(Constructs a DrakeLcmLog.

Parameter ``file_name``:
    Log's file name for reading or writing.

Parameter ``is_write``:
    If false, this instance reads from the Lcm log identified by
    ``file_name``. If true, this instance writes to the Lcm log whose
    name is given by ``file_name``.

Parameter ``overwrite_publish_time_with_system_clock``:
    This parameter only affects the Publish method in write-only mode.
    If true, override the `second` parameter passed to Publish method,
    and use host system's clock to generate the timestamp for the
    logged message. This is used to mimic lcm-logger's behavior. It
    also implicitly records how fast the messages are generated in
    real time.

Throws:
    s std::runtime_error if unable to open file.)""";

        } ctor;

        // drake::lcm::DrakeLcmLog::GetNextMessageTime
        struct /* GetNextMessageTime */ {

          // drake/lcm/drake_lcm_log.h:88
          const char* doc =
R"""(Returns the time in seconds for the next logged message's occurrence
time or infinity if there are no more messages in the current log.

Throws:
    s std::logic_error if this instance is not constructed in read-
    only mode.)""";

        } GetNextMessageTime;

        // drake::lcm::DrakeLcmLog::Publish
        struct /* Publish */ {

          // drake/lcm/drake_lcm_log.h:64
          const char* doc =
R"""(Writes an entry occurred at ``timestamp`` with content ``data`` to the
log file. The current implementation blocks until writing is done.

Parameter ``channel``:
    Channel name.

Parameter ``data``:
    Pointer to raw bytes.

Parameter ``data_size``:
    Number of bytes in ``data``.

Parameter ``time_sec``:
    Time in seconds when the message is published. Since messages are
    save to the log file in the order of Publish calls, this function
    should only be called with non-decreasing ``second``. Note that
    this parameter can be overwritten by the host system's clock if
    `overwrite_publish_time_with_system_clock` is true at construction
    time.

Throws:
    s std::logic_error if this instance is not constructed in write-
    only mode.)""";

        } Publish;

        // drake::lcm::DrakeLcmLog::Subscribe
        struct /* Subscribe */ {

          // drake/lcm/drake_lcm_log.h:74
          const char* doc =
R"""(Subscribes ``handler`` to ``channel``. Multiple handlers can subscribe
to the same channel.

Throws:
    s std::logic_error if this instance is not constructed in read-
    only mode.)""";

          // drake/lcm/drake_lcm_log.h:78
          const char* doc_2 = R"""()""";

        } Subscribe;

        // drake::lcm::DrakeLcmLog::is_write
        struct /* is_write */ {

          // drake/lcm/drake_lcm_log.h:106
          const char* doc =
R"""(Returns true if this instance is constructed in write-only mode.)""";

        } is_write;

        // drake::lcm::DrakeLcmLog::second_to_timestamp
        struct /* second_to_timestamp */ {

          // drake/lcm/drake_lcm_log.h:120
          const char* doc =
R"""(Converts time (in seconds) relative to the starting time passed to the
constructor to a timestamp in microseconds.)""";

        } second_to_timestamp;

        // drake::lcm::DrakeLcmLog::timestamp_to_second
        struct /* timestamp_to_second */ {

          // drake/lcm/drake_lcm_log.h:112
          const char* doc =
R"""(Converts ``timestamp`` (in microseconds) to time (in seconds) relative
to the starting time passed to the constructor.)""";

        } timestamp_to_second;

      } DrakeLcmLog;

      // drake::lcm::DrakeLcmMessageHandlerInterface
      struct /* DrakeLcmMessageHandlerInterface */ {

        // drake/lcm/drake_lcm_message_handler_interface.h:20
        const char* doc =
R"""(Defines a message handler interface that must be implemented by all
LCM subscribers within Drake.

See also:
    DrakeLcmInterface::Subscribe().)""";

        // drake::lcm::DrakeLcmMessageHandlerInterface::DrakeLcmMessageHandlerInterface
        struct /* ctor */ {

          // drake/lcm/drake_lcm_message_handler_interface.h:24
          const char* doc = R"""()""";

          // drake/lcm/drake_lcm_message_handler_interface.h:24
          const char* doc_2 = R"""()""";

          // drake/lcm/drake_lcm_message_handler_interface.h:26
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::lcm::DrakeLcmMessageHandlerInterface::HandleMessage
        struct /* HandleMessage */ {

          // drake/lcm/drake_lcm_message_handler_interface.h:40
          const char* doc =
R"""(This method is called when an LCM message arrives over the subscribed
channel.

Parameter ``channel``:
    The channel on which the LCM message was received.

Parameter ``message_buffer``:
    A pointer to the byte vector that is the serial representation of
    the LCM message.

Parameter ``message_size``:
    The size of ``message_buffer``.)""";

        } HandleMessage;

      } DrakeLcmMessageHandlerInterface;

      // drake::lcm::DrakeMockLcm
      struct /* DrakeMockLcm */ {

        // drake/lcm/drake_mock_lcm.h:21
        const char* doc =
R"""(A *mock* LCM instance. This does not actually publish or subscribe to
LCM messages. It contains additional methods for accessing the most
recent message that was "published," and faking a callback.)""";

        // drake::lcm::DrakeMockLcm::DecodeLastPublishedMessageAs
        struct /* DecodeLastPublishedMessageAs */ {

          // drake/lcm/drake_mock_lcm.h:58
          const char* doc =
R"""(Obtains the most recently "published" message on a particular channel.
This method automatically decodes the message into an LCM message
whose type is specified by the template type. Throws a
std::runtime_error exception if no LCM message was published on the
provided channel or if the message failed to be decoded by the
provided LCM message type.

Template parameter ``T``:
    The LCM message type.

Parameter ``channel``:
    the LCM channel for which the last published message is returned.

Returns:
    the decoded most recently transmitted LCM message on the provided
    channel.)""";

        } DecodeLastPublishedMessageAs;

        // drake::lcm::DrakeMockLcm::DrakeMockLcm
        struct /* ctor */ {

          // drake/lcm/drake_mock_lcm.h:23
          const char* doc = R"""()""";

          // drake/lcm/drake_mock_lcm.h:23
          const char* doc_2 = R"""()""";

          // drake/lcm/drake_mock_lcm.h:30
          const char* doc_3 =
R"""(A constructor that creates a DrakeMockLcm with loopback disabled,
i.e., a call to Publish() will not result in subscriber callback
functions being executed. To enable loopback behavior, call
EnableLoopBack().)""";

        } ctor;

        // drake::lcm::DrakeMockLcm::EnableLoopBack
        struct /* EnableLoopBack */ {

          // drake/lcm/drake_mock_lcm.h:38
          const char* doc =
R"""(Enables loopback behavior. With loopback enabled, a call to Publish()
will result in subscriber callback functions being called. Without
loopback enabled, the only way to induce a call to a subscriber's
callback function is through InduceSubscriberCallback().)""";

        } EnableLoopBack;

        // drake::lcm::DrakeMockLcm::InduceSubscriberCallback
        struct /* InduceSubscriberCallback */ {

          // drake/lcm/drake_mock_lcm.h:117
          const char* doc =
R"""(Fakes a callback. The callback is executed by the same thread as the
one calling this method.

Parameter ``channel``:
    The channel on which to publish the message.

Parameter ``data``:
    A buffer containing the serialized bytes of the message to
    publish.

Parameter ``data_size``:
    The length of @data in bytes.)""";

        } InduceSubscriberCallback;

        // drake::lcm::DrakeMockLcm::Publish
        struct /* Publish */ {

          // drake/lcm/drake_mock_lcm.h:40
          const char* doc = R"""()""";

        } Publish;

        // drake::lcm::DrakeMockLcm::Subscribe
        struct /* Subscribe */ {

          // drake/lcm/drake_mock_lcm.h:98
          const char* doc = R"""()""";

          // drake/lcm/drake_mock_lcm.h:102
          const char* doc_2 = R"""()""";

        } Subscribe;

        // drake::lcm::DrakeMockLcm::get_last_publication_time
        struct /* get_last_publication_time */ {

          // drake/lcm/drake_mock_lcm.h:96
          const char* doc =
R"""(Returns the time of the most recent publication on a particular
channel. Returns nullopt iff a message has never been published on
this channel or the most recent Publish call had no time_sec.)""";

        } get_last_publication_time;

        // drake::lcm::DrakeMockLcm::get_last_published_message
        struct /* get_last_published_message */ {

          // drake/lcm/drake_mock_lcm.h:88
          const char* doc =
R"""(Obtains the most recently "published" message on a particular channel.
A std::runtime_error will be thrown if no message was published on the
provide channel.

Parameter ``channel``:
    The channel on which the LCM message was published.

Returns:
    A reference to a vector containing the serialized bytes of the LCM
    message that was previously published on channel ``channel``.

@pre A message was previously published on channel ``channel``.)""";

        } get_last_published_message;

      } DrakeMockLcm;

      // drake::lcm::LcmReceiveThread
      struct /* LcmReceiveThread */ {

        // drake/lcm/lcm_receive_thread.h:17
        const char* doc =
R"""(Maintains a thread that receives LCM messages and dispatches the
messages to the appropriate message handlers.)""";

        // drake::lcm::LcmReceiveThread::LcmReceiveThread
        struct /* ctor */ {

          // drake/lcm/lcm_receive_thread.h:19
          const char* doc = R"""()""";

          // drake/lcm/lcm_receive_thread.h:19
          const char* doc_2 = R"""()""";

          // drake/lcm/lcm_receive_thread.h:28
          const char* doc_3 =
R"""(A constructor that instantiates the thread.

Parameter ``lcm``:
    A pointer to the LCM instance through which to access the LCM
    network. This parameter cannot be `nullptr` and must remain valid
    for the lifetime of this object.)""";

        } ctor;

        // drake::lcm::LcmReceiveThread::Stop
        struct /* Stop */ {

          // drake/lcm/lcm_receive_thread.h:39
          const char* doc =
R"""(Stops the LCM receive thread. This stops the reception of LCM
messages.)""";

        } Stop;

      } LcmReceiveThread;

      // drake::lcm::Publish
      struct /* Publish */ {

        // drake/lcm/drake_lcm_interface.h:89
        const char* doc =
R"""(Publishes an LCM message on channel ``channel``.

Parameter ``lcm``:
    The LCM service on which to publish the message. Must not be null.

Parameter ``channel``:
    The channel on which to publish the message. Must not be the empty
    string.

Parameter ``message``:
    The message to publish.

Parameter ``time_sec``:
    Time in seconds when the publish event occurred. If unknown, use
    the default value of drake::nullopt.)""";

      } Publish;

      // drake::lcm::Subscribe
      struct /* Subscribe */ {

        // drake/lcm/drake_lcm_interface.h:120
        const char* doc =
R"""(Subscribes to an LCM channel named ``channel`` and decodes messages of
type ``Message``.

Parameter ``lcm``:
    The LCM service on which to subscribe. Must not be null.

Parameter ``channel``:
    The channel on which to subscribe. Must not be the empty string.

Parameter ``handler``:
    The callback when a message is received and decoded without error.

Parameter ``on_error``:
    The callback when a message is received and cannot be decoded; if
    no error handler is given, an exception is thrown instead.

Note:
    Depending on the specific DrakeLcmInterface implementation, the
    handler might be invoked on a different thread than this function.)""";

      } Subscribe;

      // drake::lcm::TranslatorBase
      struct /* TranslatorBase */ {

        // drake/lcm/translator_base.h:24
        const char* doc =
R"""(Base API for a translator between arbitrary data of DataType and a Lcm
message of MsgType. This class is intended to facilitate Lcm
communication under the System framework. Within the System framework,
time can be acquired directly from the Context, so it is not uncommon
to omit time from state representations (DataType). Meanwhile, a well
defined Lcm message (MsgType) almost always contains an time stamp.
Thus, additional time information (often extracted from some Context)
can be used for message encoding (from DataType to MsgType). For
decoding (from MsgType to DataType), the message's time stamp can be
extracted and stored separately.

Note that MsgType is not required to be a Lcm message. In fact, it can
be any arbitrary data type as well.)""";

        // drake::lcm::TranslatorBase::Decode
        struct /* Decode */ {

          // drake/lcm/translator_base.h:49
          const char* doc = R"""(Decodes ``msg`` into ``data``.)""";

        } Decode;

        // drake::lcm::TranslatorBase::DecodeTime
        struct /* DecodeTime */ {

          // drake/lcm/translator_base.h:61
          const char* doc =
R"""(Decodes ``msg`` into ``time``. The default implementation does
nothing.)""";

        } DecodeTime;

        // drake::lcm::TranslatorBase::Encode
        struct /* Encode */ {

          // drake/lcm/translator_base.h:44
          const char* doc = R"""(Encodes ``data`` into ``msg``.)""";

        } Encode;

        // drake::lcm::TranslatorBase::EncodeTime
        struct /* EncodeTime */ {

          // drake/lcm/translator_base.h:54
          const char* doc =
R"""(Encodes ``time`` into ``msg``. The default implementation does
nothing.)""";

        } EncodeTime;

        // drake::lcm::TranslatorBase::TranslatorBase<DataType, MsgType>
        struct /* ctor */ {

          // drake/lcm/translator_base.h:26
          const char* doc = R"""()""";

          // drake/lcm/translator_base.h:26
          const char* doc_2 = R"""()""";

          // drake/lcm/translator_base.h:28
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::lcm::TranslatorBase::get_default_data
        struct /* get_default_data */ {

          // drake/lcm/translator_base.h:34
          const char* doc =
R"""(Returns a const reference to the default data value.)""";

        } get_default_data;

        // drake::lcm::TranslatorBase::get_default_msg
        struct /* get_default_msg */ {

          // drake/lcm/translator_base.h:39
          const char* doc =
R"""(Returns a const reference to the default message value.)""";

        } get_default_msg;

      } TranslatorBase;

    } lcm;

    // drake::log
    struct /* log */ {

      // drake/common/text_logging.h:144
      const char* doc =
R"""(Retrieve an instance of a logger to use for logging; for example:
`drake::log()->info("potato!")`)""";

    } log;

    // maliput
    struct /* maliput */ {

      // api
      struct /* api */ {

        // drake::maliput::api::BasicIdIndex
        struct /* BasicIdIndex */ {

          // drake/automotive/maliput/api/basic_id_index.h:19
          const char* doc =
R"""(Basic general-purpose concrete implementation of the
RoadGeometry::IdIndex interface.)""";

          // drake::maliput::api::BasicIdIndex::AddBranchPoint
          struct /* AddBranchPoint */ {

            // drake/automotive/maliput/api/basic_id_index.h:48
            const char* doc =
R"""(Adds ``branch_point`` to the index.

Throws:
    s if ``branch_point``'s id() already exists in the index. @pre
    ``branch_point`` is not nullptr.)""";

          } AddBranchPoint;

          // drake::maliput::api::BasicIdIndex::AddJunction
          struct /* AddJunction */ {

            // drake/automotive/maliput/api/basic_id_index.h:42
            const char* doc =
R"""(Adds ``junction`` to the index.

Throws:
    s if ``junction``'s id() already exists in the index. @pre
    ``junction`` is not nullptr.)""";

          } AddJunction;

          // drake::maliput::api::BasicIdIndex::AddLane
          struct /* AddLane */ {

            // drake/automotive/maliput/api/basic_id_index.h:30
            const char* doc =
R"""(Adds ``lane`` to the index.

Throws:
    s if ``lane``'s id() already exists in the index. @pre ``lane`` is
    not nullptr.)""";

          } AddLane;

          // drake::maliput::api::BasicIdIndex::AddSegment
          struct /* AddSegment */ {

            // drake/automotive/maliput/api/basic_id_index.h:36
            const char* doc =
R"""(Adds ``segment`` to the index.

Throws:
    s if ``segment``'s id() already exists in the index. @pre
    ``segment`` is not nullptr.)""";

          } AddSegment;

          // drake::maliput::api::BasicIdIndex::BasicIdIndex
          struct /* ctor */ {

            // drake/automotive/maliput/api/basic_id_index.h:21
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/basic_id_index.h:21
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/basic_id_index.h:23
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::BasicIdIndex::WalkAndAddAll
          struct /* WalkAndAddAll */ {

            // drake/automotive/maliput/api/basic_id_index.h:56
            const char* doc =
R"""(Walks the object graph rooted at ``road_geometry`` and adds all
components (Lane, Segment, Junction, BranchPoint) to the index.

Throws:
    s if the graph of ``road_geometry`` contains any duplicate id's,
    or if any of its id's already exist in the index. @pre
    ``road_geometry`` is not nullptr.)""";

          } WalkAndAddAll;

        } BasicIdIndex;

        // drake::maliput::api::BranchPoint
        struct /* BranchPoint */ {

          // drake/automotive/maliput/api/branch_point.h:67
          const char* doc =
R"""(A BranchPoint is a node in the network of a RoadGeometry at which
Lanes connect to one another. A BranchPoint is a collection of
LaneEnds specifying the Lanes (and, in particular, which ends of the
Lanes) are connected at the BranchPoint.

LaneEnds participating in a BranchPoint are grouped into two sets,
arbitrarily named "A-side" and "B-side". LaneEnds on the same "side"
have coincident into-the-lane tangent vectors, which are anti-parallel
to those of LaneEnds on the other side.)""";

          // drake/automotive/maliput/api/lane.h:17
          const char* doc_2 =
R"""(A BranchPoint is a node in the network of a RoadGeometry at which
Lanes connect to one another. A BranchPoint is a collection of
LaneEnds specifying the Lanes (and, in particular, which ends of the
Lanes) are connected at the BranchPoint.

LaneEnds participating in a BranchPoint are grouped into two sets,
arbitrarily named "A-side" and "B-side". LaneEnds on the same "side"
have coincident into-the-lane tangent vectors, which are anti-parallel
to those of LaneEnds on the other side.)""";

          // drake/automotive/maliput/api/road_geometry.h:18
          const char* doc_3 =
R"""(A BranchPoint is a node in the network of a RoadGeometry at which
Lanes connect to one another. A BranchPoint is a collection of
LaneEnds specifying the Lanes (and, in particular, which ends of the
Lanes) are connected at the BranchPoint.

LaneEnds participating in a BranchPoint are grouped into two sets,
arbitrarily named "A-side" and "B-side". LaneEnds on the same "side"
have coincident into-the-lane tangent vectors, which are anti-parallel
to those of LaneEnds on the other side.)""";

          // drake::maliput::api::BranchPoint::BranchPoint
          struct /* ctor */ {

            // drake/automotive/maliput/api/branch_point.h:69
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/branch_point.h:69
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/branch_point.h:117
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::BranchPoint::GetASide
          struct /* GetASide */ {

            // drake/automotive/maliput/api/branch_point.h:111
            const char* doc =
R"""(Returns the set of LaneEnds grouped together on the "A-side".)""";

          } GetASide;

          // drake::maliput::api::BranchPoint::GetBSide
          struct /* GetBSide */ {

            // drake/automotive/maliput/api/branch_point.h:114
            const char* doc =
R"""(Returns the set of LaneEnds grouped together on the "B-side".)""";

          } GetBSide;

          // drake::maliput::api::BranchPoint::GetConfluentBranches
          struct /* GetConfluentBranches */ {

            // drake/automotive/maliput/api/branch_point.h:85
            const char* doc =
R"""(Returns the set of LaneEnds on the same side as the given ``end``,
e.g., the LaneEnds merging with the given ``end``.

The returned set includes the given ``end``.

@pre ``end`` must be connected to the BranchPoint.)""";

          } GetConfluentBranches;

          // drake::maliput::api::BranchPoint::GetDefaultBranch
          struct /* GetDefaultBranch */ {

            // drake/automotive/maliput/api/branch_point.h:106
            const char* doc =
R"""(Returns the default ongoing branch (if any) for the given ``end``.
This typically represents what would be considered "continuing
through-traffic" from ``end`` (e.g., as opposed to a branch executing
a turn).

If ``end`` has no default-branch at this BranchPoint, the return value
will be nullopt.

@pre ``end`` must be connected to the BranchPoint.)""";

          } GetDefaultBranch;

          // drake::maliput::api::BranchPoint::GetOngoingBranches
          struct /* GetOngoingBranches */ {

            // drake/automotive/maliput/api/branch_point.h:93
            const char* doc =
R"""(Returns the set of LaneEnds on the other side from the given ``end``,
e.g., the LaneEnds which ``end`` flows into.

@pre ``end`` must be connected to the BranchPoint.)""";

          } GetOngoingBranches;

          // drake::maliput::api::BranchPoint::id
          struct /* id */ {

            // drake/automotive/maliput/api/branch_point.h:74
            const char* doc = R"""(Returns the persistent identifier.)""";

          } id;

          // drake::maliput::api::BranchPoint::road_geometry
          struct /* road_geometry */ {

            // drake/automotive/maliput/api/branch_point.h:77
            const char* doc =
R"""(Returns the RoadGeometry to which this BranchPoint belongs.)""";

          } road_geometry;

        } BranchPoint;

        // drake::maliput::api::GeoPositionT
        struct /* GeoPositionT */ {

          // drake/automotive/maliput/api/lane_data.h:135
          const char* doc =
R"""(A position in 3-dimensional geographical Cartesian space, i.e., in the
world frame, consisting of three components x, y, and z.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.)""";

          // drake::maliput::api::GeoPositionT::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/lane_data.h:137
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::GeoPositionT::FromXyz
          struct /* FromXyz */ {

            // drake/automotive/maliput/api/lane_data.h:146
            const char* doc =
R"""(Constructs a GeoPositionT from a 3-vector ``xyz`` of the form `[x, y,
z]`.)""";

          } FromXyz;

          // drake::maliput::api::GeoPositionT::GeoPositionT<T>
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:137
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:137
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:140
            const char* doc_3 =
R"""(Default constructor, initializing all components to zero.)""";

            // drake/automotive/maliput/api/lane_data.h:143
            const char* doc_4 = R"""(Fully parameterized constructor.)""";

          } ctor;

          // drake::maliput::api::GeoPositionT::MakeDouble
          struct /* MakeDouble */ {

            // drake/automotive/maliput/api/lane_data.h:173
            const char* doc =
R"""(Constructs a GeoPositionT<double> from other types, producing a clone
if already double.)""";

          } MakeDouble;

          // drake::maliput::api::GeoPositionT::set_x
          struct /* set_x */ {

            // drake/automotive/maliput/api/lane_data.h:160
            const char* doc = R"""(Sets `x` value.)""";

          } set_x;

          // drake::maliput::api::GeoPositionT::set_xyz
          struct /* set_xyz */ {

            // drake/automotive/maliput/api/lane_data.h:153
            const char* doc =
R"""(Sets all components from 3-vector `[x, y, z]`.)""";

          } set_xyz;

          // drake::maliput::api::GeoPositionT::set_y
          struct /* set_y */ {

            // drake/automotive/maliput/api/lane_data.h:164
            const char* doc = R"""(Sets `y` value.)""";

          } set_y;

          // drake::maliput::api::GeoPositionT::set_z
          struct /* set_z */ {

            // drake/automotive/maliput/api/lane_data.h:168
            const char* doc = R"""(Sets `z` value.)""";

          } set_z;

          // drake::maliput::api::GeoPositionT::x
          struct /* x */ {

            // drake/automotive/maliput/api/lane_data.h:158
            const char* doc = R"""(Gets `x` value.)""";

          } x;

          // drake::maliput::api::GeoPositionT::xyz
          struct /* xyz */ {

            // drake/automotive/maliput/api/lane_data.h:151
            const char* doc =
R"""(Returns all components as 3-vector `[x, y, z]`.)""";

          } xyz;

          // drake::maliput::api::GeoPositionT::y
          struct /* y */ {

            // drake/automotive/maliput/api/lane_data.h:162
            const char* doc = R"""(Gets `y` value.)""";

          } y;

          // drake::maliput::api::GeoPositionT::z
          struct /* z */ {

            // drake/automotive/maliput/api/lane_data.h:166
            const char* doc = R"""(Gets `z` value.)""";

          } z;

        } GeoPositionT;

        // drake::maliput::api::HBounds
        struct /* HBounds */ {

          // drake/automotive/maliput/api/lane_data.h:360
          const char* doc =
R"""(Bounds in the elevation dimension (`h` component) of a `Lane`-frame,
consisting of a pair of minimum and maximum `h` value. The bounds must
straddle `h = 0`, i.e., the minimum must be `<= 0` and the maximum
must be `>= 0`.)""";

          // drake::maliput::api::HBounds::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/lane_data.h:362
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::HBounds::HBounds
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:362
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:362
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:365
            const char* doc_3 = R"""(Default constructor.)""";

            // drake/automotive/maliput/api/lane_data.h:370
            const char* doc_4 =
R"""(Fully parameterized constructor.

Throws:
    s std::runtime_error When ``min`` is greater than 0.

Throws:
    s std::runtime_error When ``max`` is smaller than 0.)""";

          } ctor;

          // drake::maliput::api::HBounds::max
          struct /* max */ {

            // drake/automotive/maliput/api/lane_data.h:386
            const char* doc = R"""(Gets maximum bound.)""";

          } max;

          // drake::maliput::api::HBounds::min
          struct /* min */ {

            // drake/automotive/maliput/api/lane_data.h:378
            const char* doc = R"""(Gets minimum bound.)""";

          } min;

          // drake::maliput::api::HBounds::set_max
          struct /* set_max */ {

            // drake/automotive/maliput/api/lane_data.h:389
            const char* doc =
R"""(Sets maximum bound.

Throws:
    s std::runtime_error When ``max`` is smaller than 0.)""";

          } set_max;

          // drake::maliput::api::HBounds::set_min
          struct /* set_min */ {

            // drake/automotive/maliput/api/lane_data.h:381
            const char* doc =
R"""(Sets minimum bound.

Throws:
    s std::runtime_error When ``min`` is greater than 0.)""";

          } set_min;

        } HBounds;

        // drake::maliput::api::IsoLaneVelocity
        struct /* IsoLaneVelocity */ {

          // drake/automotive/maliput/api/lane_data.h:283
          const char* doc =
R"""(Isometric velocity vector in a `Lane`-frame.

sigma_v, rho_v, and eta_v are the components of velocity in a (sigma,
rho, eta) coordinate system. (sigma, rho, eta) have the same
orientation as the (s, r, h) at any given point in space, however they
form an isometric system with a Cartesian distance metric. Hence,
IsoLaneVelocity represents a "real" physical velocity vector (albeit
with an orientation relative to the road surface).)""";

          // drake::maliput::api::IsoLaneVelocity::IsoLaneVelocity
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:285
            const char* doc = R"""(Default constructor.)""";

            // drake/automotive/maliput/api/lane_data.h:288
            const char* doc_2 = R"""(Fully parameterized constructor.)""";

          } ctor;

          // drake::maliput::api::IsoLaneVelocity::eta_v
          struct /* eta_v */ {

            // drake/automotive/maliput/api/lane_data.h:293
            const char* doc = R"""()""";

          } eta_v;

          // drake::maliput::api::IsoLaneVelocity::rho_v
          struct /* rho_v */ {

            // drake/automotive/maliput/api/lane_data.h:292
            const char* doc = R"""()""";

          } rho_v;

          // drake::maliput::api::IsoLaneVelocity::sigma_v
          struct /* sigma_v */ {

            // drake/automotive/maliput/api/lane_data.h:291
            const char* doc = R"""()""";

          } sigma_v;

        } IsoLaneVelocity;

        // drake::maliput::api::Junction
        struct /* Junction */ {

          // drake/automotive/maliput/api/junction.h:17
          const char* doc =
R"""(A Junction is a closed set of Segments which have physically coplanar
road surfaces, in the sense that RoadPositions with the same h value
(height above surface) in the domains of two Segments map to the same
GeoPosition. The Segments need not be directly connected to one
another in the network topology.

Junctions are grouped by RoadGeometry.)""";

          // drake/automotive/maliput/api/junction.h:27
          const char* doc_2 =
R"""(A Junction is a closed set of Segments which have physically coplanar
road surfaces, in the sense that RoadPositions with the same h value
(height above surface) in the domains of two Segments map to the same
GeoPosition. The Segments need not be directly connected to one
another in the network topology.

Junctions are grouped by RoadGeometry.)""";

          // drake/automotive/maliput/api/road_geometry.h:19
          const char* doc_3 =
R"""(A Junction is a closed set of Segments which have physically coplanar
road surfaces, in the sense that RoadPositions with the same h value
(height above surface) in the domains of two Segments map to the same
GeoPosition. The Segments need not be directly connected to one
another in the network topology.

Junctions are grouped by RoadGeometry.)""";

          // drake/automotive/maliput/api/segment.h:12
          const char* doc_4 =
R"""(A Junction is a closed set of Segments which have physically coplanar
road surfaces, in the sense that RoadPositions with the same h value
(height above surface) in the domains of two Segments map to the same
GeoPosition. The Segments need not be directly connected to one
another in the network topology.

Junctions are grouped by RoadGeometry.)""";

          // drake::maliput::api::Junction::Junction
          struct /* ctor */ {

            // drake/automotive/maliput/api/junction.h:29
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/junction.h:29
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/junction.h:50
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::Junction::id
          struct /* id */ {

            // drake/automotive/maliput/api/junction.h:34
            const char* doc = R"""(Returns the persistent identifier.)""";

          } id;

          // drake::maliput::api::Junction::num_segments
          struct /* num_segments */ {

            // drake/automotive/maliput/api/junction.h:42
            const char* doc =
R"""(Returns the number of Segments in the Junction.

Return value is non-negative.)""";

          } num_segments;

          // drake::maliput::api::Junction::road_geometry
          struct /* road_geometry */ {

            // drake/automotive/maliput/api/junction.h:37
            const char* doc =
R"""(Returns the RoadGeometry to which this Junction belongs.)""";

          } road_geometry;

          // drake::maliput::api::Junction::segment
          struct /* segment */ {

            // drake/automotive/maliput/api/junction.h:47
            const char* doc =
R"""(Returns the Segment indexed by ``index``.

@pre ``index`` must be >= 0 and < num_segments().)""";

          } segment;

        } Junction;

        // drake::maliput::api::Lane
        struct /* Lane */ {

          // drake/automotive/maliput/api/lane.h:35
          const char* doc =
R"""(A Lane represents a lane of travel in a road network. A Lane defines a
curvilinear coordinate system covering the road surface, with a
longitudinal 's' coordinate that expresses the arc-length along a
central reference curve. The reference curve nominally represents an
ideal travel trajectory along the Lane.

Lanes are grouped by Segment. All Lanes belonging to a Segment
represent the same road surface, but with different coordinate
parameterizations (e.g., each Lane has its own reference curve).)""";

          // drake/automotive/maliput/api/lane_data.h:21
          const char* doc_2 =
R"""(A Lane represents a lane of travel in a road network. A Lane defines a
curvilinear coordinate system covering the road surface, with a
longitudinal 's' coordinate that expresses the arc-length along a
central reference curve. The reference curve nominally represents an
ideal travel trajectory along the Lane.

Lanes are grouped by Segment. All Lanes belonging to a Segment
represent the same road surface, but with different coordinate
parameterizations (e.g., each Lane has its own reference curve).)""";

          // drake/automotive/maliput/api/segment.h:13
          const char* doc_3 =
R"""(A Lane represents a lane of travel in a road network. A Lane defines a
curvilinear coordinate system covering the road surface, with a
longitudinal 's' coordinate that expresses the arc-length along a
central reference curve. The reference curve nominally represents an
ideal travel trajectory along the Lane.

Lanes are grouped by Segment. All Lanes belonging to a Segment
represent the same road surface, but with different coordinate
parameterizations (e.g., each Lane has its own reference curve).)""";

          // drake::maliput::api::Lane::EvalMotionDerivatives
          struct /* EvalMotionDerivatives */ {

            // drake/automotive/maliput/api/lane.h:202
            const char* doc =
R"""(Computes derivatives of LanePosition given a velocity vector
``velocity``. ``velocity`` is a isometric velocity vector oriented in
the `Lane`-frame at ``position``.

Returns:
    `Lane`-frame derivatives packed into a LanePosition struct.)""";

          } EvalMotionDerivatives;

          // drake::maliput::api::Lane::GetBranchPoint
          struct /* GetBranchPoint */ {

            // drake/automotive/maliput/api/lane.h:212
            const char* doc =
R"""(Returns the lane's BranchPoint for the end specified by ``which_end``.)""";

          } GetBranchPoint;

          // drake::maliput::api::Lane::GetConfluentBranches
          struct /* GetConfluentBranches */ {

            // drake/automotive/maliput/api/lane.h:219
            const char* doc =
R"""(Returns the set of LaneEnd's which connect with this lane on the same
side of the BranchPoint at ``which_end``. At a minimum, this set will
include this Lane.)""";

          } GetConfluentBranches;

          // drake::maliput::api::Lane::GetDefaultBranch
          struct /* GetDefaultBranch */ {

            // drake/automotive/maliput/api/lane.h:233
            const char* doc =
R"""(Returns the default ongoing LaneEnd connected at ``which_end``, or
nullopt if no default branch has been established at ``which_end``.)""";

          } GetDefaultBranch;

          // drake::maliput::api::Lane::GetOngoingBranches
          struct /* GetOngoingBranches */ {

            // drake/automotive/maliput/api/lane.h:226
            const char* doc =
R"""(Returns the set of LaneEnd's which continue onward from this lane at
the BranchPoint at ``which_end``.)""";

          } GetOngoingBranches;

          // drake::maliput::api::Lane::GetOrientation
          struct /* GetOrientation */ {

            // drake/automotive/maliput/api/lane.h:193
            const char* doc =
R"""(Returns the rotation which expresses the orientation of the
`Lane`-frame basis at ``lane_pos`` with respect to the world frame
basis.)""";

          } GetOrientation;

          // drake::maliput::api::Lane::Lane
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane.h:37
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane.h:37
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane.h:239
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::Lane::ToGeoPosition
          struct /* ToGeoPosition */ {

            // drake/automotive/maliput/api/lane.h:101
            const char* doc =
R"""(Returns the GeoPosition corresponding to the given LanePosition.

@pre The s component of ``lane_pos`` must be in domain [0,
Lane::length()]. @pre The r component of ``lane_pos`` must be in
domain [Rmin, Rmax] derived from Lane::driveable_bounds().)""";

          } ToGeoPosition;

          // drake::maliput::api::Lane::ToGeoPositionT
          struct /* ToGeoPositionT */ {

            // drake/automotive/maliput/api/lane.h:129
            const char* doc =
R"""(Generalization of ToGeoPosition to arbitrary scalar types, where the
structures `LanePositionT<T>` and `GeoPositionT<T>` are used in place
of `LanePosition` and `GeoPosition`, respectively.

When the arguments are of type AutoDiffXd, the return value is a
GeoPositionT<AutoDiffXd> containing the same partial derivatives as
those appearing in lane_pos. The provided lane_pos must be internally
consistent; the s, r, and h variables must have derivatives of equal
size, and where the i-th derivative of one variable is taken with
respect to the same quantity as the i-th derviative of another
variable.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.

Note: This is an experimental API that is not necessarily implemented
in all back-end implementations.)""";

          } ToGeoPositionT;

          // drake::maliput::api::Lane::ToLanePosition
          struct /* ToLanePosition */ {

            // drake/automotive/maliput/api/lane.h:143
            const char* doc =
R"""(Determines the LanePosition corresponding to GeoPosition ``geo_pos``.

The return value is the LanePosition of the point within the Lane's
driveable-bounds which is closest to ``geo_pos`` (as measured by the
Cartesian metric in the world frame). If ``nearest_point`` is non-
null, then it will be populated with the GeoPosition of that nearest
point. If ``distance`` is non-null, then it will be populated with the
Cartesian distance from ``geo_pos`` to that nearest point.

This method guarantees that its result satisfies the condition that
`ToGeoPosition(result)` is within `linear_tolerance()` of
`*nearest_position`.)""";

          } ToLanePosition;

          // drake::maliput::api::Lane::ToLanePositionT
          struct /* ToLanePositionT */ {

            // drake/automotive/maliput/api/lane.h:179
            const char* doc =
R"""(Generalization of ToLanePosition to arbitrary scalar types, where the
structures `LanePositionT<T>` and `GeoPositionT<T>` are used in place
of `LanePosition` and `GeoPosition`, respectively.

When the arguments are of type AutoDiffXd, the return value is a
LanePositionT<AutoDiffXd> containing the same partial derivatives as
those appearing in geo_pos. The provided geo_pos must be internally
consistent; the x, y, and z variables must have derivatives of equal
size, and where the i-th derivative of one variable is taken with
respect to the same quantity as the i-th derviative of another
variable. If either ``nearest_point`` or ``distance`` are non-null,
they will also contain ``geo_pos``'s partial derivatives.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.

Note: This is an experimental API that is not necessarily implemented
in all back-end implementations.)""";

          } ToLanePositionT;

          // drake::maliput::api::Lane::driveable_bounds
          struct /* driveable_bounds */ {

            // drake/automotive/maliput/api/lane.h:84
            const char* doc =
R"""(Returns the driveable lateral (r) bounds of the lane as a function of
s.

These are the lateral bounds for a position that is considered to be
"on pavement", reflecting the physical extent of the paved surface of
the lane's segment.)""";

          } driveable_bounds;

          // drake::maliput::api::Lane::elevation_bounds
          struct /* elevation_bounds */ {

            // drake/automotive/maliput/api/lane.h:90
            const char* doc =
R"""(Returns the elevation (`h`) bounds of the lane as a function of `(s,
r)`.

These are the elevation bounds for a position that is considered to be
within the volume modelled by the RoadGeometry.)""";

          } elevation_bounds;

          // drake::maliput::api::Lane::id
          struct /* id */ {

            // drake/automotive/maliput/api/lane.h:42
            const char* doc = R"""(Returns the persistent identifier.)""";

          } id;

          // drake::maliput::api::Lane::index
          struct /* index */ {

            // drake/automotive/maliput/api/lane.h:48
            const char* doc =
R"""(Returns the index of this Lane within the Segment which owns it.)""";

          } index;

          // drake::maliput::api::Lane::lane_bounds
          struct /* lane_bounds */ {

            // drake/automotive/maliput/api/lane.h:76
            const char* doc =
R"""(Returns the nominal lateral (r) bounds for the lane as a function of
s.

These are the lateral bounds for a position that is considered to be
"staying in the lane".)""";

          } lane_bounds;

          // drake::maliput::api::Lane::length
          struct /* length */ {

            // drake/automotive/maliput/api/lane.h:70
            const char* doc =
R"""(Returns the arc-length of the Lane along its reference curve.

The value of length() is also the maximum s-coordinate for this Lane;
i.e., the domain of s is [0, length()].)""";

          } length;

          // drake::maliput::api::Lane::segment
          struct /* segment */ {

            // drake/automotive/maliput/api/lane.h:45
            const char* doc =
R"""(Returns the Segment to which this Lane belongs.)""";

          } segment;

          // drake::maliput::api::Lane::to_left
          struct /* to_left */ {

            // drake/automotive/maliput/api/lane.h:56
            const char* doc =
R"""(Returns a pointer to the adjacent Lane to the left of this Lane.

Left is considered the +r direction with regards to the (s,r,h) frame,
e.g., "to the left along the +s direction".

Returns:
    nullptr iff parent Segment has no Lane to the left.)""";

          } to_left;

          // drake::maliput::api::Lane::to_right
          struct /* to_right */ {

            // drake/automotive/maliput/api/lane.h:64
            const char* doc =
R"""(Returns a pointer to the adjacent Lane to the right of this Lane.

Right is considered the -r direction with regards to the (s,r,h)
frame, e.g., "to the right along the +s direction".

Returns:
    nullptr iff parent Segment has no Lane to the right.)""";

          } to_right;

        } Lane;

        // drake::maliput::api::LaneEnd
        struct /* LaneEnd */ {

          // drake/automotive/maliput/api/lane_data.h:24
          const char* doc = R"""(A specific endpoint of a specific Lane.)""";

          // drake::maliput::api::LaneEnd::LaneEnd
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:40
            const char* doc = R"""(Default constructor.)""";

            // drake/automotive/maliput/api/lane_data.h:43
            const char* doc_2 =
R"""(Construct a LaneEnd specifying the ``end`` of ``lane``.)""";

          } ctor;

          // drake::maliput::api::LaneEnd::StrictOrder
          struct /* StrictOrder */ {

            // drake/automotive/maliput/api/lane_data.h:30
            const char* doc =
R"""(An arbitrary strict complete ordering, useful for, e.g., std::map.)""";

            // drake::maliput::api::LaneEnd::StrictOrder::operator()
            struct /* operator_call */ {

              // drake/automotive/maliput/api/lane_data.h:31
              const char* doc = R"""()""";

            } operator_call;

          } StrictOrder;

          // drake::maliput::api::LaneEnd::Which
          struct /* Which */ {

            // drake/automotive/maliput/api/lane_data.h:27
            const char* doc =
R"""(Labels for the endpoints of a Lane. kStart is the "s == 0" end, and
kFinish is the other end.)""";

            // drake::maliput::api::LaneEnd::Which::kFinish
            struct /* kFinish */ {

              // drake/automotive/maliput/api/lane_data.h:27
              const char* doc = R"""()""";

            } kFinish;

            // drake::maliput::api::LaneEnd::Which::kStart
            struct /* kStart */ {

              // drake/automotive/maliput/api/lane_data.h:27
              const char* doc = R"""()""";

            } kStart;

          } Which;

          // drake::maliput::api::LaneEnd::end
          struct /* end */ {

            // drake/automotive/maliput/api/lane_data.h:46
            const char* doc = R"""()""";

          } end;

          // drake::maliput::api::LaneEnd::lane
          struct /* lane */ {

            // drake/automotive/maliput/api/lane_data.h:45
            const char* doc = R"""()""";

          } lane;

        } LaneEnd;

        // drake::maliput::api::LaneEndSet
        struct /* LaneEndSet */ {

          // drake/automotive/maliput/api/branch_point.h:23
          const char* doc = R"""(A set of LaneEnds.)""";

          // drake/automotive/maliput/api/lane.h:19
          const char* doc_2 = R"""(A set of LaneEnds.)""";

          // drake::maliput::api::LaneEndSet::LaneEndSet
          struct /* ctor */ {

            // drake/automotive/maliput/api/branch_point.h:29
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/branch_point.h:29
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/branch_point.h:44
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::LaneEndSet::get
          struct /* get */ {

            // drake/automotive/maliput/api/branch_point.h:41
            const char* doc =
R"""(Returns the LaneEnd indexed by ``index``.

@pre ``index`` must be >= 0 and < size().)""";

          } get;

          // drake::maliput::api::LaneEndSet::size
          struct /* size */ {

            // drake/automotive/maliput/api/branch_point.h:36
            const char* doc =
R"""(Returns the number of LaneEnds in this set.

Return value is non-negative.)""";

          } size;

        } LaneEndSet;

        // drake::maliput::api::LanePositionT
        struct /* LanePositionT */ {

          // drake/automotive/maliput/api/lane_data.h:217
          const char* doc =
R"""(A 3-dimensional position in a `Lane`-frame, consisting of three
components: * s is longitudinal position, as arc-length along a Lane's
reference line. * r is lateral position, perpendicular to the
reference line at s. * h is height above the road surface.

Instantiated templates for the following kinds of T's are provided: -
double - drake::AutoDiffXd - drake::symbolic::Expression

They are already available to link against in the containing library.)""";

          // drake::maliput::api::LanePositionT::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/lane_data.h:219
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::LanePositionT::FromSrh
          struct /* FromSrh */ {

            // drake/automotive/maliput/api/lane_data.h:228
            const char* doc =
R"""(Constructs a LanePosition from a 3-vector ``srh`` of the form `[s, r,
h]`.)""";

          } FromSrh;

          // drake::maliput::api::LanePositionT::LanePositionT<T>
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:219
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:219
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:222
            const char* doc_3 =
R"""(Default constructor, initializing all components to zero.)""";

            // drake/automotive/maliput/api/lane_data.h:225
            const char* doc_4 = R"""(Fully parameterized constructor.)""";

          } ctor;

          // drake::maliput::api::LanePositionT::MakeDouble
          struct /* MakeDouble */ {

            // drake/automotive/maliput/api/lane_data.h:255
            const char* doc =
R"""(Constructs a LanePositionT<double> from other types, producing a clone
if already double.)""";

          } MakeDouble;

          // drake::maliput::api::LanePositionT::h
          struct /* h */ {

            // drake/automotive/maliput/api/lane_data.h:248
            const char* doc = R"""(Gets `h` value.)""";

          } h;

          // drake::maliput::api::LanePositionT::r
          struct /* r */ {

            // drake/automotive/maliput/api/lane_data.h:244
            const char* doc = R"""(Gets `r` value.)""";

          } r;

          // drake::maliput::api::LanePositionT::s
          struct /* s */ {

            // drake/automotive/maliput/api/lane_data.h:240
            const char* doc = R"""(Gets `s` value.)""";

          } s;

          // drake::maliput::api::LanePositionT::set_h
          struct /* set_h */ {

            // drake/automotive/maliput/api/lane_data.h:250
            const char* doc = R"""(Sets `h` value.)""";

          } set_h;

          // drake::maliput::api::LanePositionT::set_r
          struct /* set_r */ {

            // drake/automotive/maliput/api/lane_data.h:246
            const char* doc = R"""(Sets `r` value.)""";

          } set_r;

          // drake::maliput::api::LanePositionT::set_s
          struct /* set_s */ {

            // drake/automotive/maliput/api/lane_data.h:242
            const char* doc = R"""(Sets `s` value.)""";

          } set_s;

          // drake::maliput::api::LanePositionT::set_srh
          struct /* set_srh */ {

            // drake/automotive/maliput/api/lane_data.h:235
            const char* doc =
R"""(Sets all components from 3-vector `[s, r, h]`.)""";

          } set_srh;

          // drake::maliput::api::LanePositionT::srh
          struct /* srh */ {

            // drake/automotive/maliput/api/lane_data.h:233
            const char* doc =
R"""(Returns all components as 3-vector `[s, r, h]`.)""";

          } srh;

        } LanePositionT;

        // drake::maliput::api::RBounds
        struct /* RBounds */ {

          // drake/automotive/maliput/api/lane_data.h:315
          const char* doc =
R"""(Bounds in the lateral dimension (r component) of a `Lane`-frame,
consisting of a pair of minimum and maximum r value. The bounds must
straddle r = 0, i.e., the minimum must be <= 0 and the maximum must be
>= 0.)""";

          // drake::maliput::api::RBounds::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/lane_data.h:317
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::RBounds::RBounds
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:317
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:317
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:320
            const char* doc_3 = R"""(Default constructor.)""";

            // drake/automotive/maliput/api/lane_data.h:325
            const char* doc_4 =
R"""(Fully parameterized constructor.

Throws:
    s std::runtime_error When ``min`` is greater than 0.

Throws:
    s std::runtime_error When ``max`` is smaller than 0.)""";

          } ctor;

          // drake::maliput::api::RBounds::max
          struct /* max */ {

            // drake/automotive/maliput/api/lane_data.h:341
            const char* doc = R"""(Gets maximum bound.)""";

          } max;

          // drake::maliput::api::RBounds::min
          struct /* min */ {

            // drake/automotive/maliput/api/lane_data.h:333
            const char* doc = R"""(Gets minimum bound.)""";

          } min;

          // drake::maliput::api::RBounds::set_max
          struct /* set_max */ {

            // drake/automotive/maliput/api/lane_data.h:344
            const char* doc =
R"""(Sets maximum bound.

Throws:
    s std::runtime_error When ``max`` is smaller than 0.)""";

          } set_max;

          // drake::maliput::api::RBounds::set_min
          struct /* set_min */ {

            // drake/automotive/maliput/api/lane_data.h:336
            const char* doc =
R"""(Sets minimum bound.

Throws:
    s std::runtime_error When ``min`` is greater than 0.)""";

          } set_min;

        } RBounds;

        // drake::maliput::api::RoadGeometry
        struct /* RoadGeometry */ {

          // drake/automotive/maliput/api/branch_point.h:15
          const char* doc = R"""()""";

          // drake/automotive/maliput/api/junction.h:12
          const char* doc_2 = R"""()""";

          // drake/automotive/maliput/api/road_geometry.h:30
          const char* doc_3 = R"""()""";

          // drake::maliput::api::RoadGeometry::ById
          struct /* ById */ {

            // drake/automotive/maliput/api/road_geometry.h:69
            const char* doc =
R"""(Accesses the IdIndex interface, which allows getting elements of the
RoadGeometry's object graph by their unique id's.)""";

          } ById;

          // drake::maliput::api::RoadGeometry::CheckInvariants
          struct /* CheckInvariants */ {

            // drake/automotive/maliput/api/road_geometry.h:139
            const char* doc =
R"""(Verifies certain invariants guaranteed by the API.

Returns a vector of strings describing violations of invariants.
Return value with size() == 0 indicates success.)""";

          } CheckInvariants;

          // drake::maliput::api::RoadGeometry::IdIndex
          struct /* IdIndex */ {

            // drake/automotive/maliput/api/road_geometry.h:32
            const char* doc =
R"""(Abstract interface for a collection of methods which allow accessing
objects in a RoadGeometry's object graph (Lanes, Segments, Junctions,
BranchPoints) by their unique id's.)""";

            // drake/automotive/maliput/api/road_geometry.h:178
            const char* doc_2 =
R"""(Abstract interface for a collection of methods which allow accessing
objects in a RoadGeometry's object graph (Lanes, Segments, Junctions,
BranchPoints) by their unique id's.)""";

            // drake::maliput::api::RoadGeometry::IdIndex::GetBranchPoint
            struct /* GetBranchPoint */ {

              // drake/automotive/maliput/api/road_geometry.h:200
              const char* doc =
R"""(Returns the BranchPoint identified by ``id``, or `nullptr` if ``id``
is unknown.)""";

            } GetBranchPoint;

            // drake::maliput::api::RoadGeometry::IdIndex::GetJunction
            struct /* GetJunction */ {

              // drake/automotive/maliput/api/road_geometry.h:194
              const char* doc =
R"""(Returns the Junction identified by ``id``, or `nullptr` if ``id`` is
unknown.)""";

            } GetJunction;

            // drake::maliput::api::RoadGeometry::IdIndex::GetLane
            struct /* GetLane */ {

              // drake/automotive/maliput/api/road_geometry.h:184
              const char* doc =
R"""(Returns the Lane identified by ``id``, or `nullptr` if ``id`` is
unknown.)""";

            } GetLane;

            // drake::maliput::api::RoadGeometry::IdIndex::GetSegment
            struct /* GetSegment */ {

              // drake/automotive/maliput/api/road_geometry.h:188
              const char* doc =
R"""(Returns the Segment identified by ``id``, or `nullptr` if ``id`` is
unknown.)""";

            } GetSegment;

            // drake::maliput::api::RoadGeometry::IdIndex::IdIndex
            struct /* ctor */ {

              // drake/automotive/maliput/api/road_geometry.h:180
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/road_geometry.h:180
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/road_geometry.h:205
              const char* doc_3 = R"""()""";

            } ctor;

          } IdIndex;

          // drake::maliput::api::RoadGeometry::RoadGeometry
          struct /* ctor */ {

            // drake/automotive/maliput/api/road_geometry.h:34
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/road_geometry.h:34
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/road_geometry.h:142
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::RoadGeometry::ToRoadPosition
          struct /* ToRoadPosition */ {

            // drake/automotive/maliput/api/road_geometry.h:112
            const char* doc = R"""()""";

          } ToRoadPosition;

          // drake::maliput::api::RoadGeometry::angular_tolerance
          struct /* angular_tolerance */ {

            // drake/automotive/maliput/api/road_geometry.h:125
            const char* doc =
R"""(Returns the tolerance guaranteed for angular measurements
(orientations).)""";

          } angular_tolerance;

          // drake::maliput::api::RoadGeometry::branch_point
          struct /* branch_point */ {

            // drake/automotive/maliput/api/road_geometry.h:63
            const char* doc =
R"""(Returns the BranchPoint indexed by ``index``.

@pre ``index`` must be >= 0 and < num_branch_points().)""";

          } branch_point;

          // drake::maliput::api::RoadGeometry::id
          struct /* id */ {

            // drake/automotive/maliput/api/road_geometry.h:41
            const char* doc = R"""()""";

          } id;

          // drake::maliput::api::RoadGeometry::junction
          struct /* junction */ {

            // drake/automotive/maliput/api/road_geometry.h:53
            const char* doc =
R"""(Returns the Junction indexed by ``index``.

@pre ``index`` must be >= 0 and < num_junctions().)""";

          } junction;

          // drake::maliput::api::RoadGeometry::linear_tolerance
          struct /* linear_tolerance */ {

            // drake/automotive/maliput/api/road_geometry.h:120
            const char* doc =
R"""(Returns the tolerance guaranteed for linear measurements (positions).)""";

          } linear_tolerance;

          // drake::maliput::api::RoadGeometry::num_branch_points
          struct /* num_branch_points */ {

            // drake/automotive/maliput/api/road_geometry.h:58
            const char* doc =
R"""(Returns the number of BranchPoints in the RoadGeometry.

Return value is non-negative.)""";

          } num_branch_points;

          // drake::maliput::api::RoadGeometry::num_junctions
          struct /* num_junctions */ {

            // drake/automotive/maliput/api/road_geometry.h:48
            const char* doc =
R"""(Returns the number of Junctions in the RoadGeometry.

Return value is non-negative.)""";

          } num_junctions;

          // drake::maliput::api::RoadGeometry::scale_length
          struct /* scale_length */ {

            // drake/automotive/maliput/api/road_geometry.h:131
            const char* doc =
R"""(Returns the characteristic scale length expressed by this
RoadGeometry.)""";

          } scale_length;

        } RoadGeometry;

        // drake::maliput::api::RoadPosition
        struct /* RoadPosition */ {

          // drake/automotive/maliput/api/lane_data.h:299
          const char* doc =
R"""(A position in the road network, consisting of a pointer to a specific
Lane and a `Lane`-frame position in that Lane.)""";

          // drake::maliput::api::RoadPosition::RoadPosition
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:301
            const char* doc = R"""(Default constructor.)""";

            // drake/automotive/maliput/api/lane_data.h:304
            const char* doc_2 = R"""(Fully parameterized constructor.)""";

          } ctor;

          // drake::maliput::api::RoadPosition::lane
          struct /* lane */ {

            // drake/automotive/maliput/api/lane_data.h:307
            const char* doc = R"""()""";

          } lane;

          // drake::maliput::api::RoadPosition::pos
          struct /* pos */ {

            // drake/automotive/maliput/api/lane_data.h:308
            const char* doc = R"""()""";

          } pos;

        } RoadPosition;

        // drake::maliput::api::Rotation
        struct /* Rotation */ {

          // drake/automotive/maliput/api/lane_data.h:56
          const char* doc = R"""(A 3-dimensional rotation.)""";

          // drake::maliput::api::Rotation::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/lane_data.h:58
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::Rotation::FromQuat
          struct /* FromQuat */ {

            // drake/automotive/maliput/api/lane_data.h:65
            const char* doc =
R"""(Constructs a Rotation from a quaternion ``quaternion`` (which will be
normalized).)""";

          } FromQuat;

          // drake::maliput::api::Rotation::FromRpy
          struct /* FromRpy */ {

            // drake/automotive/maliput/api/lane_data.h:72
            const char* doc =
R"""(Constructs a Rotation from ``rpy``, a vector of `[roll, pitch, yaw]`,
expressing a roll around X, followed by pitch around Y, followed by
yaw around Z (with all angles in radians).)""";

            // drake/automotive/maliput/api/lane_data.h:79
            const char* doc_2 =
R"""(Constructs a Rotation expressing a ``roll`` around X, followed by
``pitch`` around Y, followed by ``yaw`` around Z (with all angles in
radians).)""";

          } FromRpy;

          // drake::maliput::api::Rotation::Rotation
          struct /* ctor */ {

            // drake/automotive/maliput/api/lane_data.h:58
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:58
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/lane_data.h:61
            const char* doc_3 =
R"""(Default constructor, creating an identity Rotation.)""";

          } ctor;

          // drake::maliput::api::Rotation::matrix
          struct /* matrix */ {

            // drake/automotive/maliput/api/lane_data.h:92
            const char* doc =
R"""(Provides a rotation matrix representation of the rotation.)""";

          } matrix;

          // drake::maliput::api::Rotation::pitch
          struct /* pitch */ {

            // drake/automotive/maliput/api/lane_data.h:108
            const char* doc =
R"""(Returns the pitch component of the Rotation (in radians).)""";

          } pitch;

          // drake::maliput::api::Rotation::quat
          struct /* quat */ {

            // drake/automotive/maliput/api/lane_data.h:84
            const char* doc =
R"""(Provides a quaternion representation of the rotation.)""";

          } quat;

          // drake::maliput::api::Rotation::roll
          struct /* roll */ {

            // drake/automotive/maliput/api/lane_data.h:105
            const char* doc =
R"""(Returns the roll component of the Rotation (in radians).)""";

          } roll;

          // drake::maliput::api::Rotation::rpy
          struct /* rpy */ {

            // drake/automotive/maliput/api/lane_data.h:96
            const char* doc =
R"""(Provides a representation of rotation as a vector of angles `[roll,
pitch, yaw]` (in radians).)""";

          } rpy;

          // drake::maliput::api::Rotation::set_quat
          struct /* set_quat */ {

            // drake/automotive/maliput/api/lane_data.h:87
            const char* doc =
R"""(Sets value from a Quaternion ``quaternion`` (which will be
normalized).)""";

          } set_quat;

          // drake::maliput::api::Rotation::yaw
          struct /* yaw */ {

            // drake/automotive/maliput/api/lane_data.h:111
            const char* doc =
R"""(Returns the yaw component of the Rotation (in radians).)""";

          } yaw;

        } Rotation;

        // drake::maliput::api::Segment
        struct /* Segment */ {

          // drake/automotive/maliput/api/junction.h:13
          const char* doc =
R"""(A Segment represents a bundle of adjacent Lanes which share a
continuously traversable road surface. Every LanePosition on a given
Lane of a Segment has a corresponding LanePosition on each other Lane,
all with the same height-above-surface h, that all map to the same
GeoPoint in 3-space.

Segments are grouped by Junction.)""";

          // drake/automotive/maliput/api/lane.h:18
          const char* doc_2 =
R"""(A Segment represents a bundle of adjacent Lanes which share a
continuously traversable road surface. Every LanePosition on a given
Lane of a Segment has a corresponding LanePosition on each other Lane,
all with the same height-above-surface h, that all map to the same
GeoPoint in 3-space.

Segments are grouped by Junction.)""";

          // drake/automotive/maliput/api/segment.h:27
          const char* doc_3 =
R"""(A Segment represents a bundle of adjacent Lanes which share a
continuously traversable road surface. Every LanePosition on a given
Lane of a Segment has a corresponding LanePosition on each other Lane,
all with the same height-above-surface h, that all map to the same
GeoPoint in 3-space.

Segments are grouped by Junction.)""";

          // drake::maliput::api::Segment::Segment
          struct /* ctor */ {

            // drake/automotive/maliput/api/segment.h:29
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/segment.h:29
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/segment.h:54
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::maliput::api::Segment::id
          struct /* id */ {

            // drake/automotive/maliput/api/segment.h:34
            const char* doc = R"""(Returns the persistent identifier.)""";

          } id;

          // drake::maliput::api::Segment::junction
          struct /* junction */ {

            // drake/automotive/maliput/api/segment.h:37
            const char* doc =
R"""(Returns the Junction to which this Segment belongs.)""";

          } junction;

          // drake::maliput::api::Segment::lane
          struct /* lane */ {

            // drake/automotive/maliput/api/segment.h:51
            const char* doc =
R"""(Returns the Lane indexed by ``index``.

The indexing order is meaningful; numerically adjacent indices
correspond to geometrically adjacent Lanes. Indices increase "to the
left", i.e., in the direction of increasing `r` coordinate.

@pre ``index`` must be >= 0 and < num_lanes().)""";

          } lane;

          // drake::maliput::api::Segment::num_lanes
          struct /* num_lanes */ {

            // drake/automotive/maliput/api/segment.h:42
            const char* doc =
R"""(Returns the number of Lanes contained in this Segment.

Return value is non-negative.)""";

          } num_lanes;

        } Segment;

        // drake::maliput::api::TypeSpecificIdentifier
        struct /* TypeSpecificIdentifier */ {

          // drake/automotive/maliput/api/type_specific_identifier.h:39
          const char* doc =
R"""(TypeSpecificIdentifier<T> represents an identifier specifically
identifying an entity of type `T`.

A new TypeSpecificIdentifier is constructed from a non-empty string;
TypeSpecificIdentifiers constructed from equal strings are considered
to be equal. There is currently no other semantic value attributed to
the contents of the string.

Construction from empty strings is not allowed; there is no notion of
an "unassigned" value for a TypeSpecificIdentifier. To represent a
possibly-unassigned TypeSpecificIdentifier, use
drake::optional<TypeSpecificIdentifier<T>>.

TypeSpecificIdentifier is EqualityComparable (and provides == and !=
operators), but it is not LessThanComparable; there is no particular
ordering ascribed to TypeSpecificIdentifier instances. However,
TypeSpecificIdentifier does provide a strict weak ordering via a
specialization of std::less for use in ordered containers such as
std::set and std::map. This ordering may change in future
implementations of TypeSpecificIdentifier.

TypeSpecificIdentifier also provides a specialization of std::hash to
make it easy to use with std::unordered_set and std::unordered_map.)""";

          // drake::maliput::api::TypeSpecificIdentifier::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/automotive/maliput/api/type_specific_identifier.h:41
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::maliput::api::TypeSpecificIdentifier::TypeSpecificIdentifier<T>
          struct /* ctor */ {

            // drake/automotive/maliput/api/type_specific_identifier.h:41
            const char* doc = R"""()""";

            // drake/automotive/maliput/api/type_specific_identifier.h:41
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/api/type_specific_identifier.h:49
            const char* doc_3 =
R"""(Constructs a TypeSpecificIdentifier from the given `string`.

Throws:
    s std::runtime_error if `string` is empty.)""";

          } ctor;

          // drake::maliput::api::TypeSpecificIdentifier::operator!=
          struct /* operator_ne */ {

            // drake/automotive/maliput/api/type_specific_identifier.h:64
            const char* doc =
R"""(Tests for inequality with another TypeSpecificIdentifier, specifically
returning the opposite of operator==().)""";

          } operator_ne;

          // drake::maliput::api::TypeSpecificIdentifier::string
          struct /* string */ {

            // drake/automotive/maliput/api/type_specific_identifier.h:55
            const char* doc =
R"""(Returns the string representation of the TypeSpecificIdentifier.)""";

          } string;

        } TypeSpecificIdentifier;

        // drake::maliput::api::operator!=
        struct /* operator_ne */ {

          // drake/automotive/maliput/api/lane_data.h:201
          const char* doc =
R"""(GeoPosition overload for the inequality operator.)""";

        } operator_ne;

        // drake::maliput::api::operator<<
        struct /* operator_lshift */ {

          // drake/automotive/maliput/api/lane_data.h:52
          const char* doc =
R"""(Streams a string representation of ``which_end`` into ``out``. Returns
``out``. This method is provided for the purposes of debugging or
text-logging. It is not intended for serialization.)""";

          // drake/automotive/maliput/api/lane_data.h:122
          const char* doc_2 =
R"""(Streams a string representation of ``rotation`` into ``out``. Returns
``out``. This method is provided for the purposes of debugging or
text-logging. It is not intended for serialization.)""";

          // drake/automotive/maliput/api/lane_data.h:191
          const char* doc_3 =
R"""(Streams a string representation of ``geo_position`` into ``out``.
Returns ``out``. This method is provided for the purposes of debugging
or text-logging. It is not intended for serialization.)""";

          // drake/automotive/maliput/api/lane_data.h:273
          const char* doc_4 =
R"""(Streams a string representation of ``lane_position`` into ``out``.
Returns ``out``. This method is provided for the purposes of debugging
or text-logging. It is not intended for serialization.)""";

        } operator_lshift;

        // rules
        struct /* rules */ {

          // drake::maliput::api::rules::LaneSRange
          struct /* LaneSRange */ {

            // drake/automotive/maliput/api/rules/regions.h:45
            const char* doc =
R"""(Directed longitudinal range of a specific Lane, identified by a
LaneId.)""";

            // drake::maliput::api::rules::LaneSRange::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/automotive/maliput/api/rules/regions.h:47
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::maliput::api::rules::LaneSRange::LaneSRange
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/regions.h:47
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:47
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:50
              const char* doc_3 =
R"""(Constructs a LaneSRange as `s_range` on Lane `lane_id`.)""";

            } ctor;

            // drake::maliput::api::rules::LaneSRange::lane_id
            struct /* lane_id */ {

              // drake/automotive/maliput/api/rules/regions.h:54
              const char* doc = R"""(Gets the LaneId.)""";

            } lane_id;

            // drake::maliput::api::rules::LaneSRange::s_range
            struct /* s_range */ {

              // drake/automotive/maliput/api/rules/regions.h:57
              const char* doc = R"""(Gets the SRange.)""";

            } s_range;

          } LaneSRange;

          // drake::maliput::api::rules::LaneSRoute
          struct /* LaneSRoute */ {

            // drake/automotive/maliput/api/rules/regions.h:72
            const char* doc = R"""()""";

            // drake::maliput::api::rules::LaneSRoute::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/automotive/maliput/api/rules/regions.h:74
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::maliput::api::rules::LaneSRoute::LaneSRoute
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/regions.h:74
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:74
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:77
              const char* doc_3 =
R"""(Default constructor: constructs an empty route.)""";

              // drake/automotive/maliput/api/rules/regions.h:80
              const char* doc_4 =
R"""(Constructs a LaneSRoute from the given sequence of LaneSRanges.)""";

            } ctor;

            // drake::maliput::api::rules::LaneSRoute::ranges
            struct /* ranges */ {

              // drake/automotive/maliput/api/rules/regions.h:84
              const char* doc = R"""(Returns the sequence of LaneSRanges.)""";

            } ranges;

          } LaneSRoute;

          // drake::maliput::api::rules::RightOfWayRule
          struct /* RightOfWayRule */ {

            // drake/automotive/maliput/api/rules/right_of_way_rule.h:40
            const char* doc =
R"""(Rule describing right-of-way, a.k.a. priority.

Right-of-way rules cover things like stop signs, yield signs, and
traffic lights: in other words, control over how competing traffic
flows take turns traversing regions of the road network.

Each rule instance comprises: * a zone (a LaneSRoute) which specifies
a contiguous longitudinal lane-wise section of the road network to
which the rule instance applies; * a ZoneType describing whether or
not stopping within the zone is allowed; * a catalog of one or more
States, each of which indicate the possible right-of-way semantics for
a vehicle traversing the zone.

The `zone` is directed; the rule applies to vehicles traveling forward
through the `zone`.

A rule instance with a single State is considered "static", and has
fixed semantics. A rule instance with multiple States is considered
"dynamic" and determination of the active rule State at any given time
is delegated to a RightOfWayStateProvider agent, linked by the rule's
Id.)""";

            // drake::maliput::api::rules::RightOfWayRule::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:42
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::maliput::api::rules::RightOfWayRule::RightOfWayRule
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:42
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:42
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:123
              const char* doc_3 =
R"""(Constructs a RightOfWayRule.

Parameter ``id``:
    the unique ID of this rule (in the RoadRulebook)

Parameter ``controlled_zone``:
    LaneSRoute to which this rule applies

Parameter ``type``:
    the static semantics of this rule

Throws a RuntimeError if `states` is empty or if `states` contains
duplicate State::Id's.)""";

            } ctor;

            // drake::maliput::api::rules::RightOfWayRule::State
            struct /* State */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:71
              const char* doc =
R"""(Semantic state of a RightOfWayRule.

A State describes the semantic state of a RightOfWayRule, basically
"Go", "Stop", or "Stop, Then Go". A RightOfWayRule may have multiple
possible States, in which case its States must have Id's which are
unique within the context of that RightOfWayRule.

A State also describes the yield logic of a RightOfWayRule, via a list
of Id's of other RightOfWayRules (and thus the zones which they
control) which have priority over this rule. An empty list means that
a rule in this State has priority over all other rules. Vehicles with
lower priority (i.e., traveling on lower-priority paths) must yield to
vehicles with higher priority.)""";

              // drake::maliput::api::rules::RightOfWayRule::State::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
              struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:73
                const char* doc = R"""()""";

              } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

              // drake::maliput::api::rules::RightOfWayRule::State::State
              struct /* ctor */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:73
                const char* doc = R"""()""";

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:73
                const char* doc_2 = R"""()""";

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:97
                const char* doc_3 =
R"""(Constructs a State instance.

Parameter ``id``:
    the unique Id

Parameter ``type``:
    the semantic Type

Parameter ``yield_to``:
    the other paths/rules which must be yielded to)""";

              } ctor;

              // drake::maliput::api::rules::RightOfWayRule::State::Type
              struct /* Type */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:82
                const char* doc = R"""(Basic semantic type of a rule state.)""";

                // drake::maliput::api::rules::RightOfWayRule::State::Type::kGo
                struct /* kGo */ {

                  // drake/automotive/maliput/api/rules/right_of_way_rule.h:83
                  const char* doc =
R"""(< Vehicle has right-of-way and may proceed if)""";

                } kGo;

                // drake::maliput::api::rules::RightOfWayRule::State::Type::kStop
                struct /* kStop */ {

                  // drake/automotive/maliput/api/rules/right_of_way_rule.h:85
                  const char* doc =
R"""(< Vehicle does not have right-of-way and must)""";

                } kStop;

                // drake::maliput::api::rules::RightOfWayRule::State::Type::kStopThenGo
                struct /* kStopThenGo */ {

                  // drake/automotive/maliput/api/rules/right_of_way_rule.h:87
                  const char* doc =
R"""(< Vehicle must come to complete stop before)""";

                } kStopThenGo;

              } Type;

              // drake::maliput::api::rules::RightOfWayRule::State::id
              struct /* id */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:101
                const char* doc = R"""(Returns the Id.)""";

              } id;

              // drake::maliput::api::rules::RightOfWayRule::State::type
              struct /* type */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:104
                const char* doc = R"""(Returns the Type.)""";

              } type;

              // drake::maliput::api::rules::RightOfWayRule::State::yield_to
              struct /* yield_to */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:107
                const char* doc = R"""(Returns the YieldGroup.)""";

              } yield_to;

            } State;

            // drake::maliput::api::rules::RightOfWayRule::ZoneType
            struct /* ZoneType */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:48
              const char* doc =
R"""(Description of stopping properties of the zone.)""";

              // drake::maliput::api::rules::RightOfWayRule::ZoneType::kStopAllowed
              struct /* kStopAllowed */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:54
                const char* doc =
R"""(< Vehicles are allowed to stop within the zone.)""";

              } kStopAllowed;

              // drake::maliput::api::rules::RightOfWayRule::ZoneType::kStopExcluded
              struct /* kStopExcluded */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:49
                const char* doc =
R"""(< Vehicles should not stop within the zone; vehicles)""";

              } kStopExcluded;

            } ZoneType;

            // drake::maliput::api::rules::RightOfWayRule::id
            struct /* id */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:137
              const char* doc = R"""(Returns the rule's identifier.)""";

            } id;

            // drake::maliput::api::rules::RightOfWayRule::is_static
            struct /* is_static */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:152
              const char* doc =
R"""(Returns true if the rule is static, i.e., has no dynamic state,
otherwise false.

This is true if and only if the rule has a single state.)""";

            } is_static;

            // drake::maliput::api::rules::RightOfWayRule::states
            struct /* states */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:146
              const char* doc = R"""(Returns the catalog of possible States.)""";

            } states;

            // drake::maliput::api::rules::RightOfWayRule::static_state
            struct /* static_state */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:159
              const char* doc =
R"""(Returns the static state of the rule.

This is a convenience function for returning a static rule's single
state.

Throws a RuntimeError if `is_static()` is false.)""";

            } static_state;

            // drake::maliput::api::rules::RightOfWayRule::zone
            struct /* zone */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:140
              const char* doc =
R"""(Returns the zone controlled by the rule.)""";

            } zone;

            // drake::maliput::api::rules::RightOfWayRule::zone_type
            struct /* zone_type */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:143
              const char* doc = R"""(Returns the zone's type.)""";

            } zone_type;

          } RightOfWayRule;

          // drake::maliput::api::rules::RightOfWayStateProvider
          struct /* RightOfWayStateProvider */ {

            // drake/automotive/maliput/api/rules/right_of_way_rule.h:174
            const char* doc =
R"""(Abstract interface for the provider of the state of a dynamic
(multiple state) RightOfWayRule.)""";

            // drake::maliput::api::rules::RightOfWayStateProvider::GetState
            struct /* GetState */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:207
              const char* doc =
R"""(Gets the state of the RightOfWayRule identified by `id`.

Returns a Result struct bearing the State::Id of the rule's current
state. If a transition to a new state is anticipated, Result::next
will be populated and bear the State::Id of the next state. If the
time until the transition is known, then Result::next.duration_until
will be populated with that duration.

Returns nullopt if `id` is unrecognized, which would be the case if no
such rule exists or if the rule has only static semantics.)""";

            } GetState;

            // drake::maliput::api::rules::RightOfWayStateProvider::Result
            struct /* Result */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:181
              const char* doc = R"""(Result returned by GetState().)""";

              // drake::maliput::api::rules::RightOfWayStateProvider::Result::Next
              struct /* Next */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:183
                const char* doc = R"""(Information about a subsequent State.)""";

                // drake::maliput::api::rules::RightOfWayStateProvider::Result::Next::duration_until
                struct /* duration_until */ {

                  // drake/automotive/maliput/api/rules/right_of_way_rule.h:187
                  const char* doc =
R"""(If known, estimated time until the transition to the State.)""";

                } duration_until;

                // drake::maliput::api::rules::RightOfWayStateProvider::Result::Next::id
                struct /* id */ {

                  // drake/automotive/maliput/api/rules/right_of_way_rule.h:185
                  const char* doc = R"""(ID of the State.)""";

                } id;

              } Next;

              // drake::maliput::api::rules::RightOfWayStateProvider::Result::current_id
              struct /* current_id */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:191
                const char* doc = R"""(ID of the rule's current State.)""";

              } current_id;

              // drake::maliput::api::rules::RightOfWayStateProvider::Result::next
              struct /* next */ {

                // drake/automotive/maliput/api/rules/right_of_way_rule.h:194
                const char* doc =
R"""(Information about the rule's upcoming State if a state transition is
anticipated.)""";

              } next;

            } Result;

            // drake::maliput::api::rules::RightOfWayStateProvider::RightOfWayStateProvider
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:176
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:176
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/right_of_way_rule.h:212
              const char* doc_3 = R"""()""";

            } ctor;

          } RightOfWayStateProvider;

          // drake::maliput::api::rules::RoadRulebook
          struct /* RoadRulebook */ {

            // drake/automotive/maliput/api/rules/road_rulebook.h:24
            const char* doc =
R"""(Abstract interface for querying "rules of the road". This interface
provides access to static information about a road network (i.e.,
information determined prior to the beginning of a simulation). Some
rule types may refer to additional dynamic information which will be
provided by other interfaces. (For example, see RightOfWayRule.)

Concrete implementations of this interface shall be provided by
implementing the pure virtual methods declared in private scope.)""";

            // drake::maliput::api::rules::RoadRulebook::FindRules
            struct /* FindRules */ {

              // drake/automotive/maliput/api/rules/road_rulebook.h:47
              const char* doc =
R"""(Returns a QueryResults structure which contains any rules which are
applicable to the provided `ranges`.

`tolerance` is the acceptable linear-tolerance in longitudinal
s-coordinate in each range and must be non-negative. A non-zero
`tolerance` makes the query more permissive. However, a non-zero
`tolerance` does not permit matching across BranchPoints (past the
s-bounds of a Lane).

Throws:
    s std::runtime_error if `tolerance` is negative.)""";

            } FindRules;

            // drake::maliput::api::rules::RoadRulebook::GetRule
            struct /* GetRule */ {

              // drake/automotive/maliput/api/rules/road_rulebook.h:56
              const char* doc =
R"""(Returns the RightOfWayRule with the specified `id`.

Throws ValueError if `id` is unknown.)""";

              // drake/automotive/maliput/api/rules/road_rulebook.h:63
              const char* doc_2 =
R"""(Returns the SpeedLimitRule with the specified `id`.

Throws ValueError if `id` is unknown.)""";

            } GetRule;

            // drake::maliput::api::rules::RoadRulebook::QueryResults
            struct /* QueryResults */ {

              // drake/automotive/maliput/api/rules/road_rulebook.h:32
              const char* doc =
R"""(Results of a FindRules() query. Results are organized by type; an
empty vector indicates no applicable rules of that type are known.)""";

              // drake::maliput::api::rules::RoadRulebook::QueryResults::right_of_way
              struct /* right_of_way */ {

                // drake/automotive/maliput/api/rules/road_rulebook.h:33
                const char* doc = R"""()""";

              } right_of_way;

              // drake::maliput::api::rules::RoadRulebook::QueryResults::speed_limit
              struct /* speed_limit */ {

                // drake/automotive/maliput/api/rules/road_rulebook.h:34
                const char* doc = R"""()""";

              } speed_limit;

            } QueryResults;

            // drake::maliput::api::rules::RoadRulebook::RoadRulebook
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/road_rulebook.h:26
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/road_rulebook.h:26
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/road_rulebook.h:68
              const char* doc_3 = R"""()""";

            } ctor;

          } RoadRulebook;

          // drake::maliput::api::rules::SRange
          struct /* SRange */ {

            // drake/automotive/maliput/api/rules/regions.h:16
            const char* doc =
R"""(Directed, inclusive longitudinal (s value) range from s0 to s1.)""";

            // drake::maliput::api::rules::SRange::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/automotive/maliput/api/rules/regions.h:18
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::maliput::api::rules::SRange::SRange
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/regions.h:18
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:18
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/regions.h:21
              const char* doc_3 =
R"""(Default constructor: initializes s0 and s1 to zero.)""";

              // drake/automotive/maliput/api/rules/regions.h:24
              const char* doc_4 = R"""(Constructs range [s0 --> s1].)""";

            } ctor;

            // drake::maliput::api::rules::SRange::s0
            struct /* s0 */ {

              // drake/automotive/maliput/api/rules/regions.h:27
              const char* doc = R"""(Gets s0 value.)""";

            } s0;

            // drake::maliput::api::rules::SRange::s1
            struct /* s1 */ {

              // drake/automotive/maliput/api/rules/regions.h:30
              const char* doc = R"""(Gets s1 value.)""";

            } s1;

            // drake::maliput::api::rules::SRange::set_s0
            struct /* set_s0 */ {

              // drake/automotive/maliput/api/rules/regions.h:33
              const char* doc = R"""(Sets s0 value.)""";

            } set_s0;

            // drake::maliput::api::rules::SRange::set_s1
            struct /* set_s1 */ {

              // drake/automotive/maliput/api/rules/regions.h:36
              const char* doc = R"""(Sets s1 value.)""";

            } set_s1;

          } SRange;

          // drake::maliput::api::rules::SpeedLimitRule
          struct /* SpeedLimitRule */ {

            // drake/automotive/maliput/api/rules/speed_limit_rule.h:22
            const char* doc =
R"""(Rule describing speed limits.

Each rule instance describes speed limits applied to a longitudinal
portion of a Lane (which may be the entire length of the Lane). Each
instance is tagged with a severity; multiple instances with different
severities may apply to the same region of the road network.

Each instance mandates a maximum speed limit as well as a minimum
speed limit. Since neither limit may be less than zero, a minimum
limit of exactly zero is equivalent to having no minimum limit at all.)""";

            // drake::maliput::api::rules::SpeedLimitRule::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:33
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::maliput::api::rules::SpeedLimitRule::Severity
            struct /* Severity */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:27
              const char* doc = R"""(Severity classification.)""";

              // drake::maliput::api::rules::SpeedLimitRule::Severity::kAdvisory
              struct /* kAdvisory */ {

                // drake/automotive/maliput/api/rules/speed_limit_rule.h:29
                const char* doc =
R"""(< An advisory limit is a recommendation, typically)""";

              } kAdvisory;

              // drake::maliput::api::rules::SpeedLimitRule::Severity::kStrict
              struct /* kStrict */ {

                // drake/automotive/maliput/api/rules/speed_limit_rule.h:28
                const char* doc =
R"""(< A strict limit is the established mandatory limit.)""";

              } kStrict;

            } Severity;

            // drake::maliput::api::rules::SpeedLimitRule::SpeedLimitRule
            struct /* ctor */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:33
              const char* doc = R"""()""";

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:33
              const char* doc_2 = R"""()""";

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:45
              const char* doc_3 =
R"""(Constructs a SpeedLimitRule.

Parameter ``id``:
    the unique ID of this rule (in the RoadRulebook)

Parameter ``zone``:
    LaneSRange to which this rule applies

Parameter ``severity``:
    Severity of the rule

Parameter ``min``:
    minimum speed

Parameter ``max``:
    maximum speed

`min` and `max` must be non-negative, and `min` must be less than or
equal to `max`, otherwise a runtime_error is thrown.)""";

            } ctor;

            // drake::maliput::api::rules::SpeedLimitRule::id
            struct /* id */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:54
              const char* doc = R"""(Returns the persistent identifier.)""";

            } id;

            // drake::maliput::api::rules::SpeedLimitRule::max
            struct /* max */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:66
              const char* doc = R"""(Returns the maximum limit.)""";

            } max;

            // drake::maliput::api::rules::SpeedLimitRule::min
            struct /* min */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:63
              const char* doc = R"""(Returns the minimum limit.)""";

            } min;

            // drake::maliput::api::rules::SpeedLimitRule::severity
            struct /* severity */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:60
              const char* doc =
R"""(Returns the severity of this rule instance.)""";

            } severity;

            // drake::maliput::api::rules::SpeedLimitRule::zone
            struct /* zone */ {

              // drake/automotive/maliput/api/rules/speed_limit_rule.h:57
              const char* doc =
R"""(Returns the zone to which this rule instance applies.)""";

            } zone;

          } SpeedLimitRule;

        } rules;

      } api;

      // dragway
      struct /* dragway */ {

        // drake::maliput::dragway::BranchPoint
        struct /* BranchPoint */ {

          // drake/automotive/maliput/dragway/branch_point.h:17
          const char* doc =
R"""(Dragway's implementation of api::BranchPoint.)""";

          // drake/automotive/maliput/dragway/branch_point.h:41
          const char* doc_2 =
R"""(Dragway's implementation of api::BranchPoint.)""";

          // drake/automotive/maliput/dragway/lane.h:15
          const char* doc_3 =
R"""(Dragway's implementation of api::BranchPoint.)""";

          // drake::maliput::dragway::BranchPoint::BranchPoint
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/branch_point.h:43
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/branch_point.h:43
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/branch_point.h:57
            const char* doc_3 =
R"""(Constructs a fully initialized BranchPoint for a Dragway lane.

Parameter ``id``:
    The ID of this branch point. It can be any user-specified value.

Parameter ``lane``:
    A pointer to the lane to which this branch point belongs. This
    pointer must remain valid for the lifetime of this class's
    instance.

Parameter ``road_geometry``:
    A pointer to the RoadGeometry to which this BranchPoint belongs.
    This pointer must remain valid for the lifetime of this class's
    instance.)""";

          } ctor;

        } BranchPoint;

        // drake::maliput::dragway::Junction
        struct /* Junction */ {

          // drake/automotive/maliput/dragway/junction.h:20
          const char* doc =
R"""(Dragway's implementation of api::Junction.)""";

          // drake/automotive/maliput/dragway/segment.h:18
          const char* doc_2 =
R"""(Dragway's implementation of api::Junction.)""";

          // drake::maliput::dragway::Junction::Junction
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/junction.h:22
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/junction.h:22
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/junction.h:29
            const char* doc_3 =
R"""(Constructs a Junction with a single Segment.

``road_geometry`` must remain valid for the lifetime of this class,
and must refer to the RoadGeometry which will contain this newly
constructed Junction instance.)""";

          } ctor;

        } Junction;

        // drake::maliput::dragway::Lane
        struct /* Lane */ {

          // drake/automotive/maliput/dragway/branch_point.h:18
          const char* doc =
R"""(Dragway's implementation of api::Lane. The lane is flat with a height
of zero.

The following lane is implemented:

```
lane_bounds
|<------------------------------->|
driveable_bounds
|<--------------------------------------->|

-------------------------------------------  ———  s = length()
|                    :                    |   ^
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |           world
|                    :                    |   |           frame:
|                    :                    |   |
|                    :                    |   |                X
|                    :                    |   |                ^
|                    :                    |   |                |
|                    :                    |   v                |
---------------------o---------------------  ———  s = 0   Y <--o

r_max                r_min
|<-------------------|------------------->|

y_offset
|<----------------------------------------|
```

The lane's frame is defined by three coordinates: (`s`, `r`, `h`).
Coordinate `s` is between zero and `length()`. It specifies the
longitudinal traversal of the lane. Coordinate `r` is a value between
`r_min` and `r_max`. It specifies the lateral traversal at a
particular `s`. Coordinate `h` specifies the height above the lane's
surface at a particular `s` and `r` (the lane's surface itself is
always at `h = 0`). Since Dragway lanes are flat and level, `z = h`
for all values of `s` and `r` and, in the Dragway's case, `z = 0` for
the surface itself. The origin of the lane's frame is defined by the
`o` along the above-shown `s = 0` line.

Note: Each dragway lane has a teleportation feature at both ends: the
(default) ongoing lane for LaneEnd::kFinish is LaneEnd::kStart of the
same lane, and vice versa.)""";

          // drake/automotive/maliput/dragway/lane.h:75
          const char* doc_2 =
R"""(Dragway's implementation of api::Lane. The lane is flat with a height
of zero.

The following lane is implemented:

```
lane_bounds
|<------------------------------->|
driveable_bounds
|<--------------------------------------->|

-------------------------------------------  ———  s = length()
|                    :                    |   ^
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |
|                    :                    |   |           world
|                    :                    |   |           frame:
|                    :                    |   |
|                    :                    |   |                X
|                    :                    |   |                ^
|                    :                    |   |                |
|                    :                    |   v                |
---------------------o---------------------  ———  s = 0   Y <--o

r_max                r_min
|<-------------------|------------------->|

y_offset
|<----------------------------------------|
```

The lane's frame is defined by three coordinates: (`s`, `r`, `h`).
Coordinate `s` is between zero and `length()`. It specifies the
longitudinal traversal of the lane. Coordinate `r` is a value between
`r_min` and `r_max`. It specifies the lateral traversal at a
particular `s`. Coordinate `h` specifies the height above the lane's
surface at a particular `s` and `r` (the lane's surface itself is
always at `h = 0`). Since Dragway lanes are flat and level, `z = h`
for all values of `s` and `r` and, in the Dragway's case, `z = 0` for
the surface itself. The origin of the lane's frame is defined by the
`o` along the above-shown `s = 0` line.

Note: Each dragway lane has a teleportation feature at both ends: the
(default) ongoing lane for LaneEnd::kFinish is LaneEnd::kStart of the
same lane, and vice versa.)""";

          // drake::maliput::dragway::Lane::Lane
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/lane.h:77
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/lane.h:77
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/lane.h:103
            const char* doc_3 =
R"""(Constructs a dragway Lane.

Parameter ``segment``:
    The Segment to which this lane belongs.

Parameter ``id``:
    the lane ID. This can be any user-defined value.

Parameter ``index``:
    The index of the lane with its Segment.

Parameter ``length``:
    The total length of the lane.

Parameter ``y_offset``:
    The vector from the world frame's origin to the lane's `s = 0` and
    `r = 0`. This value is positive when the lane's `s = 0` and `r =
    0` is to the left of the world frame's origin, and is negative
    otherwise.

Parameter ``lane_bounds``:
    nominal bounds of the lane, uniform along the entire reference
    path, which must be a subset of ``driveable_bounds``.

Parameter ``driveable_bounds``:
    The driveable bounds of the lane, uniform along the entire
    reference path.

Parameter ``elevation_bounds``:
    The elevation bounds of the lane, uniform along the entire
    reference path.)""";

          } ctor;

          // drake::maliput::dragway::Lane::set_lane_to_left
          struct /* set_lane_to_left */ {

            // drake/automotive/maliput/dragway/lane.h:115
            const char* doc =
R"""(@name Methods that set the lanes to the left and right of this lane.
The corresponding accessors are api::Lane::to_left() and
api::Lane::to_right(). @{)""";

          } set_lane_to_left;

          // drake::maliput::dragway::Lane::set_lane_to_right
          struct /* set_lane_to_right */ {

            // drake/automotive/maliput/dragway/lane.h:116
            const char* doc = R"""()""";

          } set_lane_to_right;

          // drake::maliput::dragway::Lane::y_offset
          struct /* y_offset */ {

            // drake/automotive/maliput/dragway/lane.h:121
            const char* doc =
R"""(Returns the y-offset of this lane's frame relative to the world frame.)""";

          } y_offset;

        } Lane;

        // drake::maliput::dragway::LaneEndSet
        struct /* LaneEndSet */ {

          // drake/automotive/maliput/dragway/branch_point.h:22
          const char* doc =
R"""(Dragway's implementation of api::LaneEndSet. Since a dragway::Lane
connects to itself, this LaneEndSet only contains one api::LaneEnd.)""";

          // drake::maliput::dragway::LaneEndSet::LaneEndSet
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/branch_point.h:24
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/branch_point.h:24
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/branch_point.h:26
            const char* doc_3 = R"""()""";

          } ctor;

        } LaneEndSet;

        // drake::maliput::dragway::RoadGeometry
        struct /* RoadGeometry */ {

          // drake/automotive/maliput/dragway/junction.h:17
          const char* doc =
R"""(Dragway's implementation of api::RoadGeometry.

To understand the characteristics of the geometry, consult the
dragway::Segment and dragway::Lane detailed class overview docs.)""";

          // drake/automotive/maliput/dragway/road_geometry.h:24
          const char* doc_2 =
R"""(Dragway's implementation of api::RoadGeometry.

To understand the characteristics of the geometry, consult the
dragway::Segment and dragway::Lane detailed class overview docs.)""";

          // drake::maliput::dragway::RoadGeometry::RoadGeometry
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/road_geometry.h:26
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/road_geometry.h:26
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/road_geometry.h:51
            const char* doc_3 =
R"""(Constructs a dragway RoadGeometry.

Parameter ``id``:
    The ID of this RoadGeometry. This can be any user-selectable
    value.

Parameter ``num_lanes``:
    The number of lanes. This must be greater than zero.

Parameter ``length``:
    The length of the dragway.

Parameter ``lane_width``:
    The width of each lane.

Parameter ``shoulder_width``:
    The width of the shoulders on each side of the road.

Parameter ``maximum_height``:
    The maximum height above the road surface modelled by the
    RoadGeometry.

Parameter ``linear_tolerance``:
    The tolerance guaranteed for linear measurements (positions).

Parameter ``angular_tolerance``:
    The tolerance guaranteed for angular measurements (orientations).)""";

          } ctor;

        } RoadGeometry;

        // drake::maliput::dragway::Segment
        struct /* Segment */ {

          // drake/automotive/maliput/dragway/lane.h:16
          const char* doc =
R"""(Dragway's implementation of api::Segment. It contains multiple
straight lanes. For the lane semantics, see the class descriptions of
Lane.

The following ASCII art shows how N lanes are arranged in a segment.

```
lane_bounds ---     X         -------- lane index 1
|     ^         |
lane index n ---       |     |         |   --- lane index 0
|       |     |         |   |
V     |<->|   |         V   V
-------------------------------------
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
Y <-----------------------------o----------------------------->
^                 |             ^   ^
|                 |             |   |
y_max               |             |  y_min
|             |
V             --- y offset of lane 0

|<--------------------------------->|
road_width
```

Note that lane indices increase to the left, which matches the fact
that within a Lane, `r` increases to the left.)""";

          // drake/automotive/maliput/dragway/segment.h:55
          const char* doc_2 =
R"""(Dragway's implementation of api::Segment. It contains multiple
straight lanes. For the lane semantics, see the class descriptions of
Lane.

The following ASCII art shows how N lanes are arranged in a segment.

```
lane_bounds ---     X         -------- lane index 1
|     ^         |
lane index n ---       |     |         |   --- lane index 0
|       |     |         |   |
V     |<->|   |         V   V
-------------------------------------
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
| | : | : | : | : | : | : | : | : | |
Y <-----------------------------o----------------------------->
^                 |             ^   ^
|                 |             |   |
y_max               |             |  y_min
|             |
V             --- y offset of lane 0

|<--------------------------------->|
road_width
```

Note that lane indices increase to the left, which matches the fact
that within a Lane, `r` increases to the left.)""";

          // drake::maliput::dragway::Segment::Segment
          struct /* ctor */ {

            // drake/automotive/maliput/dragway/segment.h:57
            const char* doc = R"""()""";

            // drake/automotive/maliput/dragway/segment.h:57
            const char* doc_2 = R"""()""";

            // drake/automotive/maliput/dragway/segment.h:74
            const char* doc_3 =
R"""(Constructs a new dragway Segment.

Parameter ``junction``:
    The junction to which this Segment belongs.

Parameter ``num_lanes``:
    The number of lanes in the segment.

Parameter ``length``:
    The length of the dragway.

Parameter ``lane_width``:
    The width of each lane.

Parameter ``shoulder_width``:
    The width of the shoulders on each side of the road.

Parameter ``maximum_height``:
    The maximum height above the road surface. modelled by the
    RoadGeometry.)""";

          } ctor;

        } Segment;

      } dragway;

    } maliput;

    // manipulation
    struct /* manipulation */ {

      // planner
      struct /* planner */ {

        // drake::manipulation::planner::ComputePoseDiffInCommonFrame
        struct /* ComputePoseDiffInCommonFrame */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:44
          const char* doc =
R"""(Computes the pose "difference" between ``pose1`` and ``pose0`` s.t.
the linear part equals p_C1 - p_C0, and the angular part equals R_C1 *
R_C0.inv(), where p and R stand for the position and rotation parts,
and C is the common frame.)""";

        } ComputePoseDiffInCommonFrame;

        // drake::manipulation::planner::ConstraintRelaxingIk
        struct /* ConstraintRelaxingIk */ {

          // drake/manipulation/planner/constraint_relaxing_ik.h:21
          const char* doc =
R"""(A wrapper class around the IK planner. This class improves IK's
usability by handling constraint relaxing and multiple initial guesses
internally.)""";

          // drake::manipulation::planner::ConstraintRelaxingIk::ConstraintRelaxingIk
          struct /* ctor */ {

            // drake/manipulation/planner/constraint_relaxing_ik.h:23
            const char* doc = R"""()""";

            // drake/manipulation/planner/constraint_relaxing_ik.h:23
            const char* doc_2 = R"""()""";

            // drake/manipulation/planner/constraint_relaxing_ik.h:49
            const char* doc_3 =
R"""(Constructor. Instantiates an internal RigidBodyTree from
``model_path``.

Parameter ``model_path``:
    Path to the model file.

Parameter ``end_effector_link_name``:
    Link name of the end effector.

Parameter ``base_to_world``:
    X_WB, transformation from robot's base to the world frame.)""";

          } ctor;

          // drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint
          struct /* IkCartesianWaypoint */ {

            // drake/manipulation/planner/constraint_relaxing_ik.h:28
            const char* doc =
R"""(Cartesian waypoint. Input to the IK solver.)""";

            // drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::constrain_orientation
            struct /* constrain_orientation */ {

              // drake/manipulation/planner/constraint_relaxing_ik.h:37
              const char* doc =
R"""(Signals if orientation constraint is enabled.)""";

            } constrain_orientation;

            // drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::pos_tol
            struct /* pos_tol */ {

              // drake/manipulation/planner/constraint_relaxing_ik.h:32
              const char* doc =
R"""(Bounding box for the end effector in the world frame.)""";

            } pos_tol;

            // drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::pose
            struct /* pose */ {

              // drake/manipulation/planner/constraint_relaxing_ik.h:30
              const char* doc =
R"""(Desired end effector pose in the world frame.)""";

            } pose;

            // drake::manipulation::planner::ConstraintRelaxingIk::IkCartesianWaypoint::rot_tol
            struct /* rot_tol */ {

              // drake/manipulation/planner/constraint_relaxing_ik.h:35
              const char* doc =
R"""(Max angle difference (in radians) between solved end effector's
orientation and the desired.)""";

            } rot_tol;

          } IkCartesianWaypoint;

          // drake::manipulation::planner::ConstraintRelaxingIk::PlanSequentialTrajectory
          struct /* PlanSequentialTrajectory */ {

            // drake/manipulation/planner/constraint_relaxing_ik.h:87
            const char* doc =
R"""(Generates IK solutions for each waypoint sequentially. For waypoint
wp_i, the IK tries to solve q_i that satisfies the end effector
constraints in wp_i and minimizes the squared difference to q_{i-1},
where q_{i-1} is the solution to the previous wp_{i-1}. q_{i-1} =
``q_current`` when i = 0. This function internally does constraint
relaxing and initial condition guessing if necessary.

Note that ``q_current`` is inserted at the beginning of ``ik_res``.

Parameter ``waypoints``:
    A sequence of desired waypoints.

Parameter ``q_current``:
    The initial generalized position.

Parameter ``ik_res``:
    Results.

Returns:
    True if solved successfully.)""";

          } PlanSequentialTrajectory;

          // drake::manipulation::planner::ConstraintRelaxingIk::SetEndEffector
          struct /* SetEndEffector */ {

            // drake/manipulation/planner/constraint_relaxing_ik.h:56
            const char* doc =
R"""(Sets end effector to ``end_effector_body``.)""";

            // drake/manipulation/planner/constraint_relaxing_ik.h:63
            const char* doc_2 = R"""(Sets end effector to ``link_name``.)""";

          } SetEndEffector;

          // drake::manipulation::planner::ConstraintRelaxingIk::get_robot
          struct /* get_robot */ {

            // drake/manipulation/planner/constraint_relaxing_ik.h:70
            const char* doc =
R"""(Returns constant reference to the robot model.)""";

          } get_robot;

        } ConstraintRelaxingIk;

        // drake::manipulation::planner::DifferentialInverseKinematicsParameters
        struct /* DifferentialInverseKinematicsParameters */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:50
          const char* doc =
R"""(Contains parameters for differential inverse kinematics.)""";

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::AddLinearVelocityConstraint
          struct /* AddLinearVelocityConstraint */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:204
            const char* doc =
R"""(Adds a linear velocity constraint.

Parameter ``linear_velocity_constraint``:
    A linear constraint on joint velocities.

Throws:
    s ValueError if `constraint->num_vars !=
    this->get_num_velocities()`.)""";

          } AddLinearVelocityConstraint;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::ClearLinearVelocityConstraints
          struct /* ClearLinearVelocityConstraints */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:210
            const char* doc = R"""(Clears all linear velocity constraints.)""";

          } ClearLinearVelocityConstraints;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:52
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::DifferentialInverseKinematicsParameters
          struct /* ctor */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:52
            const char* doc = R"""()""";

            // drake/manipulation/planner/differential_inverse_kinematics.h:52
            const char* doc_2 = R"""()""";

            // drake/manipulation/planner/differential_inverse_kinematics.h:62
            const char* doc_3 =
R"""(Constructor. Initializes the nominal joint position to zeros of size
``num_positions``. Timestep is initialized to 1. The end effector
gains are initialized to ones. All constraints are initialized to
nullopt.

Parameter ``num_positions``:
    Number of generalized positions.

Parameter ``num_velocities``:
    Number of generalized velocities.)""";

          } ctor;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_end_effector_velocity_gain
          struct /* get_end_effector_velocity_gain */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:76
            const char* doc = R"""()""";

          } get_end_effector_velocity_gain;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_acceleration_limits
          struct /* get_joint_acceleration_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:96
            const char* doc = R"""()""";

          } get_joint_acceleration_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_position_limits
          struct /* get_joint_position_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:86
            const char* doc = R"""()""";

          } get_joint_position_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_joint_velocity_limits
          struct /* get_joint_velocity_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:91
            const char* doc = R"""()""";

          } get_joint_velocity_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_linear_velocity_constraints
          struct /* get_linear_velocity_constraints */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:101
            const char* doc = R"""()""";

          } get_linear_velocity_constraints;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_nominal_joint_position
          struct /* get_nominal_joint_position */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:72
            const char* doc = R"""()""";

          } get_nominal_joint_position;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_num_positions
          struct /* get_num_positions */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:68
            const char* doc = R"""()""";

          } get_num_positions;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_num_velocities
          struct /* get_num_velocities */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:70
            const char* doc = R"""()""";

          } get_num_velocities;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_timestep
          struct /* get_timestep */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:66
            const char* doc = R"""(@name Getters. @{)""";

          } get_timestep;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::get_unconstrained_degrees_of_freedom_velocity_limit
          struct /* get_unconstrained_degrees_of_freedom_velocity_limit */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:80
            const char* doc = R"""()""";

          } get_unconstrained_degrees_of_freedom_velocity_limit;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_end_effector_velocity_gain
          struct /* set_end_effector_velocity_gain */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:140
            const char* doc =
R"""(Sets the end effector gains in the body frame. Gains can be used to
specify relative importance among different dimensions.

Throws:
    s if any element of ``gain_E`` is larger than 1 or smaller than 0.)""";

          } set_end_effector_velocity_gain;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_acceleration_limits
          struct /* set_joint_acceleration_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:188
            const char* doc =
R"""(Sets the joint acceleration limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Throws:
    s if the first or second element of ``q_bounds`` has the wrong
    dimension or any element of the second element is smaller than its
    corresponding part in the first element.)""";

          } set_joint_acceleration_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_position_limits
          struct /* set_joint_position_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:154
            const char* doc =
R"""(Sets the joint position limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Throws:
    s if the first or second element of ``q_bounds`` has the wrong
    dimension or any element of the second element is smaller than its
    corresponding part in the first element.)""";

          } set_joint_position_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_joint_velocity_limits
          struct /* set_joint_velocity_limits */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:171
            const char* doc =
R"""(Sets the joint velocity limits.

Parameter ``q_bounds``:
    The first element is the lower bound, and the second is the upper
    bound.

Throws:
    s if the first or second element of ``q_bounds`` has the wrong
    dimension or any element of the second element is smaller than its
    corresponding part in the first element.)""";

          } set_joint_velocity_limits;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_nominal_joint_position
          struct /* set_nominal_joint_position */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:129
            const char* doc =
R"""(Sets the nominal joint position.

Throws:
    s if ``nominal_joint_position``'s dimension differs.)""";

          } set_nominal_joint_position;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_timestep
          struct /* set_timestep */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:110
            const char* doc =
R"""(@name Setters. @{

Sets timestep to ``dt``.

Throws:
    s if dt <= 0.)""";

          } set_timestep;

          // drake::manipulation::planner::DifferentialInverseKinematicsParameters::set_unconstrained_degrees_of_freedom_velocity_limit
          struct /* set_unconstrained_degrees_of_freedom_velocity_limit */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:120
            const char* doc =
R"""(Sets the max magnitude of the velocity in the unconstrained degree of
freedom to ``limit``.

Throws:
    s if limit < 0.)""";

          } set_unconstrained_degrees_of_freedom_velocity_limit;

        } DifferentialInverseKinematicsParameters;

        // drake::manipulation::planner::DifferentialInverseKinematicsResult
        struct /* DifferentialInverseKinematicsResult */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:32
          const char* doc = R"""()""";

          // drake::manipulation::planner::DifferentialInverseKinematicsResult::joint_velocities
          struct /* joint_velocities */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:33
            const char* doc = R"""()""";

          } joint_velocities;

          // drake::manipulation::planner::DifferentialInverseKinematicsResult::status
          struct /* status */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:34
            const char* doc = R"""()""";

          } status;

        } DifferentialInverseKinematicsResult;

        // drake::manipulation::planner::DifferentialInverseKinematicsStatus
        struct /* DifferentialInverseKinematicsStatus */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:22
          const char* doc = R"""()""";

          // drake::manipulation::planner::DifferentialInverseKinematicsStatus::kNoSolutionFound
          struct /* kNoSolutionFound */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:24
            const char* doc = R"""(< Solver unable to find a solution.)""";

          } kNoSolutionFound;

          // drake::manipulation::planner::DifferentialInverseKinematicsStatus::kSolutionFound
          struct /* kSolutionFound */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:23
            const char* doc = R"""(< Found the optimal solution.)""";

          } kSolutionFound;

          // drake::manipulation::planner::DifferentialInverseKinematicsStatus::kStuck
          struct /* kStuck */ {

            // drake/manipulation/planner/differential_inverse_kinematics.h:25
            const char* doc =
R"""(< Unable to follow the desired velocity direction)""";

          } kStuck;

        } DifferentialInverseKinematicsStatus;

        // drake::manipulation::planner::DoDifferentialInverseKinematics
        struct /* DoDifferentialInverseKinematics */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:246
          const char* doc =
R"""(Computes a generalized velocity v, s.t. J * v has the same direction
as V, and the difference between |V| and |J * v| is minimized while
all constraints in ``parameters`` are satisfied as well. If the
problem is redundant, a secondary objective to minimize |q_current + v
* dt - q_nominal| is added to the problem. It is possible that the
solver is unable to find such a generalized velocity while not
violating the constraints, in which case, status will be set to kStuck
in the returned DifferentialInverseKinematicsResult.

Parameter ``q_current``:
    The current generalized position.

Parameter ``v_current``:
    The current generalized position.

Parameter ``V``:
    Desired spatial velocity. It must have the same number of rows as
    ``J``.

Parameter ``J``:
    Geometric Jacobian. It must have the same number of rows as ``V``.
    J * v need to represent the same spatial velocity as ``V``.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";

          // drake/manipulation/planner/differential_inverse_kinematics.h:271
          const char* doc_2 =
R"""(A wrapper over DoDifferentialInverseKinematics(q_current, v_current,
V, J, params) that tracks frame E's spatial velocity. q_current and
v_current are taken from ``cache``. V is computed by first
transforming ``V_WE`` to V_WE_E, then taking the element-wise product
between V_WE_E and the gains (specified in frame E) in ``parameters``,
and only selecting the non zero elements. J is computed similarly.

Parameter ``robot``:
    Kinematic tree.

Parameter ``cache``:
    Kinematic cache build from the current generalized position and
    velocity.

Parameter ``V_WE_desired``:
    Desired world frame spatial velocity of ``frame_E``.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";

          // drake/manipulation/planner/differential_inverse_kinematics.h:293
          const char* doc_3 =
R"""(A wrapper over DoDifferentialInverseKinematics(robot, cache,
V_WE_desired, frame_E, params) that tracks frame E's pose in the world
frame. q_current and v_current are taken from ``cache``. V_WE is
computed by ComputePoseDiffInCommonFrame(X_WE, X_WE_desired) / dt,
where X_WE is computed from ``cache``, and dt is taken from
``parameters``.

Parameter ``robot``:
    Robot model.

Parameter ``cache``:
    KinematiCache built from the current generalized position and
    velocity.

Parameter ``X_WE_desired``:
    Desired pose of ``frame_E`` in the world frame.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";

          // drake/manipulation/planner/differential_inverse_kinematics.h:316
          const char* doc_4 =
R"""(A wrapper over DoDifferentialInverseKinematics(q_current, v_current,
V, J, params) that tracks frame E's spatial velocity. q_current and
v_current are taken from ``context``. V is computed by first
transforming ``V_WE`` to V_WE_E, then taking the element-wise product
between V_WE_E and the gains (specified in frame E) in ``parameters``,
and only selecting the non zero elements. J is computed similarly.

Parameter ``robot``:
    A MultibodyTree model.

Parameter ``context``:
    Contains the current generalized position and velocity.

Parameter ``V_WE_desired``:
    Desired world frame spatial velocity of ``frame_E``.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";

          // drake/manipulation/planner/differential_inverse_kinematics.h:339
          const char* doc_5 =
R"""(A wrapper over DoDifferentialInverseKinematics(robot, context,
V_WE_desired, frame_E, params) that tracks frame E's pose in the world
frame. q_current and v_current are taken from ``cache``. V_WE is
computed by ComputePoseDiffInCommonFrame(X_WE, X_WE_desired) / dt,
where X_WE is computed from ``context``, and dt is taken from
``parameters``.

Parameter ``robot``:
    A MultibodyTree model.

Parameter ``context``:
    Contains the current generalized position and velocity.

Parameter ``X_WE_desired``:
    Desired pose of ``frame_E`` in the world frame.

Parameter ``frame_E``:
    End effector frame.

Parameter ``parameters``:
    Collection of various problem specific constraints and constants.

Returns:
    If the solver successfully finds a solution, joint_velocities will
    be set to v, otherwise it will be nullopt.)""";

        } DoDifferentialInverseKinematics;

        // drake::manipulation::planner::InterpolatorType
        struct /* InterpolatorType */ {

          // drake/manipulation/planner/robot_plan_interpolator.h:18
          const char* doc =
R"""(This enum specifies the type of interpolator to use in constructing
the piece-wise polynomial.)""";

          // drake::manipulation::planner::InterpolatorType::Cubic
          struct /* Cubic */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:22
            const char* doc = R"""()""";

          } Cubic;

          // drake::manipulation::planner::InterpolatorType::FirstOrderHold
          struct /* FirstOrderHold */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:20
            const char* doc = R"""()""";

          } FirstOrderHold;

          // drake::manipulation::planner::InterpolatorType::Pchip
          struct /* Pchip */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:21
            const char* doc = R"""()""";

          } Pchip;

          // drake::manipulation::planner::InterpolatorType::ZeroOrderHold
          struct /* ZeroOrderHold */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:19
            const char* doc = R"""()""";

          } ZeroOrderHold;

        } InterpolatorType;

        // drake::manipulation::planner::RobotPlanInterpolator
        struct /* RobotPlanInterpolator */ {

          // drake/manipulation/planner/robot_plan_interpolator.h:35
          const char* doc =
R"""(This class implements a source of joint positions for a robot. It has
two input ports, one for robot_plan_t messages containing a plan to
follow, and another vector-valued port which expects the current (q,v)
state of the robot.

The system has two output ports, one with the current desired state
(q,v) of the robot and another for the accelerations.

If a plan is received with no knot points, the system will create a
plan which commands the arm to hold at the measured position.)""";

          // drake::manipulation::planner::RobotPlanInterpolator::AllocateAbstractState
          struct /* AllocateAbstractState */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:76
            const char* doc = R"""()""";

          } AllocateAbstractState;

          // drake::manipulation::planner::RobotPlanInterpolator::DoCalcUnrestrictedUpdate
          struct /* DoCalcUnrestrictedUpdate */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:79
            const char* doc = R"""()""";

          } DoCalcUnrestrictedUpdate;

          // drake::manipulation::planner::RobotPlanInterpolator::Initialize
          struct /* Initialize */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:67
            const char* doc =
R"""(Makes a plan to hold at the measured joint configuration ``q0``
starting at ``plan_start_time``. This function needs to be explicitly
called before any simulation. Otherwise this aborts in CalcOutput().)""";

          } Initialize;

          // drake::manipulation::planner::RobotPlanInterpolator::RobotPlanInterpolator
          struct /* ctor */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:37
            const char* doc = R"""()""";

            // drake/manipulation/planner/robot_plan_interpolator.h:37
            const char* doc_2 = R"""()""";

            // drake/manipulation/planner/robot_plan_interpolator.h:39
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::manipulation::planner::RobotPlanInterpolator::SetDefaultState
          struct /* SetDefaultState */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:73
            const char* doc = R"""()""";

          } SetDefaultState;

          // drake::manipulation::planner::RobotPlanInterpolator::get_acceleration_output_port
          struct /* get_acceleration_output_port */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:58
            const char* doc = R"""()""";

          } get_acceleration_output_port;

          // drake::manipulation::planner::RobotPlanInterpolator::get_plan_input_port
          struct /* get_plan_input_port */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:44
            const char* doc = R"""()""";

          } get_plan_input_port;

          // drake::manipulation::planner::RobotPlanInterpolator::get_state_input_port
          struct /* get_state_input_port */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:48
            const char* doc = R"""()""";

          } get_state_input_port;

          // drake::manipulation::planner::RobotPlanInterpolator::get_state_output_port
          struct /* get_state_output_port */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:53
            const char* doc = R"""()""";

          } get_state_output_port;

          // drake::manipulation::planner::RobotPlanInterpolator::tree
          struct /* tree */ {

            // drake/manipulation/planner/robot_plan_interpolator.h:70
            const char* doc = R"""()""";

          } tree;

        } RobotPlanInterpolator;

        // drake::manipulation::planner::operator<<
        struct /* operator_lshift */ {

          // drake/manipulation/planner/differential_inverse_kinematics.h:29
          const char* doc = R"""()""";

        } operator_lshift;

      } planner;

    } manipulation;

    // math
    struct /* math */ {

      // drake::math::AreQuaternionsEqualForOrientation
      struct /* AreQuaternionsEqualForOrientation */ {

        // drake/math/quaternion.h:254
        const char* doc =
R"""(This function tests whether two quaternions represent the same
orientation. This function converts each quaternion to its canonical
form and tests whether the absolute value of the difference in
corresponding elements of these canonical quaternions is within
tolerance.

Parameter ``quat1``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Parameter ``quat2``:
    Quaternion with a description analogous to quat1.

Parameter ``tolerance``:
    Nonnegative real scalar defining the allowable difference in the
    orientation described by quat1 and quat2.

Returns:
    `true` if quat1 and quat2 represent the same orientation (to
    within tolerance), otherwise `false`.)""";

      } AreQuaternionsEqualForOrientation;

      // drake::math::AutoDiffToGradientMatrix
      struct /* AutoDiffToGradientMatrix */ {

        // drake/math/autodiff_gradient.h:20
        const char* doc = R"""()""";

      } AutoDiffToGradientMatrix;

      // drake::math::AutoDiffToValueMatrix
      struct /* AutoDiffToValueMatrix */ {

        // drake/math/autodiff.h:20
        const char* doc = R"""()""";

      } AutoDiffToValueMatrix;

      // drake::math::BarycentricMesh
      struct /* BarycentricMesh */ {

        // drake/math/barycentric.h:30
        const char* doc =
R"""(Represents a multi-linear function (from vector inputs to vector
outputs) by interpolating between points on a mesh using (triangular)
barycentric interpolation.

For a technical description of barycentric interpolation, see e.g.
Remi Munos and Andrew Moore, "Barycentric Interpolators for Continuous
Space and Time Reinforcement Learning", NIPS 1998

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double)""";

        // drake::math::BarycentricMesh::BarycentricMesh<T>
        struct /* ctor */ {

          // drake/math/barycentric.h:50
          const char* doc = R"""()""";

          // drake/math/barycentric.h:50
          const char* doc_2 = R"""()""";

          // drake/math/barycentric.h:60
          const char* doc_3 = R"""(Constructs the mesh.)""";

        } ctor;

        // drake::math::BarycentricMesh::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/math/barycentric.h:50
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::math::BarycentricMesh::Eval
        struct /* Eval */ {

          // drake/math/barycentric.h:117
          const char* doc =
R"""(Evaluates the function at the ``input`` values, by interpolating
between the values at ``mesh_values``. Inputs that are outside the
bounding box of the input_grid are interpolated as though they were
projected (elementwise) to the closest face of the defined mesh.

Note that the dimension of the output vector is completely defined by
the mesh_values argument. This class does not maintain any information
related to the size of the output.

Parameter ``mesh_values``:
    is a num_outputs by get_num_mesh_points() matrix containing the
    points to interpolate between. The order of the columns must be
    consistent with the mesh indices curated by this class, as exposed
    by get_mesh_point().

Parameter ``input``:
    must be a vector of length get_num_inputs().

Parameter ``output``:
    is the interpolated vector of length num_outputs)""";

          // drake/math/barycentric.h:122
          const char* doc_2 =
R"""(Returns the function evaluated at ``input``.)""";

        } Eval;

        // drake::math::BarycentricMesh::EvalBarycentricWeights
        struct /* EvalBarycentricWeights */ {

          // drake/math/barycentric.h:98
          const char* doc =
R"""(Writes the mesh indices used for interpolation to ``mesh_indices``,
and the interpolating coefficients to ``weights``. Inputs that are
outside the bounding box of the input_grid are interpolated as though
they were projected (elementwise) to the closest face of the defined
mesh.

Parameter ``input``:
    must be a vector of length get_num_inputs().

Parameter ``mesh_indices``:
    is a pointer to a vector of length get_num_interpolants().

Parameter ``weights``:
    is a vector of coefficients (which sum to 1) of length
    get_num_interpolants().)""";

        } EvalBarycentricWeights;

        // drake::math::BarycentricMesh::EvalWithMixedScalars
        struct /* EvalWithMixedScalars */ {

          // drake/math/barycentric.h:132
          const char* doc =
R"""(Performs Eval, but with the possibility of the values on the mesh
having a different scalar type than the values defining the mesh
(symbolic::Expression containing decision variables for an
optimization problem is an important example)

Template parameter ``ValueT``:
    defines the scalar type of the mesh_values and the output.

See also:
    Eval)""";

          // drake/math/barycentric.h:152
          const char* doc_2 =
R"""(Returns the function evaluated at ``input``.)""";

        } EvalWithMixedScalars;

        // drake::math::BarycentricMesh::MeshValuesFrom
        struct /* MeshValuesFrom */ {

          // drake/math/barycentric.h:168
          const char* doc =
R"""(Evaluates ``vector_func`` at all input mesh points and extracts the
mesh value matrix that should be used to approximate the function with
this barycentric interpolation.

Example usages: MatrixXd mesh_values = bary.MeshValuesFrom( [](const
auto& x) { return Vector1d(std::sin(x[0])); });)""";

        } MeshValuesFrom;

        // drake::math::BarycentricMesh::get_all_mesh_points
        struct /* get_all_mesh_points */ {

          // drake/math/barycentric.h:86
          const char* doc =
R"""(Returns a matrix with all of the mesh points, one per column.)""";

        } get_all_mesh_points;

        // drake::math::BarycentricMesh::get_input_grid
        struct /* get_input_grid */ {

          // drake/math/barycentric.h:63
          const char* doc = R"""()""";

        } get_input_grid;

        // drake::math::BarycentricMesh::get_input_size
        struct /* get_input_size */ {

          // drake/math/barycentric.h:64
          const char* doc = R"""()""";

        } get_input_size;

        // drake::math::BarycentricMesh::get_mesh_point
        struct /* get_mesh_point */ {

          // drake/math/barycentric.h:78
          const char* doc =
R"""(Writes the position of a mesh point in the input space referenced by
its scalar index to ``point``.

Parameter ``index``:
    must be in [0, get_num_mesh_points).

Parameter ``point``:
    is set to the num_inputs-by-1 location of the mesh point.)""";

          // drake/math/barycentric.h:83
          const char* doc_2 =
R"""(Returns the position of a mesh point in the input space referenced by
its scalar index to ``point``.

Parameter ``index``:
    must be in [0, get_num_mesh_points).)""";

        } get_mesh_point;

        // drake::math::BarycentricMesh::get_num_interpolants
        struct /* get_num_interpolants */ {

          // drake/math/barycentric.h:72
          const char* doc = R"""()""";

        } get_num_interpolants;

        // drake::math::BarycentricMesh::get_num_mesh_points
        struct /* get_num_mesh_points */ {

          // drake/math/barycentric.h:65
          const char* doc = R"""()""";

        } get_num_mesh_points;

      } BarycentricMesh;

      // drake::math::CalcRollPitchYawFromQuaternionAndRotationMatrix
      struct /* CalcRollPitchYawFromQuaternionAndRotationMatrix */ {

        // drake/math/roll_pitch_yaw.h:634
        const char* doc = R"""()""";

      } CalcRollPitchYawFromQuaternionAndRotationMatrix;

      // drake::math::CalculateAngularVelocityExpressedInBFromQuaternionDt
      struct /* CalculateAngularVelocityExpressedInBFromQuaternionDt */ {

        // drake/math/quaternion.h:313
        const char* doc =
R"""(This function calculates angular velocity from a quaternion and its
time- derivative. Algorithm from [Kane, 1983] Section 1.13, Pages
58-59.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat_AB``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
    quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of `quat_AB`, i.e. [ẇ, ẋ, ẏ, ż].

Returns ``w_AB_B``:
    B's angular velocity in A, expressed in B.)""";

      } CalculateAngularVelocityExpressedInBFromQuaternionDt;

      // drake::math::CalculateQuaternionDtConstraintViolation
      struct /* CalculateQuaternionDtConstraintViolation */ {

        // drake/math/quaternion.h:347
        const char* doc =
R"""(This function calculates how well a quaternion and its time-derivative
satisfy the quaternion time-derivative constraint specified in [Kane,
1983] Section 1.13, equations 12-13, page 59. For a quaternion [w, x,
y, z], the quaternion must satisfy: w^2 + x^2 + y^2 + z^2 = 1, hence
its time-derivative must satisfy: 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) = 0.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of `quat`, i.e., [ẇ, ẋ, ẏ, ż].

Returns ``quaternionDt_constraint_violation``:
    The amount the time- derivative of the quaternion constraint has
    been violated, which may be positive or negative (0 means the
    constraint is perfectly satisfied).)""";

      } CalculateQuaternionDtConstraintViolation;

      // drake::math::CalculateQuaternionDtFromAngularVelocityExpressedInB
      struct /* CalculateQuaternionDtFromAngularVelocityExpressedInB */ {

        // drake/math/quaternion.h:281
        const char* doc =
R"""(This function calculates a quaternion's time-derivative from its
quaternion and angular velocity. Algorithm from [Kane, 1983] Section
1.13, Pages 58-59.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
1983. (With P. W. Likins and D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat_AB``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note:
    quat_AB is analogous to the rotation matrix R_AB.

Parameter ``w_AB_B``:
    B's angular velocity in A, expressed in B.

Returns ``quatDt``:
    Time-derivative of quat_AB, i.e., [ẇ, ẋ, ẏ, ż].)""";

      } CalculateQuaternionDtFromAngularVelocityExpressedInB;

      // drake::math::CalculateReflectedGrayCodes
      struct /* CalculateReflectedGrayCodes */ {

        // drake/math/gray_code.h:35
        const char* doc =
R"""(Returns a matrix whose i'th row is the Gray code for integer i.

Template parameter ``NumDigits``:
    The number of digits in the Gray code.

Parameter ``num_digits``:
    The number of digits in the Gray code.

Returns:
    M. M is a matrix of size 2ᵏ x k, where `k` is `num_digits`.
    M.row(i) is the Gray code for integer i.)""";

      } CalculateReflectedGrayCodes;

      // drake::math::ClosestQuaternion
      struct /* ClosestQuaternion */ {

        // drake/math/quaternion.h:43
        const char* doc =
R"""(Returns a unit quaternion that represents the same orientation as
`q1`, and has the "shortest" geodesic distance on the unit sphere to
`q0`.)""";

      } ClosestQuaternion;

      // drake::math::ComputeBasisFromAxis
      struct /* ComputeBasisFromAxis */ {

        // drake/math/orthonormal_basis.h:25
        const char* doc =
R"""(Creates a right-handed local basis from a given axis. Defines two
other arbitrary axes such that the basis is orthonormal. The basis is
R_WL, where W is the frame in which the input axis is expressed and L
is a local basis such that v_W = R_WL * v_L.

Parameter ``axis_index``:
    The index of the axis (in the range [0,2]), with 0 corresponding
    to the x-axis, 1 corresponding to the y-axis, and z-corresponding
    to the z-axis.

Parameter ``axis_W``:
    The vector defining the basis's given axis expressed in frame W.
    The vector need not be a unit vector: this routine will normalize
    it.

Returns ``R_WL``:
    The computed basis.

Throws:
    s std::logic_error if the norm of ``axis_W`` is within 1e-10 to
    zero or ``axis_index`` does not lie in the range [0,2].)""";

      } ComputeBasisFromAxis;

      // drake::math::ContinuousAlgebraicRiccatiEquation
      struct /* ContinuousAlgebraicRiccatiEquation */ {

        // drake/math/continuous_algebraic_riccati_equation.h:20
        const char* doc =
R"""(Computes the unique stabilizing solution S to the continuous-time
algebraic Riccati equation:

@verbatim S A + A' S - S B inv(R) B' S + Q = 0 @endverbatim

Throws:
    s std::runtime_error if R is not positive definite.

Based on the Matrix Sign Function method outlined in this paper:
http://www.engr.iupui.edu/~skoskie/ECE684/Riccati_algorithms.pdf)""";

        // drake/math/continuous_algebraic_riccati_equation.h:29
        const char* doc_2 =
R"""(This is functionally the same as ContinuousAlgebraicRiccatiEquation(A,
B, Q, R). The Cholesky decomposition of R is passed in instead of R.)""";

      } ContinuousAlgebraicRiccatiEquation;

      // drake::math::ConvertTimeDerivativeToOtherFrame
      struct /* ConvertTimeDerivativeToOtherFrame */ {

        // drake/math/convert_time_derivative.h:34
        const char* doc =
R"""(Given ᴮd/dt(v) (the time derivative in frame B of an arbitrary 3D
vector v) and given ᴬωᴮ (frame B's angular velocity in another frame
A), this method computes ᴬd/dt(v) (the time derivative in frame A of
v) by: ᴬd/dt(v) = ᴮd/dt(v) + ᴬωᴮ x v

This mathematical operation is known as the "Transport Theorem" or the
"Golden Rule for Vector Differentiation" [Mitiguy 2016, §7.3]. It was
discovered by Euler in 1758. Its explicit notation with superscript
frames was invented by Thomas Kane in 1950. Its use as the defining
property of angular velocity was by Mitiguy in 1993.

In source code and comments, we use the following monogram notations:
DtA_v = ᴬd/dt(v) denotes the time derivative in frame A of the vector
v. DtA_v_E = [ᴬd/dt(v)]_E denotes the time derivative in frame A of
vector v, with the resulting new vector quantity expressed in a frame
E.

In source code, this mathematical operation is performed with all
vectors expressed in the same frame E as [ᴬd/dt(v)]ₑ = [ᴮd/dt(v)]ₑ +
[ᴬωᴮ]ₑ x [v]ₑ which in monogram notation is:

```
DtA_v_E = DtB_v_E + w_AB_E x v_E
```

[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.)""";

      } ConvertTimeDerivativeToOtherFrame;

      // drake::math::DecomposePSDmatrixIntoXtransposeTimesX
      struct /* DecomposePSDmatrixIntoXtransposeTimesX */ {

        // drake/math/quadratic_form.h:24
        const char* doc =
R"""(For a symmetric positive semidefinite matrix Y, decompose it into XᵀX,
where the number of rows in X equals to the rank of Y. Notice that
this decomposition is not unique. For any orthonormal matrix U, s.t
UᵀU = identity, X_prime = UX also satisfies X_primeᵀX_prime = Y. Here
we only return one valid decomposition.

Parameter ``Y``:
    A symmetric positive semidefinite matrix.

Parameter ``zero_tol``:
    We will need to check if some value (for example, the absolute
    value of Y's eigenvalues) is smaller than zero_tol. If it is, then
    we deem that value as 0.

Returns ``X``:
    . The matrix X satisfies XᵀX = Y and X.rows() = rank(Y). @pre 1. Y
    is positive semidefinite. 2. zero_tol is non-negative.

Throws:
    std::runtime_error when the pre-conditions are not satisfied.)""";

      } DecomposePSDmatrixIntoXtransposeTimesX;

      // drake::math::DecomposePositiveQuadraticForm
      struct /* DecomposePositiveQuadraticForm */ {

        // drake/math/quadratic_form.h:64
        const char* doc =
R"""(Rewrite a quadratic form xᵀQx + bᵀx + c to (Rx+d)ᵀ(Rx+d) where RᵀR = Q
Rᵀd = b / 2 Notice that this decomposition is not unique. For example,
with any permutation matrix P, we can define R₁ = P*R d₁ = P*d Then
(R₁*x+d₁)ᵀ(R₁*x+d₁) gives the same quadratic form.

Parameter ``Q``:
    The square matrix.

Parameter ``b``:
    The vector containing the linear coefficients.

Parameter ``c``:
    The constatnt term.

Parameter ``tol``:
    We will determine if this quadratic form is always non-negative,
    by checking the Eigen values of the matrix [Q b/2] [bᵀ/2 c] are
    all greater than -tol. @default is 0. @retval (R, d). R and d have
    the same number of rows. R.cols() == x.rows(). The matrix X = [R
    d] has the same number of rows as the rank of

```
[Q    b/2]
   [bᵀ/2   c]
```

@pre 1. The quadratic form is always non-negative, namely the matrix

```
[Q    b/2]
        [bᵀ/2   c]
```

is positive semidefinite. 2. `Q` and `b` are of the correct size. 3.
`tol` is non-negative.

Throws:
    a runtime_error if the precondition is not satisfied.)""";

      } DecomposePositiveQuadraticForm;

      // drake::math::DiscardGradient
      struct /* DiscardGradient */ {

        // drake/math/autodiff.h:59
        const char* doc =
R"""(`B = DiscardGradient(A)` enables casting from a matrix of
AutoDiffScalars to AutoDiffScalar::Scalar type, explicitly throwing
away any gradient information. For a matrix of type, e.g.
`MatrixX<AutoDiffXd> A`, the comparable operation `B =
A.cast<double>()` should (and does) fail to compile. Use
`DiscardGradient(A)` if you want to force the cast (and explicitly
declare that information is lost).

This method is overloaded to permit the user to call it for double
types and AutoDiffScalar types (to avoid the calling function having
to handle the two cases differently).

See also:
    DiscardZeroGradient)""";

        // drake/math/autodiff.h:68
        const char* doc_2 =
R"""(See also:
    DiscardGradient().)""";

        // drake/math/autodiff.h:77
        const char* doc_3 =
R"""(See also:
    DiscardGradient().)""";

        // drake/math/autodiff.h:88
        const char* doc_4 =
R"""(See also:
    DiscardGradient().)""";

      } DiscardGradient;

      // drake::math::DiscardZeroGradient
      struct /* DiscardZeroGradient */ {

        // drake/math/autodiff_gradient.h:165
        const char* doc =
R"""(`B = DiscardZeroGradient(A, precision)` enables casting from a matrix
of AutoDiffScalars to AutoDiffScalar::Scalar type, but first checking
that the gradient matrix is empty or zero. For a matrix of type, e.g.
`MatrixX<AutoDiffXd> A`, the comparable operation `B =
A.cast<double>()` should (and does) fail to compile. Use
`DiscardZeroGradient(A)` if you want to force the cast (and the
check).

This method is overloaded to permit the user to call it for double
types and AutoDiffScalar types (to avoid the calling function having
to handle the two cases differently).

Parameter ``precision``:
    is passed to Eigen's isZero(precision) to evaluate whether the
    gradients are zero.

Throws:
    s std::runtime_error if the gradients were not empty nor zero.

See also:
    DiscardGradient)""";

        // drake/math/autodiff_gradient.h:182
        const char* doc_2 =
R"""(See also:
    DiscardZeroGradient().)""";

        // drake/math/autodiff_gradient.h:193
        const char* doc_3 =
R"""(See also:
    DiscardZeroGradient().)""";

        // drake/math/autodiff_gradient.h:206
        const char* doc_4 =
R"""(See also:
    DiscardZeroGradient().)""";

      } DiscardZeroGradient;

      // drake::math::DiscreteAlgebraicRiccatiEquation
      struct /* DiscreteAlgebraicRiccatiEquation */ {

        // drake/math/discrete_algebraic_riccati_equation.h:25
        const char* doc =
R"""(Computes the unique stabilizing solution X to the discrete-time
algebraic Riccati equation:

\f[ A'XA - X - A'XB(B'XB+R)^{-1}B'XA + Q = 0 \f]

Throws:
    s std::runtime_error if Q is not positive semi-definite.

Throws:
    s std::runtime_error if R is not positive definite.

Based on the Schur Vector approach outlined in this paper: "On the
Numerical Solution of the Discrete-Time Algebraic Riccati Equation" by
Thrasyvoulos Pappas, Alan J. Laub, and Nils R. Sandell)""";

      } DiscreteAlgebraicRiccatiEquation;

      // drake::math::GetSubMatrixGradientArray
      struct /* GetSubMatrixGradientArray */ {

        // drake/math/gradient_util.h:59
        const char* doc = R"""()""";

      } GetSubMatrixGradientArray;

      // drake::math::GetSubMatrixGradientSingleElement
      struct /* GetSubMatrixGradientSingleElement */ {

        // drake/math/gradient_util.h:70
        const char* doc = R"""()""";

      } GetSubMatrixGradientSingleElement;

      // drake::math::Gradient
      struct /* Gradient */ {

        // drake/math/gradient.h:16
        const char* doc = R"""()""";

      } Gradient;

      // drake::math::GrayCodeToInteger
      struct /* GrayCodeToInteger */ {

        // drake/math/gray_code.h:59
        const char* doc =
R"""(Converts the Gray code to an integer. For example (0, 0) -> 0 (0, 1)
-> 1 (1, 1) -> 2 (1, 0) -> 3

Parameter ``gray_code``:
    The N-digit Gray code, where N is gray_code.rows()

Returns:
    The integer represented by the Gray code `gray_code`.)""";

      } GrayCodeToInteger;

      // drake::math::GrayCodesMatrix
      struct /* GrayCodesMatrix */ {

        // drake/math/gray_code.h:14
        const char* doc =
R"""(GrayCodesMatrix::type returns an Eigen matrix of integers. The size of
this matrix is determined by the number of digits in the Gray code.)""";

        // drake/math/gray_code.h:22
        const char* doc_2 = R"""()""";

      } GrayCodesMatrix;

      // drake::math::IsBothQuaternionAndQuaternionDtOK
      struct /* IsBothQuaternionAndQuaternionDtOK */ {

        // drake/math/quaternion.h:398
        const char* doc =
R"""(This function tests if a quaternion satisfies the time-derivative
constraint specified in [Kane, 1983] Section 1.13, equation 13, page
59. A quaternion [w, x, y, z] must satisfy w^2 + x^2 + y^2 + z^2 = 1,
hence its time-derivative must satisfy 2*(w*ẇ + x*ẋ + y*ẏ + z*ż) =
0. Note: To accurately test whether the time-derivative quaternion
constraint is satisfied, the quaternion constraint is also tested to
be accurate.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of `quat`, i.e., [ẇ, ẋ, ẏ, ż].

Parameter ``tolerance``:
    Tolerance for quaternion constraints.

Returns:
    `true` if both of the two previous constraints are within
    tolerance.)""";

      } IsBothQuaternionAndQuaternionDtOK;

      // drake::math::IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB
      struct /* IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB */ {

        // drake/math/quaternion.h:427
        const char* doc =
R"""(This function tests if a quaternion and a quaternions time-derivative
can calculate and match an angular velocity to within a tolerance.
Note: This function first tests if the quaternion [w, x, y, z]
satisfies w^2 + x^2 + y^2 + z^2 = 1 (to within tolerance) and if its
time-derivative satisfies w*ẇ + x*ẋ + y*ẏ + z*ż = 0 (to within
tolerance). Lastly, it tests if each element of the angular velocity
calculated from quat and quatDt is within tolerance of w_B (described
below).

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``quatDt``:
    Time-derivative of `quat`, i.e., [ẇ, ẋ, ẏ, ż].

Parameter ``w_B``:
    Rigid body B's angular velocity in frame A, expressed in B.

Parameter ``tolerance``:
    Tolerance for quaternion constraints.

Returns:
    `true` if all three of the previous constraints are within
    tolerance.)""";

      } IsQuaternionAndQuaternionDtEqualAngularVelocityExpressedInB;

      // drake::math::IsQuaternionValid
      struct /* IsQuaternionValid */ {

        // drake/math/quaternion.h:371
        const char* doc =
R"""(This function tests if a quaternion satisfies the quaternion
constraint specified in [Kane, 1983] Section 1.3, equation 4, page 12,
i.e., a quaternion [w, x, y, z] must satisfy: w^2 + x^2 + y^2 + z^2 =
1.

- [Kane, 1983] "Spacecraft Dynamics," McGraw-Hill Book Co., New York,
1983. (with P. W. Likins and D. A. Levinson). Available for free .pdf
download: https://ecommons.cornell.edu/handle/1813/637

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: A
    quaternion like quat_AB is analogous to the rotation matrix R_AB.

Parameter ``tolerance``:
    Tolerance for quaternion constraint, i.e., how much is w^2 + x^2 +
    y^2 + z^2 allowed to differ from 1.

Returns:
    `true` if the quaternion constraint is satisfied within tolerance.)""";

      } IsQuaternionValid;

      // drake::math::IsSymmetric
      struct /* IsSymmetric */ {

        // drake/math/matrix_util.h:16
        const char* doc =
R"""(Determines if a matrix is symmetric. If std::equal_to<>()(matrix(i,
j), matrix(j, i)) is true for all i, j, then the matrix is symmetric.)""";

        // drake/math/matrix_util.h:36
        const char* doc_2 =
R"""(Determines if a matrix is symmetric based on whether the difference
between matrix(i, j) and matrix(j, i) is smaller than ``precision``
for all i, j. The precision is absolute. Matrix with nan or inf
entries is not allowed.)""";

      } IsSymmetric;

      // drake::math::MatGradMult
      struct /* MatGradMult */ {

        // drake/math/gradient_util.h:42
        const char* doc = R"""()""";

      } MatGradMult;

      // drake::math::MatGradMultMat
      struct /* MatGradMultMat */ {

        // drake/math/gradient_util.h:28
        const char* doc = R"""()""";

      } MatGradMultMat;

      // drake::math::NormalizeVector
      struct /* NormalizeVector */ {

        // drake/math/normalize_vector.h:24
        const char* doc =
R"""(Computes the normalized vector, optionally with its gradient and
second derivative.

Parameter ``x``:
    An N x 1 vector to be normalized. Must not be zero.

Parameter ``x_norm``:
    The normalized vector (N x 1).

Parameter ``dx_norm``:
    If non-null, returned as an N x N matrix, where dx_norm(i,j) = D
    x_norm(i)/D x(j).

Parameter ``ddx_norm``:
    If non-null, and dx_norm is non-null, returned as an N^2 x N
    matrix, where ddx_norm.col(j) = D dx_norm/D x(j), with dx_norm
    stacked columnwise.

(D x / D y above means partial derivative of x with respect to y.))""";

      } NormalizeVector;

      // drake::math::ProjectMatToRotMatWithAxis
      struct /* ProjectMatToRotMatWithAxis */ {

        // drake/math/rotation_matrix.h:754
        const char* doc =
R"""(Projects an approximate 3 x 3 rotation matrix M onto an orthonormal
matrix R so that R is a rotation matrix associated with a angle-axis
rotation by an angle θ about a vector direction `axis`, with `angle_lb
<= θ <= angle_ub`.

Template parameter ``Derived``:
    A 3 x 3 matrix

Parameter ``M``:
    the matrix to be projected.

Parameter ``axis``:
    vector direction associated with angle-axis rotation for R. axis
    can be a non-unit vector, but cannot be the zero vector.

Parameter ``angle_lb``:
    the lower bound of the rotation angle θ.

Parameter ``angle_ub``:
    the upper bound of the rotation angle θ.

Returns:
    Rotation angle θ of the projected matrix, angle_lb <= θ <=
    angle_ub

Throws:
    s exception std::runtime_error if M is not a 3 x 3 matrix or if
    axis is the zero vector or if angle_lb > angle_ub.

Note:
    This function is useful for reconstructing a rotation matrix for a
    revolute joint with joint limits.

Note:
    This can be formulated as an optimization problem

```
min_θ trace((R - M)ᵀ*(R - M))
  subject to R = I + sinθ * A + (1 - cosθ) * A²   (1)
             angle_lb <= θ <= angle_ub
```

where A is the cross product matrix of a = axis / axis.norm() = [a₁,
a₂, a₃]

```
A = [ 0  -a₃  a₂]
    [ a₃  0  -a₁]
    [-a₂  a₁  0 ]
```

Equation (1) is the Rodriguez Formula that computes the rotation
matrix R from the angle-axis rotation with angle θ and vector
direction `axis`. For details, see
http://mathworld.wolfram.com/RodriguesRotationFormula.html The
objective function can be simplified as

```
max_θ trace(Rᵀ * M + Mᵀ * R)
```

By substituting the matrix `R` with the angle-axis representation, the
optimization problem is formulated as

```
max_θ sinθ * trace(Aᵀ*M) - cosθ * trace(Mᵀ * A²)
   subject to angle_lb <= θ <= angle_ub
```

By introducing α = atan2(-trace(Mᵀ * A²), trace(Aᵀ*M)), we can compute
the optimal θ as

```
θ = π/2 + 2kπ - α, if angle_lb <= π/2 + 2kπ - α <= angle_ub, k ∈ integers
else
   θ = angle_lb, if sin(angle_lb + α) >= sin(angle_ub + α)
   θ = angle_ub, if sin(angle_lb + α) <  sin(angle_ub + α)
```

See also:
    GlobalInverseKinematics for an usage of this function.)""";

      } ProjectMatToRotMatWithAxis;

      // drake::math::QuaternionToCanonicalForm
      struct /* QuaternionToCanonicalForm */ {

        // drake/math/quaternion.h:232
        const char* doc =
R"""(This function returns a quaternion in its "canonical form" meaning
that it returns a quaternion [w, x, y, z] with a non-negative w. For
example, if passed a quaternion [-0.3, +0.4, +0.5, +0.707], the
function returns the quaternion's canonical form [+0.3, -0.4, -0.5,
-0.707].

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Returns:
    Canonical form of quat, which means that either the original quat
    is returned or a quaternion representing the same orientation but
    with negated [w, x, y, z], to ensure a positive w in returned
    quaternion.)""";

      } QuaternionToCanonicalForm;

      // drake::math::QuaternionToSpaceXYZ
      struct /* QuaternionToSpaceXYZ */ {

        // drake/math/roll_pitch_yaw.h:642
        const char* doc =
R"""((Deprecated), use math::RollPitchYaw(quaternion).)""";

      } QuaternionToSpaceXYZ;

      // drake::math::RigidTransform
      struct /* RigidTransform */ {

        // drake/math/rigid_transform.h:50
        const char* doc =
R"""(This class represents a proper rigid transform between two frames
which can be regarded in two ways. It can be regarded as a distance-
preserving linear operator that can rotate and/or translate a rigid
body without changing its shape or size (rigid) and without
mirroring/reflecting the body (proper), e.g., it can add one position
vector to another and express the result in a particular basis as
`p_AoQ_A = X_AB * p_BoQ_B` (Q is any point). Alternately, a rigid
transform describes the pose between two frames A and B (i.e., the
relative orientation and position of A to B). Herein, the terms
rotation/orientation and translation/position are used
interchangeably. The class stores a RotationMatrix that relates right-
handed orthogonal unit vectors Ax, Ay, Az fixed in frame A to right-
handed orthogonal unit vectors Bx, By, Bz fixed in frame B. The class
also stores a position vector from Ao (the origin of frame A) to Bo
(the origin of frame B). The position vector is expressed in frame A.
The monogram notation for the transform relating frame A to B is
`X_AB`. The monogram notation for the rotation matrix relating A to B
is `R_AB`. The monogram notation for the position vector from Ao to Bo
is `p_AoBo_A`. See multibody_quantities for monogram notation for
dynamics.

Note:
    This class does not store the frames associated with the transform
    and cannot enforce correct usage of this class. For example, it
    makes sense to multiply RigidTransforms as `X_AB * X_BC`, but not
    `X_AB * X_CB`.

Note:
    This class is not a 4x4 transformation matrix -- even though its
    operator*() methods act like 4x4 matrix multiplication. Instead,
    this class contains a rotation matrix class as well as a 3x1
    position vector. To form a 4x4 matrix, use GetAsMatrix().
    GetAsIsometry() is treated similarly.

Note:
    An isometry is sometimes regarded as synonymous with rigid
    transform.

Authors:
    s Paul Mitiguy (2018) Original author.

Authors:
    s Drake team (see https://drake.mit.edu/credits).

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::math::RigidTransform::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/math/rigid_transform.h:52
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::math::RigidTransform::GetAsIsometry3
        struct /* GetAsIsometry3 */ {

          // drake/math/rigid_transform.h:189
          const char* doc =
R"""(Returns the isometry in ℜ³ that is equivalent to a RigidTransform.)""";

        } GetAsIsometry3;

        // drake::math::RigidTransform::GetAsMatrix34
        struct /* GetAsMatrix34 */ {

          // drake/math/rigid_transform.h:181
          const char* doc =
R"""(Returns the 3x4 matrix associated with this RigidTransform, i.e.,
X_AB.

```
┌                ┐
 │ R_AB  p_AoBo_A │
 └                ┘
```)""";

        } GetAsMatrix34;

        // drake::math::RigidTransform::GetAsMatrix4
        struct /* GetAsMatrix4 */ {

          // drake/math/rigid_transform.h:167
          const char* doc =
R"""(Returns the 4x4 matrix associated with this RigidTransform, i.e.,
X_AB.

```
┌                ┐
 │ R_AB  p_AoBo_A │
 │                │
 │   0      1     │
 └                ┘
```)""";

        } GetAsMatrix4;

        // drake::math::RigidTransform::GetMaximumAbsoluteDifference
        struct /* GetMaximumAbsoluteDifference */ {

          // drake/math/rigid_transform.h:299
          const char* doc =
R"""(Computes the infinity norm of `this` - `other` (i.e., the maximum
absolute value of the difference between the elements of `this` and
`other`).

Parameter ``other``:
    RigidTransform to subtract from `this`.

Returns:
    ‖`this` - `other`‖∞)""";

        } GetMaximumAbsoluteDifference;

        // drake::math::RigidTransform::GetMaximumAbsoluteTranslationDifference
        struct /* GetMaximumAbsoluteTranslationDifference */ {

          // drake/math/rigid_transform.h:309
          const char* doc =
R"""(Returns the maximum absolute value of the difference in the position
vectors (translation) in `this` and `other`. In other words, returns
the infinity norm of the difference in the position vectors.

Parameter ``other``:
    RigidTransform whose position vector is subtracted from the
    position vector in `this`.)""";

        } GetMaximumAbsoluteTranslationDifference;

        // drake::math::RigidTransform::Identity
        struct /* Identity */ {

          // drake/math/rigid_transform.h:137
          const char* doc = R"""()""";

        } Identity;

        // drake::math::RigidTransform::IsExactlyEqualTo
        struct /* IsExactlyEqualTo */ {

          // drake/math/rigid_transform.h:290
          const char* doc =
R"""(Returns true if `this` is exactly equal to `other`.

Parameter ``other``:
    RigidTransform to compare to `this`.

Returns:
    `true` if each element of `this` is exactly equal to the
    corresponding element of `other`.)""";

        } IsExactlyEqualTo;

        // drake::math::RigidTransform::IsExactlyIdentity
        struct /* IsExactlyIdentity */ {

          // drake/math/rigid_transform.h:211
          const char* doc =
R"""(Returns `true` if `this` is exactly the identity RigidTransform.

See also:
    IsIdentityToEpsilon().)""";

        } IsExactlyIdentity;

        // drake::math::RigidTransform::IsIdentityToEpsilon
        struct /* IsIdentityToEpsilon */ {

          // drake/math/rigid_transform.h:225
          const char* doc =
R"""(Return true if `this` is within tolerance of the identity
RigidTransform.

Returns:
    `true` if the RotationMatrix portion of `this` satisfies
    RotationMatrix::IsIdentityToInternalTolerance() and if the
    position vector portion of `this` is equal to zero vector within
    `translation_tolerance`.

Parameter ``translation_tolerance``:
    a non-negative number. One way to choose `translation_tolerance`
    is to multiply a characteristic length (e.g., the magnitude of a
    characteristic position vector) by an epsilon (e.g.,
    RotationMatrix::get_internal_tolerance_for_orthonormality()).

See also:
    IsExactlyIdentity().)""";

        } IsIdentityToEpsilon;

        // drake::math::RigidTransform::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {

          // drake/math/rigid_transform.h:281
          const char* doc =
R"""(Compares each element of `this` to the corresponding element of
`other` to check if they are the same to within a specified
`tolerance`.

Parameter ``other``:
    RigidTransform to compare to `this`.

Parameter ``tolerance``:
    maximum allowable absolute difference between the elements in
    `this` and `other`.

Returns:
    `true` if `‖this.matrix() - other.matrix()‖∞ <= tolerance`.

Note:
    Consider scaling tolerance with the largest of magA and magB,
    where magA and magB denoted the magnitudes of `this` position
    vector and `other` position vectors, respectively.)""";

        } IsNearlyEqualTo;

        // drake::math::RigidTransform::RigidTransform<T>
        struct /* ctor */ {

          // drake/math/rigid_transform.h:52
          const char* doc = R"""()""";

          // drake/math/rigid_transform.h:52
          const char* doc_2 = R"""()""";

          // drake/math/rigid_transform.h:59
          const char* doc_3 = R"""()""";

          // drake/math/rigid_transform.h:65
          const char* doc_4 =
R"""(Constructs a RigidTransform from a rotation matrix and a position
vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., `R_AB`).

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    `p_AoBo_A`.)""";

          // drake/math/rigid_transform.h:70
          const char* doc_5 =
R"""(Constructs a RigidTransform with a given RotationMatrix and a zero
position vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., `R_AB`).)""";

          // drake/math/rigid_transform.h:78
          const char* doc_6 =
R"""(Constructs a RigidTransform with an identity RotationMatrix and a
given position vector 'p'.

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    `p_AoBo_A`.)""";

          // drake/math/rigid_transform.h:88
          const char* doc_7 =
R"""(Constructs a RigidTransform from an Eigen Isometry3.

Parameter ``pose``:
    Isometry3 that contains an allegedly valid rotation matrix `R_AB`
    and also contains a position vector `p_AoBo_A` from frame A's
    origin to frame B's origin. `p_AoBo_A` must be expressed in frame
    A.

Throws:
    s std::logic_error in debug builds if R_AB is not a proper
    orthonormal 3x3 rotation matrix.

Note:
    no attempt is made to orthogonalize the 3x3 rotation matrix part
    of `pose`. As needed, use
    RotationMatrix::ProjectToRotationMatrix().)""";

        } ctor;

        // drake::math::RigidTransform::SetFromIsometry3
        struct /* SetFromIsometry3 */ {

          // drake/math/rigid_transform.h:107
          const char* doc =
R"""(Sets `this` RigidTransform from an Eigen Isometry3.

Parameter ``pose``:
    Isometry3 that contains an allegedly valid rotation matrix `R_AB`
    and also contains a position vector `p_AoBo_A` from frame A's
    origin to frame B's origin. `p_AoBo_A` must be expressed in frame
    A.

Throws:
    s std::logic_error in debug builds if R_AB is not a proper
    orthonormal 3x3 rotation matrix.

Note:
    no attempt is made to orthogonalize the 3x3 rotation matrix part
    of `pose`. As needed, use
    RotationMatrix::ProjectToRotationMatrix().)""";

        } SetFromIsometry3;

        // drake::math::RigidTransform::SetIdentity
        struct /* SetIdentity */ {

          // drake/math/rigid_transform.h:204
          const char* doc =
R"""(Sets `this` RigidTransform so it corresponds to aligning the two
frames so unit vectors Ax = Bx, Ay = By, Az = Bz and point Ao is
coincident with Bo. Hence, `this` RigidTransform contains a 3x3
identity matrix and a zero position vector.)""";

        } SetIdentity;

        // drake::math::RigidTransform::cast
        struct /* cast */ {

          // drake/math/rigid_transform.h:125
          const char* doc =
R"""(Creates a RigidTransform templatized on a scalar type U from a
RigidTransform templatized on scalar type T. For example,

```
RigidTransform<double> source = RigidTransform<double>::Identity();
RigidTransform<AutoDiffXd> foo = source.cast<AutoDiffXd>();
```

Template parameter ``U``:
    Scalar type on which the returned RigidTransform is templated.

Note:
    `RigidTransform<From>::cast<To>()` creates a new
    `RigidTransform<To>` from a `RigidTransform<From>` but only if
    type `To` is constructible from type `From`. This cast method
    works in accordance with Eigen's cast method for Eigen's objects
    that underlie this RigidTransform. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";

        } cast;

        // drake::math::RigidTransform::inverse
        struct /* inverse */ {

          // drake/math/rigid_transform.h:239
          const char* doc = R"""()""";

        } inverse;

        // drake::math::RigidTransform::operator*
        struct /* operator_mul */ {

          // drake/math/rigid_transform.h:259
          const char* doc =
R"""(Calculates `this` RigidTransform `X_AB` multiplied by `other`
RigidTransform `X_BC`.

Parameter ``other``:
    RigidTransform that post-multiplies `this`.

Returns ``X_AC``:
    = X_AB * X_BC)""";

          // drake/math/rigid_transform.h:268
          const char* doc_2 =
R"""(Calculates `this` RigidTransform `X_AB` multiplied by the position
vector 'p_BoQ_B` which is from Bo (B's origin) to an arbitrary point
Q.

Parameter ``p_BoQ_B``:
    position vector from Bo to Q, expressed in frame B.

Returns ``p_AoQ_A``:
    position vector from Ao to Q, expressed in frame A.)""";

        } operator_mul;

        // drake::math::RigidTransform::operator*=
        struct /* operator_imul */ {

          // drake/math/rigid_transform.h:249
          const char* doc =
R"""(In-place multiply of `this` RigidTransform `X_AB` by `other`
RigidTransform `X_BC`.

Parameter ``other``:
    RigidTransform that post-multiplies `this`.

Returns:
    `this` RigidTransform which has been multiplied by `other`. On
    return, `this = X_AC`, where `X_AC = X_AB * X_BC`.)""";

        } operator_imul;

        // drake::math::RigidTransform::rotation
        struct /* rotation */ {

          // drake/math/rigid_transform.h:144
          const char* doc =
R"""(Returns R_AB, the rotation matrix portion of `this` RigidTransform.

Returns ``R_AB``:
    the rotation matrix portion of `this` RigidTransform.)""";

        } rotation;

        // drake::math::RigidTransform::set
        struct /* set */ {

          // drake/math/rigid_transform.h:94
          const char* doc =
R"""(Sets `this` RigidTransform from a RotationMatrix and a position
vector.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., `R_AB`).

Parameter ``p``:
    position vector from frame A's origin to frame B's origin,
    expressed in frame A. In monogram notation p is denoted
    `p_AoBo_A`.)""";

        } set;

        // drake::math::RigidTransform::set_rotation
        struct /* set_rotation */ {

          // drake/math/rigid_transform.h:148
          const char* doc =
R"""(Sets the RotationMatrix portion of `this` RigidTransform.

Parameter ``R``:
    rotation matrix relating frames A and B (e.g., `R_AB`).)""";

        } set_rotation;

        // drake::math::RigidTransform::set_translation
        struct /* set_translation */ {

          // drake/math/rigid_transform.h:157
          const char* doc =
R"""(Sets the position vector portion of `this` RigidTransform.

Parameter ``p``:
    position vector from Ao (frame A's origin) to Bo (frame B's
    origin) expressed in frame A. In monogram notation p is denoted
    p_AoBo_A.)""";

        } set_translation;

        // drake::math::RigidTransform::translation
        struct /* translation */ {

          // drake/math/rigid_transform.h:152
          const char* doc =
R"""(Returns `p_AoBo_A`, the position vector portion of `this`
RigidTransform, i.e., position vector from Ao (frame A's origin) to Bo
(frame B's origin).)""";

        } translation;

      } RigidTransform;

      // drake::math::RollPitchYaw
      struct /* RollPitchYaw */ {

        // drake/math/roll_pitch_yaw.h:64
        const char* doc = R"""()""";

        // drake::math::RollPitchYaw::CalcAngularVelocityInChildFromRpyDt
        struct /* CalcAngularVelocityInChildFromRpyDt */ {

          // drake/math/roll_pitch_yaw.h:313
          const char* doc =
R"""(Calculates angular velocity from `this` RollPitchYaw whose roll-pitch-
yaw angles `[r; p; y]` relate the orientation of two generic frames A
and D.

Parameter ``rpyDt``:
    Time-derivative of `[r; p; y]`, i.e., `[ṙ; ṗ; ẏ]`.

Returns:
    w_AD_D, frame D's angular velocity in frame A, expressed in D.)""";

        } CalcAngularVelocityInChildFromRpyDt;

        // drake::math::RollPitchYaw::CalcAngularVelocityInParentFromRpyDt
        struct /* CalcAngularVelocityInParentFromRpyDt */ {

          // drake/math/roll_pitch_yaw.h:300
          const char* doc =
R"""(Calculates angular velocity from `this` RollPitchYaw whose roll-pitch-
yaw angles `[r; p; y]` relate the orientation of two generic frames A
and D.

Parameter ``rpyDt``:
    Time-derivative of `[r; p; y]`, i.e., `[ṙ; ṗ; ẏ]`.

Returns:
    w_AD_A, frame D's angular velocity in frame A, expressed in A.)""";

        } CalcAngularVelocityInParentFromRpyDt;

        // drake::math::RollPitchYaw::CalcRotationMatrixDt
        struct /* CalcRotationMatrixDt */ {

          // drake/math/roll_pitch_yaw.h:282
          const char* doc =
R"""(Forms Ṙ, the ordinary derivative of the RotationMatrix `R` with
respect to an independent variable `t` (`t` usually denotes time) and
`R` is the RotationMatrix formed by `this` RollPitchYaw. The roll-
pitch-yaw angles r, p, y are regarded as functions of `t` [i.e., r(t),
p(t), y(t)].

Parameter ``rpyDt``:
    Ordinary derivative of rpy with respect to an independent variable
    `t` (`t` usually denotes time, but not necessarily).

Returns:
    Ṙ, the ordinary derivative of `R` with respect to `t`, calculated
    as Ṙ = ∂R/∂r * ṙ + ∂R/∂p * ṗ + ∂R/∂y * ẏ. In other words, the
    returned (i, j) element is ∂Rij/∂r * ṙ + ∂Rij/∂p * ṗ + ∂Rij/∂y *
    ẏ.)""";

        } CalcRotationMatrixDt;

        // drake::math::RollPitchYaw::CalcRpyDDtFromAngularAccelInChild
        struct /* CalcRpyDDtFromAngularAccelInChild */ {

          // drake/math/roll_pitch_yaw.h:379
          const char* doc =
R"""(Uses angular acceleration to compute the 2ⁿᵈ time-derivative of `this`
RollPitchYaw whose angles `[r; p; y]` orient two generic frames A and
D.

Parameter ``rpyDt``:
    time-derivative of `[r; p; y]`, i.e., `[ṙ; ṗ; ẏ]`.

Parameter ``alpha_AD_D``:
    , frame D's angular acceleration in frame A, expressed in frame D.

Returns:
    `[r̈, p̈, ÿ]`, the 2ⁿᵈ time-derivative of `this` RollPitchYaw.

Throws:
    s std::logic_error if `cos(p) ≈ 0` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle `p` is zero [i.e., `cos(p) = 0`]. This
    problem (called "gimbal lock") occurs when `p = n π + π / 2`,
    where n is any integer. There are associated precision problems
    (inaccuracies) in the neighborhood of these pitch angles, i.e.,
    when `cos(p) ≈ 0`.)""";

        } CalcRpyDDtFromAngularAccelInChild;

        // drake::math::RollPitchYaw::CalcRpyDDtFromRpyDtAndAngularAccelInParent
        struct /* CalcRpyDDtFromRpyDtAndAngularAccelInParent */ {

          // drake/math/roll_pitch_yaw.h:358
          const char* doc =
R"""(Uses angular acceleration to compute the 2ⁿᵈ time-derivative of `this`
RollPitchYaw whose angles `[r; p; y]` orient two generic frames A and
D.

Parameter ``rpyDt``:
    time-derivative of `[r; p; y]`, i.e., `[ṙ; ṗ; ẏ]`.

Parameter ``alpha_AD_A``:
    , frame D's angular acceleration in frame A, expressed in frame A.

Returns:
    `[r̈, p̈, ÿ]`, the 2ⁿᵈ time-derivative of `this` RollPitchYaw.

Throws:
    s std::logic_error if `cos(p) ≈ 0` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle `p` is zero [i.e., `cos(p) = 0`]. This
    problem (called "gimbal lock") occurs when `p = n π + π / 2`,
    where n is any integer. There are associated precision problems
    (inaccuracies) in the neighborhood of these pitch angles, i.e.,
    when `cos(p) ≈ 0`.)""";

        } CalcRpyDDtFromRpyDtAndAngularAccelInParent;

        // drake::math::RollPitchYaw::CalcRpyDtFromAngularVelocityInParent
        struct /* CalcRpyDtFromAngularVelocityInParent */ {

          // drake/math/roll_pitch_yaw.h:333
          const char* doc =
R"""(Uses angular velocity to compute the 1ˢᵗ time-derivative of `this`
RollPitchYaw whose angles `[r; p; y]` orient two generic frames A and
D.

Parameter ``w_AD_A``:
    , frame D's angular velocity in frame A, expressed in A.

Returns:
    `[ṙ; ṗ; ẏ]`, the 1ˢᵗ time-derivative of `this` RollPitchYaw.

Throws:
    s std::logic_error if `cos(p) ≈ 0` (`p` is near gimbal-lock).

Note:
    This method has a divide-by-zero error (singularity) when the
    cosine of the pitch angle `p` is zero [i.e., `cos(p) = 0`]. This
    problem (called "gimbal lock") occurs when `p = n π + π / 2`,
    where n is any integer. There are associated precision problems
    (inaccuracies) in the neighborhood of these pitch angles, i.e.,
    when `cos(p) ≈ 0`.)""";

        } CalcRpyDtFromAngularVelocityInParent;

        // drake::math::RollPitchYaw::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/math/roll_pitch_yaw.h:66
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::math::RollPitchYaw::DoesCosPitchAngleViolateGimbalLockTolerance
        struct /* DoesCosPitchAngleViolateGimbalLockTolerance */ {

          // drake/math/roll_pitch_yaw.h:244
          const char* doc =
R"""(Returns true if the pitch-angle `p` is close to gimbal-lock, which
means `cos(p) ≈ 0` or `p ≈ (n*π + π/2)` where `n = 0, ±1, ±2, ...`.
More specifically, returns true if `abs(cos_pitch_angle)` is less than
an internally-defined tolerance of gimbal-lock.

Parameter ``cos_pitch_angle``:
    cosine of the pitch angle, i.e., `cos(p)`.

Note:
    Pitch-angles close to gimbal-lock can can cause problems with
    numerical precision and numerical integration.)""";

        } DoesCosPitchAngleViolateGimbalLockTolerance;

        // drake::math::RollPitchYaw::DoesPitchAngleViolateGimbalLockTolerance
        struct /* DoesPitchAngleViolateGimbalLockTolerance */ {

          // drake/math/roll_pitch_yaw.h:256
          const char* doc =
R"""(Returns true if the pitch-angle `p` is within an internally-defined
tolerance of gimbal-lock. In other words, this method returns true if
`p ≈ (n*π + π/2)` where `n = 0, ±1, ±2, ...`.

Note:
    To improve efficiency when cos(pitch_angle()) is already
    calculated, instead use the function
    DoesCosPitchAngleViolateGimbalLockTolerance().

See also:
    DoesCosPitchAngleViolateGimbalLockTolerance())""";

        } DoesPitchAngleViolateGimbalLockTolerance;

        // drake::math::RollPitchYaw::GimbalLockPitchAngleTolerance
        struct /* GimbalLockPitchAngleTolerance */ {

          // drake/math/roll_pitch_yaw.h:264
          const char* doc =
R"""(Returns the internally-defined allowable closeness (in radians) of the
pitch angle `p` to gimbal-lock, i.e., the allowable proximity of `p`
to `(n*π + π/2)` where `n = 0, ±1, ±2, ...`.)""";

        } GimbalLockPitchAngleTolerance;

        // drake::math::RollPitchYaw::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {

          // drake/math/roll_pitch_yaw.h:213
          const char* doc =
R"""(Compares each element of `this` to the corresponding element of
`other` to check if they are the same to within a specified
`tolerance`.

Parameter ``other``:
    RollPitchYaw to compare to `this`.

Parameter ``tolerance``:
    maximum allowable absolute difference between the matrix elements
    in `this` and `other`.

Returns:
    `true` if `‖this - other‖∞ <= tolerance`.)""";

        } IsNearlyEqualTo;

        // drake::math::RollPitchYaw::IsNearlySameOrientation
        struct /* IsNearlySameOrientation */ {

          // drake/math/roll_pitch_yaw.h:224
          const char* doc =
R"""(Compares each element of the RotationMatrix R1 produced by `this` to
the corresponding element of the RotationMatrix R2 produced by `other`
to check if they are the same to within a specified `tolerance`.

Parameter ``other``:
    RollPitchYaw to compare to `this`.

Parameter ``tolerance``:
    maximum allowable absolute difference between R1, R2.

Returns:
    `true` if `‖R1 - R2‖∞ <= tolerance`.)""";

        } IsNearlySameOrientation;

        // drake::math::RollPitchYaw::IsRollPitchYawInCanonicalRange
        struct /* IsRollPitchYawInCanonicalRange */ {

          // drake/math/roll_pitch_yaw.h:229
          const char* doc =
R"""(Returns true if roll-pitch-yaw angles `[r, p, y]` are in the range `-π
<= r <= π`, `-π/2 <= p <= π/2, `-π <= y <= π`.)""";

        } IsRollPitchYawInCanonicalRange;

        // drake::math::RollPitchYaw::IsValid
        struct /* IsValid */ {

          // drake/math/roll_pitch_yaw.h:271
          const char* doc =
R"""(Returns true if `rpy` contains valid roll, pitch, yaw angles.

Parameter ``rpy``:
    allegedly valid roll, pitch, yaw angles.

Note:
    an angle is invalid if it is NaN or infinite.)""";

        } IsValid;

        // drake::math::RollPitchYaw::RollPitchYaw<T>
        struct /* ctor */ {

          // drake/math/roll_pitch_yaw.h:66
          const char* doc = R"""()""";

          // drake/math/roll_pitch_yaw.h:66
          const char* doc_2 = R"""()""";

          // drake/math/roll_pitch_yaw.h:71
          const char* doc_3 =
R"""(Constructs a RollPitchYaw from a 3x1 array of angles.

Parameter ``rpy``:
    3x1 array with roll, pitch, yaw angles (units of radians).

Throws:
    s std::logic_error in debug builds if !IsValid(rpy).)""";

          // drake/math/roll_pitch_yaw.h:79
          const char* doc_4 =
R"""(Constructs a RollPitchYaw from roll, pitch, yaw angles (radian units).

Parameter ``roll``:
    x-directed angle in SpaceXYZ rotation sequence.

Parameter ``pitch``:
    y-directed angle in SpaceXYZ rotation sequence.

Parameter ``yaw``:
    z-directed angle in SpaceXYZ rotation sequence.

Throws:
    s std::logic_error in debug builds if !IsValid(Vector3<T>(roll,
    pitch, yaw)).)""";

          // drake/math/roll_pitch_yaw.h:89
          const char* doc_5 =
R"""(Uses a RotationMatrix to construct a RollPitchYaw with roll-pitch-yaw
angles `[r, p, y]` in the range `-π <= r <= π`, `-π/2 <= p <= π/2, `-π
<= y <= π`.

Parameter ``R``:
    a RotationMatrix.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.)""";

          // drake/math/roll_pitch_yaw.h:100
          const char* doc_6 =
R"""(Uses a Quaternion to construct a RollPitchYaw with roll-pitch-yaw
angles `[r, p, y]` in the range `-π <= r <= π`, `-π/2 <= p <= π/2, `-π
<= y <= π`.

Parameter ``quaternion``:
    unit Quaternion.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.

Throws:
    s std::logic_error in debug builds if !IsValid(rpy).)""";

        } ctor;

        // drake::math::RollPitchYaw::SetFromQuaternion
        struct /* SetFromQuaternion */ {

          // drake/math/roll_pitch_yaw.h:128
          const char* doc =
R"""(Uses a Quaternion to set `this` RollPitchYaw with roll-pitch-yaw
angles `[r, p, y]` in the range `-π <= r <= π`, `-π/2 <= p <= π/2, `-π
<= y <= π`.

Parameter ``quaternion``:
    unit Quaternion.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.

Throws:
    s std::logic_error in debug builds if !IsValid(rpy).)""";

        } SetFromQuaternion;

        // drake::math::RollPitchYaw::SetFromQuaternionAndRotationMatrix
        struct /* SetFromQuaternionAndRotationMatrix */ {

          // drake/math/roll_pitch_yaw.h:147
          const char* doc =
R"""(Uses a quaternion and its associated rotation matrix `R` to accurately
set `this` @RollPitchYaw roll-pitch-yaw angles (SpaceXYZ Euler
angles), even when the pitch angle is within 1E-6 of π/2 or -π/2.

Parameter ``quaternion``:
    unit quaternion with elements `[e0, e1, e2, e3]`.

Parameter ``R``:
    The RotationMatrix corresponding to `quaternion`.

Returns:
    RollPitchYaw containing angles `[r, p, y]` with range `-π <= r <=
    π`, `-π/2 <= p <= π/2, `-π <= y <= π`.

Throws:
    s std::logic_error in debug builds if rpy fails IsValid(rpy).

Note:
    Aborts in debug builds if `quaternion` does not correspond to `R`.)""";

        } SetFromQuaternionAndRotationMatrix;

        // drake::math::RollPitchYaw::SetFromRotationMatrix
        struct /* SetFromRotationMatrix */ {

          // drake/math/roll_pitch_yaw.h:136
          const char* doc =
R"""(Uses a RotationMatrix to set `this` RollPitchYaw with roll-pitch-yaw
angles `[r, p, y]` in the range `-π <= r <= π`, `-π/2 <= p <= π/2, `-π
<= y <= π`.

Parameter ``R``:
    a RotationMatrix.

Note:
    This new high-accuracy algorithm avoids numerical round-off issues
    encountered by some algorithms when pitch is within 1E-6 of π/2 or
    -π/2.)""";

        } SetFromRotationMatrix;

        // drake::math::RollPitchYaw::ToMatrix3ViaRotationMatrix
        struct /* ToMatrix3ViaRotationMatrix */ {

          // drake/math/roll_pitch_yaw.h:199
          const char* doc =
R"""(Returns the 3x3 matrix representation of the RotationMatrix that
corresponds to `this` RollPitchYaw. This is a convenient "sugar"
method that is exactly equivalent to RotationMatrix(rpy).ToMatrix3().)""";

        } ToMatrix3ViaRotationMatrix;

        // drake::math::RollPitchYaw::ToQuaternion
        struct /* ToQuaternion */ {

          // drake/math/roll_pitch_yaw.h:175
          const char* doc =
R"""(Returns a quaternion representation of `this` RollPitchYaw.)""";

        } ToQuaternion;

        // drake::math::RollPitchYaw::ToRotationMatrix
        struct /* ToRotationMatrix */ {

          // drake/math/roll_pitch_yaw.h:194
          const char* doc =
R"""(Returns the RotationMatrix representation of `this` RollPitchYaw.)""";

        } ToRotationMatrix;

        // drake::math::RollPitchYaw::pitch_angle
        struct /* pitch_angle */ {

          // drake/math/roll_pitch_yaw.h:157
          const char* doc =
R"""(Returns the pitch-angle underlying `this` RollPitchYaw.)""";

        } pitch_angle;

        // drake::math::RollPitchYaw::roll_angle
        struct /* roll_angle */ {

          // drake/math/roll_pitch_yaw.h:154
          const char* doc =
R"""(Returns the roll-angle underlying `this` RollPitchYaw.)""";

        } roll_angle;

        // drake::math::RollPitchYaw::set
        struct /* set */ {

          // drake/math/roll_pitch_yaw.h:107
          const char* doc =
R"""(Sets `this` RollPitchYaw from a 3x1 array of angles.

Parameter ``rpy``:
    3x1 array with roll, pitch, yaw angles (units of radians).

Throws:
    s std::logic_error in debug builds if !IsValid(rpy).)""";

          // drake/math/roll_pitch_yaw.h:117
          const char* doc_2 =
R"""(Sets `this` RollPitchYaw from roll, pitch, yaw angles (units of
radians).

Parameter ``roll``:
    x-directed angle in SpaceXYZ rotation sequence.

Parameter ``pitch``:
    y-directed angle in SpaceXYZ rotation sequence.

Parameter ``yaw``:
    z-directed angle in SpaceXYZ rotation sequence.

Throws:
    s std::logic_error in debug builds if !IsValid(Vector3<T>(roll,
    pitch, yaw)).)""";

        } set;

        // drake::math::RollPitchYaw::set_pitch_angle
        struct /* set_pitch_angle */ {

          // drake/math/roll_pitch_yaw.h:168
          const char* doc =
R"""(Set the pitch-angle underlying `this` RollPitchYaw.

Parameter ``p``:
    pitch angle (in units of radians).)""";

        } set_pitch_angle;

        // drake::math::RollPitchYaw::set_roll_angle
        struct /* set_roll_angle */ {

          // drake/math/roll_pitch_yaw.h:164
          const char* doc =
R"""(Set the roll-angle underlying `this` RollPitchYaw.

Parameter ``r``:
    roll angle (in units of radians).)""";

        } set_roll_angle;

        // drake::math::RollPitchYaw::set_yaw_angle
        struct /* set_yaw_angle */ {

          // drake/math/roll_pitch_yaw.h:172
          const char* doc =
R"""(Set the yaw-angle underlying `this` RollPitchYaw.

Parameter ``y``:
    yaw angle (in units of radians).)""";

        } set_yaw_angle;

        // drake::math::RollPitchYaw::vector
        struct /* vector */ {

          // drake/math/roll_pitch_yaw.h:151
          const char* doc =
R"""(Returns the Vector3 underlying `this` RollPitchYaw.)""";

        } vector;

        // drake::math::RollPitchYaw::yaw_angle
        struct /* yaw_angle */ {

          // drake/math/roll_pitch_yaw.h:160
          const char* doc =
R"""(Returns the yaw-angle underlying `this` RollPitchYaw.)""";

        } yaw_angle;

      } RollPitchYaw;

      // drake::math::RollPitchYawToQuaternion
      struct /* RollPitchYawToQuaternion */ {

        // drake/math/roll_pitch_yaw.h:655
        const char* doc =
R"""((Deprecated), use math::RollPitchYaw(rpy).ToQuaternion().)""";

      } RollPitchYawToQuaternion;

      // drake::math::RotationMatrix
      struct /* RotationMatrix */ {

        // drake/math/roll_pitch_yaw.h:18
        const char* doc =
R"""(This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is `R_AB`. See multibody_quantities for monogram
notation for dynamics. See orientation_discussion "a discussion on
rotation matrices".

Note:
    This class does not store the frames associated with a rotation
    matrix nor does it enforce strict proper usage of this class with
    vectors.

Note:
    When DRAKE_ASSERT_IS_ARMED is defined, several methods in this
    class do a validity check and throw an exception
    (std::logic_error) if the rotation matrix is invalid. When
    DRAKE_ASSERT_IS_ARMED is not defined, many of these validity
    checks are skipped (which helps improve speed). In addition, these
    validity tests are only performed for scalar types for which
    drake::scalar_predicate<T>::is_bool is `true`. For instance,
    validity checks are not performed when T is symbolic::Expression.

Authors:
    s Paul Mitiguy (2018) Original author.

Authors:
    s Drake team (see https://drake.mit.edu/credits).

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

        // drake/math/rotation_matrix.h:52
        const char* doc_2 =
R"""(This class represents a 3x3 rotation matrix between two arbitrary
frames A and B and helps ensure users create valid rotation matrices.
This class relates right-handed orthogonal unit vectors Ax, Ay, Az
fixed in frame A to right-handed orthogonal unit vectors Bx, By, Bz
fixed in frame B. The monogram notation for the rotation matrix
relating A to B is `R_AB`. See multibody_quantities for monogram
notation for dynamics. See orientation_discussion "a discussion on
rotation matrices".

Note:
    This class does not store the frames associated with a rotation
    matrix nor does it enforce strict proper usage of this class with
    vectors.

Note:
    When DRAKE_ASSERT_IS_ARMED is defined, several methods in this
    class do a validity check and throw an exception
    (std::logic_error) if the rotation matrix is invalid. When
    DRAKE_ASSERT_IS_ARMED is not defined, many of these validity
    checks are skipped (which helps improve speed). In addition, these
    validity tests are only performed for scalar types for which
    drake::scalar_predicate<T>::is_bool is `true`. For instance,
    validity checks are not performed when T is symbolic::Expression.

Authors:
    s Paul Mitiguy (2018) Original author.

Authors:
    s Drake team (see https://drake.mit.edu/credits).

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

        // drake::math::RotationMatrix::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/math/rotation_matrix.h:54
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::math::RotationMatrix::GetMaximumAbsoluteDifference
        struct /* GetMaximumAbsoluteDifference */ {

          // drake/math/rotation_matrix.h:387
          const char* doc =
R"""(Computes the infinity norm of `this` - `other` (i.e., the maximum
absolute value of the difference between the elements of `this` and
`other`).

Parameter ``other``:
    RotationMatrix to subtract from `this`.

Returns:
    `‖this - other‖∞`)""";

        } GetMaximumAbsoluteDifference;

        // drake::math::RotationMatrix::GetMeasureOfOrthonormality
        struct /* GetMeasureOfOrthonormality */ {

          // drake/math/rotation_matrix.h:313
          const char* doc =
R"""(Returns how close the matrix R is to to being a 3x3 orthonormal matrix
by computing `‖R ⋅ Rᵀ - I‖∞` (i.e., the maximum absolute value of the
difference between the elements of R ⋅ Rᵀ and the 3x3 identity
matrix).

Parameter ``R``:
    matrix being checked for orthonormality.

Returns:
    `‖R ⋅ Rᵀ - I‖∞`)""";

        } GetMeasureOfOrthonormality;

        // drake::math::RotationMatrix::Identity
        struct /* Identity */ {

          // drake/math/rotation_matrix.h:265
          const char* doc = R"""()""";

        } Identity;

        // drake::math::RotationMatrix::IsExactlyEqualTo
        struct /* IsExactlyEqualTo */ {

          // drake/math/rotation_matrix.h:379
          const char* doc =
R"""(Compares each element of `this` to the corresponding element of
`other` to check if they are exactly the same.

Parameter ``other``:
    RotationMatrix to compare to `this`.

Returns:
    true if each element of `this` is exactly equal to the
    corresponding element in `other`.)""";

        } IsExactlyEqualTo;

        // drake::math::RotationMatrix::IsExactlyIdentity
        struct /* IsExactlyIdentity */ {

          // drake/math/rotation_matrix.h:352
          const char* doc =
R"""(Returns `true` if `this` is exactly equal to the identity matrix.)""";

        } IsExactlyIdentity;

        // drake::math::RotationMatrix::IsIdentityToInternalTolerance
        struct /* IsIdentityToInternalTolerance */ {

          // drake/math/rotation_matrix.h:358
          const char* doc =
R"""(Returns true if `this` is equal to the identity matrix to within the
threshold of get_internal_tolerance_for_orthonormality().)""";

        } IsIdentityToInternalTolerance;

        // drake::math::RotationMatrix::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {

          // drake/math/rotation_matrix.h:369
          const char* doc =
R"""(Compares each element of `this` to the corresponding element of
`other` to check if they are the same to within a specified
`tolerance`.

Parameter ``other``:
    RotationMatrix to compare to `this`.

Parameter ``tolerance``:
    maximum allowable absolute difference between the matrix elements
    in `this` and `other`.

Returns:
    `true` if `‖this - other‖∞ <= tolerance`.)""";

        } IsNearlyEqualTo;

        // drake::math::RotationMatrix::IsOrthonormal
        struct /* IsOrthonormal */ {

          // drake/math/rotation_matrix.h:324
          const char* doc =
R"""(Tests if a generic Matrix3 has orthonormal vectors to within the
threshold specified by `tolerance`.

Parameter ``R``:
    an allegedly orthonormal rotation matrix.

Parameter ``tolerance``:
    maximum allowable absolute difference between R * Rᵀ and the
    identity matrix I, i.e., checks if `‖R ⋅ Rᵀ - I‖∞ <= tolerance`.

Returns:
    `true` if R is an orthonormal matrix.)""";

        } IsOrthonormal;

        // drake::math::RotationMatrix::IsValid
        struct /* IsValid */ {

          // drake/math/rotation_matrix.h:334
          const char* doc =
R"""(Tests if a generic Matrix3 seems to be a proper orthonormal rotation
matrix to within the threshold specified by `tolerance`.

Parameter ``R``:
    an allegedly valid rotation matrix.

Parameter ``tolerance``:
    maximum allowable absolute difference of `R * Rᵀ` and the identity
    matrix I (i.e., checks if `‖R ⋅ Rᵀ - I‖∞ <= tolerance`).

Returns:
    `true` if R is a valid rotation matrix.)""";

          // drake/math/rotation_matrix.h:342
          const char* doc_2 =
R"""(Tests if a generic Matrix3 is a proper orthonormal rotation matrix to
within the threshold of get_internal_tolerance_for_orthonormality().

Parameter ``R``:
    an allegedly valid rotation matrix.

Returns:
    `true` if R is a valid rotation matrix.)""";

          // drake/math/rotation_matrix.h:349
          const char* doc_3 =
R"""(Tests if `this` rotation matrix R is a proper orthonormal rotation
matrix to within the threshold of
get_internal_tolerance_for_orthonormality().

Returns:
    `true` if `this` is a valid rotation matrix.)""";

        } IsValid;

        // drake::math::RotationMatrix::MakeXRotation
        struct /* MakeXRotation */ {

          // drake/math/rotation_matrix.h:173
          const char* doc =
R"""(Makes the RotationMatrix `R_AB` associated with rotating a frame B
relative to a frame A by an angle `theta` about unit vector `Ax = Bx`.

Parameter ``theta``:
    radian measure of rotation angle about Ax.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitX().

Note:
    `R_AB` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, `Bx = Ax`, `By = Ay`, `Bz = Az`, then B
    undergoes a right-handed rotation relative to A by an angle
    `theta` about `Ax = Bx`.

```
⎡ 1       0                 0  ⎤
R_AB = ⎢ 0   cos(theta)   -sin(theta) ⎥
       ⎣ 0   sin(theta)    cos(theta) ⎦
```)""";

        } MakeXRotation;

        // drake::math::RotationMatrix::MakeYRotation
        struct /* MakeYRotation */ {

          // drake/math/rotation_matrix.h:198
          const char* doc =
R"""(Makes the RotationMatrix `R_AB` associated with rotating a frame B
relative to a frame A by an angle `theta` about unit vector `Ay = By`.

Parameter ``theta``:
    radian measure of rotation angle about Ay.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitY().

Note:
    `R_AB` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, `Bx = Ax`, `By = Ay`, `Bz = Az`, then B
    undergoes a right-handed rotation relative to A by an angle
    `theta` about `Ay = By`.

```
⎡  cos(theta)   0   sin(theta) ⎤
R_AB = ⎢          0    1           0  ⎥
       ⎣ -sin(theta)   0   cos(theta) ⎦
```)""";

        } MakeYRotation;

        // drake::math::RotationMatrix::MakeZRotation
        struct /* MakeZRotation */ {

          // drake/math/rotation_matrix.h:223
          const char* doc =
R"""(Makes the RotationMatrix `R_AB` associated with rotating a frame B
relative to a frame A by an angle `theta` about unit vector `Az = Bz`.

Parameter ``theta``:
    radian measure of rotation angle about Az.

Note:
    Orientation is same as Eigen::AngleAxis<T>(theta,
    Vector3d::UnitZ().

Note:
    `R_AB` relates two frames A and B having unit vectors Ax, Ay, Az
    and Bx, By, Bz. Initially, `Bx = Ax`, `By = Ay`, `Bz = Az`, then B
    undergoes a right-handed rotation relative to A by an angle
    `theta` about `Az = Bz`.

```
⎡ cos(theta)  -sin(theta)   0 ⎤
R_AB = ⎢ sin(theta)   cos(theta)   0 ⎥
       ⎣         0            0    1 ⎦
```)""";

        } MakeZRotation;

        // drake::math::RotationMatrix::ProjectToRotationMatrix
        struct /* ProjectToRotationMatrix */ {

          // drake/math/rotation_matrix.h:425
          const char* doc = R"""()""";

        } ProjectToRotationMatrix;

        // drake::math::RotationMatrix::RotationMatrix<T>
        struct /* ctor */ {

          // drake/math/rotation_matrix.h:54
          const char* doc = R"""()""";

          // drake/math/rotation_matrix.h:54
          const char* doc_2 = R"""()""";

          // drake/math/rotation_matrix.h:58
          const char* doc_3 =
R"""(Constructs a 3x3 identity RotationMatrix -- which corresponds to
aligning two frames (so that unit vectors Ax = Bx, Ay = By, Az = Bz).)""";

          // drake/math/rotation_matrix.h:63
          const char* doc_4 =
R"""(Constructs a RotationMatrix from a Matrix3.

Parameter ``R``:
    an allegedly valid rotation matrix.

Throws:
    s std::logic_error in debug builds if R fails IsValid(R).)""";

          // drake/math/rotation_matrix.h:76
          const char* doc_5 =
R"""(Constructs a RotationMatrix from an Eigen::Quaternion.

Parameter ``quaternion``:
    a non-zero, finite quaternion which may or may not have unit
    length [i.e., `quaternion.norm()` does not have to be 1].

Throws:
    s std::logic_error in debug builds if the rotation matrix R that
    is built from `quaternion` fails IsValid(R). For example, an
    exception is thrown if `quaternion` is zero or contains a NaN or
    infinity.

Note:
    This method has the effect of normalizing its `quaternion`
    argument, without the inefficiency of the square-root associated
    with normalization.)""";

          // drake/math/rotation_matrix.h:100
          const char* doc_6 = R"""()""";

          // drake/math/rotation_matrix.h:138
          const char* doc_7 =
R"""(Constructs a RotationMatrix from an RollPitchYaw. In other words,
makes the RotationMatrix for a Space-fixed (extrinsic) X-Y-Z rotation
by "roll-pitch-yaw" angles `[r, p, y]`, which is equivalent to a Body-
fixed (intrinsic) Z-Y-X rotation by "yaw-pitch-roll" angles `[y, p,
r]`.

Parameter ``rpy``:
    radian measures of three angles [roll, pitch, yaw].

Parameter ``rpy``:
    a RollPitchYaw which is a Space-fixed (extrinsic) X-Y-Z rotation
    with "roll-pitch-yaw" angles `[r, p, y]` or equivalently a Body-
    fixed (intrinsic) Z-Y-X rotation with "yaw-pitch-roll" angles `[y,
    p, r]`.

Note:
    Denoting roll `r`, pitch `p`, yaw `y`, this method returns a
    rotation matrix `R_AD` equal to the matrix multiplication shown
    below.

```
⎡cos(y) -sin(y)  0⎤   ⎡ cos(p)  0  sin(p)⎤   ⎡1      0        0 ⎤
R_AD = ⎢sin(y)  cos(y)  0⎥ * ⎢     0   1      0 ⎥ * ⎢0  cos(r)  -sin(r)⎥
       ⎣    0       0   1⎦   ⎣-sin(p)  0  cos(p)⎦   ⎣0  sin(r)   cos(r)⎦
     =       R_AB          *        R_BC          *        R_CD
```

Note: In this discussion, A is the Space frame and D is the Body
frame. One way to visualize this rotation sequence is by introducing
intermediate frames B and C (useful constructs to understand this
rotation sequence). Initially, the frames are aligned so `Di = Ci = Bi
= Ai (i = x, y, z)`. Then D is subjected to successive right-handed
rotations relative to A. @li 1st rotation R_CD: Frame D rotates
relative to frames C, B, A by a roll angle `r` about `Dx = Cx`. Note:
D and C are no longer aligned. @li 2nd rotation R_BC: Frames D, C
(collectively -- as if welded together) rotate relative to frame B, A
by a pitch angle `p` about `Cy = By`. Note: C and B are no longer
aligned. @li 3rd rotation R_AB: Frames D, C, B (collectively -- as if
welded) rotate relative to frame A by a roll angle `y` about `Bz =
Az`. Note: B and A are no longer aligned. TODO(@mitiguy) Add
Sherm/Goldstein's way to visualize rotation sequences.)""";

        } ctor;

        // drake::math::RotationMatrix::ToAngleAxis
        struct /* ToAngleAxis */ {

          // drake/math/rotation_matrix.h:530
          const char* doc =
R"""(Returns an AngleAxis `theta_lambda` containing an angle `theta` and
unit vector (axis direction) `lambda` that represents `this`
RotationMatrix.

Note:
    The orientation and RotationMatrix associated with `theta *
    lambda` is identical to that of `(-theta) * (-lambda)`. The
    AngleAxis returned by this method chooses to have `0 <= theta <=
    pi`.

Returns:
    an AngleAxis with `0 <= theta <= pi` and a unit vector `lambda`.)""";

        } ToAngleAxis;

        // drake::math::RotationMatrix::ToQuaternion
        struct /* ToQuaternion */ {

          // drake/math/rotation_matrix.h:447
          const char* doc = R"""()""";

          // drake/math/rotation_matrix.h:459
          const char* doc_2 = R"""()""";

        } ToQuaternion;

        // drake::math::RotationMatrix::ToQuaternionAsVector4
        struct /* ToQuaternionAsVector4 */ {

          // drake/math/rotation_matrix.h:512
          const char* doc =
R"""(Utility method to return the Vector4 associated with ToQuaternion().

See also:
    ToQuaternion().)""";

          // drake/math/rotation_matrix.h:519
          const char* doc_2 =
R"""(Utility method to return the Vector4 associated with ToQuaternion(M).

Parameter ``M``:
    3x3 matrix to be made into a quaternion.

See also:
    ToQuaternion().)""";

        } ToQuaternionAsVector4;

        // drake::math::RotationMatrix::cast
        struct /* cast */ {

          // drake/math/rotation_matrix.h:250
          const char* doc =
R"""(Creates a RotationMatrix templatized on a scalar type U from a
RotationMatrix templatized on scalar type T. For example,

```
RotationMatrix<double> source = RotationMatrix<double>::Identity();
RotationMatrix<AutoDiffXd> foo = source.cast<AutoDiffXd>();
```

Template parameter ``U``:
    Scalar type on which the returned RotationMatrix is templated.

Note:
    `RotationMatrix<From>::cast<To>()` creates a new
    `RotationMatrix<To>` from a `RotationMatrix<From>` but only if
    type `To` is constructible from type `From`. This cast method
    works in accordance with Eigen's cast method for Eigen's Matrix3
    that underlies this RotationMatrix. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";

        } cast;

        // drake::math::RotationMatrix::get_internal_tolerance_for_orthonormality
        struct /* get_internal_tolerance_for_orthonormality */ {

          // drake/math/rotation_matrix.h:438
          const char* doc =
R"""(Returns an internal tolerance that checks rotation matrix
orthonormality.

Returns:
    internal tolerance (small multiplier of double-precision epsilon)
    used to check whether or not a rotation matrix is orthonormal.

Note:
    The tolerance is chosen by developers to ensure a reasonably valid
    (orthonormal) rotation matrix.

Note:
    To orthonormalize a 3x3 matrix, use ProjectToRotationMatrix().)""";

        } get_internal_tolerance_for_orthonormality;

        // drake::math::RotationMatrix::inverse
        struct /* inverse */ {

          // drake/math/rotation_matrix.h:273
          const char* doc = R"""()""";

        } inverse;

        // drake::math::RotationMatrix::matrix
        struct /* matrix */ {

          // drake/math/rotation_matrix.h:278
          const char* doc =
R"""(Returns the Matrix3 underlying a RotationMatrix.)""";

        } matrix;

        // drake::math::RotationMatrix::operator*
        struct /* operator_mul */ {

          // drake/math/rotation_matrix.h:297
          const char* doc =
R"""(Calculates `this` rotation matrix `R_AB` multiplied by `other`
rotation matrix `R_BC`, returning the composition `R_AB * R_BC`.

Parameter ``other``:
    RotationMatrix that post-multiplies `this`.

Returns:
    rotation matrix that results from `this` multiplied by `other`.

Note:
    It is possible (albeit improbable) to create an invalid rotation
    matrix by accumulating round-off error with a large number of
    multiplies.)""";

          // drake/math/rotation_matrix.h:304
          const char* doc_2 =
R"""(Calculates `this` rotation matrix R multiplied by an arbitrary
Vector3.

Parameter ``v``:
    3x1 vector that post-multiplies `this`.

Returns:
    3x1 vector that results from `R * v`.)""";

        } operator_mul;

        // drake::math::RotationMatrix::operator*=
        struct /* operator_imul */ {

          // drake/math/rotation_matrix.h:286
          const char* doc =
R"""(In-place multiply of `this` rotation matrix `R_AB` by `other` rotation
matrix `R_BC`. On return, `this` is set to equal `R_AB * R_BC`.

Parameter ``other``:
    RotationMatrix that post-multiplies `this`.

Returns:
    `this` rotation matrix which has been multiplied by `other`.

Note:
    It is possible (albeit improbable) to create an invalid rotation
    matrix by accumulating round-off error with a large number of
    multiplies.)""";

        } operator_imul;

        // drake::math::RotationMatrix::set
        struct /* set */ {

          // drake/math/rotation_matrix.h:258
          const char* doc =
R"""(Sets `this` RotationMatrix from a Matrix3.

Parameter ``R``:
    an allegedly valid rotation matrix.

Throws:
    s std::logic_error in debug builds if R fails IsValid(R).)""";

        } set;

      } RotationMatrix;

      // drake::math::Slerp
      struct /* Slerp */ {

        // drake/math/quaternion.h:148
        const char* doc =
R"""(Q = Slerp(q1, q2, f) Spherical linear interpolation between two
quaternions This function uses the implementation given in Algorithm 8
of [1].

Parameter ``q1``:
    Initial quaternion (w, x, y, z)

Parameter ``q2``:
    Final quaternion (w, x, y, z)

Parameter ``interpolation_parameter``:
    between 0 and 1 (inclusive)

Returns ``Q``:
    Interpolated quaternion(s). 4-by-1 vector.

[1] Kuffner, J.J., "Effective sampling and distance metrics for 3D
rigid body path planning," Robotics and Automation, 2004. Proceedings.
ICRA '04. 2004 IEEE International Conference on , vol.4, no., pp.3993,
3998 Vol.4, April 26-May 1, 2004 doi: 10.1109/ROBOT.2004.1308895)""";

      } Slerp;

      // drake::math::SparseMatrixToRowColumnValueVectors
      struct /* SparseMatrixToRowColumnValueVectors */ {

        // drake/math/eigen_sparse_triplet.h:61
        const char* doc =
R"""(For a sparse matrix, return the row indices, the column indices, and
value of the non-zero entries. For example, the matrix <!-- mat = [1 0
2; [0 3 4] has row = [0 1 0 1] col = [0 1 2 2] val = [1 3 2 4] --> \f[
mat = \begin{bmatrix} 1 & 0 & 2\\ 0 & 3 & 4\end{bmatrix} \f] has \f[
row = \begin{bmatrix} 0 & 1 & 0 & 1\end{bmatrix}\\ col =
\begin{bmatrix} 0 & 1 & 2 & 2\end{bmatrix}\\ val = \begin{bmatrix} 1 &
3 & 2 & 4\end{bmatrix} \f]

Parameter ``matrix``:
    the input sparse matrix

Parameter ``row_indices``:
    a vector containing the row indices of the non-zero entries

Parameter ``col_indices``:
    a vector containing the column indices of the non-zero entries

Parameter ``val``:
    a vector containing the values of the non-zero entries.)""";

      } SparseMatrixToRowColumnValueVectors;

      // drake::math::SparseMatrixToTriplets
      struct /* SparseMatrixToTriplets */ {

        // drake/math/eigen_sparse_triplet.h:18
        const char* doc =
R"""(For a sparse matrix, return a vector of triplets, such that we can
reconstruct the matrix using setFromTriplet function

Parameter ``matrix``:
    A sparse matrix

Returns:
    A triplet with the row, column and value of the non-zero entries.
    See https://eigen.tuxfamily.org/dox/group__TutorialSparse.html for
    more information on the triplet)""";

      } SparseMatrixToTriplets;

      // drake::math::ToSymmetricMatrixFromLowerTriangularColumns
      struct /* ToSymmetricMatrixFromLowerTriangularColumns */ {

        // drake/math/matrix_util.h:89
        const char* doc =
R"""(Given a column vector containing the stacked columns of the lower
triangular part of a square matrix, returning a symmetric matrix whose
lower triangular part is the same as the original matrix.)""";

        // drake/math/matrix_util.h:109
        const char* doc_2 =
R"""(Given a column vector containing the stacked columns of the lower
triangular part of a square matrix, returning a symmetric matrix whose
lower triangular part is the same as the original matrix.

Template parameter ``rows``:
    The number of rows in the symmetric matrix.)""";

      } ToSymmetricMatrixFromLowerTriangularColumns;

      // drake::math::UniformPtsOnSphereFibonacci
      struct /* UniformPtsOnSphereFibonacci */ {

        // drake/math/evenly_distributed_pts_on_sphere.h:17
        const char* doc =
R"""(Deterministically generates approximate evenly distributed points on a
unit sphere. This method uses Fibonacci number. For the detailed math,
please refer to http://stackoverflow.com/questions/9600801/evenly-
distributing-n-points-on-a-sphere This algorithm generates the points
in O(n) time, where `n` is the number of points.

Parameter ``num_points``:
    The number of points we want on the unit sphere.

Returns:
    The generated points. @pre num_samples >= 1. Throw
    std::runtime_error if num_points < 1)""";

      } UniformPtsOnSphereFibonacci;

      // drake::math::UniformlyRandomAngleAxis
      struct /* UniformlyRandomAngleAxis */ {

        // drake/math/random_rotation.h:24
        const char* doc =
R"""(Generates a rotation (in the axis-angle representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere.

Justification for the algorithm can be found in, e.g.: Mervin E.
Muller. 1959. A note on a method for generating points uniformly on
n-dimensional spheres. Commun. ACM 2, 4 (April 1959), 19-20.
DOI=http://dx.doi.org/10.1145/377939.377946)""";

      } UniformlyRandomAngleAxis;

      // drake::math::UniformlyRandomQuaternion
      struct /* UniformlyRandomQuaternion */ {

        // drake/math/random_rotation.h:40
        const char* doc =
R"""(Generates a rotation (in the quaternion representation) that rotates a
point on the unit sphere to another point on the unit sphere with a
uniform distribution over the sphere.)""";

      } UniformlyRandomQuaternion;

      // drake::math::UniformlyRandomRPY
      struct /* UniformlyRandomRPY */ {

        // drake/math/random_rotation.h:60
        const char* doc =
R"""(Generates a rotation (in the roll-pitch-yaw representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.)""";

      } UniformlyRandomRPY;

      // drake::math::UniformlyRandomRotationMatrix
      struct /* UniformlyRandomRotationMatrix */ {

        // drake/math/random_rotation.h:50
        const char* doc =
R"""(Generates a rotation (in the rotation matrix representation) that
rotates a point on the unit sphere to another point on the unit sphere
with a uniform distribution over the sphere.)""";

      } UniformlyRandomRotationMatrix;

      // drake::math::VectorToSkewSymmetric
      struct /* VectorToSkewSymmetric */ {

        // drake/math/cross_product.h:11
        const char* doc = R"""()""";

      } VectorToSkewSymmetric;

      // drake::math::XRotation
      struct /* XRotation */ {

        // drake/math/rotation_matrix.h:869
        const char* doc =
R"""((Deprecated), use math::RotationMatrix::MakeXRotation().)""";

      } XRotation;

      // drake::math::YRotation
      struct /* YRotation */ {

        // drake/math/rotation_matrix.h:878
        const char* doc =
R"""((Deprecated), use math::RotationMatrix::MakeYRotation().)""";

      } YRotation;

      // drake::math::ZRotation
      struct /* ZRotation */ {

        // drake/math/rotation_matrix.h:887
        const char* doc =
R"""((Deprecated), use math::RotationMatrix::MakeZRotation().)""";

      } ZRotation;

      // drake::math::autoDiffToGradientMatrix
      struct /* autoDiffToGradientMatrix */ {

        // drake/math/autodiff_gradient.h:28
        const char* doc = R"""()""";

      } autoDiffToGradientMatrix;

      // drake::math::autoDiffToValueMatrix
      struct /* autoDiffToValueMatrix */ {

        // drake/math/autodiff.h:27
        const char* doc = R"""()""";

      } autoDiffToValueMatrix;

      // drake::math::closestExpmap
      struct /* closestExpmap */ {

        // drake/math/expmap.h:94
        const char* doc = R"""()""";

      } closestExpmap;

      // drake::math::dquat2rotmat
      struct /* dquat2rotmat */ {

        // drake/math/rotation_conversion_gradient.h:21
        const char* doc =
R"""(Computes the gradient of the function that converts a unit length
quaternion to a rotation matrix.

Parameter ``quaternion``:
    A unit length quaternion [w;x;y;z]

Returns:
    The gradient)""";

      } dquat2rotmat;

      // drake::math::drotmat2quat
      struct /* drotmat2quat */ {

        // drake/math/rotation_conversion_gradient.h:120
        const char* doc =
R"""(Computes the gradient of the function that converts rotation matrix to
quaternion.

Parameter ``R``:
    A 3 x 3 rotation matrix

Parameter ``dR``:
    A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x_var(j)

Returns:
    The gradient G. G is a 4 x N matrix G(0,j) is the gradient of w
    w.r.t x_var(j) G(1,j) is the gradient of x w.r.t x_var(j) G(2,j)
    is the gradient of y w.r.t x_var(j) G(3,j) is the gradient of z
    w.r.t x_var(j))""";

      } drotmat2quat;

      // drake::math::drotmat2rpy
      struct /* drotmat2rpy */ {

        // drake/math/rotation_conversion_gradient.h:58
        const char* doc =
R"""(Computes the gradient of the function that converts a rotation matrix
to body-fixed z-y'-x'' Euler angles.

Parameter ``R``:
    A 3 x 3 rotation matrix

Parameter ``dR``:
    A 9 x N matrix, dR(i,j) is the gradient of R(i) w.r.t x(j)

Returns:
    The gradient G. G is a 3 x N matrix. G(0,j) is the gradient of
    roll w.r.t x(j) G(1,j) is the gradient of pitch w.r.t x(j) G(2,j)
    is the gradient of yaw w.r.t x(j))""";

      } drotmat2rpy;

      // drake::math::expmap2quat
      struct /* expmap2quat */ {

        // drake/math/expmap.h:63
        const char* doc = R"""()""";

      } expmap2quat;

      // drake::math::getSubMatrixGradient
      struct /* getSubMatrixGradient */ {

        // drake/math/gradient_util.h:171
        const char* doc = R"""()""";

        // drake/math/gradient_util.h:195
        const char* doc_2 = R"""()""";

        // drake/math/gradient_util.h:220
        const char* doc_3 = R"""()""";

      } getSubMatrixGradient;

      // drake::math::gradientMatrixToAutoDiff
      struct /* gradientMatrixToAutoDiff */ {

        // drake/math/autodiff_gradient.h:126
        const char* doc = R"""()""";

      } gradientMatrixToAutoDiff;

      // drake::math::hessian
      struct /* hessian */ {

        // drake/math/jacobian.h:163
        const char* doc =
R"""(Computes a matrix of AutoDiffScalars from which the value, Jacobian,
and Hessian of a function @f[ f:\mathbb{R}^{n\times
m}\rightarrow\mathbb{R}^{p\times q} @f] (f: R^n*m -> R^p*q) can be
extracted.

The output is a matrix of nested AutoDiffScalars, being the result of
calling ::jacobian on a function that returns the output of
::jacobian, called on ``f``.

``MaxChunkSizeOuter`` and ``MaxChunkSizeInner`` can be used to control
chunk sizes (see ::jacobian).

See ::jacobian for requirements on the function ``f`` and the argument
``x``.

Parameter ``f``:
    function

Parameter ``x``:
    function argument value at which Hessian will be evaluated

Returns:
    AutoDiffScalar matrix corresponding to the Hessian of f evaluated
    at x)""";

      } hessian;

      // drake::math::initializeAutoDiff
      struct /* initializeAutoDiff */ {

        // drake/math/autodiff.h:112
        const char* doc =
R"""(Initialize a single autodiff matrix given the corresponding value
matrix.

Set the values of ``auto_diff_matrix`` to be equal to ``val``, and for
each element i of ``auto_diff_matrix``, resize the derivatives vector
to ``num_derivatives``, and set derivative number ``deriv_num_start``
+ i to one (all other elements of the derivative vector set to zero).

Parameter ``mat``:
    'regular' matrix of values

Parameter ``ret``:
    AutoDiff matrix

Parameter ``num_derivatives``:
    the size of the derivatives vector @default the size of mat

Parameter ``deriv_num_start``:
    starting index into derivative vector (i.e. element
    deriv_num_start in derivative vector corresponds to mat(0, 0)).
    @default 0)""";

        // drake/math/autodiff.h:161
        const char* doc_2 =
R"""(Initialize a single autodiff matrix given the corresponding value
matrix.

Create autodiff matrix that matches ``mat`` in size with derivatives
of compile time size ``Nq`` and runtime size ``num_derivatives``. Set
its values to be equal to ``val``, and for each element i of
``auto_diff_matrix``, set derivative number ``deriv_num_start`` + i to
one (all other derivatives set to zero).

Parameter ``mat``:
    'regular' matrix of values

Parameter ``num_derivatives``:
    the size of the derivatives vector @default the size of mat

Parameter ``deriv_num_start``:
    starting index into derivative vector (i.e. element
    deriv_num_start in derivative vector corresponds to mat(0, 0)).
    @default 0

Returns:
    AutoDiff matrix)""";

      } initializeAutoDiff;

      // drake::math::initializeAutoDiffGivenGradientMatrix
      struct /* initializeAutoDiffGivenGradientMatrix */ {

        // drake/math/autodiff_gradient.h:74
        const char* doc =
R"""(Initializes an autodiff matrix given a matrix of values and gradient
matrix

Parameter ``val``:
    value matrix

Parameter ``gradient``:
    gradient matrix; the derivatives of val(j) are stored in row j of
    the gradient matrix.

Parameter ``autodiff_matrix``:
    matrix of AutoDiffScalars with the same size as ``val``)""";

        // drake/math/autodiff_gradient.h:116
        const char* doc_2 =
R"""(Creates and initializes an autodiff matrix given a matrix of values
and gradient matrix

Parameter ``val``:
    value matrix

Parameter ``gradient``:
    gradient matrix; the derivatives of val(j) are stored in row j of
    the gradient matrix.

Returns:
    autodiff_matrix matrix of AutoDiffScalars with the same size as
    ``val``)""";

      } initializeAutoDiffGivenGradientMatrix;

      // drake::math::initializeAutoDiffTuple
      struct /* initializeAutoDiffTuple */ {

        // drake/math/autodiff.h:318
        const char* doc =
R"""(Given a series of Eigen matrices, create a tuple of corresponding
AutoDiff matrices with values equal to the input matrices and properly
initialized derivative vectors.

The size of the derivative vector of each element of the matrices in
the output tuple will be the same, and will equal the sum of the
number of elements of the matrices in ``args``. If all of the matrices
in ``args`` have fixed size, then the derivative vectors will also
have fixed size (being the sum of the sizes at compile time of all of
the input arguments), otherwise the derivative vectors will have
dynamic size. The 0th element of the derivative vectors will
correspond to the derivative with respect to the 0th element of the
first argument. Subsequent derivative vector elements correspond first
to subsequent elements of the first input argument (traversed first by
row, then by column), and so on for subsequent arguments.

Parameter ``args``:
    a series of Eigen matrices

Returns:
    a tuple of properly initialized AutoDiff matrices corresponding to
    ``args``)""";

      } initializeAutoDiffTuple;

      // drake::math::intRange
      struct /* intRange */ {

        // drake/math/gradient_util.h:16
        const char* doc = R"""()""";

      } intRange;

      // drake::math::is_quaternion_in_canonical_form
      struct /* is_quaternion_in_canonical_form */ {

        // drake/math/quaternion.h:214
        const char* doc =
R"""(This function tests whether a quaternion is in "canonical form"
meaning that it tests whether the quaternion [w, x, y, z] has a non-
negative w value. Example: [-0.3, +0.4, +0.5, +0.707] is not in
canonical form. Example: [+0.3, -0.4, -0.5, -0.707] is in canonical
form.

Parameter ``quat``:
    Quaternion [w, x, y, z] that relates two right-handed orthogonal
    unitary bases e.g., Ax, Ay, Az (A) to Bx, By, Bz (B). Note: quat
    is analogous to the rotation matrix R_AB.

Returns:
    `true` if quat.w() is nonnegative (in canonical form), else
    `false`.)""";

      } is_quaternion_in_canonical_form;

      // drake::math::jacobian
      struct /* jacobian */ {

        // drake/math/jacobian.h:57
        const char* doc =
R"""(Computes a matrix of AutoDiffScalars from which both the value and the
Jacobian of a function @f[ f:\mathbb{R}^{n\times
m}\rightarrow\mathbb{R}^{p\times q} @f] (f: R^n*m -> R^p*q) can be
extracted.

The derivative vector for each AutoDiffScalar in the output contains
the derivatives with respect to all components of the argument $ x $.

The return type of this function is a matrix with the `best' possible
AutoDiffScalar scalar type, in the following sense: - If the number of
derivatives can be determined at compile time, the AutoDiffScalar
derivative vector will have that fixed size. - If the maximum number
of derivatives can be determined at compile time, the AutoDiffScalar
derivative vector will have that maximum fixed size. - If neither the
number, nor the maximum number of derivatives can be determined at
compile time, the output AutoDiffScalar derivative vector will be
dynamically sized.

``f`` should have a templated call operator that maps an Eigen matrix
argument to another Eigen matrix. The scalar type of the output of $ f
$ need not match the scalar type of the input (useful in recursive
calls to the function to determine higher order derivatives). The
easiest way to create an ``f`` is using a C++14 generic lambda.

The algorithm computes the Jacobian in chunks of up to
``MaxChunkSize`` derivatives at a time. This has three purposes: - It
makes it so that derivative vectors can be allocated on the stack,
eliminating dynamic allocations and improving performance if the
maximum number of derivatives cannot be determined at compile time. -
It gives control over, and limits the number of required
instantiations of the call operator of f and all the functions it
calls. - Excessively large derivative vectors can result in CPU
capacity cache misses; even if the number of derivatives is fixed at
compile time, it may be better to break up into chunks if that means
that capacity cache misses can be prevented.

Parameter ``f``:
    function

Parameter ``x``:
    function argument value at which Jacobian will be evaluated

Returns:
    AutoDiffScalar matrix corresponding to the Jacobian of f evaluated
    at x.)""";

      } jacobian;

      // drake::math::matGradMult
      struct /* matGradMult */ {

        // drake/math/gradient_util.h:137
        const char* doc = R"""()""";

      } matGradMult;

      // drake::math::matGradMultMat
      struct /* matGradMultMat */ {

        // drake/math/gradient_util.h:100
        const char* doc = R"""()""";

      } matGradMultMat;

      // drake::math::quat2eigenQuaternion
      struct /* quat2eigenQuaternion */ {

        // drake/math/quaternion.h:34
        const char* doc = R"""()""";

      } quat2eigenQuaternion;

      // drake::math::quat2expmap
      struct /* quat2expmap */ {

        // drake/math/expmap.h:76
        const char* doc = R"""()""";

      } quat2expmap;

      // drake::math::quat2expmapSequence
      struct /* quat2expmapSequence */ {

        // drake/math/expmap.h:143
        const char* doc = R"""()""";

      } quat2expmapSequence;

      // drake::math::quat2rotmat
      struct /* quat2rotmat */ {

        // drake/math/quaternion.h:196
        const char* doc =
R"""(Computes the rotation matrix from quaternion representation.

Template parameter ``Derived``:
    An Eigen derived type, e.g., an Eigen Vector3d.

Parameter ``quaternion``:
    4 x 1 unit length quaternion, ``q``=[w;x;y;z]

Returns:
    3 x 3 rotation matrix (Deprecated), use
    math::RotationMatrix(quaternion).)""";

      } quat2rotmat;

      // drake::math::quatConjugate
      struct /* quatConjugate */ {

        // drake/math/quaternion.h:54
        const char* doc = R"""()""";

      } quatConjugate;

      // drake::math::quatDiff
      struct /* quatDiff */ {

        // drake/math/quaternion.h:103
        const char* doc = R"""()""";

      } quatDiff;

      // drake::math::quatDiffAxisInvar
      struct /* quatDiffAxisInvar */ {

        // drake/math/quaternion.h:112
        const char* doc = R"""()""";

      } quatDiffAxisInvar;

      // drake::math::quatNorm
      struct /* quatNorm */ {

        // drake/math/quaternion.h:125
        const char* doc = R"""()""";

      } quatNorm;

      // drake::math::quatProduct
      struct /* quatProduct */ {

        // drake/math/quaternion.h:65
        const char* doc = R"""()""";

      } quatProduct;

      // drake::math::quatRotateVec
      struct /* quatRotateVec */ {

        // drake/math/quaternion.h:85
        const char* doc = R"""()""";

      } quatRotateVec;

      // drake::math::resizeDerivativesToMatchScalar
      struct /* resizeDerivativesToMatchScalar */ {

        // drake/math/autodiff.h:210
        const char* doc =
R"""(Resize derivatives vector of each element of a matrix to to match the
size of the derivatives vector of a given scalar. If the mat and
scalar inputs are AutoDiffScalars, resize the derivatives vector of
each element of the matrix mat to match the number of derivatives of
the scalar. This is useful in functions that return matrices that do
not depend on an AutoDiffScalar argument (e.g. a function with a
constant output), while it is desired that information about the
number of derivatives is preserved.

Parameter ``mat``:
    matrix, for which the derivative vectors of the elements will be
    resized

Parameter ``scalar``:
    scalar to match the derivative size vector against.)""";

      } resizeDerivativesToMatchScalar;

      // drake::math::rpy2quat
      struct /* rpy2quat */ {

        // drake/math/roll_pitch_yaw.h:668
        const char* doc =
R"""((Deprecated), use math::RollPitchYaw(rpy).ToQuaternion().)""";

      } rpy2quat;

      // drake::math::rpy2rotmat
      struct /* rpy2rotmat */ {

        // drake/math/rotation_matrix.h:819
        const char* doc = R"""()""";

      } rpy2rotmat;

      // drake::math::saturate
      struct /* saturate */ {

        // drake/math/saturate.h:14
        const char* doc =
R"""(Saturates the input `value` between upper and lower bounds. If `value`
is within `[low, high]` then return it; else return the boundary.)""";

      } saturate;

      // drake::math::setSubMatrixGradient
      struct /* setSubMatrixGradient */ {

        // drake/math/gradient_util.h:233
        const char* doc = R"""()""";

        // drake/math/gradient_util.h:256
        const char* doc_2 = R"""()""";

        // drake/math/gradient_util.h:279
        const char* doc_3 = R"""()""";

      } setSubMatrixGradient;

      // drake::math::transposeGrad
      struct /* transposeGrad */ {

        // drake/math/gradient_util.h:83
        const char* doc = R"""()""";

      } transposeGrad;

      // drake::math::wrap_to
      struct /* wrap_to */ {

        // drake/math/wrap_to.h:19
        const char* doc =
R"""(For variables that are meant to be periodic, (e.g. over a 2π
interval), wraps `value` into the interval `[low, high)`. Precisely,
`wrap_to` returns: value + k*(high-low) for the unique integer value
`k` that lands the output in the desired interval. ``low`` and
``high`` must be finite, and low < high.)""";

      } wrap_to;

    } math;

    // multibody
    struct /* multibody */ {

      // drake::multibody::AccelerationKinematicsCache
      struct /* AccelerationKinematicsCache */ {

        // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:34
        const char* doc =
R"""(This class is one of the cache entries in MultibodyTreeContext. It
holds the kinematics results of computations that depend not only on
the generalized positions and generalized velocities, but also on the
time derivatives of the generalized coordinates. Acceleration
kinematics results include: - Spatial acceleration `A_WB` for each
body B in the model as measured and expressed in the world frame W.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::AccelerationKinematicsCache::AccelerationKinematicsCache<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:36
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:36
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:44
          const char* doc_3 =
R"""(Constructs an acceleration kinematics cache entry for the given
MultibodyTreeTopology. In Release builds specific entries are left
uninitialized resulting in a zero cost operation. However in Debug
builds those entries are set to NaN so that operations using this
uninitialized cache entry fail fast, easing bug detection.)""";

        } ctor;

        // drake::multibody::AccelerationKinematicsCache::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:36
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::AccelerationKinematicsCache::get_A_WB
        struct /* get_A_WB */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:62
          const char* doc =
R"""(Returns a constant reference to the spatial acceleration `A_WB` of the
body B (associated with node ``body_node_index``) as measured and
expressed in the world frame W. This method aborts in Debug builds if
`body_node_index` does not correspond to a valid BodyNode in the
MultibodyTree.

Parameter ``body_node_index``:
    The unique index for the computational BodyNode object associated
    with body B.

Returns ``A_WB``:
    the spatial acceleration of the body frame B measured and
    expressed in the world frame W.)""";

        } get_A_WB;

        // drake::multibody::AccelerationKinematicsCache::get_A_WB_pool
        struct /* get_A_WB_pool */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:77
          const char* doc =
R"""(Returns a const reference to the pool of body accelerations. The pool
is returned as a `std::vector` of SpatialAcceleration objects ordered
by BodyNodeIndex. Most users should not need to call this method.)""";

        } get_A_WB_pool;

        // drake::multibody::AccelerationKinematicsCache::get_mutable_A_WB
        struct /* get_mutable_A_WB */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:68
          const char* doc = R"""(Mutable version of get_A_WB().)""";

        } get_mutable_A_WB;

        // drake::multibody::AccelerationKinematicsCache::get_mutable_A_WB_pool
        struct /* get_mutable_A_WB_pool */ {

          // drake/multibody/multibody_tree/acceleration_kinematics_cache.h:82
          const char* doc = R"""(Mutable version of get_A_WB_pool().)""";

        } get_mutable_A_WB_pool;

      } AccelerationKinematicsCache;

      // drake::multibody::AddFlatTerrainToWorld
      struct /* AddFlatTerrainToWorld */ {

        // drake/multibody/rigid_body_tree_construction.h:26
        const char* doc =
R"""(Adds a box-shaped terrain to ``tree``. This directly modifies the
existing world rigid body within ``tree`` and thus does not need to
return a `model_instance_id` value.

Two opposite corners of the resulting axis-aligned box are: `(box_size
/ 2, box_size / 2, 0)` and `(-box_size / 2, -box_size / 2,
-box_depth)`.

Parameter ``tree``:
    The RigidBodyTreed to which to add the terrain.

Parameter ``box_size``:
    The length and width of the terrain aligned with the world's X and
    Y axes.

Parameter ``box_depth``:
    The depth of the terrain aligned with the world's Z axis. Note
    that regardless of how deep the terrain is, the top surface of the
    terrain will be at Z = 0.)""";

      } AddFlatTerrainToWorld;

      // drake::multibody::ArticulatedBodyInertia
      struct /* ArticulatedBodyInertia */ {

        // drake/multibody/multibody_tree/articulated_body_inertia.h:97
        const char* doc =
R"""(_Articulated Body Inertia_ is the inertia that a body appears to have
when it is the base (or root) of a rigid-body system, also referred to
as _Articulated Body_ in the context of articulated body algorithms.
The _Articulated Body Inertia_ is a very useful multibody dynamics
concept that was introduced by Featherstone [Featherstone 1983] to
develop the remarkable `O(n)` Articulated Body Algorithm (ABA) for
solving forward dynamics. Recall that the Newton-Euler equations allow
us to describe the combined rotational and translational dynamics of a
rigid body:

```
F_BBo_W = M_B_W * A_WB + b_Bo_W                                    (1)
```

where the spatial inertia (see SpatialInertia) `M_B_W` of body B
expressed in the world frame W linearly relates the spatial
acceleration (see SpatialAcceleration) of body B in the world frame
with the total applied spatial forces (see SpatialForce) `F_BBo` on
body B and where `b_Bo_W` contains the velocity dependent gyroscopic
terms.

A similar relationship is found for an articulated body with a rigid
body B at the base (or root). Even though the bodies in this multibody
system are allowed to have relative motions among them, there still is
a linear relationship between the spatial force `F_BBo_W` applied on
this body and the resulting acceleration `A_WB`:

```
F_BBo_W = P_B_W * A_WB + z_Bo_W                                       (2)
```

where `P_B_W` is the articulated body inertia of body B and `z_Bo_W`
is a bias force that includes the gyroscopic and Coriolis forces and
becomes zero when all body velocities and all applied generalized
forces outboard from body B are zero [Jain 2010, §7.2.1]. The
articulated body inertia `P_B_W` is related to the multibody subsystem
consisting only of bodies that are outboard of body B. We refer to
this subsystem as the _articulated body subsystem_ associated with
body B. Equation (2) describes the acceleration response of body B,
but also taking into account all outboard bodies connected to B. A
special case is that of an articulated body composed of a single rigid
body. For this special case, Eq. (2) reduces to Eq. (1) for the
dynamics of rigid body B. In other words, the ABI for an articulated
body consisting of a single rigid body exactly equals the spatial
inertia of that body.

Articulated body inertias are elements of ℝ⁶ˣ⁶ that, as for spatial
inertias, are symmetric and positive semi-definite. However, ABI
objects **are not** spatial inertias. The spatial inertia of a rigid
body can be described by a reduced set of ten parameters, namely the
mass, center of mass and the six components of the rotational inertia
for that body. However, this parametrization by ten parameters is just
not possible for an ABI and the full 21 elements of the symmetric
`6x6` matrix must be specified [Jain 2010, §6.4]. As a result ABI
objects can have different properties than spatial inertia objects. As
an example, the apparent mass of an articulated body will in general
depend on the direction of the applied force. That is, the simple
relationship `F = m * a` is no longer valid for an articulated body's
center of mass (refer to the excellent example 7.1 in [Featherstone
2008]).

We adopt the notation introduced by [Jain 2010] and generally we will
use an uppercase P to represent an ABI. Thus, in typeset material we
use the symbol $ [P^{A/Q}]_E $ to represent the spatial inertia of an
articulated body A, about a point Q, expressed in a frame E. For this
inertia, the monogram notation reads `P_AQ_E`.

Note:
    This class does not implement any mechanism to track the frame E
    in which an articulated body inertia is expressed or about what
    point is computed. Methods and operators on this class have no
    means to determine frame consistency through operations. It is
    therefore the responsibility of users of this class to keep track
    of frames in which operations are performed. We suggest doing that
    using disciplined notation, as described above.

- [Featherstone 1983] Featherstone, R., 1983. The calculation of robot
dynamics using articulated-body inertias. The International Journal of
Robotics Research, 2(1), pp.13-30. - [Featherstone 2008] Featherstone,
R., 2008. Rigid body dynamics algorithms. Springer. - [Jain 2010]
Jain, A., 2010. Robot and multibody dynamics: analysis and algorithms.
Springer Science & Business Media.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::ArticulatedBodyInertia::ArticulatedBodyInertia<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:99
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/articulated_body_inertia.h:99
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/articulated_body_inertia.h:103
          const char* doc_3 =
R"""(Default ArticulatedBodyInertia constructor initializes all matrix
values to NaN for a quick detection of uninitialized values.)""";

          // drake/multibody/multibody_tree/articulated_body_inertia.h:113
          const char* doc_4 =
R"""(Constructs an articulated body inertia for an articulated body
consisting of a single rigid body given its spatial inertia. From an
input spatial inertia `M_SQ_E` for a body or composite body S, about
point Q, and expressed in a frame E, this constructor creates an
articulated body inertia about the same point Q and expressed in the
same frame E.

Parameter ``M_SQ_E``:
    The spatial inertia of a body or composite body S about point Q
    and expressed in frame E.)""";

          // drake/multibody/multibody_tree/articulated_body_inertia.h:132
          const char* doc_5 =
R"""(Constructs an articulated body inertia from an input matrix.

In Debug, this constructor checks for the physical validity of the
resulting ArticulatedBodyInertia with IsPhysicallyValid() and throws a
std::runtime_error exception in the event the provided input matrix
leads to a non-physically viable articulated body inertia.

Parameter ``matrix``:
    A matrix or matrix expression representing the articulated body
    inertia. Only the lower triangular region is used and the strictly
    upper part is ignored.

Throws:
    s an exception in Debug builds if IsPhysicallyValid() for `this`
    inertia is `false`.)""";

        } ctor;

        // drake::multibody::ArticulatedBodyInertia::CopyToFullMatrix6
        struct /* CopyToFullMatrix6 */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:186
          const char* doc =
R"""(Copy to a full 6x6 matrix representation.)""";

        } CopyToFullMatrix6;

        // drake::multibody::ArticulatedBodyInertia::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:99
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::ArticulatedBodyInertia::IsPhysicallyValid
        struct /* IsPhysicallyValid */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:164
          const char* doc =
R"""(Performs a number of checks to verify that this is a physically valid
articulated body inertia.

The checks performed are: - The matrix is positive semi-definite.)""";

          // drake/multibody/multibody_tree/articulated_body_inertia.h:178
          const char* doc_2 =
R"""(IsPhysicallyValid() for non-numeric scalar types is not supported.)""";

        } IsPhysicallyValid;

        // drake::multibody::ArticulatedBodyInertia::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:278
          const char* doc =
R"""(Given `this` articulated body inertia `P_AQ_E` for some articulated
body A, computed about point Q, and expressed in frame E, this method
uses the rigid body shift operator to compute the same articulated
body inertia about a new point R. The result still is expressed in
frame E.

See also:
    ShiftInPlace() for more details.

Parameter ``p_QR_E``:
    Vector from the original about point Q to the new about point R,
    expressed in the same frame E `this` articulated body inertia is
    expressed in.

Returns ``P_AR_E``:
    This same articulated body inertia for articulated body A but now
    computed about about a new point R.)""";

        } Shift;

        // drake::multibody::ArticulatedBodyInertia::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:223
          const char* doc =
R"""(Given `this` articulated body inertia `P_AQ_E` for some articulated
body A, computed about point Q, and expressed in frame E, this method
uses the rigid body shift operator to compute the same articulated
body inertia about a new point R. The result still is expressed in
frame E.

Mathematically, this is equivalent to:

```
P_AR_E = Φ(P_RQ_E) P_AQ_E Φ(p_RQ_E)ᵀ
```

where `Φ(p_RQ_E)` is the rigid body shift operator as defined by [Jain
2010]. The definition of `Φ(p_RQ_E)` uses `p_QR_E×`, which is the
skew-symmetric cross product matrix (defined such that `a× b =
a.cross(b)`).

```
Φ(p_RQ_E) =
| I₃  p_RQ_E× |
| 0        I₃ |
```

where `p_RQ_E× = -p_QR_E×`.

This operation is performed in-place modifying the original object.

See also:
    Shift() which does not modify this object.

For details see Section 6.2.5, Page 105 of [Jain 2010].

Parameter ``p_QR_E``:
    Vector from the original about point Q to the new about point R,
    expressed in the same frame E `this` articulated body inertia is
    expressed in.

Returns:
    A reference to `this` articulated body inertia for articulated
    body A but now computed about a new point R.)""";

        } ShiftInPlace;

        // drake::multibody::ArticulatedBodyInertia::cast
        struct /* cast */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:150
          const char* doc =
R"""(Returns a new ArticulatedBodyInertia object templated on `Scalar` with
casted values of `this` articulated body inertia.

Template parameter ``Scalar``:
    The scalar type on which the new articulated body inertia will be
    templated.

Note:
    `ArticulatedBodyInertia<From>::cast<To>()` creates a new
    `ArticulatedBodyInertia<To>` from an
    `ArticulatedBodyInertia<From>` but only if type `To` is
    constructible from type `From`. As an example of this,
    `ArticulatedBodyInertia<double>::cast<AutoDiffXd>()` is valid
    since `AutoDiffXd a(1.0)` is valid. However,
    `ArticulatedBodyInertia<AutoDiffXd>::cast<double>()` is not.)""";

        } cast;

        // drake::multibody::ArticulatedBodyInertia::operator*
        struct /* operator_mul */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:317
          const char* doc =
R"""(Multiplies `this` articulated body inertia on the right by a matrix or
vector.

Note:
    This method does not evaluate the product immediately. Instead, it
    returns an intermediate Eigen quantity that can be optimized
    automatically during compile time.)""";

        } operator_mul;

        // drake::multibody::ArticulatedBodyInertia::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/articulated_body_inertia.h:303
          const char* doc =
R"""(Adds in to this articulated body inertia `P_AQ_E` for an articulated
body A about a point Q and expressed in a frame E the articulated body
inertia `P_BQ_E` for a second articulated body B about the same point
Q and expressed in the same frame E. The result is equivalent to the
articulated body inertia `P_CQ_E` for the composite articulated body C
which has at its base a rigid body composed of the bases of A and B
welded together [Featherstone 2008, example 7.1]. The composite
articulated body inertia `P_CQ_E` is also about the same point Q and
expressed in the same frame E as the addends.

Parameter ``P_BQ_E``:
    An articulated body inertia of some articulated body B to be added
    to `this` articulated body inertia. It must be defined about the
    same point Q as `this` inertia, and expressed in the same frame E.

Returns:
    A reference to `this` articulated body inertia, which has been
    updated to include the given articulated body inertia `P_BQ_E`.

@warning This operation is only valid if both articulated body
inertias are computed about the same point Q and expressed in the same
frame E.)""";

        } operator_iadd;

      } ArticulatedBodyInertia;

      // drake::multibody::ArticulatedBodyInertiaCache
      struct /* ArticulatedBodyInertiaCache */ {

        // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:31
        const char* doc =
R"""(This class is one of the cache entries in MultibodyTreeContext. It
holds the results of computations that are used in the recursive
implementation of the articulated body algorithm.

Articulated body inertia cache entries include: - Articulated body
inertia `Pplus_PB_W`, which can be thought of as the articulated body
inertia of parent body P as though it were inertialess, but taken
about Bo and expressed in W.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::ArticulatedBodyInertiaCache::ArticulatedBodyInertiaCache<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:33
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:33
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:37
          const char* doc_3 =
R"""(Constructs an articulated body cache entry for the given
MultibodyTreeTopology.)""";

        } ctor;

        // drake::multibody::ArticulatedBodyInertiaCache::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:33
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::ArticulatedBodyInertiaCache::get_Pplus_PB_W
        struct /* get_Pplus_PB_W */ {

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:45
          const char* doc =
R"""(Articulated body inertia `Pplus_PB_W`, which can be thought of as the
articulated body inertia of parent body P as though it were
inertialess, but taken about Bo and expressed in W.)""";

        } get_Pplus_PB_W;

        // drake::multibody::ArticulatedBodyInertiaCache::get_mutable_Pplus_PB_W
        struct /* get_mutable_Pplus_PB_W */ {

          // drake/multibody/multibody_tree/articulated_body_inertia_cache.h:52
          const char* doc = R"""(Mutable version of get_Pplus_PB_W().)""";

        } get_mutable_Pplus_PB_W;

      } ArticulatedBodyInertiaCache;

      // drake::multibody::Body
      struct /* Body */ {

        // drake/multibody/multibody_tree/body.h:20
        const char* doc =
R"""(Body provides the general abstraction of a body with an API that makes
no assumption about whether a body is rigid or deformable and neither
does it make any assumptions about the underlying physical model or
approximation. As an element or component of a MultibodyTree, a body
is a MultibodyTreeElement, and therefore it has a unique index of type
BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/body.h:155
        const char* doc_2 =
R"""(Body provides the general abstraction of a body with an API that makes
no assumption about whether a body is rigid or deformable and neither
does it make any assumptions about the underlying physical model or
approximation. As an element or component of a MultibodyTree, a body
is a MultibodyTreeElement, and therefore it has a unique index of type
BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/frame.h:17
        const char* doc_3 =
R"""(Body provides the general abstraction of a body with an API that makes
no assumption about whether a body is rigid or deformable and neither
does it make any assumptions about the underlying physical model or
approximation. As an element or component of a MultibodyTree, a body
is a MultibodyTreeElement, and therefore it has a unique index of type
BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/linear_spring_damper.h:13
        const char* doc_4 =
R"""(Body provides the general abstraction of a body with an API that makes
no assumption about whether a body is rigid or deformable and neither
does it make any assumptions about the underlying physical model or
approximation. As an element or component of a MultibodyTree, a body
is a MultibodyTreeElement, and therefore it has a unique index of type
BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/mobilizer.h:22
        const char* doc_5 =
R"""(Body provides the general abstraction of a body with an API that makes
no assumption about whether a body is rigid or deformable and neither
does it make any assumptions about the underlying physical model or
approximation. As an element or component of a MultibodyTree, a body
is a MultibodyTreeElement, and therefore it has a unique index of type
BodyIndex within the multibody tree it belongs to.

A Body contains a unique BodyFrame; see BodyFrame class documentation
for more information.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::Body::Body<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/body.h:157
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/body.h:157
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/body.h:161
          const char* doc_3 =
R"""(Creates a Body named `name` in model instance `model_instance` with a
given `default_mass` and a BodyFrame associated with it.)""";

        } ctor;

        // drake::multibody::Body::CalcCenterOfMassInBodyFrame
        struct /* CalcCenterOfMassInBodyFrame */ {

          // drake/multibody/multibody_tree/body.h:202
          const char* doc =
R"""(Computes the center of mass `p_BoBcm_B` (or `p_Bcm` for short) of this
body measured from this body's frame origin `Bo` and expressed in the
body frame B.)""";

        } CalcCenterOfMassInBodyFrame;

        // drake::multibody::Body::CalcSpatialInertiaInBodyFrame
        struct /* CalcSpatialInertiaInBodyFrame */ {

          // drake/multibody/multibody_tree/body.h:213
          const char* doc =
R"""(Computes the SpatialInertia `I_BBo_B` of `this` body about its frame
origin `Bo` (not necessarily its center of mass) and expressed in its
body frame `B`. In general, the spatial inertia of a body is a
function of state. Consider for instance the case of a flexible body
for which its spatial inertia in the body frame depends on the
generalized coordinates describing its state of deformation. As a
particular case, the spatial inertia of a RigidBody in its body frame
is constant.)""";

        } CalcSpatialInertiaInBodyFrame;

        // drake::multibody::Body::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/body.h:223
          const char* doc =
R"""(NVI (Non-Virtual Interface) to DoCloneToScalar() templated on the
scalar type of the new clone to be created. This method is mostly
intended to be called by MultibodyTree::CloneToScalar(). Most users
should not call this clone method directly but rather clone the entire
parent MultibodyTree if needed.

See also:
    MultibodyTree::CloneToScalar())""";

        } CloneToScalar;

        // drake::multibody::Body::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/body.h:245
          const char* doc =
R"""(Clones this Body (templated on T) to a body templated on `double`.)""";

          // drake/multibody/multibody_tree/body.h:249
          const char* doc_2 =
R"""(Clones this Body (templated on T) to a body templated on AutoDiffXd.)""";

        } DoCloneToScalar;

        // drake::multibody::Body::body_frame
        struct /* body_frame */ {

          // drake/multibody/multibody_tree/body.h:179
          const char* doc =
R"""(Returns a const reference to the associated BodyFrame.)""";

        } body_frame;

        // drake::multibody::Body::get_default_mass
        struct /* get_default_mass */ {

          // drake/multibody/multibody_tree/body.h:194
          const char* doc =
R"""(Returns the default mass (not Context dependent) for `this` body. In
general, the mass for a body can be a parameter of the model that can
be retrieved with the method get_mass(). When the mass of a body is a
parameter, the value returned by get_default_mass() is used to
initialize the mass parameter in the context.)""";

        } get_default_mass;

        // drake::multibody::Body::get_mass
        struct /* get_mass */ {

          // drake/multibody/multibody_tree/body.h:197
          const char* doc =
R"""(Returns the mass of this body stored in `context`.)""";

        } get_mass;

        // drake::multibody::Body::get_num_flexible_positions
        struct /* get_num_flexible_positions */ {

          // drake/multibody/multibody_tree/body.h:172
          const char* doc =
R"""(Returns the number of generalized positions q describing flexible
deformations for this body. A rigid body will therefore return zero.)""";

        } get_num_flexible_positions;

        // drake::multibody::Body::get_num_flexible_velocities
        struct /* get_num_flexible_velocities */ {

          // drake/multibody/multibody_tree/body.h:176
          const char* doc =
R"""(Returns the number of generalized velocities v describing flexible
deformations for this body. A rigid body will therefore return zero.)""";

        } get_num_flexible_velocities;

        // drake::multibody::Body::name
        struct /* name */ {

          // drake/multibody/multibody_tree/body.h:168
          const char* doc =
R"""(Gets the `name` associated with `this` body.)""";

        } name;

        // drake::multibody::Body::node_index
        struct /* node_index */ {

          // drake/multibody/multibody_tree/body.h:185
          const char* doc =
R"""(Returns the index of the node in the underlying tree structure of the
parent MultibodyTree to which this body belongs.)""";

        } node_index;

      } Body;

      // drake::multibody::BodyFrame
      struct /* BodyFrame */ {

        // drake/multibody/multibody_tree/body.h:58
        const char* doc =
R"""(A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.

Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a _reference frame_ in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.

Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body's principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body's reference frame. The flexible degrees of
freedom associated with a flexible body describe the body's
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.

A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/fixed_offset_frame.h:15
        const char* doc_2 =
R"""(A BodyFrame is a material Frame that serves as the unique reference
frame for a Body.

Each Body B, regardless of whether it represents a rigid body or a
flexible body, has a unique body frame for which we use the same
symbol B (with meaning clear from context). The body frame is also
referred to as a _reference frame_ in the literature for flexible body
mechanics modeling using the Finite Element Method. All properties of
a body are defined with respect to its body frame, including its mass
properties and attachment locations for joints, constraints,
actuators, geometry and so on. Run time motion of the body is defined
with respect to the motion of its body frame. We represent a body
frame by a BodyFrame object that is created whenever a Body is
constructed and is owned by the Body.

Note that the BodyFrame associated with a body does not necessarily
need to be located at its center of mass nor does it need to be
aligned with the body's principal axes, although, in practice, it
frequently is. For flexible bodies, BodyFrame provides a
representation for the body's reference frame. The flexible degrees of
freedom associated with a flexible body describe the body's
deformation in this frame. Therefore, the motion of a flexible body is
defined by the motion of its BodyFrame, or reference frame, plus the
motion of the material points on the body with respect to its
BodyFrame.

A BodyFrame and Body are tightly coupled concepts; neither makes sense
without the other. Therefore, a BodyFrame instance is constructed in
conjunction with its Body and cannot be constructed anywhere else.
However, you can still access the frame associated with a body, see
Body::body_frame(). This access is more than a convenience; you can
use the BodyFrame to define other frames on the body and to attach
other multibody elements to it.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::BodyFrame::BodyFrame<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/body.h:60
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/body.h:60
          const char* doc_2 = R"""()""";

        } ctor;

        // drake::multibody::BodyFrame::CalcOffsetPoseInBody
        struct /* CalcOffsetPoseInBody */ {

          // drake/multibody/multibody_tree/body.h:67
          const char* doc = R"""()""";

        } CalcOffsetPoseInBody;

        // drake::multibody::BodyFrame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/body.h:62
          const char* doc = R"""()""";

        } CalcPoseInBodyFrame;

        // drake::multibody::BodyFrame::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/body.h:84
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/body.h:87
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::BodyFrame::GetFixedOffsetPoseInBody
        struct /* GetFixedOffsetPoseInBody */ {

          // drake/multibody/multibody_tree/body.h:77
          const char* doc = R"""()""";

        } GetFixedOffsetPoseInBody;

        // drake::multibody::BodyFrame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/body.h:73
          const char* doc = R"""()""";

        } GetFixedPoseInBodyFrame;

      } BodyFrame;

      // drake::multibody::BodyNodeTag
      struct /* BodyNodeTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:21
        const char* doc = R"""()""";

      } BodyNodeTag;

      // drake::multibody::BodyNodeTopology
      struct /* BodyNodeTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:302
        const char* doc =
R"""(Data structure to store the topological information associated with a
tree node. A tree node essentially consists of a body and its inboard
mobilizer. A body node is in charge of the computations associated to
that body and mobilizer, especially within a base-to-tip or tip-to-
base recursion. As the topological entity associated with a tree node
(and specifically a MultibodyTree node), this struct contains
information regarding parent and child nodes, parent and child bodies,
etc.)""";

        // drake::multibody::BodyNodeTopology::BodyNodeTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:303
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:303
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:306
          const char* doc_3 =
R"""(Default construction to invalid configuration.)""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:323
          const char* doc_4 =
R"""(Constructor specifying the topological information for a tree node. A
tree node is instantiated for each body in the multibody system and it
contains, in addition to that particular body, the inboard mobilizer
connecting the body to the rest of the tree inwards (i.e. towards the
world or root of the tree) from the mobilizer.

Parameter ``index_in``:
    The unique index for `this` body node.

Parameter ``level_in``:
    The level (depth or generation) in the tree structure.

Parameter ``parent_node_in``:
    The parent node, in a tree structure sense, of `this` node.

Parameter ``body_in``:
    The index to the body associated with this node.

Parameter ``parent_body_in``:
    The parent body, in a tree structure sense, to `body_in`. In other
    words, `parent_body_in` is the body associated with node
    `parent_node_in`.

Parameter ``mobilizer_in``:
    The index to the mobilizer associated with this node.)""";

        } ctor;

        // drake::multibody::BodyNodeTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:303
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::BodyNodeTopology::body
        struct /* body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:383
          const char* doc = R"""()""";

        } body;

        // drake::multibody::BodyNodeTopology::child_nodes
        struct /* child_nodes */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:389
          const char* doc =
R"""(The list of child body nodes to this node.)""";

        } child_nodes;

        // drake::multibody::BodyNodeTopology::flexible_positions_start
        struct /* flexible_positions_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:408
          const char* doc = R"""()""";

        } flexible_positions_start;

        // drake::multibody::BodyNodeTopology::flexible_velocities_start
        struct /* flexible_velocities_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:410
          const char* doc = R"""()""";

        } flexible_velocities_start;

        // drake::multibody::BodyNodeTopology::get_num_children
        struct /* get_num_children */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:392
          const char* doc =
R"""(Returns the number of children to this node.)""";

        } get_num_children;

        // drake::multibody::BodyNodeTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:375
          const char* doc =
R"""(Unique index of this node in the MultibodyTree.)""";

        } index;

        // drake::multibody::BodyNodeTopology::level
        struct /* level */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:378
          const char* doc =
R"""(Depth level in the MultibodyTree, level = 0 for the world.)""";

        } level;

        // drake::multibody::BodyNodeTopology::mobilizer
        struct /* mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:386
          const char* doc = R"""()""";

        } mobilizer;

        // drake::multibody::BodyNodeTopology::mobilizer_positions_start
        struct /* mobilizer_positions_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:397
          const char* doc = R"""()""";

        } mobilizer_positions_start;

        // drake::multibody::BodyNodeTopology::mobilizer_velocities_start
        struct /* mobilizer_velocities_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:399
          const char* doc = R"""()""";

        } mobilizer_velocities_start;

        // drake::multibody::BodyNodeTopology::mobilizer_velocities_start_in_v
        struct /* mobilizer_velocities_start_in_v */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:404
          const char* doc = R"""()""";

        } mobilizer_velocities_start_in_v;

        // drake::multibody::BodyNodeTopology::num_flexible_positions
        struct /* num_flexible_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:407
          const char* doc =
R"""(Start and number of dofs for this node's body (flexible dofs).)""";

        } num_flexible_positions;

        // drake::multibody::BodyNodeTopology::num_flexible_velocities
        struct /* num_flexible_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:409
          const char* doc = R"""()""";

        } num_flexible_velocities;

        // drake::multibody::BodyNodeTopology::num_mobilizer_positions
        struct /* num_mobilizer_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:396
          const char* doc =
R"""(Start and number of dofs for this node's mobilizer.)""";

        } num_mobilizer_positions;

        // drake::multibody::BodyNodeTopology::num_mobilizer_velocities
        struct /* num_mobilizer_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:398
          const char* doc = R"""()""";

        } num_mobilizer_velocities;

        // drake::multibody::BodyNodeTopology::parent_body
        struct /* parent_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:384
          const char* doc = R"""()""";

        } parent_body;

        // drake::multibody::BodyNodeTopology::parent_body_node
        struct /* parent_body_node */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:381
          const char* doc =
R"""(The unique index to the parent BodyNode of this node.)""";

        } parent_body_node;

      } BodyNodeTopology;

      // drake::multibody::BodyTag
      struct /* BodyTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:15
        const char* doc = R"""()""";

      } BodyTag;

      // drake::multibody::BodyTopology
      struct /* BodyTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:39
        const char* doc =
R"""(Data structure to store the topological information associated with a
Body.)""";

        // drake::multibody::BodyTopology::BodyTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:40
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:40
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:43
          const char* doc_3 =
R"""(Default construction to invalid configuration.)""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:47
          const char* doc_4 =
R"""(Constructs a body topology struct with index `body_index` and a body
frame with index `frame_index`.)""";

        } ctor;

        // drake::multibody::BodyTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:40
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::BodyTopology::body_frame
        struct /* body_frame */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:89
          const char* doc =
R"""(Unique index to the frame associated with this body.)""";

        } body_frame;

        // drake::multibody::BodyTopology::body_node
        struct /* body_node */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:97
          const char* doc =
R"""(Index to the tree body node in the MultibodyTree.)""";

        } body_node;

        // drake::multibody::BodyTopology::child_bodies
        struct /* child_bodies */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:86
          const char* doc =
R"""(Within the tree structure of a MultibodyTree, the immediate outboard
(or "child") bodies to this Body.)""";

        } child_bodies;

        // drake::multibody::BodyTopology::inboard_mobilizer
        struct /* inboard_mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:75
          const char* doc =
R"""(Unique index to the one and only inboard mobilizer a body can have. By
default this is initialized to "invalid" so that we can detect graph
loops within add_mobilizer(). This will remain "invalid" for the world
body.)""";

        } inboard_mobilizer;

        // drake::multibody::BodyTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:69
          const char* doc = R"""(Unique index in the MultibodyTree.)""";

        } index;

        // drake::multibody::BodyTopology::level
        struct /* level */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:94
          const char* doc =
R"""(Depth level in the MultibodyTree, level = 0 for the world. Initialized
to an invalid negative value so that we can detect at Finalize() when
a user forgets to connect a body with a mobilizer.)""";

        } level;

        // drake::multibody::BodyTopology::parent_body
        struct /* parent_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:82
          const char* doc =
R"""(Within the tree structure of a MultibodyTree, the immediate inboard
(or "parent") body connected by the Mobilizer indexed by
`inboard_mobilizer`. By default this is initialized to "invalid" so
that we can assert (from within add_mobilizer()) that each body can
have only one parent body. Also, this will remain "invalid" for the
world body.)""";

        } parent_body;

      } BodyTopology;

      // drake::multibody::CreateLoadRobotMessage
      struct /* CreateLoadRobotMessage */ {

        // drake/multibody/rigid_body_plant/create_load_robot_message.h:18
        const char* doc =
R"""(Creates and returns an lcmt_viewer_load_robot message containing the
visual geometries from the provided RigidBodyTree. Note that this
includes any visual geometries attached to the world body.

Instantiated templates for the following ScalarTypes are provided: -
double

They are already available to link against in the containing library.)""";

      } CreateLoadRobotMessage;

      // drake::multibody::FixedOffsetFrame
      struct /* FixedOffsetFrame */ {

        // drake/multibody/multibody_tree/fixed_offset_frame.h:34
        const char* doc =
R"""(FixedOffsetFrame represents a material frame F whose pose is fixed
with respect to a _parent_ material frame P. The pose offset is given
by a spatial transform `X_PF`, which is constant after construction.
For instance, we could rigidly attach a frame F to move with a rigid
body B at a fixed pose `X_BF`, where B is the BodyFrame associated
with body B. Thus, the World frame pose `X_WF` of a FixedOffsetFrame F
depends only on the World frame pose `X_WP` of its parent P, and the
constant pose `X_PF`, with `X_WF=X_WP*X_PF`.

For more information about spatial transforms, see
multibody_spatial_pose. <!-- https://drake.mit.edu/doxygen_cxx/
group__multibody__spatial__pose.html -->

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::FixedOffsetFrame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/fixed_offset_frame.h:77
          const char* doc = R"""()""";

        } CalcPoseInBodyFrame;

        // drake::multibody::FixedOffsetFrame::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/fixed_offset_frame.h:99
          const char* doc =
R"""(@pre The parent frame to this frame already has a clone in
`tree_clone`.)""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:103
          const char* doc_2 =
R"""(@pre The parent frame to this frame already has a clone in
`tree_clone`.)""";

        } DoCloneToScalar;

        // drake::multibody::FixedOffsetFrame::FixedOffsetFrame<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/fixed_offset_frame.h:36
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:36
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:49
          const char* doc_3 =
R"""(Creates a material Frame F whose pose is fixed with respect to its
parent material Frame P. The pose is given by a spatial transform
`X_PF`; see class documentation for more information.

Parameter ``name``:
    The name of this frame.

Parameter ``P``:
    The frame to which this frame is attached with a fixed pose.

Parameter ``X_PF``:
    The _default_ transform giving the pose of F in P, therefore only
    the value (as an Isometry3<double>) is provided.)""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:55
          const char* doc_4 =
R"""(Creates an unnamed material Frame F. See overload with name for more
information.)""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:67
          const char* doc_5 =
R"""(Creates a material Frame F whose pose is fixed with respect to the
BodyFrame B of the given Body, which serves as F's parent frame. The
pose is given by a spatial transform `X_BF`; see class documentation
for more information.

Parameter ``name``:
    The name of this frame.

Parameter ``bodyB``:
    The body whose BodyFrame B is to be F's parent frame.

Parameter ``X_BF``:
    The transform giving the pose of F in B.)""";

          // drake/multibody/multibody_tree/fixed_offset_frame.h:73
          const char* doc_6 =
R"""(Creates an unnamed material Frame F. See overload with name for more
information.)""";

        } ctor;

        // drake::multibody::FixedOffsetFrame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/fixed_offset_frame.h:83
          const char* doc = R"""()""";

        } GetFixedPoseInBodyFrame;

      } FixedOffsetFrame;

      // drake::multibody::ForceElement
      struct /* ForceElement */ {

        // drake/multibody/multibody_tree/force_element.h:36
        const char* doc =
R"""(A ForceElement allows modeling state and time dependent forces in a
MultibodyTree model. Examples of such forces are springs, dampers,
drag and gravity. Forces that depend on accelerations such as virtual
mass cannot be modeled with a ForceElement. This abstract class
provides an API that all force elements subclasses must implement in
order to be fully defined. These are: - CalcAndAddForceContribution():
computes the force contribution of a force element in a MultibodyTree
model. - CalcPotentialEnergy(): computes a force element potential
energy contribution. - CalcConservativePower(): computes the power
generated by conservative forces. - CalcNonConservativePower():
computes the power dissipated by non-conservative forces.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::ForceElement::CalcAndAddForceContribution
        struct /* CalcAndAddForceContribution */ {

          // drake/multibody/multibody_tree/force_element.h:70
          const char* doc =
R"""(Computes the force contribution for `this` force element and **adds**
it to the output arrays of forces. Depending on their model, different
force elements may write into the array of sptial forces `F_B_W` or
the array of generalized forces `tau`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with `context`.

Parameter ``forces``:
    A pointer to a valid, non nullptr, multibody forces object. On
    output `this` force element adds its contribution into `forces`.
    This method will abort if the `forces` pointer is null or if the
    forces object is not compatible with `this` MultibodyTree, see
    MultibodyForces::CheckInvariants().

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } CalcAndAddForceContribution;

        // drake::multibody::ForceElement::CalcConservativePower
        struct /* CalcConservativePower */ {

          // drake/multibody/multibody_tree/force_element.h:125
          const char* doc =
R"""(Calculates and returns the power generated by conservative force
elements or zero if `this` force element is non-conservative. This
quantity is defined to be positive when the potential energy is
decreasing. In other words, if `PE` is the potential energy as defined
by CalcPotentialEnergy(), then the conservative power, `Pc`, is `Pc =
-d(PE)/dt`.

See also:
    CalcPotentialEnergy(), CalcNonConservativePower())""";

        } CalcConservativePower;

        // drake::multibody::ForceElement::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {

          // drake/multibody/multibody_tree/force_element.h:137
          const char* doc =
R"""(Calculates the rate at which mechanical energy is being generated
(positive) or dissipated (negative) *other than* by conversion between
potential and kinetic energy. Integrating this quantity yields work W,
and the total energy `E = PE + KE - W` should be conserved by any
physically-correct model, to within integration accuracy of W.

See also:
    CalcConservativePower())""";

        } CalcNonConservativePower;

        // drake::multibody::ForceElement::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {

          // drake/multibody/multibody_tree/force_element.h:114
          const char* doc =
R"""(Calculates the potential energy currently stored given the
configuration provided in `context`. Non-conservative force elements
will return zero.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache().

Returns:
    For conservative force models, the potential energy stored by
    `this` force element. For non-conservative force models, zero.

See also:
    CalcConservativePower())""";

        } CalcPotentialEnergy;

        // drake::multibody::ForceElement::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/force_element.h:151
          const char* doc = R"""(@cond)""";

        } CloneToScalar;

        // drake::multibody::ForceElement::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {

          // drake/multibody/multibody_tree/force_element.h:170
          const char* doc =
R"""(This method is called only from the public non-virtual
CalcAndAddForceContributions() which will already have error-checked
the parameters so you don't have to. Refer to the documentation for
CalcAndAddForceContribution() for details describing the purpose and
parameters of this method. It assumes `forces` to be a valid pointer
to a MultibodyForces object compatible with the MultibodyTree model
owning `this` force element.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } DoCalcAndAddForceContribution;

        // drake::multibody::ForceElement::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/force_element.h:228
          const char* doc =
R"""(Clones this ForceElement (templated on T) to a mobilizer templated on
`double`.)""";

          // drake/multibody/multibody_tree/force_element.h:233
          const char* doc_2 =
R"""(Clones this ForceElement (templated on T) to a mobilizer templated on
AutoDiffXd.)""";

        } DoCloneToScalar;

        // drake::multibody::ForceElement::ForceElement<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/force_element.h:39
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/force_element.h:39
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/force_element.h:42
          const char* doc_3 =
R"""(Default constructor for a generic force element.)""";

        } ctor;

      } ForceElement;

      // drake::multibody::ForceElementTag
      struct /* ForceElementTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:25
        const char* doc = R"""()""";

      } ForceElementTag;

      // drake::multibody::ForceElementTopology
      struct /* ForceElementTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:237
        const char* doc =
R"""(Data structure to store the topological information associated with a
ForceElement.)""";

        // drake::multibody::ForceElementTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:238
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::ForceElementTopology::ForceElementTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:238
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:238
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:242
          const char* doc_3 =
R"""(Default construction to an invalid configuration. This only exists to
satisfy demands of working with various container classes.)""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:245
          const char* doc_4 =
R"""(Constructs a force element topology with index `force_element_index`.)""";

        } ctor;

        // drake::multibody::ForceElementTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:256
          const char* doc = R"""(Unique index in the MultibodyTree.)""";

        } index;

      } ForceElementTopology;

      // drake::multibody::Frame
      struct /* Frame */ {

        // drake/multibody/multibody_tree/frame.h:43
        const char* doc =
R"""(Frame is an abstract class representing a _material frame_ (also
called a _physical frame_), meaning that it is associated with a
material point of a Body. A material frame can be used to apply forces
and torques to a multibody system, and can be used as an attachment
point for force-producing elements like joints, actuators, and
constraints. Despite its name, Frame is not the most general frame
representation in Drake; see FrameBase for a more-general discussion.

The pose and motion of a Frame object is always calculated relative to
the BodyFrame of the body with which it is associated, and every Frame
object can report which Body object that is. Concrete classes derived
from Frame differ only in how those kinematic properties are
calculated. For soft bodies that calculation may depend on the body's
deformation state variables. A Frame on a rigid body will usually have
a fixed offset from its BodyFrame, but that is not required -- a frame
that moves with respect to its BodyFrame can still be a material frame
on that rigid body.

As always in Drake, runtime numerical quantities are stored in a
Context. A Frame object does not store runtime values, but provides
methods for extracting frame-associated values (such as the Frame
object's kinematics) from a given Context.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::Frame::CalcOffsetPoseInBody
        struct /* CalcOffsetPoseInBody */ {

          // drake/multibody/multibody_tree/frame.h:90
          const char* doc =
R"""(Given the offset pose `X_FQ` of a frame Q in `this` frame F, this
method computes the pose `X_BQ` of frame Q in the body frame B to
which this frame is attached. In other words, if the pose of `this`
frame F in the body frame B is `X_BF`, this method computes the pose
`X_BQ` of frame Q in the body frame B as `X_BQ = X_BF * X_FQ`. In
particular, if `this` **is**` the body frame B, i.e. `X_BF` is the
identity transformation, this method directly returns `X_FQ`. Specific
frame subclasses can override this method to provide faster
implementations if needed.)""";

        } CalcOffsetPoseInBody;

        // drake::multibody::Frame::CalcPoseInBodyFrame
        struct /* CalcPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/frame.h:61
          const char* doc =
R"""(Returns the pose `X_BF` of `this` frame F in the body frame B
associated with this frame. In particular, if `this` **is** the body
frame B, this method directly returns the identity transformation.)""";

        } CalcPoseInBodyFrame;

        // drake::multibody::Frame::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/frame.h:113
          const char* doc =
R"""(NVI to DoCloneToScalar() templated on the scalar type of the new clone
to be created. This method is mostly intended to be called by
MultibodyTree::CloneToScalar(). Most users should not call this clone
method directly but rather clone the entire parent MultibodyTree if
needed.

See also:
    MultibodyTree::CloneToScalar())""";

        } CloneToScalar;

        // drake::multibody::Frame::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/frame.h:143
          const char* doc =
R"""(Clones this Frame (templated on T) to a frame templated on `double`.)""";

          // drake/multibody/multibody_tree/frame.h:147
          const char* doc_2 =
R"""(Clones this Frame (templated on T) to a frame templated on AutoDiffXd.)""";

        } DoCloneToScalar;

        // drake::multibody::Frame::Frame<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/frame.h:45
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/frame.h:45
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/frame.h:122
          const char* doc_3 =
R"""(Only derived classes can use this constructor. It creates a Frame
object attached to `body` and puts the frame in the body's model
instance.)""";

          // drake/multibody/multibody_tree/frame.h:127
          const char* doc_4 =
R"""(Overload to permit constructing an unnamed frame.)""";

        } ctor;

        // drake::multibody::Frame::GetFixedOffsetPoseInBody
        struct /* GetFixedOffsetPoseInBody */ {

          // drake/multibody/multibody_tree/frame.h:101
          const char* doc =
R"""(Variant of CalcOffsetPoseInBody() that given the offset pose `X_FQ` of
a frame Q in `this` frame F, returns the pose `X_BQ` of frame Q in the
body frame B to which this frame is attached. Throws std::logic_error
if called on a Frame that does not have a fixed offset in the body
frame.)""";

        } GetFixedOffsetPoseInBody;

        // drake::multibody::Frame::GetFixedPoseInBodyFrame
        struct /* GetFixedPoseInBodyFrame */ {

          // drake/multibody/multibody_tree/frame.h:73
          const char* doc =
R"""(Variant of CalcPoseInBodyFrame() that returns the fixed pose `X_BF` of
`this` frame F in the body frame B associated with this frame. Throws
std::logic_error if called on a Frame that does not have a fixed
offset in the body frame.)""";

        } GetFixedPoseInBodyFrame;

        // drake::multibody::Frame::body
        struct /* body */ {

          // drake/multibody/multibody_tree/frame.h:48
          const char* doc =
R"""(Returns a const reference to the body associated to this Frame.)""";

        } body;

        // drake::multibody::Frame::name
        struct /* name */ {

          // drake/multibody/multibody_tree/frame.h:53
          const char* doc =
R"""(Returns the name of this frame. It may be empty if unnamed.)""";

        } name;

      } Frame;

      // drake::multibody::FrameBase
      struct /* FrameBase */ {

        // drake/multibody/multibody_tree/frame_base.h:46
        const char* doc =
R"""(FrameBase is an abstract representation of the concept of a _frame_ in
multibody dynamics. A frame F is a mathematical object consisting of a
set of three orthogonal unit vector axes Fx,Fy,Fz forming a right-
handed orthogonal basis located at a point Fo called the frame's
origin. If the frame origin Fo is a material point of a body, then F
is a _material frame_ (also called a _physical frame_) and can be used
to apply forces and torques to its body. A material frame can serve as
an attachment point for force-producing elements such as joints and
constraints. Otherwise, we call the frame a _free-floating_ or
_computed_ frame and it is still suited for observation,
visualization, and measurement but cannot be used to apply forces.
Because material frames are by far the most common and useful frames
encountered in multibody systems, the derived class with the simple
name Frame is used to represent them.

Given numerical values in a Context for the associated multibody
system, _every_ frame has a location and orientation (collectively,
_pose_) in space that can be obtained through this base class. Most
frames will also move based on the multibody system's configuration,
or on general runtime computations, so may have meaningful spatial
velocity and acceleration -- that will always be the case for material
frames during a dynamic simulation. Such kinematic quantities must
always be measured with respect to some other specified frame. The
only frame we can be sure exists is the World frame W, so pose and
motion with respect to W are always available. Utilities are provided
for calculating frame motion with respect to other frames. Derived
frame objects will have additional properties. For example, material
frames have an associated Body.

Summarizing, FrameBase serves as an abstraction for a general frame
object; it doesn't store any values itself. As always in Drake,
runtime values are obtained from a Context object. FrameBase provides
an interface through which the pose of a frame may be obtained from a
given Context. Classes derived from FrameBase are used to represent
more specific types of frames, most importantly whether a frame is
associated with a material point of a body.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::FrameBase::FrameBase<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/frame_base.h:60
          const char* doc = R"""()""";

        } ctor;

      } FrameBase;

      // drake::multibody::FrameTag
      struct /* FrameTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:12
        const char* doc = R"""()""";

      } FrameTag;

      // drake::multibody::FrameTopology
      struct /* FrameTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:102
        const char* doc =
R"""(Data structure to store the topological information associated with a
Frame.)""";

        // drake::multibody::FrameTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:103
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::FrameTopology::FrameTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:103
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:103
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:106
          const char* doc_3 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:110
          const char* doc_4 =
R"""(Constructs a frame topology for a frame with index `frame_index`
associated with a body with index `body_index`.)""";

        } ctor;

        // drake::multibody::FrameTopology::body
        struct /* body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:125
          const char* doc =
R"""(Unique index of the body this physical frame attaches to.)""";

        } body;

        // drake::multibody::FrameTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:122
          const char* doc = R"""(Unique index in the MultibodyTree.)""";

        } index;

      } FrameTopology;

      // drake::multibody::InverseKinematics
      struct /* InverseKinematics */ {

        // drake/multibody/inverse_kinematics/inverse_kinematics.h:18
        const char* doc =
R"""(Solves an inverse kinematics (IK) problem on a MultibodyPlant, to find
the postures of the robot satisfying certain constraints. The decision
variables include the generalized position of the robot.
TODO(hongkai.dai) The bounds on the generalized positions (i.e., joint
limits) should be imposed automatially.)""";

        // drake::multibody::InverseKinematics::AddAngleBetweenVectorsConstraint
        struct /* AddAngleBetweenVectorsConstraint */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:145
          const char* doc =
R"""(Constrains that the angle between a vector na and another vector nb is
between [θ_lower, θ_upper]. na is fixed to a frame A, while nb is
fixed to a frame B. Mathematically, if we denote na_unit_A as na
expressed in frame A after normalization (na_unit_A has unit length),
and nb_unit_B as nb expressed in frame B after normalization, the
constraint is cos(θ_upper) ≤ na_unit_Aᵀ * R_AB * nb_unit_B ≤
cos(θ_lower), where R_AB is the rotation matrix, representing the
orientation of frame B expressed in frame A.

Parameter ``frameA``:
    The frame to which na is fixed.

Parameter ``na_A``:
    The vector na fixed to frame A, expressed in frame A. @pre na_A
    should be a non-zero vector.

Throws:
    invalid_argument if na_A is close to zero.

Parameter ``frameB``:
    The frame to which nb is fixed.

Parameter ``nb_B``:
    The vector nb fixed to frame B, expressed in frame B. @pre nb_B
    should be a non-zero vector.

Throws:
    invalid_argument if nb_B is close to zero.

Parameter ``angle_lower``:
    The lower bound on the angle between na and nb. It is denoted as
    θ_lower in the documentation. ``angle_lower`` is in radians. @pre
    angle_lower >= 0.

Throws:
    invalid_argument if angle_lower is negative.

Parameter ``angle_upper``:
    The upper bound on the angle between na and nb. it is denoted as
    θ_upper in the class documentation. ``angle_upper`` is in radians.
    @pre angle_lower <= angle_upper <= pi.

Throws:
    invalid_argument if angle_upper is outside the bounds.)""";

        } AddAngleBetweenVectorsConstraint;

        // drake::multibody::InverseKinematics::AddGazeTargetConstraint
        struct /* AddGazeTargetConstraint */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:111
          const char* doc =
R"""(Constrains a target point T to be within a cone K. The point T ("T"
stands for "target") is fixed in a frame B, with position p_BT. The
cone originates from a point S ("S" stands for "source"), fixed in
frame A with position p_AS, with the axis of the cone being n, also
fixed in frame A. The half angle of the cone is θ. A common usage of
this constraint is that a camera should gaze at some target; namely
the target falls within a gaze cone, originating from the camera eye.

Parameter ``frameA``:
    The frame where the gaze cone is fixed to.

Parameter ``p_AS``:
    The position of the cone source point S, measured and expressed in
    frame A.

Parameter ``n_A``:
    The directional vector representing the center ray of the cone,
    expressed in frame A. @pre ``n_A`` cannot be a zero vector.

Throws:
    invalid_argument is n_A is close to a zero vector.

Parameter ``frameB``:
    The frame where the target point T is fixed to.

Parameter ``p_BT``:
    The position of the target point T, measured and expressed in
    frame B.

Parameter ``cone_half_angle``:
    The half angle of the cone. We denote it as θ in the
    documentation. ``cone_half_angle`` is in radians. @pre ``0`` <=
    cone_half_angle <= pi.

Throws:
    invalid_argument if cone_half_angle is outside of the bound.)""";

        } AddGazeTargetConstraint;

        // drake::multibody::InverseKinematics::AddOrientationConstraint
        struct /* AddOrientationConstraint */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:82
          const char* doc =
R"""(Constrains that the angle difference θ between the orientation of
frame A and the orientation of frame B to satisfy θ ≤ θ_bound. Frame A
is fixed to frame A_bar, with orientation R_AbarA measured in frame
A_bar. Frame B is fixed to frame B_bar, with orientation R_BbarB
measured in frame B_bar. The angle difference between frame A's
orientation R_WA and B's orientation R_WB is θ, (θ ∈ [0, π]), if there
exists a rotation axis a, such that rotating frame A by angle θ about
axis a aligns it with frame B. Namely R_AB = I + sinθ â + (1-cosθ)â²
(1) where R_AB is the orientation of frame B expressed in frame A. â
is the skew symmetric matrix of the rotation axis a. Equation (1) is
the Rodrigues formula that computes the rotation matrix from a
rotation axis a and an angle θ,
https://en.wikipedia.org/wiki/Rodrigues27_rotation_formula If the
users want frame A and frame B to align perfectly, they can set
θ_bound = 0. Mathematically, this constraint is imposed as trace(R_AB)
≥ 2cos(θ_bound) + 1 (1) To derive (1), using Rodrigues formula R_AB =
I + sinθ â + (1-cosθ)â² where trace(R_AB) = 2cos(θ) + 1 ≥
2cos(θ_bound) + 1

Parameter ``frameAbar``:
    frame A_bar, the frame A is fixed to frame A_bar.

Parameter ``R_AbarA``:
    The orientation of frame A measured in frame A_bar.

Parameter ``frameBbar``:
    frame B_bar, the frame B is fixed to frame B_bar.

Parameter ``R_BbarB``:
    The orientation of frame B measured in frame B_bar.

Parameter ``theta_bound``:
    The bound on the angle difference between frame A's orientation
    and frame B's orientation. It is denoted as θ_bound in the
    documentation. ``theta_bound`` is in radians.)""";

        } AddOrientationConstraint;

        // drake::multibody::InverseKinematics::AddPositionConstraint
        struct /* AddPositionConstraint */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:46
          const char* doc =
R"""(Adds the kinematic constraint that a point Q, fixed in frame B, should
lie within a bounding box expressed in another frame A as p_AQ_lower
<= p_AQ <= p_AQ_upper, where p_AQ is the position of point Q measured
and expressed in frame A.

Parameter ``frameB``:
    The frame in which point Q is fixed.

Parameter ``p_BQ``:
    The position of the point Q, rigidly attached to frame B, measured
    and expressed in frame A.

Parameter ``frameA``:
    The frame in which the bounding box p_AQ_lower <= p_AQ <=
    p_AQ_upper is expressed.

Parameter ``p_AQ_lower``:
    The lower bound on the position of point Q, measured and expressed
    in frame A.

Parameter ``p_AQ_upper``:
    The upper bound on the position of point Q, measured and expressed
    in frame A.)""";

        } AddPositionConstraint;

        // drake::multibody::InverseKinematics::InverseKinematics
        struct /* ctor */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:20
          const char* doc = R"""()""";

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:20
          const char* doc_2 = R"""()""";

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:29
          const char* doc_3 =
R"""(Constructs an inverse kinematics problem for a MultibodyPlant.

Parameter ``plant``:
    The robot on which the inverse kinematics problem will be solved.)""";

        } ctor;

        // drake::multibody::InverseKinematics::get_mutable_prog
        struct /* get_mutable_prog */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:160
          const char* doc =
R"""(Getter for the optimization program constructed by InverseKinematics.
*/)""";

        } get_mutable_prog;

        // drake::multibody::InverseKinematics::prog
        struct /* prog */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:157
          const char* doc =
R"""(Getter for the optimization program constructed by InverseKinematics.
*/)""";

        } prog;

        // drake::multibody::InverseKinematics::q
        struct /* q */ {

          // drake/multibody/inverse_kinematics/inverse_kinematics.h:154
          const char* doc =
R"""(Getter for q. q is the decision variable for the generalized positions
of the robot.)""";

        } q;

      } InverseKinematics;

      // drake::multibody::Joint
      struct /* Joint */ {

        // drake/multibody/multibody_tree/joint_actuator.h:19
        const char* doc =
R"""(A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the _parent_ and _child_ bodies.
Although the terms _parent_ and _child_ are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody models, this usage is wholly unrelated and implies
nothing about the inboard-outboard relationship between the bodies. A
Joint is a model of a physical kinematic constraint between two
bodies, a constraint that in the real physical system does not even
allude to the ordering of the bodies.

In Drake we define a frame F rigidly attached to the parent body P
with pose `X_PF` and a frame M rigidly attached to the child body B
with pose `X_BM`. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.

Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.

Consider the following example to build a simple pendulum system:

```
MultibodyTree<double> model;
 // ... Code here to setup quantities below as mass, com, etc. ...
 const Body<double>& pendulum =
   model.AddBody<RigidBody>(SpatialInertia<double>(mass, com, unit_inertia));
 // We will connect the pendulum body to the world using a RevoluteJoint.
 // In this simple case the parent body P is the model's world body and frame
 // F IS the world frame.
 // Additionally, we need to specify the pose of frame M on the pendulum's
 // body frame B.
 // Say we declared and initialized X_BM...
 const RevoluteJoint<double>& elbow =
   model.AddJoint<RevoluteJoint>(
///     "Elbow",                /* joint name 
///     model.world_body(),     /* parent body 
///     {},                     /* frame F IS the world frame W 
///     pendulum,               /* child body, the pendulum 
///     X_BM,                   /* pose of frame M in the body frame B 
///     Vector3d::UnitZ());     /* revolute axis in this case
```

@warning Do not ever attempt to instantiate and manipulate Joint
objects on the stack; it will fail. Add joints to your model using the
provided API MultibodyTree::AddJoint() as in the example above.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/joints/joint.h:70
        const char* doc_2 =
R"""(A Joint models the kinematical relationship which characterizes the
possible relative motion between two bodies. The two bodies connected
by a Joint object are referred to as the _parent_ and _child_ bodies.
Although the terms _parent_ and _child_ are sometimes used
synonymously to describe the relationship between inboard and outboard
bodies in multibody models, this usage is wholly unrelated and implies
nothing about the inboard-outboard relationship between the bodies. A
Joint is a model of a physical kinematic constraint between two
bodies, a constraint that in the real physical system does not even
allude to the ordering of the bodies.

In Drake we define a frame F rigidly attached to the parent body P
with pose `X_PF` and a frame M rigidly attached to the child body B
with pose `X_BM`. A Joint object specifies a kinematic relation
between frames F and M, which in turn imposes a kinematic relation
between bodies P and B.

Typical joints include the ball joint, to allow unrestricted rotations
about a given point, the revolute joint, that constraints two bodies
to rotate about a given common axis, etc.

Consider the following example to build a simple pendulum system:

```
MultibodyTree<double> model;
 // ... Code here to setup quantities below as mass, com, etc. ...
 const Body<double>& pendulum =
   model.AddBody<RigidBody>(SpatialInertia<double>(mass, com, unit_inertia));
 // We will connect the pendulum body to the world using a RevoluteJoint.
 // In this simple case the parent body P is the model's world body and frame
 // F IS the world frame.
 // Additionally, we need to specify the pose of frame M on the pendulum's
 // body frame B.
 // Say we declared and initialized X_BM...
 const RevoluteJoint<double>& elbow =
   model.AddJoint<RevoluteJoint>(
///     "Elbow",                /* joint name 
///     model.world_body(),     /* parent body 
///     {},                     /* frame F IS the world frame W 
///     pendulum,               /* child body, the pendulum 
///     X_BM,                   /* pose of frame M in the body frame B 
///     Vector3d::UnitZ());     /* revolute axis in this case
```

@warning Do not ever attempt to instantiate and manipulate Joint
objects on the stack; it will fail. Add joints to your model using the
provided API MultibodyTree::AddJoint() as in the example above.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::Joint::AddInDamping
        struct /* AddInDamping */ {

          // drake/multibody/multibody_tree/joints/joint.h:257
          const char* doc =
R"""(Adds into `forces` the force due to damping within `this` joint.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which `this` joint belongs.

Parameter ``forces``:
    On return, this method will add the force due to damping within
    `this` joint. This method aborts if `forces` is `nullptr` or if
    `forces` does not have the right sizes to accommodate a set of
    forces for the model to which this joint belongs.)""";

        } AddInDamping;

        // drake::multibody::Joint::AddInOneForce
        struct /* AddInOneForce */ {

          // drake/multibody/multibody_tree/joints/joint.h:235
          const char* doc =
R"""(Adds into `forces` a force along the one of the joint's degrees of
freedom indicated by index `joint_dof`. The meaning for this degree of
freedom and even its dimensional units depend on the specific joint
sub-class. For a RevoluteJoint for instance, `joint_dof` can only be 0
since revolute joints's motion subspace only has one degree of
freedom, while the units of `joint_tau` are those of torque (N⋅m in
the MKS system of units). For multi-dof joints please refer to the
documentation provided by specific joint sub-classes regarding the
meaning of `joint_dof`.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which `this` joint belongs.

Parameter ``joint_dof``:
    Index specifying one of the degrees of freedom for this joint. The
    index must be in the range `0 <= joint_dof < num_velocities()` or
    otherwise this method will abort.

Parameter ``joint_tau``:
    Generalized force corresponding to the degree of freedom indicated
    by `joint_dof` to be added into `forces`.

Parameter ``forces``:
    On return, this method will add force `joint_tau` for the degree
    of freedom `joint_dof` into the output `forces`. This method
    aborts if `forces` is `nullptr` or if `forces` doest not have the
    right sizes to accommodate a set of forces for the model to which
    this joint belongs.)""";

        } AddInOneForce;

        // drake::multibody::Joint::BluePrint
        struct /* BluePrint */ {

          // drake/multibody/multibody_tree/joints/joint.h:289
          const char* doc =
R"""((Advanced) Structure containing all the information needed to build
the MultibodyTree implementation for a Joint. At
MultibodyTree::Finalize() a Joint creates a BluePrint of its
implementation with MakeModelBlueprint() so that MultibodyTree can
build an implementation for it.)""";

          // drake::multibody::Joint::BluePrint::mobilizers_
          struct /* mobilizers_ */ {

            // drake/multibody/multibody_tree/joints/joint.h:290
            const char* doc = R"""()""";

          } mobilizers_;

        } BluePrint;

        // drake::multibody::Joint::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/joints/joint.h:270
          const char* doc = R"""()""";

        } CloneToScalar;

        // drake::multibody::Joint::DoAddInDamping
        struct /* DoAddInDamping */ {

          // drake/multibody/multibody_tree/joints/joint.h:405
          const char* doc =
R"""(Adds into MultibodyForces the forces due to damping within `this`
joint. How forces are added to a MultibodyTree model depends on the
underlying implementation of a particular joint (for instance,
mobilizer vs. constraint) and therefore specific Joint subclasses must
provide a definition for this method. The default implementation is a
no-op for joints with no damping.)""";

        } DoAddInDamping;

        // drake::multibody::Joint::DoAddInOneForce
        struct /* DoAddInOneForce */ {

          // drake/multibody/multibody_tree/joints/joint.h:393
          const char* doc =
R"""(Adds into `forces` a force along the one of the joint's degrees of
freedom given by `joint_dof`. How forces are added to a MultibodyTree
model depends on the underlying implementation of a particular joint
and therefore specific Joint subclasses must provide a definition for
this method. For instance, a revolute joint could be modeled with a
single generalized coordinate for the angular rotation (implemented
through a RevoluteMobilizer) or it could be modeled using a constraint
that only allows rotation about the joint's axis but that constrains
the motion in the other five degrees of freedom. This method is only
called by the public NVI AddInOneForce() and therefore input arguments
were checked to be valid.

See also:
    The public NVI AddInOneForce() for details.)""";

        } DoAddInOneForce;

        // drake::multibody::Joint::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/joints/joint.h:415
          const char* doc =
R"""(@name Methods to make a clone templated on different scalar types. @{
Clones this Joint (templated on T) to a joint templated on `double`.)""";

          // drake/multibody/multibody_tree/joints/joint.h:419
          const char* doc_2 =
R"""(Clones this Joint (templated on T) to a joint templated on AutoDiffXd.)""";

        } DoCloneToScalar;

        // drake::multibody::Joint::DoGetOnePosition
        struct /* DoGetOnePosition */ {

          // drake/multibody/multibody_tree/joints/joint.h:367
          const char* doc =
R"""(Implementation to the NVI GetOnePosition() that must only be
implemented by those joint subclasses that have a single degree of
freedom. The default implementation for all other joints is to abort
with an appropriate message. Revolute and prismatic are examples of
joints that will want to implement this method.)""";

        } DoGetOnePosition;

        // drake::multibody::Joint::DoGetOneVelocity
        struct /* DoGetOneVelocity */ {

          // drake/multibody/multibody_tree/joints/joint.h:377
          const char* doc =
R"""(Implementation to the NVI GetOneVelocity() that must only be
implemented by those joint subclasses that have a single degree of
freedom. The default implementation for all other joints is to abort
with an appropriate message. Revolute and prismatic are examples of
joints that will want to implement this method.)""";

        } DoGetOneVelocity;

        // drake::multibody::Joint::DoSetTopology
        struct /* DoSetTopology */ {

          // drake/multibody/multibody_tree/joints/joint.h:410
          const char* doc = R"""()""";

        } DoSetTopology;

        // drake::multibody::Joint::GetOnePosition
        struct /* GetOnePosition */ {

          // drake/multibody/multibody_tree/joints/joint.h:195
          const char* doc =
R"""(Returns the position coordinate for joints with a single degree of
freedom.

Throws:
    s RuntimeError if the joint does not have a single degree of
    freedom.)""";

        } GetOnePosition;

        // drake::multibody::Joint::GetOneVelocity
        struct /* GetOneVelocity */ {

          // drake/multibody/multibody_tree/joints/joint.h:204
          const char* doc =
R"""(Returns the velocity coordinate for joints with a single degree of
freedom.

Throws:
    s RuntimeError if the joint does not have a single degree of
    freedom.)""";

        } GetOneVelocity;

        // drake::multibody::Joint::Joint<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/joints/joint.h:72
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/joints/joint.h:72
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/joints/joint.h:95
          const char* doc_3 =
R"""(Creates a joint between two Frame objects which imposes a given
kinematic relation between frame F attached on the parent body P and
frame M attached on the child body B. The joint will be initialized to
the model instance from ``frame_on_child`` (this is the typical
convention for joints between the world and a model, or between two
models (e.g. an arm to a gripper)). See this class's documentation for
further details.

Parameter ``name``:
    A string with a name identifying `this` joint.

Parameter ``frame_on_parent``:
    The frame F attached on the parent body connected by this joint.

Parameter ``frame_on_child``:
    The frame M attached on the child body connected by this joint.

Parameter ``lower_limit``:
    A vector storing the position lower limit for each generalized
    position. It must have the same size as `upper_limit`. A value
    equal to -∞ implies no lower limit.

Parameter ``upper_limit``:
    A vector storing the position upper limit for each generalized
    position. It must have the same size as `lower_limit`. A value
    equal to +∞ implies no upper limit.)""";

        } ctor;

        // drake::multibody::Joint::JointImplementation
        struct /* JointImplementation */ {

          // drake/multibody/multibody_tree/joints/joint.h:301
          const char* doc =
R"""((Advanced) A Joint is implemented in terms of MultibodyTree elements
such as bodies, mobilizers, force elements and constraints. This
object contains the internal details of the MultibodyTree
implementation for a joint. The implementation does not own the MBT
elements, it just keeps references to them. This is intentionally made
a protected member so that derived classes have access to its
definition.)""";

          // drake::multibody::Joint::JointImplementation::CloneToScalar
          struct /* CloneToScalar */ {

            // drake/multibody/multibody_tree/joints/joint.h:326
            const char* doc = R"""()""";

          } CloneToScalar;

          // drake::multibody::Joint::JointImplementation::JointImplementation
          struct /* ctor */ {

            // drake/multibody/multibody_tree/joints/joint.h:304
            const char* doc =
R"""(Default constructor to create an empty implementation. Used by
Joint::CloneToScalar().)""";

            // drake/multibody/multibody_tree/joints/joint.h:308
            const char* doc_2 =
R"""(This constructor creates an implementation for `this` joint from the
blueprint provided.)""";

          } ctor;

          // drake::multibody::Joint::JointImplementation::mobilizers_
          struct /* mobilizers_ */ {

            // drake/multibody/multibody_tree/joints/joint.h:341
            const char* doc =
R"""(References (raw pointers) to the mobilizers that make part of this
implementation.)""";

          } mobilizers_;

          // drake::multibody::Joint::JointImplementation::num_mobilizers
          struct /* num_mobilizers */ {

            // drake/multibody/multibody_tree/joints/joint.h:316
            const char* doc =
R"""(Returns the number of mobilizers in this implementation.)""";

          } num_mobilizers;

        } JointImplementation;

        // drake::multibody::Joint::MakeImplementationBlueprint
        struct /* MakeImplementationBlueprint */ {

          // drake/multibody/multibody_tree/joints/joint.h:426
          const char* doc =
R"""(This method must be implemented by derived classes in order to provide
JointImplementationBuilder a BluePrint of their internal
implementation JointImplementation.)""";

        } MakeImplementationBlueprint;

        // drake::multibody::Joint::child_body
        struct /* child_body */ {

          // drake/multibody/multibody_tree/joints/joint.h:122
          const char* doc =
R"""(Returns a const reference to the child body B.)""";

        } child_body;

        // drake::multibody::Joint::do_get_num_positions
        struct /* do_get_num_positions */ {

          // drake/multibody/multibody_tree/joints/joint.h:359
          const char* doc =
R"""(Implementation to the NVI num_positions(), see num_positions() for
details.)""";

        } do_get_num_positions;

        // drake::multibody::Joint::do_get_num_velocities
        struct /* do_get_num_velocities */ {

          // drake/multibody/multibody_tree/joints/joint.h:351
          const char* doc =
R"""(Implementation to the NVI num_velocities(), see num_velocities() for
details.)""";

        } do_get_num_velocities;

        // drake::multibody::Joint::do_get_position_start
        struct /* do_get_position_start */ {

          // drake/multibody/multibody_tree/joints/joint.h:355
          const char* doc =
R"""(Implementation to the NVI position_start(), see position_start() for
details.)""";

        } do_get_position_start;

        // drake::multibody::Joint::do_get_velocity_start
        struct /* do_get_velocity_start */ {

          // drake/multibody/multibody_tree/joints/joint.h:347
          const char* doc =
R"""(Implementation to the NVI velocity_start(), see velocity_start() for
details.)""";

        } do_get_velocity_start;

        // drake::multibody::Joint::frame_on_child
        struct /* frame_on_child */ {

          // drake/multibody/multibody_tree/joints/joint.h:132
          const char* doc =
R"""(Returns a const reference to the frame M attached on the child body B.)""";

        } frame_on_child;

        // drake::multibody::Joint::frame_on_parent
        struct /* frame_on_parent */ {

          // drake/multibody/multibody_tree/joints/joint.h:127
          const char* doc =
R"""(Returns a const reference to the frame F attached on the parent body
P.)""";

        } frame_on_parent;

        // drake::multibody::Joint::get_implementation
        struct /* get_implementation */ {

          // drake/multibody/multibody_tree/joints/joint.h:431
          const char* doc =
R"""(Returns a const reference to the internal implementation of `this`
joint. @warning The MultibodyTree model must have already been
finalized, or this method will abort.)""";

        } get_implementation;

        // drake::multibody::Joint::lower_limits
        struct /* lower_limits */ {

          // drake/multibody/multibody_tree/joints/joint.h:176
          const char* doc =
R"""(Returns a vector of size num_positions() storing the lower limits for
each generalized position for `this` joint. A limit with value -∞
implies no lower limit for the corresponding position. Joint limits
are returned in order with the limit for position with index
position_start() in the first entry and with the limit for position
with index position_start() + num_positions() - 1 in the last entry.)""";

        } lower_limits;

        // drake::multibody::Joint::name
        struct /* name */ {

          // drake/multibody/multibody_tree/joints/joint.h:114
          const char* doc = R"""(Returns the name of this joint.)""";

        } name;

        // drake::multibody::Joint::num_dofs
        struct /* num_dofs */ {

          // drake/multibody/multibody_tree/joints/joint.h:139
          const char* doc =
R"""(Returns the number of degrees of freedom for `this` joint. E.g., one
for a revolute joint and three for a ball joint.)""";

        } num_dofs;

        // drake::multibody::Joint::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/joints/joint.h:164
          const char* doc =
R"""(Returns the number of generalized positions describing this joint.)""";

        } num_positions;

        // drake::multibody::Joint::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/joints/joint.h:151
          const char* doc =
R"""(Returns the number of generalized velocities describing this joint.)""";

        } num_velocities;

        // drake::multibody::Joint::parent_body
        struct /* parent_body */ {

          // drake/multibody/multibody_tree/joints/joint.h:117
          const char* doc =
R"""(Returns a const reference to the parent body P.)""";

        } parent_body;

        // drake::multibody::Joint::position_start
        struct /* position_start */ {

          // drake/multibody/multibody_tree/joints/joint.h:159
          const char* doc =
R"""(Returns the index to the first generalized position for this joint
within the vector q of generalized positions for the full multibody
system.)""";

        } position_start;

        // drake::multibody::Joint::upper_limits
        struct /* upper_limits */ {

          // drake/multibody/multibody_tree/joints/joint.h:187
          const char* doc =
R"""(Returns a vector of size num_positions() storing the upper limits for
each generalized position for `this` joint. A limit with value +∞
implies no upper limit for the corresponding position. Joint limits
are returned in order with the limit for position with index
position_start() in the first entry and with the limit for position
with index position_start() + num_positions() - 1 in the last entry.)""";

        } upper_limits;

        // drake::multibody::Joint::velocity_start
        struct /* velocity_start */ {

          // drake/multibody/multibody_tree/joints/joint.h:146
          const char* doc =
R"""(Returns the index to the first generalized velocity for this joint
within the vector v of generalized velocities for the full multibody
system.)""";

        } velocity_start;

      } Joint;

      // drake::multibody::JointActuator
      struct /* JointActuator */ {

        // drake/multibody/multibody_tree/joint_actuator.h:37
        const char* doc =
R"""(The JointActuator class is mostly a simple bookkeeping structure to
represent an actuator acting on a given Joint. It helps to flag
whether a given Joint is actuated or not so that MultibodyTree clients
can apply forces on actuated joints through their actuators, see
AddInOneForce().

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::JointActuator::AddInOneForce
        struct /* AddInOneForce */ {

          // drake/multibody/multibody_tree/joint_actuator.h:81
          const char* doc =
R"""(Adds into `forces` a force along one of the degrees of freedom of the
Joint actuated by `this` actuator. The meaning for this degree of
freedom, sign conventions and even its dimensional units depend on the
specific joint sub-class being actuated. For a RevoluteJoint for
instance, `joint_dof` can only be 0 since revolute joints's motion
subspace only has one degree of freedom, while the units of `tau` are
those of torque (N⋅m in the MKS system of units). For multi-dof joints
please refer to the documentation provided by specific joint sub-
classes regarding the meaning of `joint_dof`.

Parameter ``context``:
    The context storing the state and parameters for the model to
    which `this` joint belongs.

Parameter ``joint_dof``:
    Index specifying one of the degrees of freedom for this joint. The
    index must be in the range `0 <= joint_dof < num_velocities()` or
    otherwise this method will throw an exception.

Parameter ``joint_tau``:
    Generalized force corresponding to the degree of freedom indicated
    by `joint_dof` to be added into `forces`. Refere to the specific
    Joint sub-class documentation for details on the meaning and units
    for this degree of freedom.

Parameter ``forces``:
    On return, this method will add force `tau` for the degree of
    freedom `joint_dof` into the output `forces`. This method aborts
    if `forces` is `nullptr` or if `forces` doest not have the right
    sizes to accommodate a set of forces for the model to which this
    actuator belongs.)""";

        } AddInOneForce;

        // drake::multibody::JointActuator::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/joint_actuator.h:111
          const char* doc = R"""(@cond)""";

        } CloneToScalar;

        // drake::multibody::JointActuator::JointActuator<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/joint_actuator.h:40
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/joint_actuator.h:40
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/joint_actuator.h:45
          const char* doc_3 =
R"""(Creates an actuator for `joint` with the given `name`. The name must
be unique within the given MultibodyTree model. This is enforced by
MultibodyTree::AddJointActuator().)""";

        } ctor;

        // drake::multibody::JointActuator::joint
        struct /* joint */ {

          // drake/multibody/multibody_tree/joint_actuator.h:51
          const char* doc =
R"""(Returns a reference to the joint actuated by this JointActuator.)""";

        } joint;

        // drake::multibody::JointActuator::name
        struct /* name */ {

          // drake/multibody/multibody_tree/joint_actuator.h:48
          const char* doc = R"""(Returns the name of the actuator.)""";

        } name;

        // drake::multibody::JointActuator::set_actuation_vector
        struct /* set_actuation_vector */ {

          // drake/multibody/multibody_tree/joint_actuator.h:101
          const char* doc =
R"""(Given the actuation values u_instance for `this` actuator, this method
sets the actuation vector u for the entire MultibodyTree model to
which this actuator belongs to.

Parameter ``u_instance``:
    Actuation values for `this` actuator. It must be of size equal to
    the number of degrees of freedom of the actuated Joint, see
    Joint::num_velocities(). For units and sign conventions refer to
    the specific Joint sub-class documentation.

Parameter ``u``:
    The vector containing the actuation values for the entire
    MultibodyTree model to which `this` actuator belongs to.

Throws:
    s if `u_instance.size() != this->joint().num_velocities()`.

Throws:
    s if u is nullptr.

Throws:
    s if `u.size() != this->get_parent_tree().num_actuated_dofs()`.)""";

        } set_actuation_vector;

      } JointActuator;

      // drake::multibody::JointActuatorElementTag
      struct /* JointActuatorElementTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:31
        const char* doc = R"""()""";

      } JointActuatorElementTag;

      // drake::multibody::JointActuatorTopology
      struct /* JointActuatorTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:261
        const char* doc =
R"""(Data structure to store the topological information associated with a
JointActuator.)""";

        // drake::multibody::JointActuatorTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:262
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::JointActuatorTopology::JointActuatorTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:262
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:262
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:266
          const char* doc_3 =
R"""(Default construction to an invalid configuration. This only exists to
satisfy demands of working with various container classes.)""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:269
          const char* doc_4 =
R"""(Constructs a joint actuator topology with index
`joint_actuator_index`.)""";

        } ctor;

        // drake::multibody::JointActuatorTopology::actuator_index_start
        struct /* actuator_index_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:290
          const char* doc =
R"""(For an actuator in a MultibodyTree model, this index corresponds to
the first entry in the global array u containing all actuation values
for the entire model.)""";

        } actuator_index_start;

        // drake::multibody::JointActuatorTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:286
          const char* doc = R"""(Unique index in the MultibodyTree.)""";

        } index;

        // drake::multibody::JointActuatorTopology::num_dofs
        struct /* num_dofs */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:292
          const char* doc =
R"""(The number of dofs actuated by this actuator.)""";

        } num_dofs;

      } JointActuatorTopology;

      // drake::multibody::JointElementTag
      struct /* JointElementTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:28
        const char* doc = R"""()""";

      } JointElementTag;

      // drake::multibody::LinearSpringDamper
      struct /* LinearSpringDamper */ {

        // drake/multibody/multibody_tree/linear_spring_damper.h:49
        const char* doc =
R"""(This ForceElement models a spring-damper attached between two points
on two different bodies. Given a point P on a body A and a point Q on
a body B with positions p_AP and p_BQ, respectively, this spring-
damper applies equal and opposite forces on bodies A and B according
to:

```
f_AP = (k⋅(ℓ - ℓ₀) + c⋅dℓ/dt)⋅r̂
  f_BQ = -f_AP
```

where `ℓ = ‖p_WQ - p_WP‖` is the current length of the spring, dℓ/dt
its rate of change, `r̂ = (p_WQ - p_WP) / ℓ` is the normalized vector
from P to Q, ℓ₀ is the free length of the spring and k and c are the
stiffness and damping of the spring-damper, respectively. This
ForceElement is meant to model finite free length springs attached
between two points. In this typical arrangement springs are usually
pre-loaded, meaning they apply a non-zero spring force in the static
configuration of the system. Thus, neither the free length ℓ₀ nor the
current length ℓ of the spring can ever be zero. The length of the
spring approaching zero would incur in a non-physical configuration
and therefore this element throws a std::runtime_error exception in
that case. Note that: - The applied force is always along the line
connecting points P and Q. - Damping always dissipates energy. -
Forces on bodies A and B are equal and opposite according to Newton's
third law.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::LinearSpringDamper::CalcConservativePower
        struct /* CalcConservativePower */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:97
          const char* doc = R"""()""";

        } CalcConservativePower;

        // drake::multibody::LinearSpringDamper::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:102
          const char* doc = R"""()""";

        } CalcNonConservativePower;

        // drake::multibody::LinearSpringDamper::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:93
          const char* doc = R"""()""";

        } CalcPotentialEnergy;

        // drake::multibody::LinearSpringDamper::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:108
          const char* doc = R"""()""";

        } DoCalcAndAddForceContribution;

        // drake::multibody::LinearSpringDamper::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:114
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/linear_spring_damper.h:117
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::LinearSpringDamper::LinearSpringDamper<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:51
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/linear_spring_damper.h:51
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/linear_spring_damper.h:70
          const char* doc_3 =
R"""(Constructor for a spring-damper between a point P on `bodyA` and a
point Q on `bodyB`. Point P is defined by its position `p_AP` as
measured and expressed in the body frame A and similarly, point Q is
defined by its position p_BQ as measured and expressed in body frame
B. The remaining parameters define:

Parameter ``free_length``:
    The free length of the spring ℓ₀, in meters, at which the spring
    applies no forces. Since this force element is meant to model
    finite length springs, ℓ₀ must be strictly positive.

Parameter ``stiffness``:
    The stiffness k of the spring in N/m. It must be non-negative.

Parameter ``damping``:
    The damping c of the damper in N⋅s/m. It must be non-negative.
    Refer to this class's documentation for further details.

Throws:
    s RuntimeError if `free_length` is negative or zero.

Throws:
    s RuntimeError if `stiffness` is negative.

Throws:
    s RuntimeError if `damping` is negative.)""";

        } ctor;

        // drake::multibody::LinearSpringDamper::bodyA
        struct /* bodyA */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:75
          const char* doc = R"""()""";

        } bodyA;

        // drake::multibody::LinearSpringDamper::bodyB
        struct /* bodyB */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:77
          const char* doc = R"""()""";

        } bodyB;

        // drake::multibody::LinearSpringDamper::damping
        struct /* damping */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:91
          const char* doc = R"""()""";

        } damping;

        // drake::multibody::LinearSpringDamper::free_length
        struct /* free_length */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:87
          const char* doc = R"""()""";

        } free_length;

        // drake::multibody::LinearSpringDamper::p_AP
        struct /* p_AP */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:81
          const char* doc =
R"""(The position p_AP of point P on body A as measured and expressed in
body frame A.)""";

        } p_AP;

        // drake::multibody::LinearSpringDamper::p_BQ
        struct /* p_BQ */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:85
          const char* doc =
R"""(The position p_BQ of point Q on body B as measured and expressed in
body frame B.)""";

        } p_BQ;

        // drake::multibody::LinearSpringDamper::stiffness
        struct /* stiffness */ {

          // drake/multibody/multibody_tree/linear_spring_damper.h:89
          const char* doc = R"""()""";

        } stiffness;

      } LinearSpringDamper;

      // drake::multibody::Mobilizer
      struct /* Mobilizer */ {

        // drake/multibody/multibody_tree/mobilizer.h:223
        const char* doc =
R"""(Mobilizer is a fundamental object within Drake's multibody engine used
to specify the allowed motions between two Frame objects within a
MultibodyTree. Specifying the allowed motions between two Frame
objects effectively also specifies a kinematic relationship between
the two bodies associated with those two frames. Consider the
following example to build a simple pendulum system:

```
MultibodyTree<double> model;
 // ... Code here to setup quantities below as mass, com, X_BP, etc. ...
 const Body<double>& pendulum =
   model.AddBody<RigidBody>(SpatialInertia<double>(mass, com, unit_inertia));
 // We will connect the pendulum body to the world frame using a
 // RevoluteMobilizer. To do so we define a pin frame P rigidly attached to
 // the pendulum body.
 FixedOffsetFrame<double>& pin_frame =
   model.AddFrame<FixedOffsetFrame>(
     pendulum.body_frame(),
     X_BP /* pose of pin frame P in body frame B */);
 // The mobilizer connects the world frame and the pin frame effectively
 // adding the single degree of freedom describing this system. In this
 // regard, the the role of a mobilizer is equivalent but conceptually
 // different than a set of constraints that effectively remove all degrees
 // of freedom but the one permitting rotation about the z-axis.
 const RevoluteMobilizer<double>& revolute_mobilizer =
   model.AddMobilizer<RevoluteMobilizer>(
///     model.world_frame(), /* inboard frame 
///     pin_frame, /* outboard frame 
     Vector3d::UnitZ() /* revolute axis in this case */));
```

<h3>Tree Structure</h3>

A Mobilizer induces a tree structure within a MultibodyTree model,
connecting an inboard (topologically closer to the world) frame to an
outboard (topologically further from the world) frame. Every time a
Mobilizer is added to a MultibodyTree (using the
MultibodyTree::AddMobilizer() method), a number of degrees of freedom
associated with the particular type of Mobilizer are added to the
multibody system. In the example above for the single pendulum, adding
a RevoluteMobilizer has two purposes: - It defines the tree structure
of the model. World is the inboard body while "pendulum" is the
outboard body in the MultibodyTree. - It informs the MultibodyTree of
the degrees of freedom granted by the revolute mobilizer between the
two frames it connects. - It defines a permissible motion space
spanned by the generalized coordinates introduced by the mobilizer.

<h3>Mathematical Description of a Mobilizer</h3>

A Mobilizer describes the kinematics relationship between an inboard
frame F and an outboard frame M, introducing an nq-dimensional vector
of generalized coordinates q and an nv-dimensional vector of
generalized velocities v. Notice that in general `nq != nv`, though
`nq == nv` is a very common case. The kinematic relationships
introduced by a Mobilizer are fully specified by, [Seth 2010]: -
X_FM(q): The pose of the outboard frame M as measured and expressed in
the inboard frame F, as a function of the mobilizer's generalized
positions. This pose is computed by CalcAcrossMobilizerTransform(). -
H_FM(q): the geometric Jacobian matrix describing the relationship
between generalized velocities `v ∈ ℝⁿᵛ` and the spatial velocity
`V_FM ∈ M⁶`. This Jacobian can be thought of as the application: `v ∈
ℝⁿᵛ → M⁶: V_FM(q, v) = H_FM(q) * v`, where M⁶ is the vector space of
"motion vectors" (be aware that while M⁶ is introduced in
[Featherstone 2008, Ch. 2] spatial velocities in Drake are not Plücker
vectors as in Featherstone's book). A Mobilizer implements this
operator in the method CalcAcrossMobilizerSpatialVelocity(). -
H_FMᵀ(q): The transpose of the geometric Jacobian `H_FM(q)` describing
the relationship between the spatial force `F_Mo_F ∈ F⁶` and the
generalized forces `tau ∈ ℝⁿᵛ`, where F⁶ is the vector space of "force
vectors" (be aware that while F⁶ is introduced in [Featherstone 2008,
Ch. 2] spatial forces in Drake are not Plücker vectors as in
Featherstone's book.) This mathematical object can be thought of as
the application: `F_Mo_F ∈ F⁶ → ℝⁿᵛ: tau = H_FMᵀ(q) * F_Mo_F`, where
`Mo` is M's origin (see multibody_frames_and_bodies for the monogram
notation in use.) A Mobilizer implements this operator in the method
ProjectSpatialForce(). - Hdot_FM(q, v): The time derivative of the
Jacobian matrix involved in the computation of the spatial
acceleration `A_FM(q, v, v̇)` between the F and M frames as the
application: `v̇ ∈ ℝⁿᵛ → M⁶: A_FM(q, v, v̇) = H_FM(q) * v̇ + Ḣ_FM(q,
v) * v`. A Mobilizer implements this application in
CalcAcrossMobilizerSpatialAcceleration(). - N(q): The kinematic
coupling matrix describing the relationship between the rate of change
of generalized coordinates and the generalized velocities by `q̇ =
N(q)⋅v`, [Seth 2010]. N(q) is an `nq x nv` matrix. A Mobilizer
implements this application in MapVelocityToQDot(). - N⁺(q): The left
pseudo-inverse of `N(q)`. `N⁺(q)` can be used to invert the
relationship `q̇ = N(q)⋅v` without residual error, provided that `q̇`
is in the range space of `N(q)` (that is, if it *could* have been
produced as `q̇ = N(q)⋅v` for some `v`). The application `v =
N⁺(q)⋅q̇` is implemented in MapQDotToVelocity().

In general, `nv != nq`. As an example, consider a quaternion mobilizer
that would allow frame M to move freely with respect to frame F. For
such a mobilizer the generalized positions vector might contain a
quaternion to describe rotations plus a position vector to describe
translations. However, we might choose the angular velocity `w_FM` and
the linear velocity `v_FM` as the generalized velocities (or more
generally, the spatial velocity `V_FM`.) In such a case `nq = 7` (4
dofs for a quaternion plus 3 dofs for a position vector) and `nv = 6`
(3 dofs for an angular velocity and 3 dofs for a linear velocity).

For a detailed discussion on the concept of a mobilizer please refer
to [Seth 2010]. The Jacobian or "hinge" matrix `H_FM(q)` is introduced
in [Jain 2010], though be aware that what [Jain 2010] calls the hinge
matrix is the transpose of the Jacobian H_FM matrix here in Drake. For
details in the monogram notation used above please refer to
multibody_spatial_algebra.

Mobilizer is an abstract base class defining the minimum functionality
that derived Mobilizer objects must implement in order to fully define
the kinematic relationship between the two frames they connect.
Geometric and analytical Jacobian matrices in the context of
differential kinematics are described in [Sciavicco 2000].

<h4>Relation between the analytical and geometric Jacobians</h4>

The time derivative of the across-mobilizer transform `X_FM` is
intimately related to the across-mobilizer spatial velocity `V_FM`.
This relationship immediately implies a relationship between the
analytical Jacobian `dX_FM/dq` and the geometric Jacobian matrix
`H_FM`. The linear component of the spatial velocity `V_FM` relates to
the time derivative of `X_FM` by:

```
v_FM = V_FM.translational() = dp_FM/dt = Xdot_FM.translational()
```

where `p_FM = X_FM.translational()` and `Xdot_FM = dX_FM/dt`. The time
derivative of `p_FM` can be rewritten as:

```
dp_FM/dt = dp_FM/dq * N(q) * v = Hv_FM * v
```

where `Hv_FM` denotes the last three rows in `H_FM` related with the
translational component of the Jacobian matrix Therefore:

```
Hv_FM = dp_FM/dq(q) * N(q)
```

Similarly, for the rotational component:

```
dR_FM/dt = Xdot_FM.linear() = [w_FM] * R_FM = [Hw_FM * v] * R_FM
```

where `[w_FM]` is the cross product matrix of the across-mobilizer
angular velocity `w_FM`, `R_FM` is the orientation of M in F, and
`Hw_FM` corresponds to the first three rows in `H_FM` related to the
angular component of the geometric Jacobian matrix. The time
derivative of the orientation `R_FM` can be expressed in terms of the
analytic Jacobian of `R_FM` as:

```
dR_FM/dt = dR_FM/dq * N(q) * v
```

These last two equations show that the angular components of the
Jacobian matrix `Hw_FM` are directly related to the gradients of the
rotation matrix `R_FM`. This relationhip is:

```
[Hwi_FM(q)] * R_FM(q) = dR_FM/dqi(q) * N(q)
```

corresponding to the i-th generalized position `qi` where `Hwi_FM(q)`
is the i-th column of `Hw_FM(q)` and `dR_FM/dqi(q)` is the partial
derivative of `R_FM` with respect to the i-th generalized coordinate
for this mobilizer.

<h4>Active forces and power</h4>

The power generated by a mobilizer can be computed in two equivalent
ways. That is, the power can be computed in terms of the spatial force
`F_Mo` and the spatial velocity `V_FM` as:

```
P = F_Moᵀ * V_FM
```

or in terms of the generalized forces `tau = H_FMᵀ(q) * F_Mo` and the
generalized velocities v as:

```
P = tauᵀ * v
```

Notice that spatial forces in the null space of `H_FM(q)` do not
perform any work. Since the result from the previous two expressions
must be equal, the Jacobian operator `H_FM(q)` and the transpose
operator `H_FMᵀ(q)` are constrained by:

```
(H_FMᵀ(q) * F) * v = Fᵀ * (H_FM(q) * v), ∀ v ∈ ℝⁿᵛ ∧ `F ∈ F⁶`
```

Therefore, this enforces a relationship to the operations implemented
by CalcAcrossMobilizerSpatialVelocity() and ProjectSpatialForce() for
any Mobilizer object.

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis
and algorithms. Springer Science & Business Media. - [Seth 2010] Seth,
A., Sherman, M., Eastman, P. and Delp, S., 2010. Minimal formulation
of joint motion for biomechanisms. Nonlinear dynamics, 62(1),
pp.291-303. - [Sciavicco 2000] Sciavicco, L. and Siciliano, B., 2000.
Modelling and control of robot manipulators, 2nd Edn. Springer. -
[Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics
algorithms. Springer.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::Mobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/mobilizer.h:405
          const char* doc =
R"""(Computes the across-mobilizer spatial accelerations `A_FM(q, v, v̇)`
of the outboard frame M in the inboard frame F. This method can be
thought of as the application of the operation `v̇ ∈ ℝⁿᵛ → M⁶: A_FM(q,
v, v̇) = H_FM(q) * v̇ + Ḣ_FM(q) * v`, where `nv` is the number of
generalized velocities of this mobilizer (see num_velocities()) and M⁶
is the vector space of "motion vectors" (be aware that while M⁶ is
introduced in [Featherstone 2008, Ch. 2] spatial vectors in Drake are
not Plücker vectors as in Featherstone's book). Therefore, we say this
method is in its _operator form_; the Jacobian matrix `H_FM(q)` is not
explicitly formed. This method aborts in Debug builds if the dimension
of the input vector of generalized accelerations has a size different
from num_velocities().

Parameter ``context``:
    The context of the parent tree that owns this mobilizer. This
    mobilizer's generalized positions q and generalized velocities v
    are taken from this context.

Parameter ``vdot``:
    The vector of generalized velocities' time derivatives v̇. It must
    live in ℝⁿᵛ.

Returns ``A_FM``:
    The across-mobilizer spatial acceleration of the outboard frame M
    measured and expressed in the inboard frame F.)""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::Mobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/mobilizer.h:378
          const char* doc =
R"""(Computes the across-mobilizer spatial velocity `V_FM(q, v)` of the
outboard frame M in the inboard frame F. This method can be thought of
as the application of the operator `H_FM(q)` to the input vector of
generalized velocities `v`, i.e. the output of this method is the
application `v ∈ ℝⁿᵛ → M⁶: V_FM(q, v) = H_FM(q) * v`, where `nv` is
the number of generalized velocities of this mobilizer (see
num_velocities()) and M⁶ is the vector space of "motion vectors" (be
aware that while M⁶ is introduced in [Featherstone 2008, Ch. 2]
spatial velocities in Drake are not Plücker vectors as in
Featherstone's book). Therefore we say this method is the _operator
form_ of the Jacobian matrix `H_FM(q)`. This method aborts in Debug
builds if the dimension of the input vector of generalized velocities
has a size different from num_velocities().

Parameter ``context``:
    The context of the parent tree that owns this mobilizer. This
    mobilizer's generalized positions q are inferred from this
    context.

Parameter ``v``:
    A vector of generalized velocities. It must live in ℝⁿᵛ.

Returns ``V_FM``:
    The across-mobilizer spatial velocity of the outboard frame M
    measured and expressed in the inboard frame F.)""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::Mobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/mobilizer.h:355
          const char* doc =
R"""(Computes the across-mobilizer transform `X_FM(q)` between the inboard
frame F and the outboard frame M as a function of the vector of
generalized positions `q`. Mobilizer subclasses implementing this
method can retrieve the fixed-size vector of generalized positions for
`this` mobilizer from `context` with:

```
auto q = this->get_positions(context);
```

Additionally, `context` can provide any other parameters the mobilizer
could depend on.)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::Mobilizer::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/mobilizer.h:546
          const char* doc =
R"""(NVI to DoCloneToScalar() templated on the scalar type of the new clone
to be created. This method is mostly intended to be called by
MultibodyTree::CloneToScalar(). Most users should not call this clone
method directly but rather clone the entire parent MultibodyTree if
needed.

See also:
    MultibodyTree::CloneToScalar())""";

        } CloneToScalar;

        // drake::multibody::Mobilizer::CreateBodyNode
        struct /* CreateBodyNode */ {

          // drake/multibody/multibody_tree/mobilizer.h:552
          const char* doc = R"""(For MultibodyTree internal use only.)""";

        } CreateBodyNode;

        // drake::multibody::Mobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/mobilizer.h:568
          const char* doc =
R"""(Clones this Mobilizer (templated on T) to a mobilizer templated on
`double`. @pre Inboard and outboard frames for this mobilizer already
have a clone in `tree_clone`.)""";

          // drake/multibody/multibody_tree/mobilizer.h:575
          const char* doc_2 =
R"""(Clones this Mobilizer (templated on T) to a mobilizer templated on
AutoDiffXd. @pre Inboard and outboard frames for this mobilizer
already have a clone in `tree_clone`.)""";

        } DoCloneToScalar;

        // drake::multibody::Mobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/mobilizer.h:453
          const char* doc =
R"""(Computes the mapping `v = N⁺(q)⋅q̇` from time derivatives of the
generalized positions `qdot` to generalized velocities v, where
`N⁺(q)` is the left pseudo-inverse of `N(q)` defined by
MapVelocityToQDot(). The generalized positions vector is stored in
`context`.)""";

        } MapQDotToVelocity;

        // drake::multibody::Mobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/mobilizer.h:444
          const char* doc =
R"""(Computes the kinematic mapping `q̇ = N(q)⋅v` between generalized
velocities v and time derivatives of the generalized positions `qdot`.
The generalized positions vector is stored in `context`.)""";

        } MapVelocityToQDot;

        // drake::multibody::Mobilizer::Mobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/mobilizer.h:225
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/mobilizer.h:225
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/mobilizer.h:233
          const char* doc_3 =
R"""(The minimum amount of information that we need to define a Mobilizer
is the knowledge of the inboard and outboard frames it connects.
Subclasses of Mobilizer are therefore required to provide this
information in their respective constructors.

Throws:
    s std::runtime_error if `inboard_frame` and `outboard_frame`
    reference the same frame object.)""";

        } ctor;

        // drake::multibody::Mobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/mobilizer.h:436
          const char* doc =
R"""(Projects the spatial force `F_Mo` on `this` mobilizer's outboard frame
M onto the sub-space of motions spanned by the geometric Jacobian
`H_FM(q)` to obtain the generalized forces `tau` (i.e. the active
components of `F_Mo`).

See also:
    CalcAcrossMobilizerSpatialVelocity() and this class' documentation
    for the definition of the geometric Jacobian `H_FM(q)`.

This method can be thought of as the application of the transpose
operator `H_FMᵀ(q)` to the input spatial force `F_Mo_F`, i.e. the
output of this method is the application `F_Mo_F ∈ F⁶ → ℝⁿᵛ: tau =
H_FMᵀ(q) * F_Mo_F`, where `nv` is the number of generalized velocities
of this mobilizer (see num_velocities()) and F⁶ is the vector space of
"force vectors" (be aware that while F⁶ is introduced in [Featherstone
2008, Ch. 2] spatial forces in Drake are not Plücker vectors as in
Featherstone's book). Therefore we say this method is the _operator
form_ of the Jacobian matrix transpose `H_FMᵀ(q)`. This method aborts
in Debug builds if the dimension of the output vector of generalized
forces has a size different from num_velocities().

Parameter ``context``:
    The context of the parent tree that owns this mobilizer. This
    mobilizer's generalized positions q are stored in this context.

Parameter ``F_Mo_F``:
    A SpatialForce applied at `this` mobilizer's outboard frame origin
    `Mo`, expressed in the inboard frame F.

Returns ``tau``:
    The vector of generalized forces. It must live in ℝⁿᵛ.)""";

        } ProjectSpatialForce;

        // drake::multibody::Mobilizer::get_accelerations_from_array
        struct /* get_accelerations_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:509
          const char* doc =
R"""(Returns a const Eigen expression of the vector of generalized
accelerations for `this` mobilizer from a vector `vdot_array` of
generalized accelerations for the entire MultibodyTree model. This
method aborts if the input array is not of size
MultibodyTree::num_velocities().)""";

        } get_accelerations_from_array;

        // drake::multibody::Mobilizer::get_generalized_forces_from_array
        struct /* get_generalized_forces_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:527
          const char* doc =
R"""(Returns a const Eigen expression of the vector of generalized forces
for `this` mobilizer from a vector of generalized forces for the
entire MultibodyTree model. This method aborts if the input array is
not of size MultibodyTree::num_velocities().)""";

        } get_generalized_forces_from_array;

        // drake::multibody::Mobilizer::get_mutable_accelerations_from_array
        struct /* get_mutable_accelerations_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:516
          const char* doc =
R"""(Mutable version of get_accelerations_from_array().)""";

        } get_mutable_accelerations_from_array;

        // drake::multibody::Mobilizer::get_mutable_generalized_forces_from_array
        struct /* get_mutable_generalized_forces_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:534
          const char* doc =
R"""(Mutable version of get_generalized_forces_from_array().)""";

        } get_mutable_generalized_forces_from_array;

        // drake::multibody::Mobilizer::get_mutable_positions_from_array
        struct /* get_mutable_positions_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:472
          const char* doc =
R"""(Mutable version of get_positions_from_array().)""";

        } get_mutable_positions_from_array;

        // drake::multibody::Mobilizer::get_mutable_velocities_from_array
        struct /* get_mutable_velocities_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:494
          const char* doc =
R"""(Mutable version of get_velocities_from_array().)""";

        } get_mutable_velocities_from_array;

        // drake::multibody::Mobilizer::get_positions_from_array
        struct /* get_positions_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:464
          const char* doc =
R"""(Returns a const Eigen expression of the vector of generalized
positions for `this` mobilizer from a vector `q_array` of generalized
positions for the entire MultibodyTree model. @pre ``q_array`` is of
size MultibodyTree::num_positions().)""";

        } get_positions_from_array;

        // drake::multibody::Mobilizer::get_topology
        struct /* get_topology */ {

          // drake/multibody/multibody_tree/mobilizer.h:307
          const char* doc =
R"""(Returns the topology information for this mobilizer. Users should not
need to call this method since MobilizerTopology is an internal
bookkeeping detail.)""";

        } get_topology;

        // drake::multibody::Mobilizer::get_velocities_from_array
        struct /* get_velocities_from_array */ {

          // drake/multibody/multibody_tree/mobilizer.h:486
          const char* doc =
R"""(Returns a const Eigen expression of the vector of generalized
velocities for `this` mobilizer from a vector `v_array` of generalized
velocities for the entire MultibodyTree model. @pre ``v_array`` is of
size MultibodyTree::num_velocities().)""";

        } get_velocities_from_array;

        // drake::multibody::Mobilizer::inboard_body
        struct /* inboard_body */ {

          // drake/multibody/multibody_tree/mobilizer.h:294
          const char* doc =
R"""(Returns a constant reference to the body associated with `this`
mobilizer's inboard frame.)""";

        } inboard_body;

        // drake::multibody::Mobilizer::inboard_frame
        struct /* inboard_frame */ {

          // drake/multibody/multibody_tree/mobilizer.h:283
          const char* doc =
R"""(Returns a constant reference to the inboard frame.)""";

        } inboard_frame;

        // drake::multibody::Mobilizer::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/mobilizer.h:253
          const char* doc =
R"""(Returns the number of generalized coordinates granted by this
mobilizer. As an example, consider RevoluteMobilizer, for which
`num_positions() == 1` since RevoluteMobilizer adds a single
generalized coordinate representing the rotational degree of freedom
about a given axis between the inboard and outboard frames. Another
example would be a 6 DOF "free" mobilizer internally using a
quaternion representation to parameterize free rotations and a
position vector to parameterize free translations; this method would
return 7 (a quaternion plus a position vector).

See also:
    num_velocities())""";

        } num_positions;

        // drake::multibody::Mobilizer::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/mobilizer.h:264
          const char* doc =
R"""(Returns the number of generalized velocities granted by this
mobilizer. Given that all physics occurs in the generalized velocities
space, the number of generalized velocities exactly matches the number
of degrees of freedom granted by the mobilizer. As an example,
consider RevoluteMobilizer, for which `num_velocities() == 1` since
for RevoluteMobilizer its one and only generalized velocity describes
the magnitude of the angular velocity about a given axis between the
inboard and outboard frames.

See also:
    num_positions())""";

        } num_velocities;

        // drake::multibody::Mobilizer::outboard_body
        struct /* outboard_body */ {

          // drake/multibody/multibody_tree/mobilizer.h:300
          const char* doc =
R"""(Returns a constant reference to the body associated with `this`
mobilizer's outboard frame.)""";

        } outboard_body;

        // drake::multibody::Mobilizer::outboard_frame
        struct /* outboard_frame */ {

          // drake/multibody/multibody_tree/mobilizer.h:288
          const char* doc =
R"""(Returns a constant reference to the outboard frame.)""";

        } outboard_frame;

        // drake::multibody::Mobilizer::position_start_in_q
        struct /* position_start_in_q */ {

          // drake/multibody/multibody_tree/mobilizer.h:269
          const char* doc =
R"""(Returns the index to the first generalized position for this mobilizer
within the vector q of generalized positions for the full multibody
system.)""";

        } position_start_in_q;

        // drake::multibody::Mobilizer::set_zero_configuration
        struct /* set_zero_configuration */ {

          // drake/multibody/multibody_tree/mobilizer.h:339
          const char* doc =
R"""(Sets the state stored in `context` to a _zero configuration_ as
defined by set_zero_state(). See set_zero_state() for details.)""";

        } set_zero_configuration;

        // drake::multibody::Mobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/mobilizer.h:333
          const char* doc =
R"""(Sets the `state` to what will be considered to be the _zero_
configuration for `this` mobilizer. For most mobilizers the _zero_
configuration corresponds to the value of generalized positions at
which the inboard frame F and the outboard frame coincide or, in other
words, when `X_FM = Id` is the identity pose. In the general case
however, the zero configuration will correspond to a value of the
generalized positions for which `X_FM = X_FM_ref` where `X_FM_ref` may
generally be different from the identity transformation. In other
words, `X_FM_ref = CalcAcrossMobilizerTransform(ref_context)` where
`ref_context` is a Context storing a State set to the zero
configuration with set_zero_state(). In addition, all generalized
velocities are set to zero in the _zero_ configuration.

Most often the _zero_ configuration will correspond to setting the
vector of generalized positions related to this mobilizer to zero.
However, in the general case, setting all generalized coordinates to
zero does not correspond to the _zero_ configuration and it might even
not represent a mathematicaly valid one. Consider for instance a
quaternion mobilizer, for which its _zero_ configuration corresponds
to the quaternion [1, 0, 0, 0].)""";

        } set_zero_state;

        // drake::multibody::Mobilizer::velocity_start_in_v
        struct /* velocity_start_in_v */ {

          // drake/multibody/multibody_tree/mobilizer.h:277
          const char* doc =
R"""(Returns the index to the first generalized velocity for this mobilizer
within the vector v of generalized velocities for the full multibody
system.)""";

        } velocity_start_in_v;

      } Mobilizer;

      // drake::multibody::MobilizerImpl
      struct /* MobilizerImpl */ {

        // drake/multibody/multibody_tree/mobilizer_impl.h:36
        const char* doc =
R"""(Base class for specific Mobilizer implementations with the number of
generalized positions and velocities resolved at compile time as
template parameters. This allows specific mobilizer implementations to
only work on fixed-size Eigen expressions therefore allowing for
optimized operations on fixed-size matrices. In addition, this layer
discourages the proliferation of dynamic-sized Eigen matrices that
would otherwise lead to run-time dynamic memory allocations.
MobilizerImpl also provides a number of size specific methods to
retrieve multibody quantities of interest from caching structures.
These are common to all mobilizer implementations and therefore they
live in this class. Users should not need to interact with this class
directly unless they need to implement a custom Mobilizer class.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::MobilizerImpl::CreateBodyNode
        struct /* CreateBodyNode */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:56
          const char* doc = R"""(For MultibodyTree internal use only.)""";

        } CreateBodyNode;

        // drake::multibody::MobilizerImpl::GetMultibodyTreeContextOrThrow
        struct /* GetMultibodyTreeContextOrThrow */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:148
          const char* doc =
R"""(Helper method to retrieve a const reference to the
MultibodyTreeContext object referenced by `context`.

Throws:
    s `std::logic_error` if `context` is not a MultibodyTreeContext
    object.)""";

        } GetMultibodyTreeContextOrThrow;

        // drake::multibody::MobilizerImpl::GetMutableMultibodyTreeContextOrThrow
        struct /* GetMutableMultibodyTreeContextOrThrow */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:166
          const char* doc =
R"""(Helper method to retrieve a mutable pointer to the
MultibodyTreeContext object referenced by `context`.

Throws:
    s `std::logic_error` if `context` is not a MultibodyTreeContext
    object.)""";

        } GetMutableMultibodyTreeContextOrThrow;

        // drake::multibody::MobilizerImpl::MobilizerImpl<T, compile_time_num_positions, compile_time_num_velocities>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:38
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/mobilizer_impl.h:38
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/mobilizer_impl.h:45
          const char* doc_3 =
R"""(As with Mobilizer this the only constructor available for this base
class. The minimum amount of information that we need to define a
mobilizer is the knowledge of the inboard and outboard frames it
connects. Subclasses of MobilizerImpl are therefore forced to provide
this information in their respective constructors.)""";

        } ctor;

        // drake::multibody::MobilizerImpl::get_mutable_positions
        struct /* get_mutable_positions */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:79
          const char* doc =
R"""(Helper to return a mutable fixed-size Eigen::VectorBlock referencing
the segment in the state vector corresponding to `this` mobilizer's
state.)""";

          // drake/multibody/multibody_tree/mobilizer_impl.h:100
          const char* doc_2 =
R"""(Helper variant to return a const fixed-size Eigen::VectorBlock
referencing the segment in the `state` corresponding to `this`
mobilizer's generalized positions.)""";

        } get_mutable_positions;

        // drake::multibody::MobilizerImpl::get_mutable_state_vector
        struct /* get_mutable_state_vector */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:87
          const char* doc =
R"""(Returns a mutable reference to the state vector stored in `state` as
an Eigen::VectorBlock<VectorX<T>>.)""";

        } get_mutable_state_vector;

        // drake::multibody::MobilizerImpl::get_mutable_velocities
        struct /* get_mutable_velocities */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:115
          const char* doc =
R"""(Helper variant to return a const fixed-size Eigen::VectorBlock
referencing the segment in the `state` corresponding to `this`
mobilizer's generalized velocities.)""";

          // drake/multibody/multibody_tree/mobilizer_impl.h:137
          const char* doc_2 =
R"""(Helper to return a mutable fixed-size Eigen::VectorBlock referencing
the segment in the state vector corresponding to `this` mobilizer's
state.)""";

        } get_mutable_velocities;

        // drake::multibody::MobilizerImpl::get_positions
        struct /* get_positions */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:71
          const char* doc =
R"""(Helper to return a const fixed-size Eigen::VectorBlock referencing the
segment in the state vector corresponding to `this` mobilizer's state.)""";

        } get_positions;

        // drake::multibody::MobilizerImpl::get_velocities
        struct /* get_velocities */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:129
          const char* doc =
R"""(Helper to return a const fixed-size Eigen::VectorBlock referencing the
segment in the state vector corresponding to `this` mobilizer's state.)""";

        } get_velocities;

        // drake::multibody::MobilizerImpl::kNq
        struct /* kNq */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:65
          const char* doc = R"""()""";

        } kNq;

        // drake::multibody::MobilizerImpl::kNv
        struct /* kNv */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:65
          const char* doc = R"""()""";

        } kNv;

        // drake::multibody::MobilizerImpl::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:50
          const char* doc =
R"""(Returns the number of generalized coordinates granted by this
mobilizer.)""";

        } num_positions;

        // drake::multibody::MobilizerImpl::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:53
          const char* doc =
R"""(Returns the number of generalized velocities granted by this
mobilizer.)""";

        } num_velocities;

        // drake::multibody::MobilizerImpl::set_default_zero_state
        struct /* set_default_zero_state */ {

          // drake/multibody/multibody_tree/mobilizer_impl.h:184
          const char* doc =
R"""(Helper to set `state` to a default zero state with all generalized
positions and generalized velocities related to this mobilizer to
zero. Be aware however that this default does not apply in general to
all mobilizers and specific subclasses (for instance for unit
quaternions) must override this method for correctness.)""";

        } set_default_zero_state;

      } MobilizerImpl;

      // drake::multibody::MobilizerTag
      struct /* MobilizerTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:18
        const char* doc = R"""()""";

      } MobilizerTag;

      // drake::multibody::MobilizerTopology
      struct /* MobilizerTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:137
        const char* doc =
R"""(Data structure to store the topological information associated with a
Mobilizer object. It stores: - Indexes to the inboard/outboard frames
of this mobilizer. - Indexes to the inboard/outboard bodies of this
mobilizer. - Numbers of dofs admitted by this mobilizer. - Indexing
information to retrieve entries from the parent MultibodyTree Context.
Additional information on topology classes is given in this file's
documentation at the top.)""";

        // drake::multibody::MobilizerTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:138
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::MobilizerTopology::MobilizerTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:138
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:138
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:141
          const char* doc_3 =
R"""(Default construction to invalid configuration.)""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:151
          const char* doc_4 =
R"""(Constructs a MobilizerTopology by specifying the the index
`mobilizer_index` for `this` new topology, the indexes to the inboard
and outboard frames the Mobilizer will connect, given by `in_frame`
and `out_frame` respectively, and similarly the inboard and outboard
bodies being connected, given by `in_body` and `out_body`,
respectively. The constructed topology will correspond to that of a
Mobilizer with `num_positions_in` generalized positions and
`num_velocities_in` generalized velocities.)""";

        } ctor;

        // drake::multibody::MobilizerTopology::body_node
        struct /* body_node */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:214
          const char* doc =
R"""(Index to the tree node in the MultibodyTree responsible for this
mobilizer's computations. See the documentation for BodyNodeTopology
for further details on how these computations are organized.)""";

        } body_node;

        // drake::multibody::MobilizerTopology::connects_bodies
        struct /* connects_bodies */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:190
          const char* doc =
R"""(Returns `true` if this MobilizerTopology connects bodies identified by
indexes `body1` and `body2`.)""";

        } connects_bodies;

        // drake::multibody::MobilizerTopology::connects_frames
        struct /* connects_frames */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:183
          const char* doc =
R"""(Returns `true` if this MobilizerTopology connects frames identified by
indexes `frame1` and `frame2`.)""";

        } connects_frames;

        // drake::multibody::MobilizerTopology::inboard_body
        struct /* inboard_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:208
          const char* doc = R"""(Index to the inboard body.)""";

        } inboard_body;

        // drake::multibody::MobilizerTopology::inboard_frame
        struct /* inboard_frame */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:204
          const char* doc = R"""(Index to the inboard frame.)""";

        } inboard_frame;

        // drake::multibody::MobilizerTopology::index
        struct /* index */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:202
          const char* doc = R"""(Unique index in the set of mobilizers.)""";

        } index;

        // drake::multibody::MobilizerTopology::is_weld_mobilizer
        struct /* is_weld_mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:197
          const char* doc =
R"""(Returns `true` if this mobilizer topology corresponds to that of a
weld mobilizer.)""";

        } is_weld_mobilizer;

        // drake::multibody::MobilizerTopology::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:218
          const char* doc =
R"""(Mobilizer indexing info: Set at Finalize() time. Number of generalized
coordinates granted by this mobilizer.)""";

        } num_positions;

        // drake::multibody::MobilizerTopology::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:223
          const char* doc =
R"""(Number of generalized velocities granted by this mobilizer.)""";

        } num_velocities;

        // drake::multibody::MobilizerTopology::outboard_body
        struct /* outboard_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:210
          const char* doc = R"""(Index to the outboard body.)""";

        } outboard_body;

        // drake::multibody::MobilizerTopology::outboard_frame
        struct /* outboard_frame */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:206
          const char* doc = R"""(Index to the outboard frame.)""";

        } outboard_frame;

        // drake::multibody::MobilizerTopology::positions_start
        struct /* positions_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:221
          const char* doc =
R"""(First entry in the global array of states, `x = [q v z]`, for the
parent MultibodyTree.)""";

        } positions_start;

        // drake::multibody::MobilizerTopology::velocities_start
        struct /* velocities_start */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:226
          const char* doc =
R"""(First entry in the global array of states, `x = [q v z]`, for the
parent MultibodyTree.)""";

        } velocities_start;

        // drake::multibody::MobilizerTopology::velocities_start_in_v
        struct /* velocities_start_in_v */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:232
          const char* doc =
R"""(Start index in a vector containing only generalized velocities. It is
also a valid index into a vector of generalized accelerations (which
are the time derivatives of the generalized velocities) and into a
vector of generalized forces.)""";

        } velocities_start_in_v;

      } MobilizerTopology;

      // drake::multibody::ModelInstanceTag
      struct /* ModelInstanceTag */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:35
        const char* doc = R"""()""";

      } ModelInstanceTag;

      // drake::multibody::MultibodyForces
      struct /* MultibodyForces */ {

        // drake/multibody/multibody_tree/multibody_forces.h:28
        const char* doc =
R"""(A class to hold a set of forces applied to a MultibodyTree system.
Forces can include generalized forces as well as body spatial forces.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::MultibodyForces::AddInForces
        struct /* AddInForces */ {

          // drake/multibody/multibody_tree/multibody_forces.h:80
          const char* doc =
R"""(Adds into `this` the force contribution stored in `addend`.)""";

        } AddInForces;

        // drake::multibody::MultibodyForces::CheckHasRightSizeForModel
        struct /* CheckHasRightSizeForModel */ {

          // drake/multibody/multibody_tree/multibody_forces.h:86
          const char* doc =
R"""(Utility that checks that the forces stored by `this` object have the
proper sizes to represent the set of forces for the given `model`.

Returns:
    true if `this` forces object has the proper sizes for the given
    `model`.)""";

        } CheckHasRightSizeForModel;

        // drake::multibody::MultibodyForces::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_forces.h:30
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::MultibodyForces::MultibodyForces<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_forces.h:30
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_forces.h:30
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_forces.h:36
          const char* doc_3 =
R"""(Constructs a force object to store a set of forces to be applied to
`model`. Forces are initialized to zero, meaning no forces are applied
to `model`. `model` must have been already finalized with
MultibodyTree::Finalize() or this constructor will abort.)""";

        } ctor;

        // drake::multibody::MultibodyForces::SetZero
        struct /* SetZero */ {

          // drake/multibody/multibody_tree/multibody_forces.h:39
          const char* doc =
R"""(Sets `this` to store zero forces (no applied forces).)""";

        } SetZero;

        // drake::multibody::MultibodyForces::body_forces
        struct /* body_forces */ {

          // drake/multibody/multibody_tree/multibody_forces.h:70
          const char* doc =
R"""(Returns a constant reference to the vector of spatial body forces
`F_BBo_W` on each body B in the model, at the body's frame origin
`Bo`, expressed in the world frame W.

Note:
    Entries are ordered by BodyNodeIndex.)""";

        } body_forces;

        // drake::multibody::MultibodyForces::generalized_forces
        struct /* generalized_forces */ {

          // drake/multibody/multibody_tree/multibody_forces.h:57
          const char* doc =
R"""(Returns a constant reference to the vector of generalized forces
stored by `this` forces object.)""";

        } generalized_forces;

        // drake::multibody::MultibodyForces::mutable_body_forces
        struct /* mutable_body_forces */ {

          // drake/multibody/multibody_tree/multibody_forces.h:75
          const char* doc = R"""(Mutable version of body_forces().)""";

        } mutable_body_forces;

        // drake::multibody::MultibodyForces::mutable_generalized_forces
        struct /* mutable_generalized_forces */ {

          // drake/multibody/multibody_tree/multibody_forces.h:62
          const char* doc =
R"""(Mutable version of generalized_forces().)""";

        } mutable_generalized_forces;

        // drake::multibody::MultibodyForces::num_bodies
        struct /* num_bodies */ {

          // drake/multibody/multibody_tree/multibody_forces.h:43
          const char* doc =
R"""(Returns the number of bodies for which `this` force object applies.
Determined at construction from the given model MultibodyTree object.)""";

        } num_bodies;

        // drake::multibody::MultibodyForces::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/multibody_forces.h:51
          const char* doc =
R"""(Returns the number of generalized velocities for the model to which
these forces apply. The number of generalized forces in a multibody
model always equals the number of generalized velocities. Determined
at construction from the given model MultibodyTree object.)""";

        } num_velocities;

      } MultibodyForces;

      // drake::multibody::MultibodyTree
      struct /* MultibodyTree */ {

        // drake/multibody/multibody_tree/body.h:114
        const char* doc =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/body_node.h:25
        const char* doc_2 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/fixed_offset_frame.h:16
        const char* doc_3 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/multibody_forces.h:13
        const char* doc_4 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/multibody_tree.h:63
        const char* doc_5 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/multibody_tree_element.h:12
        const char* doc_6 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/rigid_body.h:20
        const char* doc_7 =
R"""(MultibodyTree provides a representation for a physical system
consisting of a collection of interconnected rigid and deformable
bodies. As such, it owns and manages each of the elements that belong
to this physical system. Multibody dynamics elements include bodies,
joints, force elements and constraints.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::MultibodyTree::AddBody
        struct /* AddBody */ {

          // drake/multibody/multibody_tree/multibody_tree.h:109
          const char* doc =
R"""(Takes ownership of `body` and adds it to `this` MultibodyTree. Returns
a constant reference to the body just added, which will remain valid
for the lifetime of `this` MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  const RigidBody<T>& body =
      model.AddBody(std::make_unique<RigidBody<T>>(spatial_inertia));
```

Throws:
    s std::logic_error if `body` is a nullptr.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Parameter ``body``:
    A unique pointer to a body to add to `this` MultibodyTree. The
    body class must be specialized on the same scalar type T as this
    MultibodyTree.

Returns:
    A constant reference of type `BodyType` to the created body. This
    reference which will remain valid for the lifetime of `this`
    MultibodyTree.

Template parameter ``BodyType``:
    The type of the specific sub-class of Body to add. The template
    needs to be specialized on the same scalar type T of this
    MultibodyTree.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:181
          const char* doc_2 =
R"""(Constructs a new body with type `BodyType` with the given `args`, and
adds it to `this` MultibodyTree, which retains ownership. The
`BodyType` will be specialized on the scalar type T of this
MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  // Notice RigidBody is a template on a scalar type.
  const RigidBody<T>& body = model.AddBody<RigidBody>(spatial_inertia);
```

Note that for dependent names you must use the template keyword (say
for instance you have a MultibodyTree<T> member within your custom
class):

```
MultibodyTree<T> model;
  auto body = model.template AddBody<RigidBody>(Args...);
```

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Parameter ``args``:
    The arguments needed to construct a valid Body of type `BodyType`.
    `BodyType` must provide a public constructor that takes these
    arguments.

Returns:
    A constant reference of type `BodyType` to the created body. This
    reference which will remain valid for the lifetime of `this`
    MultibodyTree.

Template parameter ``BodyType``:
    A template for the type of Body to construct. The template will be
    specialized on the scalar type T of this MultibodyTree.)""";

        } AddBody;

        // drake::multibody::MultibodyTree::AddForceElement
        struct /* AddForceElement */ {

          // drake/multibody/multibody_tree/multibody_tree.h:507
          const char* doc =
R"""(Creates and adds to `this` MultibodyTree (which retains ownership) a
new `ForceElement` member with the specific type `ForceElementType`.
The arguments to this method `args` are forwarded to
`ForceElementType`'s constructor.

The newly created `ForceElementType` object will be specialized on the
scalar type T of this MultibodyTree.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:561
          const char* doc_2 =
R"""(Adds a new force element model of type `ForceElementType` to `this`
MultibodyTree. The arguments to this method `args` are forwarded to
`ForceElementType`'s constructor.

Parameter ``args``:
    Zero or more parameters provided to the constructor of the new
    force element. It must be the case that `JointType<T>(args)` is a
    valid constructor.

Template parameter ``ForceElementType``:
    The type of the ForceElement to add. This method can only be
    called once for elements of type UniformGravityFieldElement. That
    is, gravity can only be specified once and std::runtime_error is
    thrown if the model already contains a gravity field element.

Returns:
    A constant reference to the new ForceElement just added, of type
    `ForceElementType<T>` specialized on the scalar type T of `this`
    MultibodyTree. It will remain valid for the lifetime of `this`
    MultibodyTree.

See also:
    The ForceElement class's documentation for further details on how
    a force element is defined.

Throws:
    s RuntimeError if gravity was already added to the model.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:575
          const char* doc_3 = R"""()""";

        } AddForceElement;

        // drake::multibody::MultibodyTree::AddFrame
        struct /* AddFrame */ {

          // drake/multibody/multibody_tree/multibody_tree.h:298
          const char* doc =
R"""(Takes ownership of `frame` and adds it to `this` MultibodyTree.
Returns a constant reference to the frame just added, which will
remain valid for the lifetime of `this` MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Define body and X_BF ...
  const FixedOffsetFrame<T>& frame =
      model.AddFrame(std::make_unique<FixedOffsetFrame<T>>(body, X_BF));
```

Throws:
    s std::logic_error if `frame` is a nullptr.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Parameter ``frame``:
    A unique pointer to a frame to be added to `this` MultibodyTree.
    The frame class must be specialized on the same scalar type T as
    this MultibodyTree.

Returns:
    A constant reference of type `FrameType` to the created frame.
    This reference which will remain valid for the lifetime of `this`
    MultibodyTree.

Template parameter ``FrameType``:
    The type of the specific sub-class of Frame to add. The template
    needs to be specialized on the same scalar type T of this
    MultibodyTree.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:361
          const char* doc_2 =
R"""(Constructs a new frame with type `FrameType` with the given `args`,
and adds it to `this` MultibodyTree, which retains ownership. The
`FrameType` will be specialized on the scalar type T of this
MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Define body and X_BF ...
  // Notice FixedOffsetFrame is a template an a scalar type.
  const FixedOffsetFrame<T>& frame =
      model.AddFrame<FixedOffsetFrame>(body, X_BF);
```

Note that for dependent names you must use the template keyword (say
for instance you have a MultibodyTree<T> member within your custom
class):

```
MultibodyTree<T> model;
  // ... Define body and X_BF ...
  const auto& frame =
      model.template AddFrame<FixedOffsetFrame>(body, X_BF);
```

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Parameter ``args``:
    The arguments needed to construct a valid Frame of type
    `FrameType`. `FrameType` must provide a public constructor that
    takes these arguments.

Returns:
    A constant reference of type `FrameType` to the created frame.
    This reference which will remain valid for the lifetime of `this`
    MultibodyTree.

Template parameter ``FrameType``:
    A template for the type of Frame to construct. The template will
    be specialized on the scalar type T of this MultibodyTree.)""";

        } AddFrame;

        // drake::multibody::MultibodyTree::AddJoint
        struct /* AddJoint */ {

          // drake/multibody/multibody_tree/multibody_tree.h:600
          const char* doc =
R"""(This method adds a Joint of type `JointType` between the frames
specified by the joint.

Parameter ``joint``:
    Joint to be added.

Template parameter ``JointType``:
    The type of the new joint to add, which must be a subclass of
    Joint<T>.

Returns:
    A const lvalue reference to the added joint.

See also:
    The Joint class's documentation for further details on how a Joint
    is defined, or the semi-emplace `AddJoint<>` overload below.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:697
          const char* doc_2 =
R"""(This method helps to create a Joint of type `JointType` between two
bodies. The two bodies connected by this Joint object are referred to
as the _parent_ and _child_ bodies. Although the terms _parent_ and
_child_ are sometimes used synonymously to describe the relationship
between inboard and outboard bodies in multibody models, this usage is
wholly unrelated and implies nothing about the inboard-outboard
relationship between the bodies. As explained in the Joint class's
documentation, in Drake we define a frame F attached to the parent
body P with pose `X_PF` and a frame M attached to the child body B
with pose `X_BM`. This method helps create a joint between two bodies
with fixed poses `X_PF` and `X_BM`. Refer to the Joint class's
documentation for more details.

The arguments to this method `args` are forwarded to `JointType`'s
constructor. The newly created `JointType` object will be specialized
on the scalar type T of this MultibodyTree.

Parameter ``name``:
    The name of the joint.

Parameter ``parent``:
    The parent body connected by the new joint.

Parameter ``X_PF``:
    The fixed pose of frame F attached to the parent body, measured in
    the frame P of that body. `X_PF` is an optional parameter; empty
    curly braces `{}` imply that frame F **is** the same body frame P.
    If instead your intention is to make a frame F with pose `X_PF`,
    provide `Isometry3<double>::Identity()` as your input.

Parameter ``child``:
    The child body connected by the new joint.

Parameter ``X_BM``:
    The fixed pose of frame M attached to the child body, measured in
    the frame B of that body. `X_BM` is an optional parameter; empty
    curly braces `{}` imply that frame M **is** the same body frame B.
    If instead your intention is to make a frame F with pose `X_PF`,
    provide `Isometry3<double>::Identity()` as your input.

Template parameter ``JointType``:
    The type of the new joint to add, which must be a subclass of
    Joint<T>.

Returns:
    A constant reference to the new joint just added, of type
    `JointType<T>` specialized on the scalar type T of `this`
    MultibodyTree. It will remain valid for the lifetime of `this`
    MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
   // ... Code to define a parent body P and a child body B.
   const Body<double>& parent_body =
     model.AddBody<RigidBody>(SpatialInertia<double>(...));
   const Body<double>& child_body =
     model.AddBody<RigidBody>(SpatialInertia<double>(...));
   // Define the pose X_BM of a frame M rigidly atached to child body B.
   const RevoluteJoint<double>& elbow =
     model.AddJoint<RevoluteJoint>(
///       "Elbow",                /* joint name 
///       model.world_body(),     /* parent body 
///       {},                     /* frame F IS the parent body frame P 
///       pendulum,               /* child body, the pendulum 
///       X_BM,                   /* pose of frame M in the body frame B 
///       Vector3d::UnitZ());     /* revolute axis in this case
```

Throws:
    s if `this` model already contains a joint with the given `name`.
    See HasJointNamed(), Joint::name().

See also:
    The Joint class's documentation for further details on how a Joint
    is defined.)""";

        } AddJoint;

        // drake::multibody::MultibodyTree::AddJointActuator
        struct /* AddJointActuator */ {

          // drake/multibody/multibody_tree/multibody_tree.h:745
          const char* doc =
R"""(Creates and adds a JointActuator model for an actuator acting on a
given `joint`. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
`this` MultibodyTree.

Parameter ``name``:
    A string that identifies the new actuator to be added to `this`
    model. An exception is thrown if an actuator with the same name
    already exists in the same model instance as ``joint``. See
    HasJointActuatorNamed().

Parameter ``joint``:
    The Joint to be actuated by the new JointActuator.

Returns:
    A constant reference to the new JointActuator just added, which
    will remain valid for the lifetime of `this` MultibodyTree.

Throws:
    s if `this` model already contains a joint actuator with the given
    `name`. See HasJointActuatorNamed(), JointActuator::get_name().)""";

        } AddJointActuator;

        // drake::multibody::MultibodyTree::AddMobilizer
        struct /* AddMobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree.h:408
          const char* doc =
R"""(Takes ownership of `mobilizer` and adds it to `this` MultibodyTree.
Returns a constant reference to the mobilizer just added, which will
remain valid for the lifetime of `this` MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define inboard and outboard frames by calling
  // MultibodyTree::AddFrame() ...
  const RevoluteMobilizer<T>& pin =
    model.AddMobilizer(std::make_unique<RevoluteMobilizer<T>>(
      inboard_frame, outboard_frame,
      Vector3d::UnitZ() /*revolute axis*/));
```

A Mobilizer effectively connects the two bodies to which the inboard
and outboard frames belong.

Throws:
    s std::logic_error if `mobilizer` is a nullptr.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Throws:
    s a std::runtime_error if the new mobilizer attempts to connect a
    frame with itself.

Throws:
    s std::runtime_error if attempting to connect two bodies with more
    than one mobilizer between them.

Parameter ``mobilizer``:
    A unique pointer to a mobilizer to add to `this` MultibodyTree.
    The mobilizer class must be specialized on the same scalar type T
    as this MultibodyTree. Notice this is a requirement of this
    method's signature and therefore an input mobilzer specialized on
    a different scalar type than that of this MultibodyTree's T will
    fail to compile.

Returns:
    A constant reference of type `MobilizerType` to the created
    mobilizer. This reference which will remain valid for the lifetime
    of `this` MultibodyTree.

Template parameter ``MobilizerType``:
    The type of the specific sub-class of Mobilizer to add. The
    template needs to be specialized on the same scalar type T of this
    MultibodyTree.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:492
          const char* doc_2 =
R"""(Constructs a new mobilizer with type `MobilizerType` with the given
`args`, and adds it to `this` MultibodyTree, which retains ownership.
The `MobilizerType` will be specialized on the scalar type T of this
MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define inboard and outboard frames by calling
  // MultibodyTree::AddFrame() ...
  // Notice RevoluteMobilizer is a template an a scalar type.
  const RevoluteMobilizer<T>& pin =
    model.template AddMobilizer<RevoluteMobilizer>(
      inboard_frame, outboard_frame,
      Vector3d::UnitZ() /*revolute axis*/);
```

Note that for dependent names _only_ you must use the template keyword
(say for instance you have a MultibodyTree<T> member within your
custom class).

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.

Throws:
    s a std::runtime_error if the new mobilizer attempts to connect a
    frame with itself.

Throws:
    s std::runtime_error if attempting to connect two bodies with more
    than one mobilizer between them.

Parameter ``args``:
    The arguments needed to construct a valid Mobilizer of type
    `MobilizerType`. `MobilizerType` must provide a public constructor
    that takes these arguments.

Returns:
    A constant reference of type `MobilizerType` to the created
    mobilizer. This reference which will remain valid for the lifetime
    of `this` MultibodyTree.

Template parameter ``MobilizerType``:
    A template for the type of Mobilizer to construct. The template
    will be specialized on the scalar type T of `this` MultibodyTree.)""";

        } AddMobilizer;

        // drake::multibody::MultibodyTree::AddModelInstance
        struct /* AddModelInstance */ {

          // drake/multibody/multibody_tree/multibody_tree.h:778
          const char* doc =
R"""(Creates a new model instance. Returns the index for a new model
instance (as there is no concrete object beyond the index).

Parameter ``name``:
    A string that uniquely identifies the new instance to be added to
    `this` model. An exception is thrown if an instance with the same
    name already exists in the model. See HasModelInstanceNamed().

Throws:
    s std::logic_error if Finalize() was already called on `this`
    tree.)""";

        } AddModelInstance;

        // drake::multibody::MultibodyTree::AddRigidBody
        struct /* AddRigidBody */ {

          // drake/multibody/multibody_tree/multibody_tree.h:215
          const char* doc =
R"""(Creates a rigid body with the provided name, model instance, and
spatial inertia. This method returns a constant reference to the body
just added, which will remain valid for the lifetime of `this`
MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  ModelInstanceIndex model_instance = model.AddModelInstance("instance");
  const RigidBody<T>& body =
    model.AddRigidBody("BodyName", model_instance, spatial_inertia);
```

Parameter ``name``:
    A string that identifies the new body to be added to `this` model.
    A std::runtime_error is thrown if a body named `name` already is
    part of ``model_instance``. See HasBodyNamed(), Body::name().

Parameter ``model_instance``:
    A model instance index which this body is part of.

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to `this`
    model, computed about the body frame origin `Bo` and expressed in
    the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of `this` MultibodyTree.

Throws:
    s std::logic_error if a body named `name` already exists in this
    model instance.

Throws:
    s std::logic_error if the model instance does not exist.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:261
          const char* doc_2 =
R"""(Creates a rigid body with the provided name, model instance, and
spatial inertia. The newly created body will be placed in the default
model instance. This method returns a constant reference to the body
just added, which will remain valid for the lifetime of `this`
MultibodyTree.

Example of usage:

```
MultibodyTree<T> model;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  const RigidBody<T>& body =
    model.AddRigidBody("BodyName", spatial_inertia);
```

Parameter ``name``:
    A string that identifies the new body to be added to `this` model.
    A std::runtime_error is thrown if a body named `name` already is
    part of the model in the default model instance. See
    HasBodyNamed(), Body::name().

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to `this`
    model, computed about the body frame origin `Bo` and expressed in
    the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of `this` MultibodyTree.

Throws:
    s std::logic_error if a body named `name` already exists.

Throws:
    s std::logic_error if additional model instances have been created
    beyond the world and default instances.)""";

        } AddRigidBody;

        // drake::multibody::MultibodyTree::CalcAccelerationKinematicsCache
        struct /* CalcAccelerationKinematicsCache */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1896
          const char* doc =
R"""(Computes all the kinematic quantities that depend on the generalized
accelerations that is, the generalized velocities' time derivatives,
and stores them in the acceleration kinematics cache `ac`. These
include: - Spatial acceleration `A_WB` for each body B in the model as
measured and expressed in the world frame W.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with `context`.

Parameter ``known_vdot``:
    A vector with the generalized accelerations for the full
    MultibodyTree model.

Parameter ``ac``:
    A pointer to a valid, non nullptr, acceleration kinematics cache.
    This method aborts if `ac` is nullptr.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } CalcAccelerationKinematicsCache;

        // drake::multibody::MultibodyTree::CalcAllBodyPosesInWorld
        struct /* CalcAllBodyPosesInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1565
          const char* doc =
R"""(Computes the world pose `X_WB(q)` of each body B in the model as a
function of the generalized positions q stored in `context`.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q of the model.

Parameter ``X_WB``:
    On output this vector will contain the pose of each body in the
    model ordered by BodyIndex. The index of a body in the model can
    be obtained with Body::index(). This method throws an exception if
    `X_WB` is `nullptr`. Vector `X_WB` is resized when needed to have
    size num_bodies().

Throws:
    s if X_WB is nullptr.)""";

        } CalcAllBodyPosesInWorld;

        // drake::multibody::MultibodyTree::CalcAllBodySpatialVelocitiesInWorld
        struct /* CalcAllBodySpatialVelocitiesInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1584
          const char* doc =
R"""(Computes the spatial velocity `V_WB(q, v)` of each body B in the
model, measured and expressed in the world frame W. The body spatial
velocities are a function of the generalized positions q and
generalized velocities v, both stored in `context`.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q and velocities v of the model.

Parameter ``V_WB``:
    On output this vector will contain the spatial velocity of each
    body in the model ordered by BodyIndex. The index of a body in the
    model can be obtained with Body::index(). This method throws an
    exception if `V_WB` is `nullptr`. Vector `V_WB` is resized when
    needed to have size num_bodies().

///

Throws:
    s if V_WB is nullptr.)""";

        } CalcAllBodySpatialVelocitiesInWorld;

        // drake::multibody::MultibodyTree::CalcArticulatedBodyInertiaCache
        struct /* CalcArticulatedBodyInertiaCache */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2301
          const char* doc =
R"""(Computes all the quantities that are required in the final pass of the
articulated body algorithm and stores them in the articulated body
cache `abc`.

These include: - Articulated body inertia `Pplus_PB_W`, which can be
thought of as the articulated body inertia of parent body P as though
it were inertialess, but taken about Bo and expressed in W.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``abc``:
    A pointer to a valid, non nullptr, articulated body cache. This
    method throws an exception if `abc` is a nullptr.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache() using the same `context`
.)""";

        } CalcArticulatedBodyInertiaCache;

        // drake::multibody::MultibodyTree::CalcBiasTerm
        struct /* CalcBiasTerm */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2202
          const char* doc =
R"""(Computes the bias term `C(q, v)v` containing Coriolis and gyroscopic
effects of the multibody equations of motion:

```
M(q)v̇ + C(q, v)v = tau_app + ∑ J_WBᵀ(q) Fapp_Bo_W
```

where `M(q)` is the multibody model's mass matrix and `tau_app`
consists of a vector applied generalized forces. The last term is a
summation over all bodies in the model where `Fapp_Bo_W` is an applied
spatial force on body B at `Bo` which gets projected into the space of
generalized forces with the geometric Jacobian `J_WB(q)` which maps
generalized velocities into body B spatial velocity as `V_WB =
J_WB(q)v`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model. It
    stores the generalized positions q and the generalized velocities
    v.

Parameter ``Cv``:
    On output, `Cv` will contain the product `C(q, v)v`. It must be a
    valid (non-null) pointer to a column vector in `ℛⁿ` with n the
    number of generalized velocities (num_velocities()) of the model.
    This method aborts if Cv is nullptr or if it does not have the
    proper size.)""";

        } CalcBiasTerm;

        // drake::multibody::MultibodyTree::CalcConservativePower
        struct /* CalcConservativePower */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2147
          const char* doc =
R"""(Computes and returns the power generated by conservative forces in the
multibody model. This quantity is defined to be positive when the
potential energy is decreasing. In other words, if `U(q)` is the
potential energy as defined by CalcPotentialEnergy(), then the
conservative power, `Pc`, is `Pc = -U̇(q)`.

See also:
    CalcPotentialEnergy())""";

        } CalcConservativePower;

        // drake::multibody::MultibodyTree::CalcForceElementsContribution
        struct /* CalcForceElementsContribution */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2127
          const char* doc =
R"""(Computes the combined force contribution of ForceElement objects in
the model. A ForceElement can apply forces as a spatial force per body
or as generalized forces, depending on the ForceElement model.
Therefore this method provides outputs for both spatial forces per
body (with `F_Bo_W_array`) and generalized forces (with `tau_array`).
ForceElement contributions are a function of the state and time only.
The output from this method can immediately be used as input to
CalcInverseDynamics() to include the effect of applied forces by force
elements.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with `context`.

Parameter ``forces``:
    A pointer to a valid, non nullptr, multibody forces object. On
    output `forces` will store the forces exerted by all the
    ForceElement objects in the model. This method will abort if the
    `forces` pointer is null or if the forces object is not compatible
    with `this` MultibodyTree, see MultibodyForces::CheckInvariants().

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } CalcForceElementsContribution;

        // drake::multibody::MultibodyTree::CalcFrameGeometricJacobianExpressedInWorld
        struct /* CalcFrameGeometricJacobianExpressedInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1819
          const char* doc =
R"""(Given a frame F with fixed position `p_BoFo_B` in a frame B, this
method computes the geometric Jacobian `Jv_WF` defined by:

```
V_WF(q, v) = Jv_WF(q)⋅v
```

where `V_WF(q, v)` is the spatial velocity of frame F measured and
expressed in the world frame W and q and v are the vectors of
generalized position and velocity, respectively. Since the spatial
velocity of frame F is linear in the generalized velocities, the
geometric Jacobian `Jv_WF` is a function of the generalized
coordinates q only.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q.

Parameter ``frame_B``:
    The position `p_BoFo_B` of frame F is measured and expressed in
    this frame B.

Parameter ``p_BoFo_B``:
    The (fixed) position of frame F as measured and expressed in frame
    B.

Parameter ``Jv_WF``:
    The geometric Jacobian `Jv_WF(q)`, function of the generalized
    positions q only. This Jacobian relates to the spatial velocity
    `V_WF` of frame F by:

```
V_WF(q, v) = Jv_WF(q)⋅v
```

Therefore `Jv_WF` is a matrix of size `6 x nv`, with `nv` the number
of generalized velocities. On input, matrix `Jv_WF` **must** have size
`6 x nv` or this method throws an exception. The top rows of this
matrix (which can be accessed with Jv_WF.topRows<3>()) is the Jacobian
`Hw_WF` related to the angular velocity of F in W by `w_WF = Hw_WF⋅v`.
The bottom rows of this matrix (which can be accessed with
Jv_WF.bottomRows<3>()) is the Jacobian `Hv_WF` related to the
translational velocity of the origin of frame F in W by `v_WFo =
Hw_WF⋅v`. This ordering is consistent with the internal storage of the
SpatialVector class. Therefore the following operations results in a
valid spatial velocity:

```
SpatialVelocity<double> Jv_WF_times_v(Jv_WF * v);
```

Throws:
    s if `J_WF` is nullptr or if it is not of size `6 x nv`.)""";

        } CalcFrameGeometricJacobianExpressedInWorld;

        // drake::multibody::MultibodyTree::CalcGravityGeneralizedForces
        struct /* CalcGravityGeneralizedForces */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2227
          const char* doc =
R"""(Computes the generalized forces `tau_g(q)` due to gravity as a
function of the generalized positions `q` stored in the input
`context`. The vector of generalized forces due to gravity `tau_g(q)`
is defined such that it appears on the right hand side of the
equations of motion together with any other generalized forces, like
so:

```
Mv̇ + C(q, v)v = tau_g(q) + tau_app
```

where `tau_app` includes any other generalized forces applied on the
system.

Parameter ``context``:
    The context storing the state of the multibody model.

Returns:
    tau_g A vector containing the generalized forces due to gravity.
    The generalized forces are consistent with the vector of
    generalized velocities `v` for `this` MultibodyTree model so that
    the inner product `v⋅tau_g` corresponds to the power applied by
    the gravity forces on the mechanical system. That is, `v⋅tau_g >
    0` corresponds to potential energy going into the system, as
    either mechanical kinetic energy, some other potential energy, or
    heat, and therefore to a decrease of the gravitational potential
    energy.)""";

        } CalcGravityGeneralizedForces;

        // drake::multibody::MultibodyTree::CalcInverseDynamics
        struct /* CalcInverseDynamics */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1977
          const char* doc =
R"""(Given the state of `this` MultibodyTree in `context` and a known
vector of generalized accelerations `vdot`, this method computes the
set of generalized forces `tau` that would need to be applied in order
to attain the specified generalized accelerations. Mathematically,
this method computes:

```
tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
```

where `M(q)` is the MultibodyTree mass matrix, `C(q, v)v` is the bias
term containing Coriolis and gyroscopic effects and `tau_app` consists
of a vector applied generalized forces. The last term is a summation
over all bodies in the model where `Fapp_Bo_W` is an applied spatial
force on body B at `Bo` which gets projected into the space of
generalized forces with the geometric Jacobian `J_WB(q)` which maps
generalized velocities into body B spatial velocity as `V_WB =
J_WB(q)v`. This method does not compute explicit expressions for the
mass matrix nor for the bias term, which would be of at least `O(n²)`
complexity, but it implements an `O(n)` Newton-Euler recursive
algorithm, where n is the number of bodies in the MultibodyTree. The
explicit formation of the mass matrix `M(q)` would require the
calculation of `O(n²)` entries while explicitly forming the product
`C(q, v) * v` could require up to `O(n³)` operations (see
[Featherstone 1987, §4]), depending on the implementation. The
recursive Newton-Euler algorithm is the most efficient currently known
general method for solving inverse dynamics [Featherstone 2008].

Parameter ``context``:
    The context containing the state of the model.

Parameter ``known_vdot``:
    A vector with the known generalized accelerations `vdot` for the
    full MultibodyTree model. Use the provided Joint APIs in order to
    access entries into this array.

Parameter ``external_forces``:
    A set of forces to be applied to the system either as body spatial
    forces `Fapp_Bo_W` or generalized forces `tau_app`, see
    MultibodyForces for details.

Returns:
    the vector of generalized forces that would need to be applied to
    the mechanical system in order to achieve the desired acceleration
    given by `known_vdot`.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:2087
          const char* doc_2 =
R"""((Advanced) Given the state of `this` MultibodyTree in `context` and a
known vector of generalized accelerations `vdot`, this method computes
the set of generalized forces `tau` that would need to be applied at
each Mobilizer in order to attain the specified generalized
accelerations. Mathematically, this method computes:

```
tau = M(q)v̇ + C(q, v)v - tau_app - ∑ J_WBᵀ(q) Fapp_Bo_W
```

where `M(q)` is the MultibodyTree mass matrix, `C(q, v)v` is the bias
term containing Coriolis and gyroscopic effects and `tau_app` consists
of a vector applied generalized forces. The last term is a summation
over all bodies in the model where `Fapp_Bo_W` is an applied spatial
force on body B at `Bo` which gets projected into the space of
generalized forces with the geometric Jacobian `J_WB(q)` which maps
generalized velocities into body B spatial velocity as `V_WB =
J_WB(q)v`. This method does not compute explicit expressions for the
mass matrix nor for the bias term, which would be of at least `O(n²)`
complexity, but it implements an `O(n)` Newton-Euler recursive
algorithm, where n is the number of bodies in the MultibodyTree. The
explicit formation of the mass matrix `M(q)` would require the
calculation of `O(n²)` entries while explicitly forming the product
`C(q, v) * v` could require up to `O(n³)` operations (see
[Featherstone 1987, §4]), depending on the implementation. The
recursive Newton-Euler algorithm is the most efficient currently known
general method for solving inverse dynamics [Featherstone 2008].

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with `context`.

Parameter ``known_vdot``:
    A vector with the known generalized accelerations `vdot` for the
    full MultibodyTree model. Use
    Mobilizer::get_accelerations_from_array() to access entries into
    this array for a particular Mobilizer. You can use the mutable
    version of this method to write into this array.

Parameter ``Fapplied_Bo_W_array``:
    A vector containing the spatial force `Fapplied_Bo_W` applied on
    each body at the body's frame origin `Bo` and expressed in the
    world frame W. `Fapplied_Bo_W_array` can have zero size which
    means there are no applied forces. To apply non-zero forces,
    `Fapplied_Bo_W_array` must be of size equal to the number of
    bodies in `this` MultibodyTree model. This array must be ordered
    by BodyNodeIndex, which for a given body can be retrieved with
    Body::node_index(). This method will abort if provided with an
    array that does not have a size of either `num_bodies()` or zero.

Parameter ``tau_applied_array``:
    An array of applied generalized forces for the entire model. For a
    given mobilizer, entries in this array can be accessed using the
    method Mobilizer::get_generalized_forces_from_array() while its
    mutable counterpart,
    Mobilizer::get_mutable_generalized_forces_from_array(), allows
    writing into this array. `tau_applied_array` can have zero size,
    which means there are no applied forces. To apply non-zero forces,
    `tau_applied_array` must be of size equal to the number to the
    number of generalized velocities in the model, see
    MultibodyTree::num_velocities(). This method will abort if
    provided with an array that does not have a size of either
    MultibodyTree::num_velocities() or zero.

Parameter ``A_WB_array``:
    A pointer to a valid, non nullptr, vector of spatial accelerations
    containing the spatial acceleration `A_WB` for each body. It must
    be of size equal to the number of bodies. This method will abort
    if the the pointer is null or if `A_WB_array` is not of size
    `num_bodies()`. On output, entries will be ordered by
    BodyNodeIndex. To access the acceleration `A_WB` of given body B
    in this array, use the index returned by Body::node_index().

Parameter ``F_BMo_W_array``:
    A pointer to a valid, non nullptr, vector of spatial forces
    containing, for each body B, the spatial force `F_BMo_W`
    corresponding to its inboard mobilizer reaction forces on body B
    applied at the origin `Mo` of the inboard mobilizer, expressed in
    the world frame W. It must be of size equal to the number of
    bodies in the MultibodyTree. This method will abort if the the
    pointer is null or if `F_BMo_W_array` is not of size
    `num_bodies()`. On output, entries will be ordered by
    BodyNodeIndex. To access a mobilizer's reaction force on given
    body B in this array, use the index returned by
    Body::node_index().

Parameter ``tau_array``:
    On output this array will contain the generalized forces that must
    be applied in order to achieve the desired generalized
    accelerations given by the input argument `known_vdot`. It must
    not be nullptr and it must be of size
    MultibodyTree::num_velocities(). Generalized forces for each
    Mobilizer can be accessed with
    Mobilizer::get_generalized_forces_from_array().

@warning There is no mechanism to assert that either `A_WB_array` nor
`F_BMo_W_array` are ordered by BodyNodeIndex. You can use
Body::node_index() to obtain the node index for a given body.

Note:
    This method uses `F_BMo_W_array` and `tau_array` as the only local
    temporaries and therefore no additional dynamic memory allocation
    is performed.

@warning `F_BMo_W_array` (`tau_array`) and `Fapplied_Bo_W_array`
(`tau_applied_array`) can actually be the same array in order to
reduce memory footprint and/or dynamic memory allocations. However the
information in `Fapplied_Bo_W_array` (`tau_applied_array`) would be
overwritten through `F_BMo_W_array` (`tau_array`). Make a copy if data
must be preserved.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } CalcInverseDynamics;

        // drake::multibody::MultibodyTree::CalcMassMatrixViaInverseDynamics
        struct /* CalcMassMatrixViaInverseDynamics */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2179
          const char* doc =
R"""(Performs the computation of the mass matrix `M(q)` of the model using
inverse dynamics, where the generalized positions q are stored in
`context`. See CalcInverseDynamics().

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``H``:
    A valid (non-null) pointer to a squared matrix in `ℛⁿˣⁿ` with n
    the number of generalized velocities (num_velocities()) of the
    model. This method aborts if H is nullptr or if it does not have
    the proper size.

The algorithm used to build `M(q)` consists in computing one column of
`M(q)` at a time using inverse dynamics. The result from inverse
dynamics, with no applied forces, is the vector of generalized forces:

```
tau = M(q)v̇ + C(q, v)v
```

where q and v are the generalized positions and velocities,
respectively. When `v = 0` the Coriolis and gyroscopic forces term
`C(q, v)v` is zero. Therefore the `i-th` column of `M(q)` can be
obtained performing inverse dynamics with an acceleration vector `v̇ =
eᵢ`, with `eᵢ` the standard (or natural) basis of `ℛⁿ` with n the
number of generalized velocities. We write this as:

```
H.ᵢ(q) = M(q) * e_i
```

where `H.ᵢ(q)` (notice the dot for the rows index) denotes the `i-th`
column in M(q).

@warning This is an O(n²) algorithm. Avoid the explicit computation of
the mass matrix whenever possible.)""";

        } CalcMassMatrixViaInverseDynamics;

        // drake::multibody::MultibodyTree::CalcPointsGeometricJacobianExpressedInWorld
        struct /* CalcPointsGeometricJacobianExpressedInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1729
          const char* doc =
R"""(Given a set of points `Qi` with fixed position vectors `p_BQi` in a
frame B, (that is, their time derivative `ᴮd/dt(p_BQi)` in frame B is
zero), this method computes the geometric Jacobian `Jv_WQi` defined
by:

```
v_WQi(q, v) = Jv_WQi(q)⋅v
```

where `p_WQi` is the position vector in the world frame for each point
`Qi` in the input set, `v_WQi(q, v)` is the translational velocity of
point `Qi` in the world frame W and q and v are the vectors of
generalized position and velocity, respectively. Since the spatial
velocity of each point `Qi` is linear in the generalized velocities,
the geometric Jacobian `Jv_WQi` is a function of the generalized
coordinates q only.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q.

Parameter ``frame_B``:
    The positions `p_BQi` of each point in the input set are measured
    and expressed in this frame B and are constant (fixed) in this
    frame.

Parameter ``p_BQi_set``:
    A matrix with the fixed position of a set of points `Qi` measured
    and expressed in `frame_B`. Each column of this matrix contains
    the position vector `p_BQi` for a point `Qi` measured and
    expressed in frame B. Therefore this input matrix lives in ℝ³ˣⁿᵖ
    with `np` the number of points in the set.

Parameter ``p_WQi_set``:
    The output positions of each point `Qi` now computed as measured
    and expressed in frame W. These positions are computed in the
    process of computing the geometric Jacobian `J_WQi` and therefore
    external storage must be provided. The output `p_WQi_set` **must**
    have the same size as the input set `p_BQi_set` or otherwise this
    method throws a std::runtime_error exception. That is `p_WQi_set`
    **must** be in `ℝ³ˣⁿᵖ`.

Parameter ``Jv_WQi``:
    The geometric Jacobian `Jv_WQi(q)`, function of the generalized
    positions q only. This Jacobian relates the translational velocity
    `v_WQi` of each point `Qi` in the input set by:

```
`v_WQi(q, v) = Jv_WQi(q)⋅v`
```

so that `v_WQi` is a column vector of size `3⋅np` concatenating the
velocity of all points `Qi` in the same order they were given in the
input set. Therefore `J_WQi` is a matrix of size `3⋅np x nv`, with
`nv` the number of generalized velocities. On input, matrix `J_WQi`
**must** have size `3⋅np x nv` or this method throws a
std::runtime_error exception.

Throws:
    s an exception if the output `p_WQi_set` is nullptr or does not
    have the same size as the input array `p_BQi_set`.

Throws:
    s an exception if `Jv_WQi` is nullptr or if it does not have the
    appropriate size, see documentation for `Jv_WQi` for details.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1774
          const char* doc_2 =
R"""(This is a variant to compute the geometric Jacobian `Jv_WQi` for a set
of points `Qi` moving with `frame_B`, given that we know the position
`p_WQi` of each point in the set measured and expressed in the world
frame W. The geometric Jacobian `Jv_WQi` is defined such that:

```
v_WQi(q, v) = Jv_WQi(q)⋅v
```

where `v_WQi(q, v)` is the translational velocity of point `Qi` in the
world frame W and q and v are the vectors of generalized position and
velocity, respectively. Since the spatial velocity of each point `Qi`
is linear in the generalized velocities, the geometric Jacobian
`Jv_WQi` is a function of the generalized coordinates q only.

Parameter ``context``:
    The context containing the state of the model. It stores the
    generalized positions q.

Parameter ``frame_B``:
    Points `Qi` in the set instantaneously move with this frame.

Parameter ``p_WQi_set``:
    A matrix with the fixed position of a set of points `Qi` measured
    and expressed in the world frame W. Each column of this matrix
    contains the position vector `p_WQi` for a point `Qi` measured and
    expressed in the world frame W. Therefore this input matrix lives
    in ℝ³ˣⁿᵖ with `np` the number of points in the set.

Parameter ``Jv_WQi``:
    The geometric Jacobian `Jv_WQi(q)`, function of the generalized
    positions q only. This Jacobian relates the translational velocity
    `v_WQi` of each point `Qi` in the input set by:

```
`v_WQi(q, v) = Jv_WQi(q)⋅v`
```

so that `v_WQi` is a column vector of size `3⋅np` concatenating the
velocity of all points `Qi` in the same order they were given in the
input set. Therefore `J_WQi` is a matrix of size `3⋅np x nv`, with
`nv` the number of generalized velocities. On input, matrix `J_WQi`
**must** have size `3⋅np x nv` or this method throws a
std::runtime_error exception.

Throws:
    s an exception if `Jv_WQi` is nullptr or if it does not have the
    appropriate size, see documentation for `Jv_WQi` for details.)""";

        } CalcPointsGeometricJacobianExpressedInWorld;

        // drake::multibody::MultibodyTree::CalcPointsPositions
        struct /* CalcPointsPositions */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1637
          const char* doc =
R"""(Given the positions `p_BQi` for a set of points `Qi` measured and
expressed in a frame B, this method computes the positions `p_AQi(q)`
of each point `Qi` in the set as measured and expressed in another
frame A, as a function of the generalized positions q of the model.

Parameter ``context``:
    The context containing the state of the MultibodyTree model. It
    stores the generalized positions q of the model.

Parameter ``frame_B``:
    The frame B in which the positions `p_BQi` of a set of points `Qi`
    are given.

Parameter ``p_BQi``:
    The input positions of each point `Qi` in frame B. `p_BQi ∈ ℝ³ˣⁿᵖ`
    with `np` the number of points in the set. Each column of `p_BQi`
    corresponds to a vector in ℝ³ holding the position of one of the
    points in the set as measured and expressed in frame B.

Parameter ``frame_A``:
    The frame A in which it is desired to compute the positions
    `p_AQi` of each point `Qi` in the set.

Parameter ``p_AQi``:
    The output positions of each point `Qi` now computed as measured
    and expressed in frame A. The output `p_AQi` **must** have the
    same size as the input `p_BQi` or otherwise this method aborts.
    That is `p_AQi` **must** be in `ℝ³ˣⁿᵖ`.

Note:
    Both `p_BQi` and `p_AQi` must have three rows. Otherwise this
    method will throw a std::runtime_error exception. This method also
    throws a std::runtime_error exception if `p_BQi` and `p_AQi`
    differ in the number of columns.)""";

        } CalcPointsPositions;

        // drake::multibody::MultibodyTree::CalcPositionKinematicsCache
        struct /* CalcPositionKinematicsCache */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1849
          const char* doc =
R"""(Computes into the position kinematics `pc` all the kinematic
quantities that depend on the generalized positions only. These
include: - For each body B, the pose `X_BF` of each of the frames F
attached to body B. - Pose `X_WB` of each body B in the model as
measured and expressed in the world frame W. - Across-mobilizer
Jacobian matrices `H_FM` and `H_PB_W`. - Body specific quantities such
as `com_W` and `M_Bo_W`.

Aborts if `pc` is nullptr.)""";

        } CalcPositionKinematicsCache;

        // drake::multibody::MultibodyTree::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2138
          const char* doc =
R"""(Computes and returns the total potential energy stored in `this`
multibody model for the configuration given by `context`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Returns:
    The total potential energy stored in `this` multibody model.)""";

        } CalcPotentialEnergy;

        // drake::multibody::MultibodyTree::CalcRelativeTransform
        struct /* CalcRelativeTransform */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1604
          const char* doc =
R"""(Computes the relative transform `X_AB(q)` from a frame B to a frame A,
as a function of the generalized positions q of the model. That is,
the position `p_AQ` of a point Q measured and expressed in frame A can
be computed from the position `p_BQ` of this point measured and
expressed in frame B using the transformation `p_AQ = X_AB⋅p_BQ`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model. It
    stores the generalized positions q of the model.

Parameter ``frame_A``:
    The target frame A in the computed relative transform `X_AB`.

Parameter ``frame_B``:
    The source frame B in the computed relative transform `X_AB`.

Returns ``X_AB``:
    The relative transform from frame B to frame A, such that `p_AQ =
    X_AB⋅p_BQ`.)""";

        } CalcRelativeTransform;

        // drake::multibody::MultibodyTree::CalcSpatialAccelerationsFromVdot
        struct /* CalcSpatialAccelerationsFromVdot */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1932
          const char* doc =
R"""(Given the state of `this` MultibodyTree in `context` and a known
vector of generalized accelerations `known_vdot`, this method computes
the spatial acceleration `A_WB` for each body as measured and
expressed in the world frame W.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``pc``:
    A position kinematics cache object already updated to be in sync
    with `context`.

Parameter ``vc``:
    A velocity kinematics cache object already updated to be in sync
    with `context`.

Parameter ``known_vdot``:
    A vector with the generalized accelerations for the full
    MultibodyTree model.

Parameter ``A_WB_array``:
    A pointer to a valid, non nullptr, vector of spatial accelerations
    containing the spatial acceleration `A_WB` for each body. It must
    be of size equal to the number of bodies in the MultibodyTree.
    This method will abort if the the pointer is null or if
    `A_WB_array` is not of size `num_bodies()`. On output, entries
    will be ordered by BodyNodeIndex. These accelerations can be read
    in the proper order with
    Body::get_from_spatial_acceleration_array().

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache(). @pre The velocity
kinematics `vc` must have been previously updated with a call to
CalcVelocityKinematicsCache().)""";

        } CalcSpatialAccelerationsFromVdot;

        // drake::multibody::MultibodyTree::CalcVelocityKinematicsCache
        struct /* CalcVelocityKinematicsCache */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1865
          const char* doc =
R"""(Computes all the kinematic quantities that depend on the generalized
velocities and stores them in the velocity kinematics cache `vc`.
These include: - Spatial velocity `V_WB` for each body B in the model
as measured and expressed in the world frame W. - Spatial velocity
`V_PB` for each body B in the model as measured and expressed in the
inboard (or parent) body frame P.

@pre The position kinematics `pc` must have been previously updated
with a call to CalcPositionKinematicsCache().

Aborts if `vc` is nullptr.)""";

        } CalcVelocityKinematicsCache;

        // drake::multibody::MultibodyTree::Clone
        struct /* Clone */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2378
          const char* doc =
R"""(Creates a deep copy of `this` MultibodyTree templated on the same
scalar type T as `this` tree.)""";

        } Clone;

        // drake::multibody::MultibodyTree::CloneToScalar
        struct /* CloneToScalar */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2424
          const char* doc =
R"""(Creates a deep copy of `this` MultibodyTree templated on the scalar
type `ToScalar`. The new deep copy is guaranteed to have exactly the
same MultibodyTreeTopology as the original tree the method is called
on. This method ensures the following cloning order: - Body objects,
and their corresponding BodyFrame objects. - Frame objects. - If a
Frame is attached to another frame, its parent frame is guaranteed to
be created first. - Mobilizer objects are created last and therefore
clones of the original Frame objects are guaranteed to already be part
of the cloned tree.

Consider the following code example:

```
// The user creates a model.
  MultibodyTree<double> model;
  // User adds a body and keeps a reference to it.
  const RigidBody<double>& body = model.AddBody<RigidBody>(...);
  // User creates an AutoDiffXd variant, where ToScalar = AutoDiffXd.
  std::unique_ptr<MultibodyTree<AutoDiffXd>> model_autodiff =
      model.CloneToScalar<AutoDiffXd>();
  // User retrieves the AutoDiffXd variant corresponding to the original
  // body added above.
  const RigidBody<AutoDiffXd>&
      body_autodiff = model_autodiff.get_variant(body);
```

MultibodyTree::get_variant() is templated on the multibody element
type which is deduced from its only input argument. The returned
element is templated on the scalar type T of the MultibodyTree on
which this method is invoked. In the example above, the user could
have also invoked the method ToAutoDiffXd().

@pre Finalize() must have already been called on this MultibodyTree.)""";

        } CloneToScalar;

        // drake::multibody::MultibodyTree::CreateDefaultContext
        struct /* CreateDefaultContext */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1474
          const char* doc =
R"""(Allocates a new context for this MultibodyTree uniquely identifying
the state of the multibody system.

@pre The method Finalize() must be called before attempting to create
a context in order for the MultibodyTree topology to be valid at the
moment of allocation.

Throws:
    s std::logic_error If users attempt to call this method on a
    MultibodyTree with an invalid topology.)""";

        } CreateDefaultContext;

        // drake::multibody::MultibodyTree::EvalBodyPoseInWorld
        struct /* EvalBodyPoseInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1653
          const char* doc =
R"""(Evaluate the pose `X_WB` of a body B in the world frame W.

Parameter ``context``:
    The context storing the state of the MultibodyTree model.

Parameter ``body_B``:
    The body B for which the pose is requested.

Returns ``X_WB``:
    The pose of body frame B in the world frame W.

Throws:
    s if Finalize() was not called on `this` model or if `body_B` does
    not belong to this model.)""";

        } EvalBodyPoseInWorld;

        // drake::multibody::MultibodyTree::EvalBodySpatialVelocityInWorld
        struct /* EvalBodySpatialVelocityInWorld */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1666
          const char* doc =
R"""(Evaluate the spatial velocity `V_WB` of a body B in the world frame W.

Parameter ``context``:
    The context storing the state of the MultibodyTree model.

Parameter ``body_B``:
    The body B for which the spatial velocity is requested.

Returns:
    V_WB The spatial velocity of body frame B in the world frame W.

Throws:
    s if Finalize() was not called on `this` model or if `body_B` does
    not belong to this model.)""";

        } EvalBodySpatialVelocityInWorld;

        // drake::multibody::MultibodyTree::EvalPositionKinematics
        struct /* EvalPositionKinematics */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2490
          const char* doc =
R"""(Evaluates position kinematics cached in context.

Parameter ``context``:
    A MultibodyTreeContext on which to update position kinematics.

Returns:
    Reference to the PositionKinematicsCache of context.)""";

        } EvalPositionKinematics;

        // drake::multibody::MultibodyTree::EvalVelocityKinematics
        struct /* EvalVelocityKinematics */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2497
          const char* doc =
R"""(Evaluates velocity kinematics cached in context.

Parameter ``context``:
    A MultibodyTreeContext on which to update velocity kinematics.

Returns:
    Reference to the VelocityKinematicsCache of context.)""";

        } EvalVelocityKinematics;

        // drake::multibody::MultibodyTree::Finalize
        struct /* Finalize */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1463
          const char* doc =
R"""(This method must be called after all elements in the tree (joints,
bodies, force elements, constraints) were added and before any
computations are performed. It essentially compiles all the necessary
"topological information", i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required pre-
processing to perform computations at a later stage.

If the finalize stage is successful, the topology of this
MultibodyTree is validated, meaning that the topology is up-to-date
after this call. No more multibody tree elements can be added after a
call to Finalize().

Throws:
    s RuntimeError if called post-finalize.)""";

        } Finalize;

        // drake::multibody::MultibodyTree::GetBodyByName
        struct /* GetBodyByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1136
          const char* doc =
R"""(Returns a constant reference to a body that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no body with the requested name.

Throws:
    s std::logic_error if the body name occurs in multiple model
    instances.

See also:
    HasBodyNamed() to query if there exists a body in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1148
          const char* doc_2 =
R"""(Returns a constant reference to the body that is uniquely identified
by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no body with the requested name.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasBodyNamed() to query if there exists a body in `this` model
    with a given specified name.)""";

        } GetBodyByName;

        // drake::multibody::MultibodyTree::GetFrameByName
        struct /* GetFrameByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1170
          const char* doc =
R"""(Returns a constant reference to a frame that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no frame with the requested name.

Throws:
    s std::logic_error if the frame name occurs in multiple model
    instances.

See also:
    HasFrameNamed() to query if there exists a body in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1182
          const char* doc_2 =
R"""(Returns a constant reference to the frame that is uniquely identified
by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no frame with the requested name.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasFrameNamed() to query if there exists a frame in `this` model
    with a given specified name.)""";

        } GetFrameByName;

        // drake::multibody::MultibodyTree::GetJointActuatorByName
        struct /* GetJointActuatorByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1330
          const char* doc =
R"""(Returns a constant reference to an actuator that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no actuator with the requested
    name.

Throws:
    s std::logic_error if the actuator name occurs in multiple model
    instances.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    `this` model with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1344
          const char* doc_2 =
R"""(Returns a constant reference to the actuator that is uniquely
identified by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no actuator with the requested
    name.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    `this` model with a given specified name.)""";

        } GetJointActuatorByName;

        // drake::multibody::MultibodyTree::GetJointByName
        struct /* GetJointByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1242
          const char* doc =
R"""(Returns a constant reference to a joint that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no joint with the requested name.

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.

See also:
    HasJointNamed() to query if there exists a joint in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1254
          const char* doc_2 =
R"""(Returns a constant reference to the joint that is uniquely identified
by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no joint with the requested name.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasJointNamed() to query if there exists a joint in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1281
          const char* doc_3 =
R"""(A templated version of GetJointByName() to return a constant reference
of the specified type `JointType` in place of the base Joint class.
See GetJointByName() for details.

Template parameter ``JointType``:
    The specific type of the Joint to be retrieved. It must be a
    subclass of Joint.

Throws:
    s std::logic_error if the named joint is not of type `JointType`
    or if there is no Joint with that name.

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.

See also:
    HasJointNamed() to query if there exists a joint in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1306
          const char* doc_4 =
R"""(A templated version of GetJointByName() to return a constant reference
of the specified type `JointType` in place of the base Joint class.
See GetJointByName() for details.

Template parameter ``JointType``:
    The specific type of the Joint to be retrieved. It must be a
    subclass of Joint.

Throws:
    s std::logic_error if the named joint is not of type `JointType`
    or

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model. if there is no Joint with that name.

See also:
    HasJointNamed() to query if there exists a joint in `this` model
    with a given specified name.)""";

        } GetJointByName;

        // drake::multibody::MultibodyTree::GetModelInstanceByName
        struct /* GetModelInstanceByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1364
          const char* doc =
R"""(Returns the index to the model instance that is uniquely identified by
the string `name` in `this` model.

Throws:
    s std::logic_error if there is no instance with the requested
    name.

See also:
    HasModelInstanceNamed() to query if there exists an instance in
    `this` model with a given specified name.)""";

        } GetModelInstanceByName;

        // drake::multibody::MultibodyTree::GetModelInstanceName
        struct /* GetModelInstanceName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:958
          const char* doc =
R"""(Returns the name of a model_instance.

Throws:
    s std::logic_error when `model_instance` does not correspond to a
    model in this multibody tree.)""";

        } GetModelInstanceName;

        // drake::multibody::MultibodyTree::GetRigidBodyByName
        struct /* GetRigidBodyByName */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1205
          const char* doc =
R"""(Returns a constant reference to a rigid body that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no body with the requested name.

Throws:
    s std::logic_error if the body name occurs in multiple model
    instances.

Throws:
    s std::logic_error if the requested body is not a RigidBody.

See also:
    HasBodyNamed() to query if there exists a body in `this` model
    with a given specified name.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1222
          const char* doc_2 =
R"""(Returns a constant reference to the rigid body that is uniquely
identified by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no body with the requested name.

Throws:
    s std::logic_error if the requested body is not a RigidBody.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasBodyNamed() to query if there exists a body in `this` model
    with a given specified name.)""";

        } GetRigidBodyByName;

        // drake::multibody::MultibodyTree::HasBodyNamed
        struct /* HasBodyNamed */ {

          // drake/multibody/multibody_tree/multibody_tree.h:983
          const char* doc =
R"""(Returns:
    `true` if a body named `name` was added to the model.

See also:
    AddRigidBody().

Throws:
    s std::logic_error if the body name occurs in multiple model
    instances.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:996
          const char* doc_2 =
R"""(Returns:
    `true` if a body named `name` was added to ``model_instance``.

See also:
    AddRigidBody().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

        } HasBodyNamed;

        // drake::multibody::MultibodyTree::HasFrameNamed
        struct /* HasFrameNamed */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1018
          const char* doc =
R"""(Returns:
    `true` if a frame named `name` was added to the model.

See also:
    AddFrame().

Throws:
    s std::logic_error if the frame name occurs in multiple model
    instances.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1031
          const char* doc_2 =
R"""(Returns:
    `true` if a frame named `name` was added to ``model_instance``.

See also:
    AddFrame().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

        } HasFrameNamed;

        // drake::multibody::MultibodyTree::HasJointActuatorNamed
        struct /* HasJointActuatorNamed */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1080
          const char* doc =
R"""(Returns:
    `true` if a joint actuator named `name` was added to the model.

See also:
    AddJointActuator().

Throws:
    s std::logic_error if the actuator name occurs in multiple model
    instances.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1094
          const char* doc_2 =
R"""(Returns:
    `true` if a joint actuator named `name` was added to
    ``model_instance``.

See also:
    AddJointActuator().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

        } HasJointActuatorNamed;

        // drake::multibody::MultibodyTree::HasJointNamed
        struct /* HasJointNamed */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1049
          const char* doc =
R"""(Returns:
    `true` if a joint named `name` was added to the model.

See also:
    AddJoint().

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1062
          const char* doc_2 =
R"""(Returns:
    `true` if a joint named `name` was added to ``model_instance``.

See also:
    AddJoint().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

        } HasJointNamed;

        // drake::multibody::MultibodyTree::HasModelInstanceNamed
        struct /* HasModelInstanceNamed */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1109
          const char* doc =
R"""(Returns:
    `true` if a model instance named `name` was added to the model.

See also:
    AddModelInstance().)""";

        } HasModelInstanceNamed;

        // drake::multibody::MultibodyTree::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2276
          const char* doc =
R"""(Transforms the time derivative `qdot` of the generalized positions
vector `q` (stored in `context`) to generalized velocities `v`. `v`
and `q̇` are related linearly by `q̇ = N(q)⋅v`. Although `N(q)` is not
necessarily square, its left pseudo-inverse `N⁺(q)` can be used to
invert that relationship without residual error, provided that `qdot`
is in the range space of `N(q)` (that is, if it *could* have been
produced as `q̇ = N(q)⋅v` for some `v`). Using the configuration `q`
stored in the given `context` this method calculates `v = N⁺(q)⋅q̇`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``qdot``:
    A vector containing the time derivatives of the generalized
    positions. This method aborts if `qdot` is not of size
    num_positions().

Parameter ``v``:
    A valid (non-null) pointer to a vector in `ℛⁿ` with n the number
    of generalized velocities. This method aborts if v is nullptr or
    if it is not of size num_velocities().

See also:
    MapVelocityToQDot()

See also:
    Mobilizer::MapQDotToVelocity())""";

        } MapQDotToVelocity;

        // drake::multibody::MultibodyTree::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2249
          const char* doc =
R"""(Transforms generalized velocities v to time derivatives `qdot` of the
generalized positions vector `q` (stored in `context`). `v` and `qdot`
are related linearly by `q̇ = N(q)⋅v`. Using the configuration `q`
stored in the given `context` this method calculates `q̇ = N(q)⋅v`.

Parameter ``context``:
    The context containing the state of the MultibodyTree model.

Parameter ``v``:
    A vector of of generalized velocities for `this` MultibodyTree
    model. This method aborts if v is not of size num_velocities().

Parameter ``qdot``:
    A valid (non-null) pointer to a vector in `ℝⁿ` with n being the
    number of generalized positions in `this` MultibodyTree model,
    given by `num_positions()`. This method aborts if `qdot` is
    nullptr or if it is not of size num_positions().

See also:
    MapQDotToVelocity()

See also:
    Mobilizer::MapVelocityToQDot())""";

        } MapVelocityToQDot;

        // drake::multibody::MultibodyTree::MultibodyTree<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree.h:65
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree.h:65
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree.h:68
          const char* doc_3 =
R"""(Creates a MultibodyTree containing only a **world** body.)""";

        } ctor;

        // drake::multibody::MultibodyTree::SetDefaultContext
        struct /* SetDefaultContext */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1479
          const char* doc =
R"""(Sets default values in the context. For mobilizers, this method sets
them to their _zero_ configuration according to
Mobilizer::set_zero_configuration().)""";

        } SetDefaultContext;

        // drake::multibody::MultibodyTree::SetDefaultState
        struct /* SetDefaultState */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1484
          const char* doc =
R"""(Sets default values in the `state`. For mobilizers, this method sets
them to their _zero_ configuration according to
Mobilizer::set_zero_configuration().)""";

        } SetDefaultState;

        // drake::multibody::MultibodyTree::SetFreeBodyPoseOrThrow
        struct /* SetFreeBodyPoseOrThrow */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1508
          const char* doc =
R"""(Sets `context` to store the pose `X_WB` of a given `body` B in the
world frame W.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Throws:
    s RuntimeError if `body` is not a free body in the model.

Throws:
    s RuntimeError if called pre-finalize.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1530
          const char* doc_2 =
R"""(Sets `sate` to store the pose `X_WB` of a given `body` B in the world
frame W, for a given `context` of `this` model.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Throws:
    s RuntimeError if `body` is not a free body in the model.

Throws:
    s RuntimeError if called pre-finalize.)""";

        } SetFreeBodyPoseOrThrow;

        // drake::multibody::MultibodyTree::SetFreeBodySpatialVelocityOrThrow
        struct /* SetFreeBodySpatialVelocityOrThrow */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1519
          const char* doc =
R"""(Sets `context` to store the spatial velocity `V_WB` of a given `body`
B in the world frame W.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Throws:
    s RuntimeError if `body` is not a free body in the model.

Throws:
    s RuntimeError if called pre-finalize.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:1541
          const char* doc_2 =
R"""(Sets `state` to store the spatial velocity `V_WB` of a given `body` B
in the world frame W, for a given `context` of `this` model.

Note:
    In general setting the pose and/or velocity of a body in the model
    would involve a complex inverse kinematics problem. This method
    allows us to simplify this process when we know the body is free
    in space.

Throws:
    s RuntimeError if `body` is not a free body in the model.

Throws:
    s RuntimeError if called pre-finalize.)""";

        } SetFreeBodySpatialVelocityOrThrow;

        // drake::multibody::MultibodyTree::ToAutoDiffXd
        struct /* ToAutoDiffXd */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2383
          const char* doc =
R"""(Creates a deep copy of `this` MultibodyTree templated on AutoDiffXd.)""";

        } ToAutoDiffXd;

        // drake::multibody::MultibodyTree::get_body
        struct /* get_body */ {

          // drake/multibody/multibody_tree/multibody_tree.h:915
          const char* doc =
R"""(Returns a constant reference to the body with unique index
`body_index`.

Throws:
    s if `body_index` does not correspond to a body in this multibody
    tree.)""";

        } get_body;

        // drake::multibody::MultibodyTree::get_frame
        struct /* get_frame */ {

          // drake/multibody/multibody_tree/multibody_tree.h:941
          const char* doc =
R"""(Returns a constant reference to the frame with unique index
`frame_index`.

Throws:
    s if `frame_index` does not correspond to a frame in `this`
    multibody tree.)""";

        } get_frame;

        // drake::multibody::MultibodyTree::get_joint
        struct /* get_joint */ {

          // drake/multibody/multibody_tree/multibody_tree.h:923
          const char* doc =
R"""(Returns a constant reference to the joint with unique index
`joint_index`.

Throws:
    s std::runtime_error when `joint_index` does not correspond to a
    joint in this multibody tree.)""";

        } get_joint;

        // drake::multibody::MultibodyTree::get_joint_actuator
        struct /* get_joint_actuator */ {

          // drake/multibody/multibody_tree/multibody_tree.h:932
          const char* doc =
R"""(Returns a constant reference to the joint actuator with unique index
`actuator_index`.

Throws:
    s if `actuator_index` does not correspond to a joint actuator in
    this multibody tree.)""";

        } get_joint_actuator;

        // drake::multibody::MultibodyTree::get_mobilizer
        struct /* get_mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree.h:950
          const char* doc =
R"""(Returns a constant reference to the mobilizer with unique index
`mobilizer_index`.

Throws:
    s std::runtime_error when `mobilizer_index` does not correspond to
    a mobilizer in this multibody tree.)""";

        } get_mobilizer;

        // drake::multibody::MultibodyTree::get_multibody_state_vector
        struct /* get_multibody_state_vector */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1490
          const char* doc =
R"""(Returns a const Eigen vector containing the multibody state `x = [q;
v]` of the model with q the vector of generalized positions and v the
vector of generalized velocities.)""";

        } get_multibody_state_vector;

        // drake::multibody::MultibodyTree::get_mutable_multibody_state_vector
        struct /* get_mutable_multibody_state_vector */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1498
          const char* doc =
R"""(Returns a mutable Eigen vector containing the multibody state `x = [q;
v]` of the model with q the vector of generalized positions and v the
vector of generalized velocities.

Throws:
    s RuntimeError if the `context` is nullptr or if it does not
    correspond to the context for a multibody model.)""";

        } get_mutable_multibody_state_vector;

        // drake::multibody::MultibodyTree::get_positions_from_array
        struct /* get_positions_from_array */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1413
          const char* doc =
R"""(Returns a vector of generalized positions for `model_instance` from a
vector `q_array` of generalized positions for the entire MultibodyTree
model. This method throws an exception if `q_array` is not of size
MultibodyTree::num_positions().)""";

        } get_positions_from_array;

        // drake::multibody::MultibodyTree::get_topology
        struct /* get_topology */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1385
          const char* doc =
R"""(Returns the topology information for this multibody tree. Users should
not need to call this method since MultibodyTreeTopology is an
internal bookkeeping detail. Used at Finalize() stage by multibody
elements to retrieve a local copy of their topology.)""";

        } get_topology;

        // drake::multibody::MultibodyTree::get_variant
        struct /* get_variant */ {

          // drake/multibody/multibody_tree/multibody_tree.h:2346
          const char* doc = R"""(SFINAE overload for Frame<T> elements.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:2354
          const char* doc_2 = R"""(SFINAE overload for Body<T> elements.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:2362
          const char* doc_3 =
R"""(SFINAE overload for Mobilizer<T> elements.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:2370
          const char* doc_4 = R"""(SFINAE overload for Joint<T> elements.)""";

        } get_variant;

        // drake::multibody::MultibodyTree::get_velocities_from_array
        struct /* get_velocities_from_array */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1431
          const char* doc =
R"""(Returns a vector of generalized velocities for ``model_instance`` from
a vector `v_array` of generalized velocities for the entire
MultibodyTree model. This method throws an exception if the input
array is not of size MultibodyTree::num_velocities().)""";

        } get_velocities_from_array;

        // drake::multibody::MultibodyTree::num_actuated_dofs
        struct /* num_actuated_dofs */ {

          // drake/multibody/multibody_tree/multibody_tree.h:877
          const char* doc =
R"""(Returns the total number of Joint degrees of freedom actuated by the
set of JointActuator elements added to `this` model.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:883
          const char* doc_2 =
R"""(Returns the total number of Joint degrees of freedom actuated by the
set of JointActuator elements added to a specific model instance.)""";

        } num_actuated_dofs;

        // drake::multibody::MultibodyTree::num_actuators
        struct /* num_actuators */ {

          // drake/multibody/multibody_tree/multibody_tree.h:817
          const char* doc =
R"""(Returns the number of actuators in the model.

See also:
    AddJointActuator().)""";

        } num_actuators;

        // drake::multibody::MultibodyTree::num_bodies
        struct /* num_bodies */ {

          // drake/multibody/multibody_tree/multibody_tree.h:810
          const char* doc =
R"""(Returns the number of bodies in the MultibodyTree including the
*world* body. Therefore the minimum number of bodies in a
MultibodyTree is one.)""";

        } num_bodies;

        // drake::multibody::MultibodyTree::num_force_elements
        struct /* num_force_elements */ {

          // drake/multibody/multibody_tree/multibody_tree.h:832
          const char* doc =
R"""(Returns the number of ForceElement objects in the MultibodyTree.)""";

        } num_force_elements;

        // drake::multibody::MultibodyTree::num_frames
        struct /* num_frames */ {

          // drake/multibody/multibody_tree/multibody_tree.h:804
          const char* doc =
R"""(Returns the number of Frame objects in the MultibodyTree. Frames
include body frames associated with each of the bodies in the
MultibodyTree including the _world_ body. Therefore the minimum number
of frames in a MultibodyTree is one.)""";

        } num_frames;

        // drake::multibody::MultibodyTree::num_joints
        struct /* num_joints */ {

          // drake/multibody/multibody_tree/multibody_tree.h:813
          const char* doc =
R"""(Returns the number of joints added with AddJoint() to the
MultibodyTree.)""";

        } num_joints;

        // drake::multibody::MultibodyTree::num_mobilizers
        struct /* num_mobilizers */ {

          // drake/multibody/multibody_tree/multibody_tree.h:827
          const char* doc =
R"""(Returns the number of mobilizers in the MultibodyTree. Since the world
has no Mobilizer, the number of mobilizers equals the number of bodies
minus one, i.e. num_mobilizers() returns num_bodies() - 1.)""";

        } num_mobilizers;

        // drake::multibody::MultibodyTree::num_model_instances
        struct /* num_model_instances */ {

          // drake/multibody/multibody_tree/multibody_tree.h:837
          const char* doc =
R"""(Returns the number of model instances in the MultibodyTree.)""";

        } num_model_instances;

        // drake::multibody::MultibodyTree::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/multibody_tree.h:842
          const char* doc =
R"""(Returns the number of generalized positions of the model.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:847
          const char* doc_2 =
R"""(Returns the number of generalized positions in a specific model
instance.)""";

        } num_positions;

        // drake::multibody::MultibodyTree::num_states
        struct /* num_states */ {

          // drake/multibody/multibody_tree/multibody_tree.h:864
          const char* doc =
R"""(Returns the total size of the state vector in the model.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:869
          const char* doc_2 =
R"""(Returns the total size of the state vector in a specific model
instance.)""";

        } num_states;

        // drake::multibody::MultibodyTree::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree.h:853
          const char* doc =
R"""(Returns the number of generalized velocities of the model.)""";

          // drake/multibody/multibody_tree/multibody_tree.h:858
          const char* doc_2 =
R"""(Returns the number of generalized velocities in a specific model
instance.)""";

        } num_velocities;

        // drake::multibody::MultibodyTree::set_actuation_vector
        struct /* set_actuation_vector */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1404
          const char* doc =
R"""(Given the actuation values ``u_instance`` for all actuators in
``model_instance``, this method sets the actuation vector u for the
entire MultibodyTree model to which this actuator belongs to. This
method throws an exception if the size of `u_instance` is not equal to
the number of degrees of freedom of all of the actuated joints in
`model_instance`.

Parameter ``u_instance``:
    Actuation values for the actuators. It must be of size equal to
    the number of degrees of freedom of all of the actuated joints in
    `model_instance`.

Parameter ``u``:
    The vector containing the actuation values for the entire
    MultibodyTree.)""";

        } set_actuation_vector;

        // drake::multibody::MultibodyTree::set_positions_in_array
        struct /* set_positions_in_array */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1422
          const char* doc =
R"""(Sets the vector of generalized positions for `model_instance` in
`q_array` using `model_q`, leaving all other elements in the array
untouched. This method throws an exception if `q_array` is not of size
MultibodyTree::num_positions() or `model_q` is not of size
`MultibodyTree::num_positions(model_instance)`.)""";

        } set_positions_in_array;

        // drake::multibody::MultibodyTree::set_velocities_in_array
        struct /* set_velocities_in_array */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1440
          const char* doc =
R"""(Sets the vector of generalized velocities for `model_instance` in
`v_array` using `model_v`, leaving all other elements in the array
untouched. This method throws an exception if `v_array` is not of size
MultibodyTree::num_velocities() or `model_v` is not of size
`MultibodyTree::num_positions(model_instance)`.)""";

        } set_velocities_in_array;

        // drake::multibody::MultibodyTree::topology_is_valid
        struct /* topology_is_valid */ {

          // drake/multibody/multibody_tree/multibody_tree.h:1379
          const char* doc =
R"""(Returns `true` if this MultibodyTree was finalized with Finalize()
after all multibody elements were added, and `false` otherwise. When a
MultibodyTree is instantiated, its topology remains invalid until
Finalize() is called, which validates the topology.

See also:
    Finalize().)""";

        } topology_is_valid;

        // drake::multibody::MultibodyTree::tree_height
        struct /* tree_height */ {

          // drake/multibody/multibody_tree/multibody_tree.h:895
          const char* doc =
R"""(Returns the height of the tree data structure of `this` MultibodyTree.
That is, the number of bodies in the longest kinematic path between
the world and any other leaf body. For a model that only contains the
_world_ body, the height of the tree is one. Kinematic paths are
created by Mobilizer objects connecting a chain of frames. Therefore,
this method does not count kinematic cycles, which could only be
considered in the model using constraints.)""";

        } tree_height;

        // drake::multibody::MultibodyTree::world_body
        struct /* world_body */ {

          // drake/multibody/multibody_tree/multibody_tree.h:900
          const char* doc =
R"""(Returns a constant reference to the *world* body.)""";

        } world_body;

        // drake::multibody::MultibodyTree::world_frame
        struct /* world_frame */ {

          // drake/multibody/multibody_tree/multibody_tree.h:908
          const char* doc =
R"""(Returns a constant reference to the *world* frame.)""";

        } world_frame;

      } MultibodyTree;

      // drake::multibody::MultibodyTreeContext
      struct /* MultibodyTreeContext */ {

        // drake/multibody/multibody_tree/multibody_tree_context.h:40
        const char* doc =
R"""(MultibodyTreeContext is an object that contains all the information
needed to uniquely determine the state of a MultibodyTree.
MultibodyTreeContext provides a collection of convenient access
methods to retrieve generalized positions, velocities, cache entries,
etc. Users should not need to make calls to these methods directly but
rather access portions of a MultibodyTree state through the API
provided by the different MultibodyTree elements such as Body, Frame,
etc.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::MultibodyTreeContext::MultibodyTreeContext<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:42
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_context.h:42
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_context.h:46
          const char* doc_3 =
R"""(Instantiates a MultibodyTreeContext for a MultibodyTree with a given
`topology`. The stored state is continuous.)""";

          // drake/multibody/multibody_tree/multibody_tree_context.h:55
          const char* doc_4 =
R"""(Instantiates a MultibodyTreeContext for a MultibodyTree with a given
`topology`.

Parameter ``discrete_state``:
    `true` if the state is to be stored as discrete state. Otherwise
    the state is stored as continuous state. `false` if the state is
    to be stored as continuous state.)""";

        } ctor;

        // drake::multibody::MultibodyTreeContext::get_mutable_position_kinematics_cache
        struct /* get_mutable_position_kinematics_cache */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:241
          const char* doc = R"""()""";

        } get_mutable_position_kinematics_cache;

        // drake::multibody::MultibodyTreeContext::get_mutable_positions
        struct /* get_mutable_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:148
          const char* doc =
R"""(Returns a mutable Eigen expression of the vector of generalized
positions.)""";

        } get_mutable_positions;

        // drake::multibody::MultibodyTreeContext::get_mutable_state_segment
        struct /* get_mutable_state_segment */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:180
          const char* doc =
R"""(Returns a mutable fixed-size Eigen::VectorBlock of `count` elements
referencing a segment in the state vector with its first element at
`start`.)""";

          // drake/multibody/multibody_tree/multibody_tree_context.h:213
          const char* doc_2 =
R"""(Returns a mutable fixed-size Eigen::VectorBlock of `count` elements
referencing a segment in the state vector with its first element at
`start`.)""";

        } get_mutable_state_segment;

        // drake::multibody::MultibodyTreeContext::get_mutable_state_vector
        struct /* get_mutable_state_vector */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:128
          const char* doc =
R"""(Returns a mutable reference to the state vector stored in `this`
context as an `Eigen::VectorBlock<VectorX<T>>`.)""";

        } get_mutable_state_vector;

        // drake::multibody::MultibodyTreeContext::get_mutable_velocities
        struct /* get_mutable_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:154
          const char* doc =
R"""(Returns a mutable Eigen expression of the vector of generalized
velocities.)""";

        } get_mutable_velocities;

        // drake::multibody::MultibodyTreeContext::get_mutable_velocity_kinematics_cache
        struct /* get_mutable_velocity_kinematics_cache */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:245
          const char* doc = R"""()""";

        } get_mutable_velocity_kinematics_cache;

        // drake::multibody::MultibodyTreeContext::get_position_kinematics_cache
        struct /* get_position_kinematics_cache */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:233
          const char* doc =
R"""(@name KinematicsCacheAccessors @{ Accessors to the kinematics caches
stored in MultibodyTreeContext. These will be deprecated once caching
lands.)""";

        } get_position_kinematics_cache;

        // drake::multibody::MultibodyTreeContext::get_positions
        struct /* get_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:138
          const char* doc =
R"""(Returns an Eigen expression of the vector of generalized positions.)""";

        } get_positions;

        // drake::multibody::MultibodyTreeContext::get_state_segment
        struct /* get_state_segment */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:162
          const char* doc =
R"""(Returns a const fixed-size Eigen::VectorBlock of `count` elements
referencing a segment in the state vector with its first element at
`start`.)""";

          // drake/multibody/multibody_tree/multibody_tree_context.h:196
          const char* doc_2 =
R"""(Returns a const fixed-size Eigen::VectorBlock of `count` elements
referencing a segment in the state vector with its first element at
`start`.)""";

        } get_state_segment;

        // drake::multibody::MultibodyTreeContext::get_state_vector
        struct /* get_state_vector */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:117
          const char* doc =
R"""(Returns a const reference to the state vector stored in `this` context
as an `Eigen::VectorBlock<const VectorX<T>>`.)""";

        } get_state_vector;

        // drake::multibody::MultibodyTreeContext::get_velocities
        struct /* get_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:143
          const char* doc =
R"""(Returns an Eigen expression of the vector of generalized velocities.)""";

        } get_velocities;

        // drake::multibody::MultibodyTreeContext::get_velocity_kinematics_cache
        struct /* get_velocity_kinematics_cache */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:237
          const char* doc = R"""()""";

        } get_velocity_kinematics_cache;

        // drake::multibody::MultibodyTreeContext::is_state_discrete
        struct /* is_state_discrete */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:111
          const char* doc =
R"""(Returns `true` if the state is discrete and `false` if the state is
continuous.)""";

        } is_state_discrete;

        // drake::multibody::MultibodyTreeContext::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:100
          const char* doc =
R"""(Returns the size of the generalized positions vector.)""";

        } num_positions;

        // drake::multibody::MultibodyTreeContext::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_context.h:105
          const char* doc =
R"""(Returns the size of the generalized velocities vector.)""";

        } num_velocities;

      } MultibodyTreeContext;

      // drake::multibody::MultibodyTreeElement
      struct /* MultibodyTreeElement */ {

        // drake/multibody/multibody_tree/multibody_tree_element.h:36
        const char* doc = R"""(@cond)""";

      } MultibodyTreeElement;

      // drake::multibody::MultibodyTreeTopology
      struct /* MultibodyTreeTopology */ {

        // drake/multibody/multibody_tree/multibody_tree_topology.h:415
        const char* doc =
R"""(Data structure to store the topological information associated with an
entire MultibodyTree.)""";

        // drake::multibody::MultibodyTreeTopology::CreateListOfWeldedBodies
        struct /* CreateListOfWeldedBodies */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:913
          const char* doc =
R"""(This method partitions the tree topology into sub-graphs such that two
bodies are in the same sub-graph if there is a path between them which
includes only welded-mobilizer. Each sub-graph of welded bodies is
represented as a set of body indices. By definition, these sub-graphs
will be disconnected by any non-weld mobilizers that may be inboard or
outboard of any given body. The first sub-graph will have all of the
bodies welded to the world; all subsequent sub-graphs will be in no
particular order. A few more notes: - Each body in the topology is
included in one set and one set only. - The maximum size of the list
equals the number of bodies in the topology (num_bodies()). This
corresponds to a topology with no weld mobilizers. - The world body is
also included in a welded-bodies set, and this set is element zero in
the returned vector. - The minimum size of the list is one. This
corresponds to a topology with all bodies welded to the world.)""";

        } CreateListOfWeldedBodies;

        // drake::multibody::MultibodyTreeTopology::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:417
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::MultibodyTreeTopology::Finalize
        struct /* Finalize */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:700
          const char* doc =
R"""(This method must be called by MultibodyTree::Finalize() after all
topological elements in the tree (corresponding to joints, bodies,
force elements, constraints) were added and before any computations
are performed. It essentially compiles all the necessary "topological
information", i.e. how bodies, joints and, any other elements connect
with each other, and performs all the required pre-processing to
perform computations at a later stage. This preprocessing includes: -
sorting in BFT order for fast recursions through the tree, -
computation of state sizes and of pool sizes within cache entries, -
computation of index maps to retrieve either state or cache entries
for each multibody element.

If the finalize stage is successful, the `this` topology is validated,
meaning it is up-to-date after this call. No more multibody tree
elements can be added after a call to Finalize().

Throws:
    s std::logic_error If users attempt to call this method on an
    already finalized topology.

See also:
    is_valid())""";

        } Finalize;

        // drake::multibody::MultibodyTreeTopology::GetKinematicPathToWorld
        struct /* GetKinematicPathToWorld */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:880
          const char* doc =
R"""(Given a node in `this` topology, specified by its BodyNodeIndex
`from`, this method computes the kinematic path formed by all the
nodes in the tree that connect `from` with the root (corresponding to
the world).

Parameter ``from``:
    A node in the tree topology to which the path to the root (world)
    is to be computed.

Parameter ``path_to_world``:
    A std::vector of body node indexes that on output will contain the
    path to the root of the tree. Forward iteration (from element 0 to
    element size()-1) of `path_to_world` will traverse all nodes in
    the tree starting at the root along the path to `from`. That is,
    forward iteration starts with the root of the tree at
    `path_to_world[0]` and ends with `from` at `path_to_world.back()`.
    On input, `path_to_world` must be a valid pointer. On output this
    vector will be resized, only if needed, to store as many elements
    as the level (BodyNodeTopology::level) of body node `from` plus
    one (so that we can include the root node in the path).)""";

        } GetKinematicPathToWorld;

        // drake::multibody::MultibodyTreeTopology::MultibodyTreeTopology
        struct /* ctor */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:417
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:417
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/multibody_tree_topology.h:424
          const char* doc_3 =
R"""(Default constructor creates an empty, invalid topology. The minimum
valid topology for a minimum valid MultibodyTree contains at least the
BodyTopology for the world. The topology for the _world_ body does not
get added until MultibodyTree construction, which creates a _world_
body and adds it to the tree.)""";

        } ctor;

        // drake::multibody::MultibodyTreeTopology::add_body
        struct /* add_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:528
          const char* doc =
R"""(Creates and adds a new BodyTopology to this MultibodyTreeTopology. The
BodyTopology will be assigned a new, unique BodyIndex and FrameIndex
values.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    topology.

Returns:
    a std::pair<BodyIndex, FrameIndex> containing the indexes assigned
    to the new BodyTopology.)""";

        } add_body;

        // drake::multibody::MultibodyTreeTopology::add_force_element
        struct /* add_force_element */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:643
          const char* doc =
R"""(Creates and adds a new ForceElementTopology, associated with the given
force_index, to this MultibodyTreeTopology.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    topology.

Returns:
    The ForceElementIndex assigned to the new ForceElementTopology.)""";

        } add_force_element;

        // drake::multibody::MultibodyTreeTopology::add_frame
        struct /* add_frame */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:547
          const char* doc =
R"""(Creates and adds a new FrameTopology, associated with the given
body_index, to this MultibodyTreeTopology.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    topology.

Returns:
    The FrameIndex assigned to the new FrameTopology.)""";

        } add_frame;

        // drake::multibody::MultibodyTreeTopology::add_joint_actuator
        struct /* add_joint_actuator */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:664
          const char* doc =
R"""(Creates and adds a new JointActuatorTopology for a joint with
`num_dofs` degrees of freedom.

Parameter ``num_dofs``:
    The number of joint dofs actuated by this actuator.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    topology.

Returns:
    The JointActuatorIndex assigned to the new JointActuatorTopology.)""";

        } add_joint_actuator;

        // drake::multibody::MultibodyTreeTopology::add_mobilizer
        struct /* add_mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:573
          const char* doc =
R"""(Creates and adds a new MobilizerTopology connecting the inboard and
outboard multibody frames identified by indexes `in_frame` and
`out_frame`, respectively. The created topology will correspond to
that of a Mobilizer with `num_positions` and `num_velocities`.

Throws:
    s std::runtime_error if either `in_frame` or `out_frame` do not
    index frame topologies in `this` MultibodyTreeTopology.

Throws:
    s a std::runtime_error if `in_frame == out_frame`.

Throws:
    s a std::runtime_error if `in_frame` and `out_frame` already are
    connected by another mobilizer. More than one mobilizer between
    two frames is not allowed.

Throws:
    s std::logic_error if Finalize() was already called on `this`
    topology.

Returns:
    The MobilizerIndex assigned to the new MobilizerTopology.)""";

        } add_mobilizer;

        // drake::multibody::MultibodyTreeTopology::get_body
        struct /* get_body */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:492
          const char* doc =
R"""(Returns a constant reference to the corresponding BodyTopology given a
BodyIndex.)""";

        } get_body;

        // drake::multibody::MultibodyTreeTopology::get_body_node
        struct /* get_body_node */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:514
          const char* doc =
R"""(Returns a constant reference to the corresponding BodyNodeTopology
given a BodyNodeIndex.)""";

        } get_body_node;

        // drake::multibody::MultibodyTreeTopology::get_frame
        struct /* get_frame */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:485
          const char* doc =
R"""(Returns a constant reference to the corresponding FrameTopology given
the FrameIndex.)""";

        } get_frame;

        // drake::multibody::MultibodyTreeTopology::get_joint_actuator
        struct /* get_joint_actuator */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:506
          const char* doc =
R"""(Returns a constant reference to the corresponding
JointActuatorTopology given a JointActuatorIndex.)""";

        } get_joint_actuator;

        // drake::multibody::MultibodyTreeTopology::get_mobilizer
        struct /* get_mobilizer */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:499
          const char* doc =
R"""(Returns a constant reference to the corresponding BodyTopology given a
BodyIndex.)""";

        } get_mobilizer;

        // drake::multibody::MultibodyTreeTopology::get_num_body_nodes
        struct /* get_num_body_nodes */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:464
          const char* doc =
R"""(Returns the number of tree nodes. This must equal the number of
bodies.)""";

        } get_num_body_nodes;

        // drake::multibody::MultibodyTreeTopology::is_valid
        struct /* is_valid */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:848
          const char* doc =
R"""(Returns `true` if Finalize() was already called on `this` topology.

See also:
    Finalize())""";

        } is_valid;

        // drake::multibody::MultibodyTreeTopology::num_actuated_dofs
        struct /* num_actuated_dofs */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:860
          const char* doc =
R"""(Returns the total number of actuated joint dofs in the model.)""";

        } num_actuated_dofs;

        // drake::multibody::MultibodyTreeTopology::num_bodies
        struct /* num_bodies */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:449
          const char* doc =
R"""(Returns the number of bodies in the multibody tree. This includes the
"world" body and therefore the minimum number of bodies after
MultibodyTree::Finalize() will always be one, not zero.)""";

        } num_bodies;

        // drake::multibody::MultibodyTreeTopology::num_force_elements
        struct /* num_force_elements */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:469
          const char* doc =
R"""(Returns the number of force elements in the topology.)""";

        } num_force_elements;

        // drake::multibody::MultibodyTreeTopology::num_frames
        struct /* num_frames */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:452
          const char* doc =
R"""(Returns the number of physical frames in the multibody tree.)""";

        } num_frames;

        // drake::multibody::MultibodyTreeTopology::num_joint_actuators
        struct /* num_joint_actuators */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:474
          const char* doc =
R"""(Returns the number of joint actuators in the topology.)""";

        } num_joint_actuators;

        // drake::multibody::MultibodyTreeTopology::num_mobilizers
        struct /* num_mobilizers */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:459
          const char* doc =
R"""(Returns the number of mobilizers in the multibody tree. Since the
"world" body does not have a mobilizer, the number of mobilizers will
always equal the number of bodies minus one.)""";

        } num_mobilizers;

        // drake::multibody::MultibodyTreeTopology::num_positions
        struct /* num_positions */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:851
          const char* doc =
R"""(Returns the total number of generalized positions in the model.)""";

        } num_positions;

        // drake::multibody::MultibodyTreeTopology::num_states
        struct /* num_states */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:857
          const char* doc =
R"""(Returns the total size of the state vector in the model.)""";

        } num_states;

        // drake::multibody::MultibodyTreeTopology::num_velocities
        struct /* num_velocities */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:854
          const char* doc =
R"""(Returns the total number of generalized velocities in the model.)""";

        } num_velocities;

        // drake::multibody::MultibodyTreeTopology::tree_height
        struct /* tree_height */ {

          // drake/multibody/multibody_tree/multibody_tree_topology.h:479
          const char* doc =
R"""(Returns the number of tree levels in the topology.)""";

        } tree_height;

      } MultibodyTreeTopology;

      // drake::multibody::PositionKinematicsCache
      struct /* PositionKinematicsCache */ {

        // drake/multibody/multibody_tree/position_kinematics_cache.h:33
        const char* doc =
R"""(This class is one of the cache entries in MultibodyTreeContext. It
holds the kinematics results of computations that only depend on the
generalized positions of the system. Kinematics results include: -
Body frame B poses X_WB measured and expressed in the world frame W. -
Pose X_FM of a mobilizer's outboard frame M measured and expressed in
the inboard frame F. - Mobilizer's matrices H_FM (with F and M defined
above) that map the mobilizer's generalized velocities v to cross-
joint spatial velocities V_FM = H_FM * v.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::PositionKinematicsCache::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:35
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::PositionKinematicsCache::PositionKinematicsCache<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:35
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/position_kinematics_cache.h:35
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/position_kinematics_cache.h:39
          const char* doc_3 =
R"""(Constructs a position kinematics cache entry for the given
MultibodyTreeTopology.)""";

        } ctor;

        // drake::multibody::PositionKinematicsCache::get_X_FM
        struct /* get_X_FM */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:89
          const char* doc =
R"""(For the mobilizer associated with the body node indexed by
`body_node_index`, this method returns a const reference to the pose
`X_FM` of the outboard frame M as measured and expressed in the
inboard frame F.

Parameter ``body_node_index``:
    The unique index for the computational BodyNode object associated
    with the mobilizer of interest.

Returns:
    A const reference to the pose `X_FM` of the outboard frame M as
    measured and expressed in the inboard frame F.)""";

        } get_X_FM;

        // drake::multibody::PositionKinematicsCache::get_X_PB
        struct /* get_X_PB */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:68
          const char* doc =
R"""(Returns a const reference to the pose `X_PB` of the body frame B as
measured and expressed in its parent body frame P.

Parameter ``body_node_id``:
    The unique identifier for the computational BodyNode object
    associated with body B.

Returns:
    `X_PB` a const reference to the pose of the the body frame B
    measured and expressed in the parent body frame P.)""";

        } get_X_PB;

        // drake::multibody::PositionKinematicsCache::get_X_WB
        struct /* get_X_WB */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:51
          const char* doc =
R"""(Returns a constant reference to the pose `X_WB` of the body B
(associated with node ``body_node_index``) as measured and expressed
in the world frame W.

Parameter ``body_node_index``:
    The unique index for the computational BodyNode object associated
    with body B.

Returns:
    `X_WB` the pose of the the body frame B measured and expressed in
    the world frame W.)""";

        } get_X_WB;

        // drake::multibody::PositionKinematicsCache::get_mutable_X_FM
        struct /* get_mutable_X_FM */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:95
          const char* doc =
R"""(See documentation on the const version get_X_FM() for details.)""";

        } get_mutable_X_FM;

        // drake::multibody::PositionKinematicsCache::get_mutable_X_PB
        struct /* get_mutable_X_PB */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:74
          const char* doc =
R"""(See documentation on the const version get_X_PB() for details.)""";

        } get_mutable_X_PB;

        // drake::multibody::PositionKinematicsCache::get_mutable_X_WB
        struct /* get_mutable_X_WB */ {

          // drake/multibody/multibody_tree/position_kinematics_cache.h:57
          const char* doc =
R"""(See documentation on the const version get_X_WB() for details.)""";

        } get_mutable_X_WB;

      } PositionKinematicsCache;

      // drake::multibody::PrismaticJoint
      struct /* PrismaticJoint */ {

        // drake/multibody/multibody_tree/joints/prismatic_joint.h:35
        const char* doc =
R"""(This Joint allows two bodies to translate relative to one another
along a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class's documentation), this Joint allows frames F and M to translate
with respect to each other along an axis â. The translation distance
is defined positive when child body B translates along the direction
of â. Axis â is constant and has the same measures in both frames F
and M, that is, `â_F = â_M`.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::PrismaticJoint::AddInForce
        struct /* AddInForce */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:167
          const char* doc =
R"""(Adds into `multibody_forces` a given `force`, in Newtons, for `this`
joint that is to be applied along the joint's axis. The force is
defined to be positive in the direction along this joint's axis. That
is, a positive force causes a positive translational acceleration
along the joint's axis.)""";

        } AddInForce;

        // drake::multibody::PrismaticJoint::DoAddInDamping
        struct /* DoAddInDamping */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:203
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into `forces` a dissipative force according to the viscous law `f =
-d⋅v`, with d the damping coefficient (see damping()).)""";

        } DoAddInDamping;

        // drake::multibody::PrismaticJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:186
          const char* doc =
R"""(Joint<T> virtual override called through public NVI,
Joint::AddInForce(). Therefore arguments were already checked to be
valid. For a PrismaticJoint, we must always have `joint_dof = 0` since
there is only a single degree of freedom (num_velocities() == 1).
`joint_tau` is the linear force applied along the joint's axis, on the
body declared as child (according to the prismatic joint's
constructor) at the origin of the child frame (which is coincident
with the origin of the parent frame at all times).)""";

        } DoAddInOneForce;

        // drake::multibody::PrismaticJoint::PrismaticJoint<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:37
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:37
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:71
          const char* doc_3 =
R"""(Constructor to create a prismatic joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, translate relatively to one another along a common axis.
See this class's documentation for further details on the definition
of these frames and translation distance. The first three arguments to
this constructor are those of the Joint class constructor. See the
Joint class's documentation for details. The additional parameter
`axis` is:

Parameter ``axis``:
    A vector in ℝ³ specifying the translation axis for this joint.
    Given that frame M only translates with respect to F and there is
    no relative rotation, the measures of `axis` in either frame F or
    M are exactly the same, that is, `axis_F = axis_M`. This vector
    can have any length, only the direction is used.

Parameter ``lower_limit``:
    Lower limit, in meters, for the translation coordinate (see
    get_translation()).

Parameter ``upper_limit``:
    Upper limit, in meters, for the translation coordinate (see
    get_translation()).

Parameter ``damping``:
    Viscous damping coefficient, in N⋅s/m, used to model losses within
    the joint. The damping force (in N) is modeled as `f =
    -damping⋅v`, i.e. opposing motion, with v the translational speed
    for `this` joint (see get_translation_rate()).

Throws:
    s RuntimeError if the L2 norm of `axis` is less than the square
    root of machine epsilon.

Throws:
    s RuntimeError if damping is negative.

Throws:
    s RuntimeError if lower_limit > upper_limit.)""";

        } ctor;

        // drake::multibody::PrismaticJoint::damping
        struct /* damping */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:100
          const char* doc =
R"""(Returns `this` joint's damping constant in N⋅s/m.)""";

        } damping;

        // drake::multibody::PrismaticJoint::get_translation
        struct /* get_translation */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:118
          const char* doc =
R"""(Gets the translation distance of `this` mobilizer from `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The translation coordinate of `this` joint read from `context`.)""";

        } get_translation;

        // drake::multibody::PrismaticJoint::get_translation_rate
        struct /* get_translation_rate */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:141
          const char* doc =
R"""(Gets the rate of change, in meters per second, of `this` joint's
translation distance (see get_translation()) from `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The rate of change of `this` joint's translation read from
    `context`.)""";

        } get_translation_rate;

        // drake::multibody::PrismaticJoint::lower_limit
        struct /* lower_limit */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:103
          const char* doc =
R"""(Returns the lower limit for `this` joint in meters.)""";

        } lower_limit;

        // drake::multibody::PrismaticJoint::set_translation
        struct /* set_translation */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:129
          const char* doc =
R"""(Sets `context` so that the generalized coordinate corresponding to the
translation distance of `this` joint equals `translation`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``translation``:
    The desired translation in meters to be stored in `context`.

Returns:
    a constant reference to `this` joint.)""";

        } set_translation;

        // drake::multibody::PrismaticJoint::set_translation_rate
        struct /* set_translation_rate */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:154
          const char* doc =
R"""(Sets the rate of change, in meters per second, of `this` joint's
translation distance to `translation_dot`. The new rate of change
`translation_dot` gets stored in `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``translation_dot``:
    The desired rate of change of `this` joints's translation in
    meters per second.

Returns:
    a constant reference to `this` joint.)""";

        } set_translation_rate;

        // drake::multibody::PrismaticJoint::translation_axis
        struct /* translation_axis */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:95
          const char* doc =
R"""(Returns the axis of translation for `this` joint as a unit vector.
Since the measures of this axis in either frame F or M are the same
(see this class's documentation for frames's definitions) then, `axis
= axis_F = axis_M`.)""";

        } translation_axis;

        // drake::multibody::PrismaticJoint::upper_limit
        struct /* upper_limit */ {

          // drake/multibody/multibody_tree/joints/prismatic_joint.h:106
          const char* doc =
R"""(Returns the upper limit for `this` joint in meters.)""";

        } upper_limit;

      } PrismaticJoint;

      // drake::multibody::PrismaticMobilizer
      struct /* PrismaticMobilizer */ {

        // drake/multibody/multibody_tree/prismatic_mobilizer.h:40
        const char* doc =
R"""(This Mobilizer allows two frames to translate relative to one another
along an axis whose direction is constant when measured in either this
mobilizer's inboard frame or its outboard frame. There is no relative
rotation between the inboard and outboard frames, just translation. To
fully specify this mobilizer, a user must provide the inboard frame F,
the outboard (or "mobilized") frame M and the axis `axis_F` (expressed
in frame F) along which frame M translates with respect to frame F.
The single generalized coordinate q introduced by this mobilizer
corresponds to the translation distance (in meters) of the origin `Mo`
of frame M with respect to frame F along `axis_F`. When `q = 0`,
frames F and M are coincident. The translation distance is defined to
be positive in the direction of `axis_F`.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::PrismaticMobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:136
          const char* doc =
R"""(Computes the across-mobilizer acceleration `A_FM(q, v, v̇)` of the
outboard frame M in the inboard frame F. By definition `A_FM =
d_F(V_FM)/dt`. The acceleration `A_FM` will be a function of the
translation distance q, its rate of change v for the current state in
`context` and of the input generalized acceleration `v̇ = dv/dt`, the
rate of change of v. See class documentation for the translation sign
convention. This method aborts in Debug builds if `vdot.size()` is not
one.)""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::PrismaticMobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:124
          const char* doc =
R"""(Computes the across-mobilizer velocity `V_FM(q, v)` of the outboard
frame M measured and expressed in frame F as a function of the
translation taken from `context` and input translational velocity `v`
along this mobilizer's axis (see translation_axis()). The generalized
coordinate q for `this` mobilizer (the translation distance) is read
from in `context`. This method aborts in Debug builds if `v.size()` is
not one.)""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::PrismaticMobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:114
          const char* doc =
R"""(Computes the across-mobilizer transform `X_FM(q)` between the inboard
frame F and the outboard frame M as a function of the translation
distance along this mobilizer's axis (see translation_axis().) The
generalized coordinate q for `this` mobilizer (the translation
distance) is read from in `context`.)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::PrismaticMobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:168
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:171
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::PrismaticMobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:162
          const char* doc =
R"""(Computes the kinematic mapping from time derivatives of the
generalized positions `q̇` to generalized velocities v. For this
mobilizer `v = q̇`.)""";

        } MapQDotToVelocity;

        // drake::multibody::PrismaticMobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:155
          const char* doc =
R"""(Computes the kinematic mapping from generalized velocities v to time
derivatives of the generalized positions `q̇`. For this mobilizer `q̇
= v`.)""";

        } MapVelocityToQDot;

        // drake::multibody::PrismaticMobilizer::PrismaticMobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:42
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:42
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:52
          const char* doc_3 =
R"""(Constructor for a PrismaticMobilizer between the `inboard_frame_F` and
`outboard_frame_M` granting a single translational degree of freedom
along `axis_F`, expressed in the `inboard_frame_F`. @pre `axis_F` must
be a non-zero vector with norm at least root square of machine
epsilon. This vector can have any length, only the direction is used.

Throws:
    s RuntimeError if the L2 norm of `axis_F` is less than the square
    root of machine epsilon.)""";

        } ctor;

        // drake::multibody::PrismaticMobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:148
          const char* doc =
R"""(Projects the spatial force `F_Mo_F` on `this` mobilizer's outboard
frame M onto its translation axis (see translation_axis().)
Mathematically:

```
tau = F_Mo_F.translational().dot(axis_F)
```

Therefore, the result of this method is the scalar value of the linear
force along the axis of `this` mobilizer. This method aborts in Debug
builds if `tau.size()` is not one.)""";

        } ProjectSpatialForce;

        // drake::multibody::PrismaticMobilizer::get_translation
        struct /* get_translation */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:72
          const char* doc =
R"""(Gets the translational distance for `this` mobilizer from `context`.
See class documentation for sign convention details.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns:
    The translation coordinate of `this` mobilizer in the `context`.)""";

        } get_translation;

        // drake::multibody::PrismaticMobilizer::get_translation_rate
        struct /* get_translation_rate */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:91
          const char* doc =
R"""(Gets the rate of change, in meters per second, of `this` mobilizer's
translation (see get_translation()) from `context`. See class
documentation for the translation sign convention.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns:
    The rate of change of `this` mobilizer's translation in the
    `context`.)""";

        } get_translation_rate;

        // drake::multibody::PrismaticMobilizer::set_translation
        struct /* set_translation */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:81
          const char* doc =
R"""(Sets `context` so that the generalized coordinate corresponding to the
translation for `this` mobilizer equals `translation`.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``translation``:
    The desired translation in meters.

Returns:
    a constant reference to `this` mobilizer.)""";

        } set_translation;

        // drake::multibody::PrismaticMobilizer::set_translation_rate
        struct /* set_translation_rate */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:102
          const char* doc =
R"""(Sets the rate of change, in meters per second, of `this` mobilizer's
translation to `translation_dot`. The new rate of change
`translation_dot` gets stored in `context`. See class documentation
for the translation sign convention.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``translation_dot``:
    The desired rate of change of `this` mobilizer's translation in
    meters per second.

Returns:
    a constant reference to `this` mobilizer.)""";

        } set_translation_rate;

        // drake::multibody::PrismaticMobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:106
          const char* doc =
R"""(Sets `state` to store a zero translation and translational rate.)""";

        } set_zero_state;

        // drake::multibody::PrismaticMobilizer::translation_axis
        struct /* translation_axis */ {

          // drake/multibody/multibody_tree/prismatic_mobilizer.h:63
          const char* doc =
R"""(Returns ``axis_F``:
    The translation axis as a unit vector expressed in the inboard
    frame F.)""";

        } translation_axis;

      } PrismaticMobilizer;

      // drake::multibody::QuaternionFloatingMobilizer
      struct /* QuaternionFloatingMobilizer */ {

        // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:37
        const char* doc =
R"""(This Mobilizer allows two frames to move freely relatively to one
another. To fully specify this mobilizer a user must provide an
inboard frame F and an outboard frame M. This mobilizer introduces six
degrees of freedom which allow frame M to freely move with respect to
frame F. This mobilizer introduces four generalized positions to
describe the orientation `R_FM` of frame M in F with a quaternion
`q_FM`, and three generalized positions to describe the position of
frame M's origin in F with a position vector `p_FM`. As generalized
velocities, this mobilizer introduces the angular velocity `w_FM` of
frame M in F and the linear velocity `v_FM` of frame M's origin in
frame F.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::QuaternionFloatingMobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:190
          const char* doc = R"""()""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::QuaternionFloatingMobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:186
          const char* doc = R"""()""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::QuaternionFloatingMobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:183
          const char* doc =
R"""(@name Mobilizer overrides Refer to the Mobilizer class documentation
for details. @{)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::QuaternionFloatingMobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:211
          const char* doc = R"""(@})""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:214
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::QuaternionFloatingMobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:204
          const char* doc = R"""()""";

        } MapQDotToVelocity;

        // drake::multibody::QuaternionFloatingMobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:199
          const char* doc = R"""()""";

        } MapVelocityToQDot;

        // drake::multibody::QuaternionFloatingMobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:194
          const char* doc = R"""()""";

        } ProjectSpatialForce;

        // drake::multibody::QuaternionFloatingMobilizer::QuaternionFloatingMobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:39
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:39
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:50
          const char* doc_3 =
R"""(Constructor for a QuaternionFloatingMobilizer granting six degrees of
freedom to an outboard frame M with respect to an inboard frame F. The
orientation of frame M in F is represented by a quaternion `q_FM`
while the position of F in M is given by a position vector `p_FM`
expressed in frame F.

Parameter ``inboard_frame_F``:
    the inboard frame F.

Parameter ``outboard_frame_M``:
    the outboard frame M which can move freely with respect to frame
    F.)""";

        } ctor;

        // drake::multibody::QuaternionFloatingMobilizer::SetFromRotationMatrix
        struct /* SetFromRotationMatrix */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:120
          const char* doc =
R"""(Sets `context` to store the quaternion `q_FM` which represents the
same orientation of M in F as given by the rotation matrix `R_FM`.

Parameter ``context``:
    The context of the MultibodyTree to which this mobilizer belongs
    to.

Parameter ``R_FM``:
    The desired orientation of M in F given as a rotation matrix.

Returns:
    a constant reference to `this` mobilizer.)""";

        } SetFromRotationMatrix;

        // drake::multibody::QuaternionFloatingMobilizer::get_angular_velocity
        struct /* get_angular_velocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:128
          const char* doc =
R"""(Returns the angular velocity `w_FM` of frame M in F stored in
`context`.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns ``w_FM``:
    The angular velocity of the outboard frame M in the inboard frame
    F.)""";

        } get_angular_velocity;

        // drake::multibody::QuaternionFloatingMobilizer::get_position
        struct /* get_position */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:77
          const char* doc =
R"""(Returns the position `p_FM` of the outboard frame M's origin as
measured and expressed in the inboard frame F. Refer to the
documentation for this class for details.

Parameter ``context``:
    The context storing the state of the MultibodyTree this mobilizer
    belongs to.

Returns ``p_FM``:
    The position vector of frame M's origin in frame F.)""";

        } get_position;

        // drake::multibody::QuaternionFloatingMobilizer::get_quaternion
        struct /* get_quaternion */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:67
          const char* doc =
R"""(Gets the quaternion `q_FM` that represents the orientation of outboard
frame M in the inboard frame F. Refer to the documentation for this
class for details.

Parameter ``context``:
    The context storing the state of the MultibodyTree this mobilizer
    belongs to.

Returns ``q_FM``:
    The quaternion representing the orientaiton of frame M in F.)""";

        } get_quaternion;

        // drake::multibody::QuaternionFloatingMobilizer::get_translational_velocity
        struct /* get_translational_velocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:152
          const char* doc =
R"""(Retrieves and returns from `context` the translational velocity `v_FM`
of frame M's origin as measured and expressed in frame F.

Parameter ``context``:
    The context of the MultibodyTree to which this mobilizer belongs
    to.

Returns ``v_FM``:
    The translational velocity of the outboard frame M in the inboard
    frame F, expressed in F.)""";

        } get_translational_velocity;

        // drake::multibody::QuaternionFloatingMobilizer::set_angular_velocity
        struct /* set_angular_velocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:136
          const char* doc =
R"""(Sets `context` to store the angular velocity `w_FM` of frame M in
frame F.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``w_FM``:
    The desired angular velocity of frame M in F, expressed in F.

Returns:
    a constant reference to `this` mobilizer.)""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:141
          const char* doc_2 =
R"""(Alternative signature to set_angular_velocity(context, w_FM) to set
`state` to store the angular velocity `w_FM` of M in F.)""";

        } set_angular_velocity;

        // drake::multibody::QuaternionFloatingMobilizer::set_position
        struct /* set_position */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:104
          const char* doc =
R"""(Sets `context` to store the position `p_FM` of frame M's origin `Mo`
measured and expressed in frame F.

Parameter ``context``:
    The context storing the state of the MultibodyTree this mobilizer
    belongs to.

Parameter ``p_FM``:
    The desired position of frame M in F to be stored in `context`.

Returns:
    a constant reference to `this` mobilizer.)""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:109
          const char* doc_2 =
R"""(Alternative signature to set_position(context, p_FM) to set `state` to
store the position `p_FM` of M in F.)""";

        } set_position;

        // drake::multibody::QuaternionFloatingMobilizer::set_quaternion
        struct /* set_quaternion */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:87
          const char* doc =
R"""(Sets `context` so that the orientation of frame M in F is given by the
input quaternion `q_FM`.

Parameter ``context``:
    The context storing the state of the MultibodyTree this mobilizer
    belongs to.

Parameter ``q_FM``:
    The desired orientation of M in F to be stored in `context`.

Returns:
    a constant reference to `this` mobilizer.)""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:92
          const char* doc_2 =
R"""(Alternative signature to set_quaternion(context, q_FM) to set `state`
to store the orientation of M in F given by the equaternion `q_FM`.)""";

        } set_quaternion;

        // drake::multibody::QuaternionFloatingMobilizer::set_translational_velocity
        struct /* set_translational_velocity */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:162
          const char* doc =
R"""(Sets `context` to store the translational velocity `v_FM` of frame M
in frame F.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``v_FM``:
    The desired translational velocity of frame M in F, expressed in
    F.

Returns:
    a constant reference to `this` mobilizer.)""";

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:167
          const char* doc_2 =
R"""(Alternative signature to set_translational_velocity(context, v_FM) to
set `state` to store the translational velocity `v_FM` of M in F.)""";

        } set_translational_velocity;

        // drake::multibody::QuaternionFloatingMobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/quaternion_floating_mobilizer.h:175
          const char* doc =
R"""(Sets `state` to store a configuration in which M coincides with F
(i.e. q_FM is the identity quaternion) and the spatial velocity V_FM
of M in F is zero.)""";

        } set_zero_state;

      } QuaternionFloatingMobilizer;

      // drake::multibody::RevoluteJoint
      struct /* RevoluteJoint */ {

        // drake/multibody/multibody_tree/joints/revolute_joint.h:36
        const char* doc =
R"""(This Joint allows two bodies to rotate relatively to one another
around a common axis. That is, given a frame F attached to the parent
body P and a frame M attached to the child body B (see the Joint
class's documentation), this Joint allows frames F and M to rotate
with respect to each other about an axis â. The rotation angle's sign
is defined such that child body B rotates about axis â according to
the right hand rule, with thumb aligned in the axis direction. Axis â
is constant and has the same measures in both frames F and M, that is,
`â_F = â_M`.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::RevoluteJoint::AddInTorque
        struct /* AddInTorque */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:202
          const char* doc =
R"""(Adds into `forces` a given `torque` for `this` joint that is to be
applied about the joint's axis. The torque is defined to be positive
according to the right-hand-rule with the thumb aligned in the
direction of `this` joint's axis. That is, a positive torque causes a
positive rotational acceleration according to the right-hand-rule
around the joint's axis.

Note:
    A torque is the moment of a set of forces whose resultant is zero.)""";

        } AddInTorque;

        // drake::multibody::RevoluteJoint::DoAddInDamping
        struct /* DoAddInDamping */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:242
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInDamping().
Therefore arguments were already checked to be valid. This method adds
into `forces` a dissipative torque according to the viscous law `τ =
-d⋅ω`, with d the damping coefficient (see damping()).)""";

        } DoAddInDamping;

        // drake::multibody::RevoluteJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:224
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Therefore arguments were already checked to be valid. For a
RevoluteJoint, we must always have `joint_dof = 0` since there is only
a single degree of freedom (num_velocities() == 1). `joint_tau` is the
torque applied about the joint's axis, on the body declared as child
(according to the revolute joint's constructor) at the origin of the
child frame (which is coincident with the origin of the parent frame
at all times). The torque is defined to be positive according to the
right-hand-rule with the thumb aligned in the direction of `this`
joint's axis. That is, a positive torque causes a positive rotational
acceleration (of the child body frame) according to the right-hand-
rule around the joint's axis.)""";

        } DoAddInOneForce;

        // drake::multibody::RevoluteJoint::RevoluteJoint<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:38
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/joints/revolute_joint.h:38
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/joints/revolute_joint.h:68
          const char* doc_3 =
R"""(Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class's documentation for further details on the definition
of these frames and rotation angle. This constructor signature creates
a joint with no joint limits, i.e. the joint limits are the pair `(-∞,
∞)`. The first three arguments to this constructor are those of the
Joint class constructor. See the Joint class's documentation for
details. The additional parameters are:

Parameter ``axis``:
    A vector in ℝ³ specifying the axis of revolution for this joint.
    Given that frame M only rotates with respect to F and their
    origins are coincident at all times, the measures of `axis` in
    either frame F or M are exactly the same, that is, `axis_F =
    axis_M`. In other words, `axis_F` (or `axis_M`) is the eigenvector
    of `R_FM` with eigenvalue equal to one. This vector can have any
    length, only the direction is used. This method aborts if `axis`
    is the zero vector.

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. The damping torque (in N⋅m) is modeled as `τ =
    -damping⋅ω`, i.e. opposing motion, with ω the angular rate for
    `this` joint (see get_angular_rate()).

Throws:
    s RuntimeError if damping is negative.)""";

          // drake/multibody/multibody_tree/joints/revolute_joint.h:106
          const char* doc_4 =
R"""(Constructor to create a revolute joint between two bodies so that
frame F attached to the parent body P and frame M attached to the
child body B, rotate relatively to one another about a common axis.
See this class's documentation for further details on the definition
of these frames and rotation angle. The first three arguments to this
constructor are those of the Joint class constructor. See the Joint
class's documentation for details. The additional parameters are:

Parameter ``axis``:
    A vector in ℝ³ specifying the axis of revolution for this joint.
    Given that frame M only rotates with respect to F and their
    origins are coincident at all times, the measures of `axis` in
    either frame F or M are exactly the same, that is, `axis_F =
    axis_M`. In other words, `axis_F` (or `axis_M`) is the eigenvector
    of `R_FM` with eigenvalue equal to one. This vector can have any
    length, only the direction is used. This method aborts if `axis`
    is the zero vector.

Parameter ``lower_limit``:
    Lower limit, in radians, for the rotation coordinate (see
    get_angle()).

Parameter ``upper_limit``:
    Upper limit, in radians, for the rotation coordinate (see
    get_angle()).

Parameter ``damping``:
    Viscous damping coefficient, in N⋅m⋅s, used to model losses within
    the joint. The damping torque (in N⋅m) is modeled as `τ =
    -damping⋅ω`, i.e. opposing motion, with ω the angular rate for
    `this` joint (see get_angular_rate()).

Throws:
    s RuntimeError if damping is negative.

Throws:
    s RuntimeError if lower_limit > upper_limit.)""";

        } ctor;

        // drake::multibody::RevoluteJoint::damping
        struct /* damping */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:133
          const char* doc =
R"""(Returns `this` joint's damping constant in N⋅m⋅s.)""";

        } damping;

        // drake::multibody::RevoluteJoint::get_angle
        struct /* get_angle */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:151
          const char* doc =
R"""(Gets the rotation angle of `this` mobilizer from `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The angle coordinate of `this` joint stored in the `context`.)""";

        } get_angle;

        // drake::multibody::RevoluteJoint::get_angular_rate
        struct /* get_angular_rate */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:174
          const char* doc =
R"""(Gets the rate of change, in radians per second, of `this` joint's
angle (see get_angle()) from `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Returns:
    The rate of change of `this` joint's angle as stored in the
    `context`.)""";

        } get_angular_rate;

        // drake::multibody::RevoluteJoint::lower_limit
        struct /* lower_limit */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:136
          const char* doc =
R"""(Returns the lower limit for `this` joint in radians.)""";

        } lower_limit;

        // drake::multibody::RevoluteJoint::revolute_axis
        struct /* revolute_axis */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:128
          const char* doc =
R"""(Returns the axis of revolution of `this` joint as a unit vector. Since
the measures of this axis in either frame F or M are the same (see
this class's documentation for frames's definitions) then, `axis =
axis_F = axis_M`.)""";

        } revolute_axis;

        // drake::multibody::RevoluteJoint::set_angle
        struct /* set_angle */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:162
          const char* doc =
R"""(Sets the `context` so that the generalized coordinate corresponding to
the rotation angle of `this` joint equals `angle`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``angle``:
    The desired angle in radians to be stored in `context`.

Returns:
    a constant reference to `this` joint.)""";

        } set_angle;

        // drake::multibody::RevoluteJoint::set_angular_rate
        struct /* set_angular_rate */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:187
          const char* doc =
R"""(Sets the rate of change, in radians per second, of this `this` joint's
angle to `theta_dot`. The new rate of change `theta_dot` gets stored
in `context`.

Parameter ``context``:
    The context of the MultibodyTree this joint belongs to.

Parameter ``theta_dot``:
    The desired rate of change of `this` joints's angle in radians per
    second.

Returns:
    a constant reference to `this` joint.)""";

        } set_angular_rate;

        // drake::multibody::RevoluteJoint::upper_limit
        struct /* upper_limit */ {

          // drake/multibody/multibody_tree/joints/revolute_joint.h:139
          const char* doc =
R"""(Returns the upper limit for `this` joint in radians.)""";

        } upper_limit;

      } RevoluteJoint;

      // drake::multibody::RevoluteMobilizer
      struct /* RevoluteMobilizer */ {

        // drake/multibody/multibody_tree/revolute_mobilizer.h:41
        const char* doc =
R"""(This Mobilizer allows two frames to rotate relatively to one another
around an axis that is constant when measured in either this
mobilizer's inboard or outboard frames, while the distance between the
two frames does not vary. To fully specify this mobilizer a user must
provide the inboard frame F, the outboard (or "mobilized") frame M and
the axis `axis_F` (expressed in frame F) about which frame M rotates
with respect to F. The single generalized coordinate q introduced by
this mobilizer corresponds to the rotation angle in radians of frame M
with respect to frame F about the rotation axis `axis_F`. When `q =
0`, frames F and M are coincident. The rotation angle is defined to be
positive according to the right-hand-rule with the thumb aligned in
the direction of the `axis_F`. Notice that the components of the
rotation axis as expressed in either frame F or M are constant. That
is, `axis_F` and `axis_M` remain unchanged w.r.t. both frames by this
mobilizer's motion.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::RevoluteMobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:145
          const char* doc =
R"""(Computes the across-mobilizer acceleration `A_FM(q, v, v̇)` of the
outboard frame M in the inboard frame F. By definition `A_FM =
d_F(V_FM)/dt = H_FM(q) * v̇ + Ḣ_FM * v`. The acceleration `A_FM` will
be a function of the rotation angle q, its rate of change v for the
current state in `context` and of the input generalized acceleration
`v̇ = dv/dt`, the rate of change of v. See class documentation for the
angle sign convention. This method aborts in Debug builds if
`vdot.size()` is not one.)""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::RevoluteMobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:133
          const char* doc =
R"""(Computes the across-mobilizer velocity `V_FM(q, v)` of the outboard
frame M measured and expressed in frame F as a function of the
rotation angle and input angular velocity `v` about this mobilizer's
axis (

See also:
    revolute_axis()). The generalized coordinate q for `this`
    mobilizer (the rotation angle) is stored in `context`. This method
    aborts in Debug builds if `v.size()` is not one.)""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::RevoluteMobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:123
          const char* doc =
R"""(Computes the across-mobilizer transform `X_FM(q)` between the inboard
frame F and the outboard frame M as a function of the rotation angle
about this mobilizer's axis (

See also:
    revolute_axis().) The generalized coordinate q for `this`
    mobilizer (the rotation angle) is stored in `context`. This method
    aborts in Debug builds if `v.size()` is not one.)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::RevoluteMobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:173
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/revolute_mobilizer.h:176
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::RevoluteMobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:167
          const char* doc = R"""()""";

        } MapQDotToVelocity;

        // drake::multibody::RevoluteMobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:162
          const char* doc = R"""()""";

        } MapVelocityToQDot;

        // drake::multibody::RevoluteMobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:157
          const char* doc =
R"""(Projects the spatial force `F_Mo_F` on `this` mobilizer's outboard
frame M onto its rotation axis (

See also:
    revolute_axis().) Mathematically:

```
tau = F_Mo_F.rotational().dot(axis_F)
```

Therefore, the result of this method is the scalar value of the torque
at the axis of `this` mobilizer. This method aborts in Debug builds if
`tau.size()` is not one.)""";

        } ProjectSpatialForce;

        // drake::multibody::RevoluteMobilizer::RevoluteMobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:43
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/revolute_mobilizer.h:43
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/revolute_mobilizer.h:56
          const char* doc_3 =
R"""(Constructor for a RevoluteMobilizer between the inboard frame F
`inboard_frame_F` and the outboard frame M `outboard_frame_F` granting
a single rotational degree of freedom about axis `axis_F` expressed in
the inboard frame F. @pre axis_F must be a unit vector within at least
1.0e-6. This rather loose tolerance (at least for simulation) allows
users to provide "near unity" axis vectors originated, for instance,
during the parsing of a file with limited precision. Internally, we
re-normalize the axis to within machine precision.

Throws:
    s std::runtime_error if the provided rotational axis is not a unit
    vector.)""";

        } ctor;

        // drake::multibody::RevoluteMobilizer::get_angle
        struct /* get_angle */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:80
          const char* doc =
R"""(Gets the rotation angle of `this` mobilizer from `context`. See class
documentation for sign convention.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns:
    The angle coordinate of `this` mobilizer in the `context`.)""";

        } get_angle;

        // drake::multibody::RevoluteMobilizer::get_angular_rate
        struct /* get_angular_rate */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:99
          const char* doc =
R"""(Gets the rate of change, in radians per second, of `this` mobilizer's
angle (see get_angle()) from `context`. See class documentation for
the angle sign convention.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns:
    The rate of change of `this` mobilizer's angle in the `context`.)""";

        } get_angular_rate;

        // drake::multibody::RevoluteMobilizer::revolute_axis
        struct /* revolute_axis */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:71
          const char* doc =
R"""(Returns ``axis_F``:
    The rotation axis as a unit vector expressed in the inboard frame
    F.)""";

        } revolute_axis;

        // drake::multibody::RevoluteMobilizer::set_angle
        struct /* set_angle */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:90
          const char* doc =
R"""(Sets the `context` so that the generalized coordinate corresponding to
the rotation angle of `this` mobilizer equals `angle`.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``angle``:
    The desired angle in radians.

Returns:
    a constant reference to `this` mobilizer.)""";

        } set_angle;

        // drake::multibody::RevoluteMobilizer::set_angular_rate
        struct /* set_angular_rate */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:110
          const char* doc =
R"""(Sets the rate of change, in radians per second, of this `this`
mobilizer's angle to `theta_dot`. The new rate of change `theta_dot`
gets stored in `context`. See class documentation for the angle sign
convention.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``theta_dot``:
    The desired rate of change of `this` mobilizer's angle in radians
    per second.

Returns:
    a constant reference to `this` mobilizer.)""";

        } set_angular_rate;

        // drake::multibody::RevoluteMobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/revolute_mobilizer.h:114
          const char* doc =
R"""(Sets `state` to store a zero angle and angular rate.)""";

        } set_zero_state;

      } RevoluteMobilizer;

      // drake::multibody::RigidBody
      struct /* RigidBody */ {

        // drake/multibody/multibody_tree/fixed_offset_frame.h:17
        const char* doc =
R"""(The term **rigid body** implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six **degrees of freedom**. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is *not* free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
"tree joint" or "inboard joint"). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.

- [Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical
Mechanics (3rd Edition), Addison-Wesley, 2001.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake/multibody/multibody_tree/rigid_body.h:52
        const char* doc_2 =
R"""(The term **rigid body** implies that the deformations of the body
under consideration are so small that they have no significant effect
on the overall motions of the body and therefore deformations can be
neglected. If deformations are neglected, the distance between any two
points on the rigid body remains constant at all times. This
invariance of the distance between two arbitrary points is often taken
as the definition of a rigid body in classical treatments of multibody
mechanics [Goldstein 2001]. It can be demonstrated that the
unconstrained three-dimensional motions of a rigid body can be
described by six coordinates and thus it is often said that a free
body in space has six **degrees of freedom**. These degrees of freedom
obey the Newton-Euler equations of motion. However, within a
MultibodyTree, a RigidBody is *not* free in space; instead, it is
assigned a limited number of degrees of freedom (0-6) with respect to
its parent body in the multibody tree by its Mobilizer (also called a
"tree joint" or "inboard joint"). Additional constraints on
permissible motion can be added using Constraint objects to remove
more degrees of freedom.

- [Goldstein 2001] H Goldstein, CP Poole, JL Safko, Classical
Mechanics (3rd Edition), Addison-Wesley, 2001.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::RigidBody::CalcCenterOfMassInBodyFrame
        struct /* CalcCenterOfMassInBodyFrame */ {

          // drake/multibody/multibody_tree/rigid_body.h:147
          const char* doc = R"""()""";

        } CalcCenterOfMassInBodyFrame;

        // drake::multibody::RigidBody::CalcSpatialInertiaInBodyFrame
        struct /* CalcSpatialInertiaInBodyFrame */ {

          // drake/multibody/multibody_tree/rigid_body.h:152
          const char* doc = R"""()""";

        } CalcSpatialInertiaInBodyFrame;

        // drake::multibody::RigidBody::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/rigid_body.h:259
          const char* doc = R"""(@})""";

          // drake/multibody/multibody_tree/rigid_body.h:264
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::RigidBody::RigidBody<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/rigid_body.h:54
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/rigid_body.h:54
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/rigid_body.h:62
          const char* doc_3 =
R"""(Constructs a RigidBody with the given default SpatialInertia.

Parameter ``M_BBo_B``:
    Spatial inertia of `this` body B about the frame's origin `Bo` and
    expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";

          // drake/multibody/multibody_tree/rigid_body.h:74
          const char* doc_4 =
R"""(Constructs a RigidBody named `body_name` with the given default
SpatialInertia.

Parameter ``body_name``:
    A name associated with `this` body.

Parameter ``M_BBo_B``:
    Spatial inertia of `this` body B about the frame's origin `Bo` and
    expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";

          // drake/multibody/multibody_tree/rigid_body.h:89
          const char* doc_5 =
R"""(Constructs a RigidBody named `body_name` with the given default
SpatialInertia.

Parameter ``body_name``:
    A name associated with `this` body.

Parameter ``model_instance``:
    The model instance associated with `this` body.

Parameter ``M_BBo_B``:
    Spatial inertia of `this` body B about the frame's origin `Bo` and
    expressed in the body frame B.

Note:
    See multibody_spatial_inertia for details on the monogram notation
    used for spatial inertia quantities.)""";

        } ctor;

        // drake::multibody::RigidBody::default_com
        struct /* default_com */ {

          // drake/multibody/multibody_tree/rigid_body.h:115
          const char* doc =
R"""(Returns the default value of this rigid body's center of mass as
measured and expressed in this body's frame. This value is initially
supplied at construction when specifying this body's SpatialInertia.

Returns ``p_BoBcm_B``:
    The position of this rigid body B's center of mass `Bcm` measured
    from Bo (B's frame origin) and expressed in B (body B's frame).)""";

        } default_com;

        // drake::multibody::RigidBody::default_mass
        struct /* default_mass */ {

          // drake/multibody/multibody_tree/rigid_body.h:106
          const char* doc =
R"""(Returns the default value of this body's mass. This value is initially
supplied at construction when specifying this body's SpatialInertia.

Returns:
    This body's default mass.)""";

        } default_mass;

        // drake::multibody::RigidBody::default_rotational_inertia
        struct /* default_rotational_inertia */ {

          // drake/multibody/multibody_tree/rigid_body.h:131
          const char* doc =
R"""(Gets the default value of this body B's rotational inertia about Bo
(B's origin), expressed in B (this body's frame). This value is
calculated from the SpatialInertia supplied at construction of this
body.

Returns ``I_BBo_B``:
    body B's rotational inertia about Bo, expressed in B.)""";

        } default_rotational_inertia;

        // drake::multibody::RigidBody::default_spatial_inertia
        struct /* default_spatial_inertia */ {

          // drake/multibody/multibody_tree/rigid_body.h:139
          const char* doc =
R"""(Gets the default value of this body B's spatial inertia about Bo (B's
origin) and expressed in B (this body's frame).

Returns ``M_BBo_B``:
    body B's spatial inertia about Bo, expressed in B.)""";

        } default_spatial_inertia;

        // drake::multibody::RigidBody::default_unit_inertia
        struct /* default_unit_inertia */ {

          // drake/multibody/multibody_tree/rigid_body.h:123
          const char* doc =
R"""(Returns the default value of this body B's unit inertia about Bo (body
B's origin), expressed in B (this body's frame). This value is
initially supplied at construction when specifying this body's
SpatialInertia.

Returns ``G_BBo_B``:
    rigid body B's unit inertia about Bo, expressed in B.)""";

        } default_unit_inertia;

        // drake::multibody::RigidBody::get_angular_acceleration_in_world
        struct /* get_angular_acceleration_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:244
          const char* doc =
R"""(Extract this body's angular acceleration in world, expressed in world.

Parameter ``ac``:
    velocity kinematics cache.

Returns ``alpha_WB_W``:
    B's angular acceleration in world W, expressed in W.)""";

        } get_angular_acceleration_in_world;

        // drake::multibody::RigidBody::get_angular_velocity_in_world
        struct /* get_angular_velocity_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:211
          const char* doc =
R"""(Extract this body angular velocity in world, expressed in world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``w_WB_W``:
    rigid body B's angular velocity in world W, expressed in W.)""";

        } get_angular_velocity_in_world;

        // drake::multibody::RigidBody::get_body_orientation_in_world
        struct /* get_body_orientation_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:176
          const char* doc =
R"""(Extract the rotation matrix relating the world frame to this body's
frame.

Parameter ``pc``:
    position kinematics cache.

Returns ``R_WB``:
    rotation matrix relating rigid body B in world frame W.)""";

        } get_body_orientation_in_world;

        // drake::multibody::RigidBody::get_mass
        struct /* get_mass */ {

          // drake/multibody/multibody_tree/rigid_body.h:143
          const char* doc = R"""()""";

        } get_mass;

        // drake::multibody::RigidBody::get_num_flexible_positions
        struct /* get_num_flexible_positions */ {

          // drake/multibody/multibody_tree/rigid_body.h:96
          const char* doc =
R"""(There are no flexible degrees of freedom associated with a rigid body
and therefore this method returns zero. By definition, a rigid body
has no state associated with flexible deformations.)""";

        } get_num_flexible_positions;

        // drake::multibody::RigidBody::get_num_flexible_velocities
        struct /* get_num_flexible_velocities */ {

          // drake/multibody/multibody_tree/rigid_body.h:101
          const char* doc =
R"""(There are no flexible degrees of freedom associated with a rigid body
and therefore this method returns zero. By definition, a rigid body
has no state associated with flexible deformations.)""";

        } get_num_flexible_velocities;

        // drake::multibody::RigidBody::get_origin_acceleration_in_world
        struct /* get_origin_acceleration_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:252
          const char* doc =
R"""(Extract acceleration of this body's origin in world, expressed in
world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``a_WBo_W``:
    acceleration of body origin Bo in world W, expressed in W.)""";

        } get_origin_acceleration_in_world;

        // drake::multibody::RigidBody::get_origin_position_in_world
        struct /* get_origin_position_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:186
          const char* doc =
R"""(Extract the position vector from world origin to this body's origin,
expressed in world.

Parameter ``pc``:
    position kinematics cache.

Returns ``p_WoBo_W``:
    position vector from Wo (world origin) to Bo (this body's origin)
    expressed in W (world).)""";

        } get_origin_position_in_world;

        // drake::multibody::RigidBody::get_origin_velocity_in_world
        struct /* get_origin_velocity_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:219
          const char* doc =
R"""(Extract the velocity of this body's origin in world, expressed in
world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``v_WBo_W``:
    velocity of Bo (body origin) in world W, expressed in W.)""";

        } get_origin_velocity_in_world;

        // drake::multibody::RigidBody::get_pose_in_world
        struct /* get_pose_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:168
          const char* doc =
R"""(Extract this body's pose in world (from the position kinematics).

Parameter ``pc``:
    position kinematics cache.

Returns ``X_WB``:
    pose of rigid body B in world frame W.)""";

        } get_pose_in_world;

        // drake::multibody::RigidBody::get_spatial_acceleration_in_world
        struct /* get_spatial_acceleration_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:236
          const char* doc =
R"""(Extract this body spatial acceleration in world, expressed in world.

Parameter ``ac``:
    acceleration kinematics cache.

Returns ``A_WB_W``:
    body B's spatial acceleration in world W, expressed in W.)""";

        } get_spatial_acceleration_in_world;

        // drake::multibody::RigidBody::get_spatial_velocity_in_world
        struct /* get_spatial_velocity_in_world */ {

          // drake/multibody/multibody_tree/rigid_body.h:203
          const char* doc =
R"""(Extract this body spatial velocity in world, expressed in world.

Parameter ``vc``:
    velocity kinematics cache.

Returns ``V_WB_W``:
    rigid body B's spatial velocity in world W, expressed in W.)""";

        } get_spatial_velocity_in_world;

      } RigidBody;

      // drake::multibody::RotationalInertia
      struct /* RotationalInertia */ {

        // drake/multibody/multibody_tree/rotational_inertia.h:103
        const char* doc =
R"""(This class helps describe the mass distribution (inertia properties)
of a body or composite body about a particular point. Herein,
"composite body" means one body or a collection of bodies that are
welded together. In this documentation, "body" and "composite body"
are used interchangeably.

A **rigid** body's mass distribution is described by three quantities:
the body's mass; the body's center of mass; and the body's rotational
inertia about a particular point. The term **rotational inertia** is
used here and by [Jain 2010] to distinguish from a body's **spatial
inertia**. In this class, a 3x3 **inertia matrix** I represents a
body's rotational inertia about a point and expressed in a frame
(e.g., about-point P and expressed-in frame E with right-handed
orthogonal unit vectors x̂, ŷ, ẑ).

```
| Ixx Ixy Ixz |
I = | Ixy Iyy Iyz |
    | Ixz Iyz Izz |
```

The moments of inertia Ixx, Iyy, Izz and products of inertia Ixy, Ixz,
Iyz are defined in terms of the mass dm of a differential volume of
the body. The position of dm from about-point P is xx̂ + yŷ + zẑ =
[x, y, z]_E.

```
Ixx = ∫ (y² + z²) dm
Iyy = ∫ (x² + z²) dm
Izz = ∫ (x² + y²) dm
Ixy = - ∫ x y dm
Ixz = - ∫ x z dm
Iyz = - ∫ y z dm
```

We use the negated convention for products of inertia, so that I
serves to relate angular velocity ω and angular momentum h via `h = I
⋅ ω`. Ensure your products of inertia follow this negative sign
convention.

The 3x3 inertia matrix is symmetric and its diagonal elements (moments
of inertia) and off-diagonal elements (products of inertia) are
associated with a body (or composite body) S, an about-point P, and an
expressed-in- frame E (x̂, ŷ, ẑ). A rotational inertia is ill-
defined unless there is a body S, about-point P, and expressed-in
frame E. The user of this class is responsible for tracking the body
S, about-point P and expressed-in frame E (none of these are stored in
this class).

Note:
    This class does not store the about-point nor the expressed-in
    frame, nor does this class help enforce consistency of the about-
    point or expressed-in frame. To help users of this class track the
    about-point and expressed-in frame, we strongly recommend the
    following notation.

In typeset material, use the symbol $ [I^{S/P}]_E $ to represent the
rotational inertia (inertia matrix) of a body (or composite body) S
about-point P, expressed in frame E. In code and comments, use the
monogram notation `I_SP_E` (e.g., as described in
multibody_spatial_inertia). If the about-point P is fixed to a body B,
the point is named $ B_P $ and this appears in code/comments as `Bp`.
Examples: `I_BBp_E` is rigid body B's rotational inertia about-point
Bp expressed-in frame E; I_BBo_E is B's rotational inertia about-point
`Bo` (body B's origin) expressed-in frame E; and I_BBcm_E is B's
inertia matrix about-point `Bcm` (B's center of mass) expressed-in
frame E.

Note:
    The rotational inertia (inertia matrix) can be re-expressed in
    terms of a special frame whose orthogonal unit vectors are
    parallel to **principal axes of inertia** so that the inertia
    matrix is diagonalized with elements called **principal moments of
    inertia**.

Note:
    Several methods in this class throw a RuntimeError for invalid
    rotational inertia operations in debug releases only. This
    provides speed in a release build while facilitating debugging in
    debug builds. In addition, these validity tests are only performed
    for scalar types for which drake::scalar_predicate<T>::is_bool is
    `true`. For instance, validity checks are not performed when T is
    symbolic::Expression.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar. Various
    methods in this class require numerical (not symbolic) data types.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::multibody::RotationalInertia::CalcMaximumPossibleMomentOfInertia
        struct /* CalcMaximumPossibleMomentOfInertia */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:180
          const char* doc =
R"""(Returns the maximum possible moment of inertia for `this` rotational
inertia about-point P for any expressed-in frame E.

Remark:
    The maximum moment Imax has range: trace / 3 <= Imax <= trace / 2.

See also:
    Trace())""";

        } CalcMaximumPossibleMomentOfInertia;

        // drake::multibody::RotationalInertia::CalcPrincipalMomentsOfInertia
        struct /* CalcPrincipalMomentsOfInertia */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:425
          const char* doc =
R"""(This method takes `this` rotational inertia about-point P, expressed-
in- frame E, and computes its principal moments of inertia about-point
P, but expressed-in a frame aligned with the principal axes.

Note:
    : This method only works for a rotational inertia with scalar type
    T that can be converted to a double (discarding any supplemental
    scalar data such as derivatives of an AutoDiffScalar).

Returns ``principal_moments``:
    The vector of principal moments of inertia `[Ixx Iyy Izz]` sorted
    in ascending order.

Throws:
    s std::runtime_error if eigenvalue solver fails or if scalar type
    T cannot be converted to a double.)""";

        } CalcPrincipalMomentsOfInertia;

        // drake::multibody::RotationalInertia::CopyToFullMatrix3
        struct /* CopyToFullMatrix3 */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:198
          const char* doc =
R"""(Gets a full 3x3 matrix copy of this rotational inertia. The returned
copy is symmetric and includes both lower and upper parts of the
matrix.)""";

        } CopyToFullMatrix3;

        // drake::multibody::RotationalInertia::CouldBePhysicallyValid
        struct /* CouldBePhysicallyValid */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:484
          const char* doc =
R"""(Performs several necessary checks to verify whether `this` rotational
inertia *could* be physically valid, including: - No NaN moments or
products of inertia. - Ixx, Iyy, Izz and principal moments are all
non-negative. - Ixx, Iyy Izz and principal moments satisfy the
triangle inequality: - `Ixx + Iyy >= Izz` - `Ixx + Izz >= Iyy` - `Iyy
+ Izz >= Ixx`

@warning These checks are necessary (but NOT sufficient) conditions
for a rotational inertia to be physically valid. The sufficient
condition requires a rotational inertia to satisfy the above checks
*after* `this` is shifted to the center of mass, i.e., the sufficient
condition requires calling CouldBePhysicallyValid() when the about-
point is Bcm (the body's center of mass). Note: this class does not
know its about-point or its center of mass location.

Returns:
    `true` for a plausible rotational inertia passing the above
    necessary but insufficient checks and `false` otherwise.

Throws:
    s std::runtime_error if principal moments of inertia cannot be
    calculated (eigenvalue solver) or if scalar type T cannot be
    converted to a double.)""";

        } CouldBePhysicallyValid;

        // drake::multibody::RotationalInertia::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:105
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::RotationalInertia::IsNaN
        struct /* IsNaN */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:381
          const char* doc =
R"""(Returns `true` if any moment/product in `this` rotational inertia is
NaN. Otherwise returns `false`.)""";

        } IsNaN;

        // drake::multibody::RotationalInertia::IsNearlyEqualTo
        struct /* IsNearlyEqualTo */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:221
          const char* doc =
R"""(Compares `this` rotational inertia to `other` rotional inertia within
the specified `precision` (which is a dimensionless number specifying
the relative precision to which the comparison is performed). Denoting
`I_maxA` as the largest element value that can appear in a valid
`this` rotational inertia (independent of the expressed-in frame E)
and denoting `I_maxB` as the largest element value that can appear in
a valid `other` rotational inertia (independent of the expressed-in
frame E), `this` and `other` are considered nearly equal to each
other, if: ‖this - other‖∞ < precision * min(I_maxA, I_maxB)

Parameter ``other``:
    Rotational inertia to compare with `this` rotational inertia.

Parameter ``precision``:
    is a dimensionless real positive number that is usually based on
    two factors, namely expected accuracy of moments/products of
    inertia (e.g., from end-user or CAD) and/or machine-precision.

Returns:
    `true` if the absolute value of each moment/product of inertia in
    `this` is within `epsilon` of the corresponding moment/ product
    absolute value in `other`. Otherwise returns `false`.

Note:
    : This method only works if all moments of inertia with scalar
    type T in `this` and `other` can be converted to a double
    (discarding supplemental scalar data such as derivatives of an
    AutoDiffScalar). It fails at runtime if type T cannot be converted
    to `double`.)""";

        } IsNearlyEqualTo;

        // drake::multibody::RotationalInertia::MinusEqualsUnchecked
        struct /* MinusEqualsUnchecked */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:701
          const char* doc =
R"""(Subtracts a rotational inertia `I_BP_E` from `this` rotational
inertia. No check is done to determine if the result is physically
valid.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from `this` rotational inertia.

Returns:
    A reference to `this` rotational inertia. `this` changes since
    rotational inertia `I_BP_E` has been subtracted from it.

See also:
    operator-(). @warning This operator may produce an invalid
    rotational inertia. Use operator-=() to perform necessary (but
    insufficient) checks on the physical validity of the resulting
    rotational inertia.

Note:
    : Although this method is mathematically useful, it may result in
    a rotational inertia that is physically invalid. This method helps
    perform intermediate calculations which do not necessarily
    represent a real rotational inertia. For example, an efficient way
    to shift a rotational inertia from an arbitrary point P to an
    arbitrary point Q is mathematical equivalent to a + (b - c).
    Although `a` must be physically valid and the result `a + (b - c)`
    must be physically valid, the intermediate quantity (b - c) is not
    necessarily physically valid. This method allows (b - c) to be
    calculated without requiring (b - c) to be physically valid.

See also:
    operator-=().)""";

        } MinusEqualsUnchecked;

        // drake::multibody::RotationalInertia::ReExpress
        struct /* ReExpress */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:544
          const char* doc =
R"""(Re-expresses `this` rotational inertia `I_BP_E` to `I_BP_A` i.e., re-
expresses body B's rotational inertia from frame E to frame A.

Parameter ``R_AE``:
    Rotation matrix from frame A to frame E.

Returns ``I_BP_A``:
    Rotational inertia of B about-point P expressed-in frame A.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is re-expressed-in frame A violates CouldBePhysicallyValid().

See also:
    ReExpressInPlace())""";

        } ReExpress;

        // drake::multibody::RotationalInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:513
          const char* doc =
R"""(Re-expresses `this` rotational inertia `I_BP_E` to `I_BP_A`. In other
words, starts with `this` rotational inertia of a body (or composite
body) B about-point P expressed-in frame E and re-expresses to B's
rotational inertia about-point P expressed-in frame A, i.e., `I_BP_A =
R_AE * I_BP_E * (R_AE)ᵀ`.

Parameter ``R_AE``:
    Rotation matrix from frame A to frame E.

Returns:
    A reference to `this` rotational inertia about-point P, but with
    `this` expressed in frame A (instead of frame E).

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is re-expressed-in frame A violates CouldBePhysicallyValid().

See also:
    ReExpress().)""";

        } ReExpressInPlace;

        // drake::multibody::RotationalInertia::RotationalInertia<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:105
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/rotational_inertia.h:105
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/rotational_inertia.h:109
          const char* doc_3 =
R"""(Constructs a rotational inertia that has all its moments/products of
inertia equal to NaN (helps quickly detect uninitialized values).)""";

          // drake/multibody/multibody_tree/rotational_inertia.h:114
          const char* doc_4 =
R"""(Creates a rotational inertia with moments of inertia `Ixx`, `Iyy`,
`Izz`, and with each product of inertia set to zero.

Throws:
    s std::logic_error for Debug builds if not
    CouldBePhysicallyValid().)""";

          // drake/multibody/multibody_tree/rotational_inertia.h:120
          const char* doc_5 =
R"""(Creates a rotational inertia with moments of inertia `Ixx`, `Iyy`,
`Izz`, and with products of inertia `Ixy`, `Ixz`, `Iyz`.

Throws:
    s std::logic_error for Debug builds if not
    CouldBePhysicallyValid().)""";

          // drake/multibody/multibody_tree/rotational_inertia.h:135
          const char* doc_6 =
R"""(Constructs a rotational inertia for a particle Q of mass `mass`, whose
position vector from about-point P is p_PQ_E (E is expressed-in
frame). This std::logic_error exception only occurs if `mass` < 0.

Parameter ``mass``:
    The mass of particle Q.

Parameter ``p_PQ_E``:
    Position from about-point P to Q, expressed-in frame E.

Returns ``I_QP_E``:
    , Q's rotational inertia about-point P expressed-in frame E.

Remark:
    Negating the position vector p_PQ_E has no affect on the result.

Throws:
    s std::logic_error for Debug builds if not
    CouldBePhysicallyValid().)""";

        } ctor;

        // drake::multibody::RotationalInertia::SetToNaN
        struct /* SetToNaN */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:364
          const char* doc =
R"""(Sets `this` rotational inertia so all its elements are equal to NaN.
This helps quickly detect uninitialized moments/products of inertia.)""";

        } SetToNaN;

        // drake::multibody::RotationalInertia::SetZero
        struct /* SetZero */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:373
          const char* doc =
R"""(Sets `this` rotational inertia so all its moments/products of inertia
are zero, e.g., for convenient initialization before a computation or
for inertia calculations involving a particle (point-mass). Note: Real
3D massive physical objects have non-zero moments of inertia.)""";

        } SetZero;

        // drake::multibody::RotationalInertia::ShiftFromCenterOfMass
        struct /* ShiftFromCenterOfMass */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:589
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting `this`
rotational inertia for a body (or composite body) B from about-point
Bcm (B's center of mass) to about-point Q. I.e., shifts `I_BBcm_E` to
`I_BQ_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_BcmQ_E``:
    Position vector from Bcm to Q, expressed-in frame E.

Returns ``I_BQ_E``:
    B's rotational inertia about-point Q expressed-in frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating the position vector p_BcmQ_E has no affect on the result.)""";

        } ShiftFromCenterOfMass;

        // drake::multibody::RotationalInertia::ShiftFromCenterOfMassInPlace
        struct /* ShiftFromCenterOfMassInPlace */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:572
          const char* doc =
R"""(Shifts `this` rotational inertia for a body (or composite body) B from
about-point Bcm (B's center of mass) to about-point Q. I.e., shifts
`I_BBcm_E` to `I_BQ_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_BcmQ_E``:
    Position vector from Bcm to Q, expressed-in frame E.

Returns:
    A reference to `this` rotational inertia expressed-in frame E, but
    with `this` shifted from about-point Bcm to about-point Q. i.e.,
    returns I_BQ_E, B's rotational inertia about-point Bcm expressed-
    in frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating the position vector p_BcmQ_E has no affect on the result.)""";

        } ShiftFromCenterOfMassInPlace;

        // drake::multibody::RotationalInertia::ShiftToCenterOfMass
        struct /* ShiftToCenterOfMass */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:627
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting `this`
rotational inertia for a body (or composite body) B from about-point Q
to about-point `Bcm` (B's center of mass). I.e., shifts `I_BQ_E` to
`I_BBcm_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_QBcm_E``:
    Position vector from Q to `Bcm`, expressed-in frame E.

Returns ``I_BBcm_E``:
    B's rotational inertia about-point `Bcm` expressed-in frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point `Bcm` violates CouldBePhysicallyValid().

Remark:
    Negating the position vector `p_QBcm_E` has no affect on the
    result.)""";

        } ShiftToCenterOfMass;

        // drake::multibody::RotationalInertia::ShiftToCenterOfMassInPlace
        struct /* ShiftToCenterOfMassInPlace */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:609
          const char* doc =
R"""(Shifts `this` rotational inertia for a body (or composite body) B from
about-point Q to about-point `Bcm` (B's center of mass). I.e., shifts
`I_BQ_E` to `I_BBcm_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_QBcm_E``:
    Position vector from Q to `Bcm`, expressed-in frame E.

Returns:
    A reference to `this` rotational inertia expressed-in frame E, but
    with `this` shifted from about-point Q to about-point `Bcm`, i.e.,
    returns `I_BBcm_E`, B's rotational inertia about-point `Bcm`
    expressed-in frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point `Bcm` violates CouldBePhysicallyValid().

Remark:
    Negating the position vector `p_QBcm_E` has no affect on the
    result.)""";

        } ShiftToCenterOfMassInPlace;

        // drake::multibody::RotationalInertia::ShiftToThenAwayFromCenterOfMass
        struct /* ShiftToThenAwayFromCenterOfMass */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:671
          const char* doc =
R"""(Calculates the rotational inertia that results from shifting `this`
rotational inertia for a body (or composite body) B from about-point P
to about-point Q via Bcm (B's center of mass). I.e., shifts `I_BP_E`
to `I_BQ_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_PBcm_E``:
    Position vector from P to Bcm, expressed-in frame E.

Parameter ``p_QBcm_E``:
    Position vector from Q to Bcm, expressed-in frame E.

Returns ``I_BQ_E``:
    , B's rotational inertia about-point Q expressed-in frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
    has no affect on the result.)""";

        } ShiftToThenAwayFromCenterOfMass;

        // drake::multibody::RotationalInertia::ShiftToThenAwayFromCenterOfMassInPlace
        struct /* ShiftToThenAwayFromCenterOfMassInPlace */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:650
          const char* doc =
R"""(Shifts `this` rotational inertia for a body (or composite body) B from
about-point P to about-point Q via Bcm (B's center of mass). I.e.,
shifts `I_BP_E` to `I_BQ_E` (both are expressed-in frame E).

Parameter ``mass``:
    The mass of body (or composite body) B.

Parameter ``p_PBcm_E``:
    Position vector from P to Bcm, expressed-in frame E.

Parameter ``p_QBcm_E``:
    Position vector from Q to Bcm, expressed-in frame E.

Returns:
    A reference to `this` rotational inertia expressed-in frame E, but
    with `this` shifted from about-point P to about-point Q, i.e.,
    returns I_BQ_E, B's rotational inertia about-point Q expressed-in
    frame E.

Throws:
    s std::logic_error for Debug builds if the rotational inertia that
    is shifted to about-point Q violates CouldBePhysicallyValid().

Remark:
    Negating either (or both) position vectors p_PBcm_E and p_QBcm_E
    has no affect on the result.

Remark:
    This method is more efficient (by 6 multiplications) than first
    shifting to the center of mass, then shifting away, e.g., as
    (ShiftToCenterOfMassInPlace()).ShiftFromCenterOfMassInPlace();)""";

        } ShiftToThenAwayFromCenterOfMassInPlace;

        // drake::multibody::RotationalInertia::Trace
        struct /* Trace */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:174
          const char* doc =
R"""(Returns a rotational inertia's trace (i.e., Ixx + Iyy + Izz, the sum
of the diagonal elements of the inertia matrix). The trace happens to
be invariant to its expressed-in frame (i.e., the trace does not
depend on the frame in which it is expressed). The trace is useful
because the largest moment of inertia Imax has range: trace / 3 <=
Imax <= trace / 2, and the largest possible product of inertia must be
<= Imax / 2. Hence, trace / 3 and trace / 2 give a lower and upper
bound on the largest possible element that can be in a valid
rotational inertia.)""";

        } Trace;

        // drake::multibody::RotationalInertia::TriaxiallySymmetric
        struct /* TriaxiallySymmetric */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:143
          const char* doc = R"""()""";

        } TriaxiallySymmetric;

        // drake::multibody::RotationalInertia::cast
        struct /* cast */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:409
          const char* doc =
R"""(Returns a new RotationalInertia object templated on `Scalar`
initialized from the values of `this` rotational inertia's entries.

Template parameter ``Scalar``:
    The scalar type on which the new rotational inertia will be
    templated.

Note:
    `RotationalInertia<From>::cast<To>()` creates a new
    `RotationalInertia<To>` from a `RotationalInertia<From>` but only
    if type `To` is constructible from type `From`. This cast method
    works in accordance with Eigen's cast method for Eigen's Matrix3
    that underlies this RotationalInertia. For example, Eigen
    currently allows cast from type double to AutoDiffXd, but not
    vice-versa.)""";

        } cast;

        // drake::multibody::RotationalInertia::cols
        struct /* cols */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:151
          const char* doc =
R"""(For consistency with Eigen's API, the cols() method returns 3.)""";

        } cols;

        // drake::multibody::RotationalInertia::get_moments
        struct /* get_moments */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:154
          const char* doc =
R"""(Returns 3-element vector with moments of inertia [Ixx, Iyy, Izz].)""";

        } get_moments;

        // drake::multibody::RotationalInertia::get_products
        struct /* get_products */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:157
          const char* doc =
R"""(Returns 3-element vector with products of inertia [Ixy, Ixz, Iyz].)""";

        } get_products;

        // drake::multibody::RotationalInertia::operator()
        struct /* operator_call */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:189
          const char* doc =
R"""(Const access to the `(i, j)` element of this rotational inertia.

Remark:
    A mutable version of operator() is intentionally absent so as to
    prevent an end-user from directly setting elements. This prevents
    the creation of a non-physical (or non-symmetric) rotational
    inertia.)""";

        } operator_call;

        // drake::multibody::RotationalInertia::operator*
        struct /* operator_mul */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:314
          const char* doc =
R"""(Multiplies `this` rotational inertia by a nonnegative scalar (>= 0).
In debug builds, throws std::logic_error if `nonnegative_scalar` < 0.

Parameter ``nonnegative_scalar``:
    Nonnegative scalar which multiplies `this`.

Returns:
    `this` rotational inertia multiplied by `nonnegative_scalar`.

See also:
    operator*=(), operator*(const T&, const RotationalInertia<T>&))""";

          // drake/multibody/multibody_tree/rotational_inertia.h:336
          const char* doc_2 = R"""()""";

        } operator_mul;

        // drake::multibody::RotationalInertia::operator*=
        struct /* operator_imul */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:302
          const char* doc =
R"""(Multiplies `this` rotational inertia by a nonnegative scalar (>= 0).
In debug builds, throws RuntimeError if `nonnegative_scalar` < 0.

Parameter ``nonnegative_scalar``:
    Nonnegative scalar which multiplies `this`.

Returns:
    A reference to `this` rotational inertia. `this` changes since
    `this` has been multiplied by `nonnegative_scalar`.

See also:
    operator*(), operator*(const T&, const RotationalInertia<T>&).)""";

        } operator_imul;

        // drake::multibody::RotationalInertia::operator+
        struct /* operator_add */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:255
          const char* doc =
R"""(Adds a rotational inertia `I_BP_E` to `this` rotational inertia. This
method requires both rotational inertias (`I_BP_E` and `this`) to have
the same about-point P and the same expressed-in frame E.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be added to
    `this` rotational inertia. `I_BP_E` and `this` must have the same
    about-point P and expressed-in frame E.

Returns:
    The sum of `this` rotational inertia and `I_BP_E`.

See also:
    operator+=().)""";

        } operator_add;

        // drake::multibody::RotationalInertia::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:242
          const char* doc = R"""()""";

        } operator_iadd;

        // drake::multibody::RotationalInertia::operator-
        struct /* operator_sub */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:292
          const char* doc =
R"""(Subtracts a rotational inertia `I_BP_E` from `this` rotational
inertia. This method requires both rotational inertias (`I_BP_E` and
`this`) to have the same about-point P and the same expressed-in frame
E.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from `this` rotational inertia. `I_BP_E` and `this`
    must have the same about-point P and expressed-in frame E.

Returns:
    The subtraction of `I_BP_E` from `this` rotational inertia.

Throws:
    s std::logic_error for Debug builds if not
    CouldBePhysicallyValid().

See also:
    operator-=(). @warning See warning and documentation for
    operator-=().)""";

        } operator_sub;

        // drake::multibody::RotationalInertia::operator-=
        struct /* operator_isub */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:276
          const char* doc =
R"""(Subtracts a rotational inertia `I_BP_E` from `this` rotational
inertia. This method requires both rotational inertias (`I_BP_E` and
`this`) to have the same about-point P and the same expressed-in frame
E. The -= operator updates `this` so `I_BP_E` is subtracted from
`this`.

Parameter ``I_BP_E``:
    Rotational inertia of a body (or composite body) B to be
    subtracted from `this` rotational inertia. `I_BP_E` and `this`
    must have the same about-point P and expressed-in frame E.

Returns:
    A reference to `this` rotational inertia. `this` changes since
    rotational inertia `I_BP_E` has been subtracted from it.

Throws:
    s std::logic_error for Debug builds if not
    CouldBePhysicallyValid().

See also:
    operator-().

Note:
    This subtract operator is useful for computing rotational inertia
    of a body with a hole. First the rotational inertia of a fully
    solid body S (without the hole) is calculated, then the rotational
    inertia of the hole (treated as a massive solid body B) is
    calculated. The rotational inertia of a composite body C
    (comprised of S and -B) is computed by subtracting B's rotational
    inertia from S's rotational inertia.)""";

        } operator_isub;

        // drake::multibody::RotationalInertia::operator/
        struct /* operator_div */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:358
          const char* doc = R"""()""";

        } operator_div;

        // drake::multibody::RotationalInertia::operator/=
        struct /* operator_idiv */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:346
          const char* doc =
R"""(Divides `this` rotational inertia by a positive scalar (> 0). In debug
builds, throws RuntimeError if `positive_scalar` <= 0.

Parameter ``positive_scalar``:
    Positive scalar (> 0) which divides `this`.

Returns:
    A reference to `this` rotational inertia. `this` changes since
    `this` has been divided by `positive_scalar`.

See also:
    operator/().)""";

        } operator_idiv;

        // drake::multibody::RotationalInertia::rows
        struct /* rows */ {

          // drake/multibody/multibody_tree/rotational_inertia.h:148
          const char* doc =
R"""(For consistency with Eigen's API, the rows() method returns 3.)""";

        } rows;

      } RotationalInertia;

      // drake::multibody::SpaceXYZMobilizer
      struct /* SpaceXYZMobilizer */ {

        // drake/multibody/multibody_tree/space_xyz_mobilizer.h:70
        const char* doc =
R"""(This mobilizer models a gimbal joint between an inboard frame F and an
outboard frame M that allows frame M to rotate freely with respect to
F ( though a gimbal joint provides arbitrary orientation like a ball
joint but with some restrictions, discussed below). No translational
motion of M in F is allowed and the inboard frame origin `Fo` and the
outboard frame origin `Mo` are coincident at all times.

The orientation `R_FM` of the outboard frame M in F is parameterized
with space `x-y-z` Euler angles (also known as extrinsic angles). That
is, the generalized coordinates for this mobilizer correspond to
angles θ₁, θ₂, θ₃, for a sequence of rotations about the x̂, ŷ, ẑ
axes solidary with frame F, respectively. Mathematically, rotation
`R_FM` is given in terms of angles θ₁, θ₂, θ₃ by:

```
R_FM(q) = Rz(θ₃) * Ry(θ₂) * Rx(θ₁)
```

where `Rx(θ)`, `Ry(θ)` and `Rz(θ)` correspond to the elemental
rotations in amount of θ about the x, y and z axes respectively. Zero
θ₁, θ₂, θ₃ angles define the "zero configuration" which corresponds to
frames F and M being coincident, see set_zero_configuration(). Angles
θ₁, θ₂, θ₃ are defined to be positive according to the right-hand-rule
with the thumb aligned in the direction of their respective axes.

The generalized velocities for this mobilizer correspond to the
angular velocity `w_FM` of frame M in F, expressed in frame F.
MapVelocityToQDot() maps the angular velocity `w_FM` to Euler angles's
rates while MapQDotToVelocity() maps Euler angles's rates to angular
velocity `w_FM`. While the mapping MapVelocityToQDot() always exists,
its inverse MapQDotToVelocity() is singular for values of θ₂ (many
times referred to as the pitch angle) such that `θ₂ = π/2 + kπ, ∀ k ∈
ℤ`.

Note:
    Space `x-y-z` angles (extrinsic) are equivalent to Body `z-y-x`
    angles (intrinsic).

Note:
    This particular choice of generalized coordinates θ₁, θ₂, θ₃ for
    this mobilizer is many times referred to as the roll, pitch and
    yaw angles by many dynamicists. They are also known as the Tait-
    Bryan angles or Cardan angles.

Note:
    The mapping from angular velocity to Euler angle's rates is
    singular for angle `θ₂` (many times referred to as the pitch
    angle) such that `θ₂ = π/2 + kπ, ∀ k ∈ ℤ`.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::SpaceXYZMobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:210
          const char* doc =
R"""(Computes the across-mobilizer acceleration `A_FM(q, v, v̇)` of the
outboard frame M in the inboard frame F. The acceleration `A_FM` will
be a function of the generalized positions q (space x-y-z angles)
stored in `context`, of the generalized velocities v (angular velocity
`w_FM`) also stored in `context` and of the supplied generalized
accelerations `vdot`, which in this case correspond to angular
acceleration of M in F `alpha_FM = Dt_F(w_FM)` (see
Dt_multibody_quantities for our notation of time derivatives in
different reference frames).)""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::SpaceXYZMobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:197
          const char* doc =
R"""(Computes the across-mobilizer velocity `V_FM(q, v)` of the outboard
frame M measured and expressed in frame F as a function of the space
x-y-z angles θ₁, θ₂, θ₃ stored in `context` and of the input
generalized velocity v which contains the components of the angular
velocity `w_FM` expressed in frame F.)""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::SpaceXYZMobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:189
          const char* doc =
R"""(Computes the across-mobilizer transform `X_FM(q)` between the inboard
frame F and the outboard frame M as a function of the space x-y-z
angles θ₁, θ₂, θ₃ stored in `context`.)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::SpaceXYZMobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:261
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:264
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::SpaceXYZMobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:254
          const char* doc =
R"""(Maps time derivatives of the space x-y-z angles θ₁, θ₂, θ₃ in `qdot`
to the generalized velocity v, which corresponds to the angular
velocity `w_FM`.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``qdot``:
    A vector containing the time derivatives of the space x-y-z angles
    θ₁, θ₂, θ₃ in `qdot(0)`, `qdot(1)` and `qdot(2)`, respectively.

Parameter ``v``:
    A vector of generalized velocities for this Mobilizer which should
    correspond to a vector in ℝ³ for an angular velocity `w_FM` of M
    in F.)""";

        } MapQDotToVelocity;

        // drake::multibody::SpaceXYZMobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:237
          const char* doc =
R"""(Maps the generalized velocity v, which corresponds to the angular
velocity `w_FM`, to time derivatives of space x-y-z angles θ₁, θ₂, θ₃
in `qdot`.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``v``:
    A vector of generalized velocities for this Mobilizer which should
    correspond to a vector in ℝ³ for an angular velocity `w_FM` of M
    in F.

Parameter ``qdot``:
    A Vector3 packing of the time derivatives of the space x-y-z
    angles θ₁, θ₂, θ₃ in `qdot(0)`, `qdot(1)` and `qdot(2)`,
    respectively.

@warning The mapping from Euler angle's rates to angular velocity is
singular for angle `θ₂` such that `θ₂ = π/2 + kπ, ∀ k ∈ ℤ`. To avoid
working close to this singularity (which could potentially result in
large errors for `qdot`), this method aborts when the absolute value
of the cosine of θ₂ is smaller than 10⁻³, a number arbitrarily chosen
to this end.)""";

        } MapVelocityToQDot;

        // drake::multibody::SpaceXYZMobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:214
          const char* doc = R"""()""";

        } ProjectSpatialForce;

        // drake::multibody::SpaceXYZMobilizer::SetFromRotationMatrix
        struct /* SetFromRotationMatrix */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:135
          const char* doc =
R"""(Given a desired orientation `R_FM` of frame M in F as a rotation
matrix, This method sets `context` so that the generalized coordinates
corresponding to the space x-y-z angles θ₁, θ₂, θ₃ of `this` mobilizer
represent this rotation.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``R_FM``:
    The desired pose of M in F. A valid element of `SO(3)`.

Returns:
    a constant reference to `this` mobilizer.

@warning Ideally, `R_FM` would correspond to a valid rotation in the
special orthogonal group `SO(3)`. To eliminate possible round-off
errors in the input matrix `R_FM` this method performs a projection of
`R_FM` into its closest element in `SO(3)` and then computes the space
x-y-z angles θ₁, θ₂, θ₃ that correspond to this rotation. See
RotationMatrix<T>::ProjectToRotationMatrix

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.

Throws:
    s std::logic_error if an improper rotation results after
    projection of `R_FM`, that is, if the projected matrix's
    determinant is `-1`.)""";

        } SetFromRotationMatrix;

        // drake::multibody::SpaceXYZMobilizer::SpaceXYZMobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:72
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:72
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:78
          const char* doc_3 =
R"""(Constructor for a SpaceXYZMobilizer between an inboard frame F
`inboard_frame_F` and an outboard frame M `outboard_frame_M` granting
three rotational degree of freedom corresponding to angles θ₁, θ₂, θ₃
as described in this class's documentation.)""";

        } ctor;

        // drake::multibody::SpaceXYZMobilizer::get_angles
        struct /* get_angles */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:95
          const char* doc =
R"""(Retrieves from `context` the three space x-y-z angles θ₁, θ₂, θ₃ which
describe the state for `this` mobilizer as documented in this class's
documentation.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns ``angles``:
    The three space x-y-z angles θ₁, θ₂, θ₃, associated with the
    sequence of rotations about the space fixed axes x̂, ŷ, ẑ,
    respectively packed and returned as a Vector3 with entries
    `angles(0) = θ₁`, `angles(1) = θ₂`, `angles(2) = θ₃`.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.)""";

        } get_angles;

        // drake::multibody::SpaceXYZMobilizer::get_angular_velocity
        struct /* get_angular_velocity */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:152
          const char* doc =
R"""(Retrieves from `context` the angular velocity `w_FM` of the outboard
frame M in the inboard frame F, expressed in F.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Returns ``w_FM``:
    A vector in ℝ³ with the angular velocity of the outboard frame M
    in the inboard frame F, expressed in F.

Note:
    Many dynamicists follow the convention of expressing angular
    velocity in the outboard frame M; we return it expressed in the
    inboard frame F. That is, this method returns `W_FM_F`.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.)""";

        } get_angular_velocity;

        // drake::multibody::SpaceXYZMobilizer::set_angles
        struct /* set_angles */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:110
          const char* doc =
R"""(Sets in `context` the state for `this` mobilizer to have the space
x-y-z angles θ₁, θ₂, θ₃, provided in the input argument `angles`,
which stores the with the format `angles = [θ₁, θ₂, θ₃]`.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``angles``:
    A Vector3 which must pack values for the space x-y-z angles θ₁,
    θ₂, θ₃, described in this class's documentation, at entries
    `angles(0)`, `angles(1)` and `angles(2)`, respectively.

Returns:
    a constant reference to `this` mobilizer.

Throws:
    s std::logic_error if `context` is not a valid
    MultibodyTreeContext.)""";

        } set_angles;

        // drake::multibody::SpaceXYZMobilizer::set_angular_velocity
        struct /* set_angular_velocity */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:162
          const char* doc =
R"""(Sets in `context` the state for `this` mobilizer so that the angular
velocity of the outboard frame M in the inboard frame F is `w_FM`.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``w_FM``:
    A vector in ℝ³ with the desired angular velocity of the outboard
    frame M in the inboard frame F, expressed in F.

Returns:
    a constant reference to `this` mobilizer.)""";

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:177
          const char* doc_2 =
R"""(Stores in `state` the angular velocity `w_FM` of the outboard frame M
in the inboard frame F corresponding to `this` mobilizer.

Parameter ``context``:
    The context of the MultibodyTree this mobilizer belongs to.

Parameter ``state``:
    On return, `state` will store the angular velocity `w_FM` of frame
    F in frame M.

Parameter ``w_FM``:
    A vector in ℝ³ with the desired angular velocity of the outboard
    frame M in the inboard frame F, expressed in F.

Returns:
    a constant reference to `this` mobilizer.)""";

        } set_angular_velocity;

        // drake::multibody::SpaceXYZMobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/space_xyz_mobilizer.h:183
          const char* doc =
R"""(Sets `state` to store zero space x-y-z angles θ₁, θ₂, θ₃ and zero
across mobilizer angular velocity `w_FM`.)""";

        } set_zero_state;

      } SpaceXYZMobilizer;

      // drake::multibody::SpatialAcceleration
      struct /* SpatialAcceleration */ {

        // drake/multibody/multibody_tree/math/spatial_acceleration.h:52
        const char* doc =
R"""(This class is used to represent a _spatial acceleration_ that combines
rotational (angular acceleration) and translational (linear
acceleration) components. While a SpatialVelocity `V_XY` represents
the motion of a "moving frame" Y measured with respect to a "measured-
in" frame X, the SpatialAcceleration `A_XY` represents the rate of
change of this spatial velocity `V_XY` in frame X. That is $^XA^Y =
\frac{^Xd}{dt}\,{^XV^Y} $ where $\frac{^Xd}{dt} $ denotes the time
derivative taken in frame X. That is, to compute an acceleration we
need to specify in what frame the time derivative is taken, see
[Mitiguy 2016, §6.1] for a more in depth discussion on this. Time
derivatives can be taken in different frames, and they transform
according to the "Transport Theorem", which is in Drake is implemented
in drake::math::ConvertTimeDerivativeToOtherFrame(). In source code
comments we write `A_XY = DtX(V_XY)`, where `DtX()` is the operator
that takes the time derivative in the X frame. By convention, and
unless otherwise stated, we assume that the frame in which the time
derivative is taken is the "measured-in" frame, i.e. the time
derivative used in `A_XY` is in frame X by default (i.e. DtX()). To
perform numerical computations, we need to specify an "expressed-in"
frame E (which may be distinct from either X or Y), so that components
can be expressed as real numbers. Only the vector values are stored in
a SpatialAcceleration object; the frames must be understood from
context and it is the responsibility of the user to keep track of
them. That is best accomplished through disciplined notation. In
source code we use monogram notation where capital A is used to
designate a spatial acceleration quantity. The same monogram notation
rules for SpatialVelocity are also used for SpatialAcceleration. That
is, the spatial acceleration of a frame Y measured in X and expressed
in E is denoted with `A_XY_E`. For a more detailed introduction on
spatial vectors and the monogram notation please refer to section
multibody_spatial_vectors.

[Mitiguy 2016] Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::SpatialAcceleration::ComposeWithMovingFrameAcceleration
        struct /* ComposeWithMovingFrameAcceleration */ {

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:374
          const char* doc =
R"""(This method composes `this` spatial acceleration `A_WP` of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial acceleration `A_PB`. The result is the spatial acceleration
`A_WB` of frame B measured in W. At the instant in which the
accelerations are composed, frame B is located with its origin `Bo` at
`p_PoBo` from P's origin Po.

This operation can be written in a more compact fom in terms of the
rigid shift operator `Φᵀ(p_PoBo)` (see SpatialVelocity::Shift()) as:

```
A_WB = Φᵀ(p_PoBo)A_WP + Ac_WB(w_WP, V_PB) + A_PB_W
```

where `Φᵀ(p_PoBo)A_WP` denotes the application of the rigid shift
operation as in SpatialVelocity::Shift() and `Ac_WB(w_WP, V_PB)`
contains the centrifugal and Coriolis terms:

```
Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                            |
                      | w_WP x w_WP x p_PoBo_W + 2 w_WP x v_PB_W |
                                  ^^^                ^^^
                              centrifugal         Coriolis
```

The equation above shows that composing spatial accelerations cannot
be simply accomplished by adding `A_WP` with `A_PB` (this is the
reason why this class does not overload the `operator+()` and provides
this method instead). Moreover, we see that, unlike with angular
velocities, angular accelerations cannot be added in order to compose
them. That is `w_AC = w_AB + w_BC` but `alpha_AC ≠ alpha_AB +
alpha_BC` due to the cross term `w_AC x w_BC`. See the derivation
below for more details.

See also:
    SpatialVelocity::ComposeWithMovingFrameVelocity() for the
    composition of SpatialVelocity quantities.

Note:
    This method is the extension to the Shift() operator, which
    computes the spatial acceleration frame P shifted to `Bo` as if
    frame B moved rigidly with P, that is, for when `V_PB` and `A_PB`
    are both zero. In other words the results from Shift() equal the
    results from this method when `V_PB` and `A_PB` are both zero.

Parameter ``p_PoBo_E``:
    Shift vector from P's origin to B's origin, expressed in frame E.
    The "from" point `Po` must be the point whose acceleration is
    currently represented in `this` spatial acceleration, and E must
    be the same expressed-in frame as for `this` spatial acceleration.

Parameter ``w_WP_E``:
    Angular velocity of frame P measured in frame A and expressed in
    frame E.

Parameter ``V_PB_E``:
    The spatial velocity of a third frame B in motion with respect to
    P, expressed in the same frame E as `this` spatial acceleration.

Parameter ``A_PB_E``:
    The spatial acceleration of a third frame B in motion with respect
    to P, expressed in the same frame E as `this` spatial
    acceleration.

Returns ``A_WB_E``:
    The spatial acceleration of frame B in W, expressed in frame E.

<h3> Derivation </h3> The spatial velocity of frame B in W can be
obtained by composing `V_WP` with `V_PB`:

```
V_WB = V_WPb + V_PB = V_WP.Shift(p_PoBo) + V_PB                     (1)
```

This operation can be performed with the SpatialVelocity method
ComposeWithMovingFrameVelocity().

<h4> Translational acceleration component </h4>

The translational velocity `v_WBo` of point Bo in W corresponds to the
translational component in Eq. (1):

```
v_WBo = v_WPo + w_WP x p_PoBo + v_PBo                               (2)
```

Therefore, for the translational acceleration we have:

```
a_WBo = DtW(v_WBo)
        = DtW(v_WPo + w_WP x p_PoBo + v_PBo)
        = DtW(v_WPo) + DtW(w_WP x p_PoBo) + DtW(v_PBo)
        = a_WPo + DtW(w_WP) x p_PoBo + w_WP x DtW(p_PoBo) + DtW(v_PBo)
        = a_WPo + alpha_WP x p_PoBo + w_WP x DtW(p_PoBo) + DtW(v_PBo) (3)
```

with `a_WPo = DtW(v_WPo)` and `alpha_WP = DtW(w_WP)` by definition.
The term DtW(p_PoBo) in Eq. (3) is obtained by converting the vector
time derivative from `DtW()` to `DtP()`, see
drake::math::ConvertTimeDerivativeToOtherFrame():

```
DtW(p_PoBo) = DtP(p_PoBo) + w_WP x p_PoBo
              = v_PBo + w_WP x p_PoBo                                 (4)
```

since `v_PBo = DtP(p_PoBo)` by definition. Similarly, the term
`DtW(v_PBo)` in Eq. (3) is also obtained by converting the time
derivative from `DtW()` to `DtP()`:

```
DtW(v_PBo) = DtP(v_PBo) + w_WP x v_PBo
             = a_PBo + w_WP x v_PBo                                   (5)
```

with `a_PBo = DtP(v_PBo)` by definition. Using Eqs. (4) and (5) in Eq.
(3) yields for the translational acceleration:

```
a_WBo = a_WPo + alpha_WP x p_PoBo
        + w_WP x (v_PBo + w_WP x p_PoBo) + a_PBo + w_WP x v_PBo
```

and finally, by grouping terms together:

```
a_WBo = a_WPo + alpha_WP x p_PoBo
        + w_WP x w_WP x p_PoBo + 2 * w_WP x v_PBo + a_PBo             (6)
```

which includes the effect of angular acceleration of P in W `alpha_WP
x p_PoBo`, the centrifugual acceleration `w_WP x w_WP x p_PoBo`, the
Coriolis acceleration `2 * w_WP x v_PBo` due to the motion of `Bo` in
P and, the additional acceleration of `Bo` in P `a_PBo`.

<h4> Rotational acceleration component </h4>

The rotational velocity `w_WB` of frame B in W corresponds to the
rotational component in Eq. (1):

```
w_WB = w_WP + w_PB                                                  (7)
```

Therefore, the rotational acceleration of B in W corresponds to:

```
alpha_WB = DtW(w_WB) = DtW(w_WP) + DtW(w_PB)
           = alpha_WP + DtW(w_PB)                                     (8)
```

where the last term in Eq. (8) can be converted to a time derivative
in P as:

```
DtW(w_PB) = DtP(w_PB) + w_WP x w_PB = alpha_PB + w_WP x w_PB        (9)
```

where `alpha_PB = DtP(w_PB)` by definition. Thus, the final expression
for `alpha_WB` is obtained by using Eq. (9) into Eq. (8):

```
alpha_WB = alpha_WP + alpha_PB + w_WP x w_PB                       (10)
```

Equation (10) shows that angular accelerations cannot be simply added
as angular velocities can but there exists an additional term `w_WP x
w_PB`.

<h4> The spatial acceleration </h4>

The rotational and translational components of the spatial
acceleration are given by Eqs. (10) and (6) respectively:

```
A_WB.rotational() = alpha_WB = {alpha_WP} + alpha_PB + w_WP x w_PB (11)
  A_WB.translational() = a_WBo
                     = {a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo}
                     + 2 * w_WP x v_PBo + a_PBo                      (12)
```

where we have placed within curly brackets `{}` all the terms that
also appear in the Shift() operation, which is equivalent to this
method when `V_PB` and `A_PB` are both zero. In the equations above
`alpha_WP = A_WP.rotational()` and `a_WPo = A_WP.translational()`. The
above expression can be written in a more compact fom in terms of the
rigid shift operator `Φᵀ(p_PoBo)` (see SpatialVelocity::Shift()) as
presented in the main body of this documentation:

```
A_WB = Φᵀ(p_PoBo)A_WP + Ac_WB(w_WP, V_PB) + A_PB_W                 (13)
```

where `Ac_WB(w_WP, V_PB)` contains the centrifugal and Coriolis terms:

```
Ac_WB(w_WP, V_PB) = | w_WP x w_PB_W                            |
                      | w_WP x w_WP x p_PoBo_W + 2 w_WP x v_PB_W |
                                  ^^^                ^^^
                              centrifugal         Coriolis
```

As usual, for computation, all quantities above must be expressed in a
common frame E; we add an `_E` suffix to each symbol to indicate that.)""";

        } ComposeWithMovingFrameAcceleration;

        // drake::multibody::SpatialAcceleration::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:60
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialAcceleration::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:215
          const char* doc =
R"""(Shifts `this` spatial acceleration `A_WP` of a frame P into the
spatial acceleration `A_WPb` of a frame `Pb` which is an offset frame
rigidly aligned with P, but with its origin shifted to a point `Bo` by
an offset p_PoBo. Frame `Pb` is instantaneously moving together with
frame P as if rigidly attached to it. As an example of application,
this operation can be used to compute `A_WPb` where P is a frame on a
rigid body and `Bo` is another point on that same body. Therefore P
and `Pb` move together with the spatial velocity `V_PPb` being zero at
all times. This is an alternate signature for shifting a spatial
acceleration that does not change the original object. See
ShiftInPlace() for more information and a description of the
arguments.)""";

        } Shift;

        // drake::multibody::SpatialAcceleration::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:191
          const char* doc =
R"""(In-place shift of `this` spatial acceleration `A_WP` of a frame P into
the spatial acceleration `A_WPb` of a frame `Pb` which is an offset
frame rigidly aligned with P, but with its origin shifted to a point
`Bo` by an offset p_PoBo. Frame `Pb` is instantaneously moving
together with frame P as if rigidly attached to it. As an example of
application, this operation can be used to compute `A_WPb` where P is
a frame on a rigid body and `Bo` is another point on that same body.
Therefore P and `Pb` move together with the spatial velocity `V_PPb`
being zero at all times.

The shift operation modifies `this` spatial acceleration `A_WP_E` of a
frame P measured in a frame W and expressed in a frame E, to become
`A_WPb_E`, representing the acceleration of a frame `Pb` result of
shifting frame P to point `Bo` which instantaneously moves together
with frame P. This requires adjusting the linear acceleration
component to account for: 1. the angular acceleration `alpha_WP` of
frame P in W. 2. the centrifugal acceleration due to the angular
velocity `w_WP` of frame P in W.

We are given the vector from the origin `Po` of frame P to point `Bo`,
which becomes the origin of the shifted frame `Pb`, as the position
vector `p_PoBo_E` expressed in the same frame E as `this` spatial
acceleration. The operation performed, in coordinate-free form, is:

```
alpha_WPb  = alpha_WP,  i.e. the angular acceleration is unchanged.
  a_WBo = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo
```

where `alpha` and `a` represent the angular and linear acceleration
components respectively. See notes at the end of this documentation
for a detailed derivation.

For computation, all quantities above must be expressed in a common
frame E; we add an `_E` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_PoBo_E``:
    Shift vector from the origin `Po` of frame P to point `Bo`,
    expressed in frame E. The "from" frame P must be the frame whose
    acceleration is currently represented in `this` spatial
    acceleration, and E must be the same expressed-in frame as for
    this spatial acceleration.

Parameter ``w_WP_E``:
    Angular velocity of frame P measured in frame W and expressed in
    frame E.

Returns:
    A reference to `this` spatial acceleration which is now `A_WPb_E`,
    that is, the spatial acceleration of frame `Pb`, still measured in
    frame W and expressed in frame E.

See also:
    Shift() to compute the shifted spatial acceleration without
    modifying this original object.

<h3> Derivation </h3>

<h4> Translational acceleration component </h4>

Recall that frame `Pb` is an offset frame rigidly aligned with P, but
with its origin shifted to a point `Bo` by an offset `p_PoBo`. Frame
`Pb` is instantaneously moving together with frame P as if rigidly
attached to it. The translational velocity `v_WPb` of frame `Pb`'s
origin, point `Bo`, in W can be obtained by the shift operation as:

```
v_WPb = v_WPo + w_WP x p_PoBo                                       (1)
```

Therefore, for the translational acceleration we have:

```
a_WBo = DtW(v_WPb)
        = DtW(v_WPo + w_WP x p_PoBo)
        = DtW(v_WPo) + DtW(w_WP x p_PoBo)
        = a_WPo + DtW(w_WP) x p_PoBo + w_WP x DtW(p_PoBo)
        = a_WPo + alpha_WP x p_PoBo + w_WP x DtW(p_PoBo)              (2)
```

with `a_WPo = DtW(v_WPo)` and `alpha_WP = DtW(w_WP)` by definition.
The last term in Eq. (2) is obtained by converting the vector time
derivative from `DtW()` to `DtP()`, see
drake::math::ConvertTimeDerivativeToOtherFrame():

```
DtW(p_PoBo) = DtP(p_PoBo) + w_WP x p_PoBo
              = w_WP x p_PoBo                                         (3)
```

since `v_PBo = DtP(p_PoBo) = 0` because the position of point `Bo` is
fixed in frame P. Using Eq. (3) in Eq. (2) finally yields for the
translational acceleration:

```
a_WBo = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo            (4)
```

<h4> Rotational acceleration component </h4>

The rotational velocity of frame `Pb` simply equals that of frame P
since they are moving together in rigid motion, therefore `w_WPb =
w_WP`. From this, the rotational acceleration of frame `Pb` in W is
obtained as:

```
alpha_WPb = DtW(w_WPb) = DtW(w_WP) = alpha_WP                       (5)
```

which should be immediately obvious considering that frame `Pb`
rotates together with frame P.

With the rotational, Eq. (5), and translational, Eq. (4), components
of acceleration derived above, we can write for `A_WPb`:

```
A_WPb.rotational() = alpha_WPb = alpha_WP
  A_WPb.translational() = a_WBo
                        = a_WPo + alpha_WP x p_PoBo + w_WP x w_WP x p_PoBo
```

with `alpha_WP = A_WP.rotational()` and `a_WPo =
A_WP.translational()`. As usual, for computation, all quantities above
must be expressed in a common frame E; we add an `_E` suffix to each
symbol to indicate that.)""";

        } ShiftInPlace;

        // drake::multibody::SpatialAcceleration::SpatialAcceleration<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:60
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:60
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:67
          const char* doc_3 =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial acceleration are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial acceleration
fail fast, allowing fast bug detection.)""";

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:71
          const char* doc_4 =
R"""(SpatialAcceleration constructor from an angular acceleration `alpha`
and a linear acceleration `a`.)""";

          // drake/multibody/multibody_tree/math/spatial_acceleration.h:86
          const char* doc_5 =
R"""(SpatialAcceleration constructor from an Eigen expression that
represents a six-dimensional vector. Under the hood, spatial
accelerations are 6-element quantities that are pairs of ordinary
3-vectors. Elements 0-2 constitute the angular acceleration component
while elements 3-5 constitute the translational acceleration. The
argument `A` in this constructor is the concatenation of the
rotational 3D component followed by the translational 3D component.
This constructor will assert the size of `A` is six (6) at compile-
time for fixed sized Eigen expressions and at run-time for dynamic
sized Eigen expressions.)""";

        } ctor;

      } SpatialAcceleration;

      // drake::multibody::SpatialForce
      struct /* SpatialForce */ {

        // drake/multibody/multibody_tree/math/spatial_force.h:40
        const char* doc =
R"""(This class is used to represent a _spatial force_ (also called a
_wrench_) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as $B_P$ which
appears in code and comments as `Bp`. Then we write a particular
spatial force as `F_Bp_E` where the `_E` suffix indicates that the
expressed-in frame is E. This symbol represents a torque applied to
body B, and a force applied to point P on B, with both vectors
expressed in E. Very often the application point will be the body
origin `Bo`; if no point is shown the origin is understood, so `F_B_E`
means `F_Bo_E`. For a more detailed introduction on spatial vectors
and the monogram notation please refer to section
multibody_spatial_vectors.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/math/spatial_velocity.h:14
        const char* doc_2 =
R"""(This class is used to represent a _spatial force_ (also called a
_wrench_) that combines both rotational (torque) and translational
force components. Spatial forces are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are the torque component
while elements 3-5 are the force component. Both vectors must be
expressed in the same frame, and the translational force is applied to
a particular point of a body, but neither the frame nor the point are
stored with a SpatialForce object; they must be understood from
context. It is the responsibility of the user to keep track of the
application point and the expressed-in frame. That is best
accomplished through disciplined notation. In source code we use
monogram notation where capital F is used to designate a spatial force
quantity. We write a point P fixed to body (or frame) B as $B_P$ which
appears in code and comments as `Bp`. Then we write a particular
spatial force as `F_Bp_E` where the `_E` suffix indicates that the
expressed-in frame is E. This symbol represents a torque applied to
body B, and a force applied to point P on B, with both vectors
expressed in E. Very often the application point will be the body
origin `Bo`; if no point is shown the origin is understood, so `F_B_E`
means `F_Bo_E`. For a more detailed introduction on spatial vectors
and the monogram notation please refer to section
multibody_spatial_vectors.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::SpatialForce::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:48
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialForce::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:141
          const char* doc =
R"""(Shift of a SpatialForce from one application point to another. This is
an alternate signature for shifting a spatial force's application
point that does not change the original object. See ShiftInPlace() for
more information.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point `Bp` must be the current application
    point of `this` spatial force, and E must be the same expressed-in
    frame as for this spatial force.

Returns ``F_Bq_E``:
    The equivalent shifted spatial force, now applied at point Q
    rather than P.

See also:
    ShiftInPlace() to compute the shifted spatial force in-place
    modifying the original object.)""";

        } Shift;

        // drake::multibody::SpatialForce::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:119
          const char* doc =
R"""(In-place shift of a SpatialForce from one application point to
another. `this` spatial force `F_Bp_E`, which applies its
translational force component to point P of body B, is modified to
become the equivalent spatial force `F_Bq_E` that considers the force
to be applied to point Q of body B instead (see class comment for more
about this notation). This requires adjusting the torque component to
account for the change in moment caused by the force shift.

We are given the vector from point P to point Q, as a position vector
`p_BpBq_E` (or `p_PQ_E`) expressed in the same frame E as the spatial
force. The operation performed, in coordinate-free form, is:

```
τ_B  = τ_B -  p_BpBq x f_Bp
  f_Bq = f_Bp,  i.e. the force as applied to body B at Q is the
                same as was applied to B at P.
```

where τ and f represent the torque and force components respectively.

Notice this operation is linear. [Jain 2010], (§1.5, page 15) uses the
"rigid body transformation operator" to write this as:

```
F_Bq = Φ(p_BqBp)F_Bp = Φ(-p_BpBq)F_Bp
```

where `Φ(p_PQ)` is the linear operator:

```
Φ(p_PQ) = | I₃ p_PQx |
            | 0     I₃ |
```

where `p_PQx` denotes the cross product, skew-symmetric, matrix such
that `p_PQx v = p_PQ x v`. The transpose of this operator allow us to
shift spatial velocities, see SpatialVelocity::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis
and algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an `_E` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point `Bp` must be the current application
    point of `this` spatial force, and E must be the same expressed-in
    frame as for this spatial force.

Returns:
    A reference to `this` spatial force which is now `F_Bq_E`, that
    is, the force is now applied at point Q rather than P.

See also:
    Shift() to compute the shifted spatial force without modifying
    this original object.)""";

        } ShiftInPlace;

        // drake::multibody::SpatialForce::SpatialForce<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:48
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_force.h:48
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_force.h:55
          const char* doc_3 =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial force are left uninitialized resulting in a zero
cost operation. However in Debug builds those entries are set to NaN
so that operations using this uninitialized spatial force fail fast,
allowing fast bug detection.)""";

          // drake/multibody/multibody_tree/math/spatial_force.h:58
          const char* doc_4 =
R"""(SpatialForce constructor from a torque `tau` and a force `f`.)""";

          // drake/multibody/multibody_tree/math/spatial_force.h:67
          const char* doc_5 =
R"""(SpatialForce constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at run-
time for dynamic sized Eigen expressions.)""";

        } ctor;

        // drake::multibody::SpatialForce::dot
        struct /* dot */ {

          // drake/multibody/multibody_tree/math/spatial_algebra.h:28
          const char* doc =
R"""(Given `this` spatial force `F_Bp_E` applied at point P of body B and
expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity `V_IBp_E` of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by `this` spatial force when its body and application
point have the given spatial velocity. Although the two spatial
vectors must be expressed in the same frame, the result is independent
of that frame.

@warning The result of this method cannot be interpreted as power
unless the spatial velocity is measured in an inertial frame I.)""";

          // drake/multibody/multibody_tree/math/spatial_force.h:193
          const char* doc_2 =
R"""(Given `this` spatial force `F_Bp_E` applied at point P of body B and
expressed in a frame E, this method computes the 6-dimensional dot
product with the spatial velocity `V_IBp_E` of body B at point P,
measured in an inertial frame I and expressed in the same frame E in
which the spatial force is expressed. This dot-product represents the
power generated by `this` spatial force when its body and application
point have the given spatial velocity. Although the two spatial
vectors must be expressed in the same frame, the result is independent
of that frame.

@warning The result of this method cannot be interpreted as power
unless the spatial velocity is measured in an inertial frame I.)""";

        } dot;

        // drake::multibody::SpatialForce::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:158
          const char* doc =
R"""(Adds in a spatial force to `this` spatial force.

Parameter ``F_Sp_E``:
    A spatial force to be added to `this` spatial force. It must be on
    the same system or body S on which `this` spatial force is applied
    and at the same point P as `this` spatial force, and expressed in
    the same frame E.

Returns:
    A reference to `this` spatial force, which has been updated to
    include the given spatial force `F_Sp_E`.

@warning This operation is only valid if both spatial forces are
applied on the same system or body S, at the same point P and
expressed in the same frame E.)""";

        } operator_iadd;

        // drake::multibody::SpatialForce::operator-=
        struct /* operator_isub */ {

          // drake/multibody/multibody_tree/math/spatial_force.h:176
          const char* doc =
R"""(Subtracts a spatial force from `this` spatial force.

Parameter ``F_Sp_E``:
    A spatial force to be subtracted from `this` spatial force. It
    must be on the same system or body S on which `this` spatial force
    is applied and at the same point P as `this` spatial force, and
    expressed in the same frame E.

Returns:
    A reference to `this` spatial force, which has been updated to
    exclude the given spatial force `F_Sp_E`.

@warning This operation is only valid if both spatial forces are
applied on the same system or body S, at the same point P and
expressed in the same frame E.)""";

        } operator_isub;

      } SpatialForce;

      // drake::multibody::SpatialInertia
      struct /* SpatialInertia */ {

        // drake/multibody/multibody_tree/spatial_inertia.h:96
        const char* doc =
R"""(This class represents the physical concept of a _Spatial Inertia_. A
spatial inertia (or spatial mass matrix) encapsulates the mass, center
of mass, and rotational inertia of the mass distribution of a body or
composite body S, where with "composite body" we mean a collection of
bodies welded together containing at least one body (throughout this
documentation "body" is many times used instead of "composite body"
but the same concepts apply to a collection of bodies as well.) A
spatial inertia is an element of ℝ⁶ˣ⁶ that is symmetric, and positive
semi-definite. It logically consists of `3x3` sub-matrices arranged
like so, [Jain 2010]:

```
Spatial mass matrix
          ------------ ------------
       0 |            |            |
       1 |    I_SP    | m p_PScm×  |
       2 |            |            |
          ------------ ------------
       3 |            |            |
       4 | -m p_PScm× |     m Id   |
       5 |            |            |
          ------------ ------------
               Symbol: M
```

where, with the monogram notation described in
multibody_spatial_inertia, `I_SP` is the rotational inertia of body or
composite body S computed about a point P, m is the mass of this
composite body, `p_PScm` is the position vector from point P to the
center of mass `Scm` of the composite body S with `p_PScm×` denoting
its skew-symmetric cross product matrix (defined such that `a× b =
a.cross(b)`), and `Id` is the identity matrix in ℝ³ˣ³. See Section
2.1, p. 17 of [Jain 2010]. The logical arrangement as shown above is
chosen to be consistent with our logical arrangement for spatial
vectors as documented in multibody_spatial_algebra for which the
rotational component comes first followed by the translational
component.

In typeset material we use the symbol $ [M^{S/P}]_E $ to represent the
spatial inertia of a body or composite body S about point P, expressed
in frame E. For this inertia, the monogram notation reads `M_SP_E`. If
the point P is fixed to a body B, we write that point as $ B_P $ which
appears in code and comments as `Bp`. So if the body or composite body
is B and the about point is `Bp`, the monogram notation reads
`M_BBp_E`, which can be abbreviated to `M_Bp_E` since the about point
`Bp` also identifies the body. Common cases are that the about point
is the origin `Bo` of the body, or it's the center of mass `Bcm` for
which the rotational inertia in monogram notation would read as
`I_Bo_E` and `I_Bcm_E`, respectively. Given `M_BP_E` ($[M^{B/P}]_E$),
the rotational inertia of this spatial inertia is `I_BP_E`
($[I^{B/P}]_E$) and the position vector of the center of mass measured
from point P and expressed in E is `p_PBcm_E` ($[^Pp^{B_{cm}}]_E$).

Note:
    This class does not implement any mechanism to track the frame E
    in which a spatial inertia is expressed or about what point is
    computed. Methods and operators on this class have no means to
    determine frame consistency through operations. It is therefore
    the responsibility of users of this class to keep track of frames
    in which operations are performed. We suggest doing that using
    disciplined notation, as described above.

Note:
    Several methods in this class throw a RuntimeError for invalid
    rotational inertia operations in debug releases only. This
    provides speed in a release build while facilitating debugging in
    debug builds. In addition, these validity tests are only performed
    for scalar types for which drake::scalar_predicate<T>::is_bool is
    `true`. For instance, validity checks are not performed when T is
    symbolic::Expression.

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis
and algorithms. Springer Science & Business Media.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::multibody::SpatialInertia::CalcComMoment
        struct /* CalcComMoment */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:190
          const char* doc =
R"""(Computes the center of mass moment vector `mass * p_PScm_E` given the
position vector `p_PScm_E` from the _about point_ P to the center of
mass `Scm` of the body or composite body S, expressed in frame E. See
the documentation of this class for details.)""";

        } CalcComMoment;

        // drake::multibody::SpatialInertia::CalcRotationalInertia
        struct /* CalcRotationalInertia */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:200
          const char* doc =
R"""(Computes the rotational inertia `I_SP_E = mass * G_SP_E` of this
spatial inertia, computed about point P and expressed in frame E. See
the documentation of this class for details.)""";

        } CalcRotationalInertia;

        // drake::multibody::SpatialInertia::CopyToFullMatrix6
        struct /* CopyToFullMatrix6 */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:234
          const char* doc =
R"""(Copy to a full 6x6 matrix representation.)""";

        } CopyToFullMatrix6;

        // drake::multibody::SpatialInertia::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:98
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialInertia::IsNaN
        struct /* IsNaN */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:204
          const char* doc =
R"""(Returns `true` if any of the elements in this spatial inertia is NaN
and `false` otherwise.)""";

        } IsNaN;

        // drake::multibody::SpatialInertia::IsPhysicallyValid
        struct /* IsPhysicallyValid */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:226
          const char* doc =
R"""(Performs a number of checks to verify that this is a physically valid
spatial inertia. The checks performed are: - No NaN entries. - Non-
negative mass. - Non-negative principal moments about the center of
mass. - Principal moments about the center of mass must satisfy the
triangle inequality: - `Ixx + Iyy >= Izz` - `Ixx + Izz >= Iyy` - `Iyy
+ Izz >= Ixx` These are the tests performed by
RotationalInertia::CouldBePhysicallyValid() which become a sufficient
condition when performed on a rotational inertia about a body's center
of mass.

See also:
    RotationalInertia::CouldBePhysicallyValid().)""";

        } IsPhysicallyValid;

        // drake::multibody::SpatialInertia::MakeFromCentralInertia
        struct /* MakeFromCentralInertia */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:116
          const char* doc =
R"""(Creates a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass, and central
rotational inertia. For example, this method creates a body's
SpatialInertia about its body origin Bo from the body's mass, position
vector from Bo to the body's center of mass, and rotational inertia
about the body's center of mass.

This method checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a
std::runtime_error exception in the event the provided input
parameters lead to a non-physically viable spatial inertia.

Parameter ``mass``:
    The mass of the body or composite body S.

Parameter ``p_PScm_E``:
    The position vector from point P to point `Scm` (S's center of
    mass), expressed in a frame E.

Parameter ``I_SScm_E``:
    S's RotationalInertia about Scm, expressed in frame E.

Returns ``M_SP_E``:
    S's spatial inertia about point P, expressed in frame E.)""";

        } MakeFromCentralInertia;

        // drake::multibody::SpatialInertia::ReExpress
        struct /* ReExpress */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:306
          const char* doc =
R"""(Given `this` spatial inertia `M_SP_E` for some body or composite body
S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A.

Parameter ``R_AE``:
    Rotation matrix from frame E to frame A.

Returns ``M_SP_A``:
    The same spatial inertia of S about P but now re-expressed in
    frame A.

See also:
    ReExpressInPlace() for details.)""";

        } ReExpress;

        // drake::multibody::SpatialInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:292
          const char* doc =
R"""(Given `this` spatial inertia `M_SP_E` for some body or composite body
S, taken about a point P and expressed in frame E, this method
computes the same inertia re-expressed in another frame A. This
operation is performed in-place modifying the original object.

Parameter ``R_AE``:
    Rotation matrix from frame E to frame A.

Returns:
    A reference to `this` rotational inertia about the same point P
    but now re-expressed in frame A, that is, `M_SP_A`.

@warning This method does not check whether the input matrix `R_AE`
represents a valid rotation or not. It is the resposibility of users
to provide valid rotation matrices.)""";

        } ReExpressInPlace;

        // drake::multibody::SpatialInertia::SetNaN
        struct /* SetNaN */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:246
          const char* doc =
R"""(Sets `this` spatial inertia to have NaN entries. Typically used for
quick detection of uninitialized values.)""";

        } SetNaN;

        // drake::multibody::SpatialInertia::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:351
          const char* doc =
R"""(Given `this` spatial inertia `M_SP_E` for some body or composite body
S, computed about point P, and expressed in frame E, this method uses
the _Parallel Axis Theorem_ for spatial inertias to compute the same
spatial inertia about a new point Q. The result still is expressed in
frame E.

See also:
    ShiftInPlace() for more details.

Parameter ``p_PQ_E``:
    Vector from the original about point P to the new about point Q,
    expressed in the same frame E `this` spatial inertia is expressed
    in. @retval `M_SQ_E` This same spatial inertia for body or
    composite body S but computed about about a new point Q.)""";

        } Shift;

        // drake::multibody::SpatialInertia::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:325
          const char* doc =
R"""(Given `this` spatial inertia `M_SP_E` for some body or composite body
S, computed about point P, and expressed in frame E, this method uses
the _Parallel Axis Theorem_ for spatial inertias to compute the same
spatial inertia about a new point Q. The result still is expressed in
frame E. This operation is performed in-place modifying the original
object.

See also:
    Shift() which does not modify this object.

For details see Section 2.1.2, p. 20 of [Jain 2010].

Parameter ``p_PQ_E``:
    Vector from the original about point P to the new about point Q,
    expressed in the same frame E `this` spatial inertia is expressed
    in.

Returns:
    A reference to `this` spatial inertia for body or composite body S
    but now computed about about a new point Q.)""";

        } ShiftInPlace;

        // drake::multibody::SpatialInertia::SpatialInertia<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:98
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/spatial_inertia.h:98
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/spatial_inertia.h:128
          const char* doc_3 =
R"""(Default SpatialInertia constructor initializes mass, center of mass
and rotational inertia to invalid NaN's for a quick detection of
uninitialized values.)""";

          // drake/multibody/multibody_tree/spatial_inertia.h:152
          const char* doc_4 =
R"""(Constructs a spatial inertia for a physical body or composite body S
about a point P from a given mass, center of mass and rotational
inertia. The center of mass is specified by the position vector
`p_PScm_E` from point P to the center of mass point `Scm`, expressed
in a frame E. The rotational inertia is provided as the UnitInertia
`G_SP_E` of the body or composite body S computed about point P and
expressed in frame E.

Note:
    The third argument of this constructor is unusual in that it is an
    UnitInertia (not a traditional RotationalInertia) and its inertia
    is about the arbitrary point P (not Scm -- S's center of mass).

See also:
    MakeFromCentralInertia a factory method with traditional utility.

This constructor checks for the physical validity of the resulting
SpatialInertia with IsPhysicallyValid() and throws a
std::runtime_error exception in the event the provided input
parameters lead to non-physically viable spatial inertia.

Parameter ``mass``:
    The mass of the body or composite body S.

Parameter ``p_PScm_E``:
    The position vector from point P to the center of mass of body or
    composite body S expressed in frame E.

Parameter ``G_SP_E``:
    UnitInertia of the body or composite body S computed about origin
    point P and expressed in frame E.)""";

        } ctor;

        // drake::multibody::SpatialInertia::cast
        struct /* cast */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:171
          const char* doc =
R"""(Returns a new SpatialInertia object templated on `Scalar` initialized
from the value of `this` spatial inertia.

Template parameter ``Scalar``:
    The scalar type on which the new spatial inertia will be
    templated.

Note:
    `SpatialInertia<From>::cast<To>()` creates a new
    `SpatialInertia<To>` from a `SpatialInertia<From>` but only if
    type `To` is constructible from type `From`. This cast method
    works in accordance with Eigen's cast method for Eigen's objects
    that underlie this SpatialInertia. For example, Eigen currently
    allows cast from type double to AutoDiffXd, but not vice-versa.)""";

        } cast;

        // drake::multibody::SpatialInertia::get_com
        struct /* get_com */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:184
          const char* doc =
R"""(Get a constant reference to the position vector `p_PScm_E` from the
_about point_ P to the center of mass `Scm` of the body or composite
body S, expressed in frame E. See the documentation of this class for
details.)""";

        } get_com;

        // drake::multibody::SpatialInertia::get_mass
        struct /* get_mass */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:179
          const char* doc =
R"""(Get a constant reference to the mass of this spatial inertia.)""";

        } get_mass;

        // drake::multibody::SpatialInertia::get_unit_inertia
        struct /* get_unit_inertia */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:195
          const char* doc =
R"""(Get a constant reference to the unit inertia `G_SP_E` of this spatial
inertia, computed about point P and expressed in frame E. See the
documentation of this class for details.)""";

        } get_unit_inertia;

        // drake::multibody::SpatialInertia::operator*
        struct /* operator_mul */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:379
          const char* doc =
R"""(Multiplies `this` spatial inertia `M_Bo_E` of a body B about its frame
origin `Bo` by the spatial acceleration of the body frame B in a frame
W. Mathematically:

```
F_Bo_E = M_Bo_E * A_WB_E
```

or, in terms of its rotational and translational components (see this
class's documentation for the block form of a rotational inertia):

```
t_Bo = I_Bo * alpha_WB + m * p_BoBcm x a_WBo
  f_Bo = -m * p_BoBcm x alpha_WB + m * a_WBo
```

where `alpha_WB` and `a_WBo` are the rotational and translational
components of the spatial acceleration `A_WB`, respectively.

Note:
    The term `F_Bo_E` computed by this operator appears in the
    equations of motion for a rigid body which, when written about the
    origin `Bo` of the body frame B (which does not necessarily need
    to coincide with the body's center of mass), read as:

```
Ftot_BBo = M_Bo_W * A_WB + b_Bo
```

where `Ftot_BBo` is the total spatial force applied on body B at at
`Bo` that corresponds to the body spatial acceleration `A_WB` and
`b_Bo` contains the velocity dependent gyroscopic terms (see Eq. 2.26,
p. 27, in A. Jain's book).)""";

          // drake/multibody/multibody_tree/spatial_inertia.h:413
          const char* doc_2 =
R"""(Multiplies `this` spatial inertia `M_BP_E` of a body B about a point P
by the spatial velocity `V_WBp`, in a frame W, of the body frame B
shifted to point P. Mathematically:

```
L_WBp_E = M_BP_E * V_WBp_E
```

or, in terms of its rotational and translational components (see this
class's documentation for the block form of a rotational inertia):

```
h_WB  = I_Bp * w_WB + m * p_BoBcm x v_WP
  l_WBp = -m * p_BoBcm x w_WB + m * v_WP
```

where `w_WB` and `v_WP` are the rotational and translational
components of the spatial velocity `V_WBp`, respectively and, `h_WB`
and `l_WBp` are the angular and linear components of the spatial
momentum `L_WBp`, respectively.

Note:
    It is possible to show that `M_BP_E.Shift(p_PQ_E) *
    V_WBp_E.Shift(p_PQ_E)` exactly equals `L_WBp_E.Shift(p_PQ_E)`.)""";

        } operator_mul;

        // drake::multibody::SpatialInertia::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/spatial_inertia.h:270
          const char* doc =
R"""(Adds in a spatial inertia to `this` spatial inertia.

Parameter ``M_BP_E``:
    A spatial inertia of some body B to be added to `this` spatial
    inertia. It must be defined about the same point P as `this`
    inertia, and expressed in the same frame E.

Returns:
    A reference to `this` spatial inertia, which has been updated to
    include the given spatial inertia `M_BP_E`.

Note:
    This operation aborts if the mass of the resulting spatial inertia
    is zero since in that case the position vector from the about
    point to the center of mass is not well defined.

@warning This operation is only valid if both spatial inertias are
computed about the same point P and expressed in the same frame E.
Considering `this` spatial inertia to be `M_SP_E` for some body or
composite body S, about some point P, the supplied spatial inertia
`M_BP_E` must be for some other body or composite body B about the
_same_ point P; B's inertia is then included in S.)""";

        } operator_iadd;

      } SpatialInertia;

      // drake::multibody::SpatialMomentum
      struct /* SpatialMomentum */ {

        // drake/multibody/multibody_tree/math/spatial_momentum.h:64
        const char* doc =
R"""(This class is used to represent the _spatial momentum_ of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum `l_NS` of a system of particles S in a reference frame N is
defined by:

```
l_NS = ∑l_NQi = ∑mᵢv_NQi
```

where `mᵢ` and `v_NQi` are the mass and linear velocity (in frame N)
of the i-th particle in the system, respectively. Their product `l_NQi
= mᵢv_NQi` is the linear momentum of the i-th particle in the N
reference frame. The angular momentum `h_NSp` of a system of particles
S in a reference frame N about an arbitrary point P is defined by:

```
h_NSp = ∑ p_PQi x l_NQi
```

where `p_PQi` is the position vector from point P to the i-th particle
position `Qi`. The definitions above extend to a continuum of
particles as:

```
h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
```

where `ρ(r)` is the density of the body at each material location `r`.
In particular, the continuum version above also applies to rigid
bodies.

Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.

Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L is used to
designate a spatial momentum quantity. We write a point P fixed to
body (or frame) B as $B_P$ which appears in code and comments as `Bp`.
Then we write as $[^NL^{S/B_P}]_E$, which appears in code as
`L_NBp_E`, the spatial momentum of a body B in a reference frame N,
about a point P and, expressed in frame E. Very often the about-point
will be the body origin `Bo`; if no point is shown the origin is
understood, thus `L_NB_E` means `L_NBo_E`. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.

- [Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics
algorithms. Springer.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/math/spatial_velocity.h:17
        const char* doc_2 =
R"""(This class is used to represent the _spatial momentum_ of a particle,
system of particles or body (whether rigid or soft.) The linear
momentum `l_NS` of a system of particles S in a reference frame N is
defined by:

```
l_NS = ∑l_NQi = ∑mᵢv_NQi
```

where `mᵢ` and `v_NQi` are the mass and linear velocity (in frame N)
of the i-th particle in the system, respectively. Their product `l_NQi
= mᵢv_NQi` is the linear momentum of the i-th particle in the N
reference frame. The angular momentum `h_NSp` of a system of particles
S in a reference frame N about an arbitrary point P is defined by:

```
h_NSp = ∑ p_PQi x l_NQi
```

where `p_PQi` is the position vector from point P to the i-th particle
position `Qi`. The definitions above extend to a continuum of
particles as:

```
h_NSp = ∫p_PQ(r) x v_NQ(r) ρ(r)d³r
  l_NS = ∫v_NQ(r) ρ(r)d³r
```

where `ρ(r)` is the density of the body at each material location `r`.
In particular, the continuum version above also applies to rigid
bodies.

Spatial momenta are elements of F⁶ (see [Featherstone 2008]) that
combine both rotational (angular momentum) and translational (linear
momentum) components. Spatial momenta are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular momentum
component while elements 3-5 are the linear momentum component. As
with any other spatial vector, both vector components must be
expressed in the same frame.

Neither the expressed-in frame nor the about-point are stored with a
SpatialMomentum object; they must be understood from context. It is
the responsibility of the user to keep track of the about-point and
the expressed-in frame. That is best accomplished through disciplined
notation. In source code we use monogram notation where L is used to
designate a spatial momentum quantity. We write a point P fixed to
body (or frame) B as $B_P$ which appears in code and comments as `Bp`.
Then we write as $[^NL^{S/B_P}]_E$, which appears in code as
`L_NBp_E`, the spatial momentum of a body B in a reference frame N,
about a point P and, expressed in frame E. Very often the about-point
will be the body origin `Bo`; if no point is shown the origin is
understood, thus `L_NB_E` means `L_NBo_E`. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.

- [Featherstone 2008] Featherstone, R., 2008. Rigid body dynamics
algorithms. Springer.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::SpatialMomentum::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:72
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialMomentum::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:159
          const char* doc =
R"""(Shift of a SpatialMomentum from one application point to another. This
is an alternate signature for shifting a spatial momentum's about-
point that does not change the original object. See ShiftInPlace() for
more information.

Parameter ``p_PQ_E``:
    Shift vector from point P to point Q.

Returns ``L_NSq_E``:
    The equivalent shifted spatial momentum, now applied at point Q
    rather than P.

See also:
    ShiftInPlace() to compute the shifted spatial momentum in-place
    modifying the original object.)""";

        } Shift;

        // drake::multibody::SpatialMomentum::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:141
          const char* doc =
R"""(In-place shift of a SpatialMomentum from one "about-point" to another.
`this` spatial momentum `L_NSp_E` for a system S in a reference frame
N about a point P, and expressed in frame E, is modified to become the
equivalent spatial momentum `L_NSq_E` of the same system about another
point Q.

We are given the vector from point P to point Q, as a position vector
`p_PQ_E` expressed in the same frame E as the spatial momentum. The
operation performed, in coordinate-free form, is:

```
h_NSq  = h_NSp -  p_PQ x l_NSp
  l_NSq = l_NSp,  i.e. the linear momentum about point Q is the
                  same as the linear momentum about point P.
```

where h and l represent the angular and linear momentum components
respectively. Notice that spatial momenta shift in the same way as
spatial forces (see SpatialForce.)

The operation is linear, which [Jain 2010], (§2.1, page 22) writes
using the "rigid body transformation operator" as:

```
L_NSq = Φ(p_QP)L_NSp = Φ(-p_PQ)L_NSp
```

where `Φ(p_PQ)` is the linear operator:

```
Φ(p_PQ) = | I₃ p_PQx |
            | 0     I₃ |
```

where `p_PQx` denotes the cross product, skew-symmetric, matrix such
that `p_PQx v = p_PQ x v`. This same operator shifts spatial forces in
analogous way (see SpatialForce::Shift()) while the transpose of this
operator allow us to shift spatial velocities, see
SpatialVelocity::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis
and algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an `_E` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_PQ_E``:
    Shift vector from point P to point Q, expressed in frame E.

Returns:
    A reference to `this` spatial momentum which is now `L_NSq_E`,
    that is, the spatial momentum about point Q rather than P.

See also:
    Shift() to compute the shifted spatial momentum without modifying
    this original object.)""";

        } ShiftInPlace;

        // drake::multibody::SpatialMomentum::SpatialMomentum<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:72
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_momentum.h:72
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_momentum.h:79
          const char* doc_3 =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial momentum are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial momentum fail
fast, allowing fast bug detection.)""";

          // drake/multibody/multibody_tree/math/spatial_momentum.h:83
          const char* doc_4 =
R"""(SpatialMomentum constructor from an angular momentum h and a linear
momentum l.)""";

          // drake/multibody/multibody_tree/math/spatial_momentum.h:92
          const char* doc_5 =
R"""(SpatialMomentum constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of L is
six (6) at compile-time for fixed sized Eigen expressions and at run-
time for dynamic sized Eigen expressions.)""";

        } ctor;

        // drake::multibody::SpatialMomentum::dot
        struct /* dot */ {

          // drake/multibody/multibody_tree/math/spatial_algebra.h:33
          const char* doc =
R"""(Given `this` spatial momentum `L_NBp_E` of a rigid body B, about point
P and, expressed in a frame E, this method computes the dot product
with the spatial velocity `V_NBp_E` of body B frame shifted to point
P, measured in an inertial (or Newtonian) frame N and expressed in the
same frame E in which the spatial momentum is expressed. This dot-
product is twice the kinetic energy `ke_NB` of body B in reference
frame N. The kinetic energy `ke_NB` is independent of the about-point
P and so is this dot product. Therefore it is always true that:

```
ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
```

where `L_NBcm` is the spatial momentum about the center of mass of
body B and `V_NBcm` is the spatial velocity of frame B shifted to its
center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";

          // drake/multibody/multibody_tree/math/spatial_momentum.h:211
          const char* doc_2 =
R"""(Given `this` spatial momentum `L_NBp_E` of a rigid body B, about point
P and, expressed in a frame E, this method computes the dot product
with the spatial velocity `V_NBp_E` of body B frame shifted to point
P, measured in an inertial (or Newtonian) frame N and expressed in the
same frame E in which the spatial momentum is expressed. This dot-
product is twice the kinetic energy `ke_NB` of body B in reference
frame N. The kinetic energy `ke_NB` is independent of the about-point
P and so is this dot product. Therefore it is always true that:

```
ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
```

where `L_NBcm` is the spatial momentum about the center of mass of
body B and `V_NBcm` is the spatial velocity of frame B shifted to its
center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";

        } dot;

        // drake::multibody::SpatialMomentum::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:174
          const char* doc =
R"""(Adds in a spatial momentum to `this` spatial momentum.

Parameter ``L_NSp_E``:
    A spatial momentum to be added to `this` spatial momentum. It must
    be about the same point P as this spatial momentum and expressed
    in the same frame E.

Returns:
    A reference to `this` spatial momentum, which has been updated to
    include the given spatial momentum `L_NSp_E`.

@warning This operation is only valid if both spatial momenta are
applied about same point P and expressed in the same frame E.)""";

        } operator_iadd;

        // drake::multibody::SpatialMomentum::operator-=
        struct /* operator_isub */ {

          // drake/multibody/multibody_tree/math/spatial_momentum.h:190
          const char* doc =
R"""(Subtracts a spatial momentum from `this` spatial momentum.

Parameter ``L_NSp_E``:
    A spatial momentum to be subtracted from `this` spatial momentum.
    It must be about the same point P as this spatial momentum and
    expressed in the same frame E.

Returns:
    A reference to `this` spatial momentum, which has been updated to
    exclude the given spatial momentum `L_NSp_E`.

@warning This operation is only valid if both spatial momenta are
applied about same point P and expressed in the same frame E.)""";

        } operator_isub;

      } SpatialMomentum;

      // drake::multibody::SpatialVector
      struct /* SpatialVector */ {

        // drake/multibody/multibody_tree/math/spatial_vector.h:25
        const char* doc =
R"""(This class is used to represent physical quantities that correspond to
spatial vectors such as spatial velocities, spatial accelerations and
spatial forces. Spatial vectors are 6-element quantities that are
pairs of ordinary 3-vectors. Elements 0-2 are always the rotational
component while elements 3-5 are always the translational component.
For a more detailed introduction on spatial vectors please refer to
section multibody_spatial_vectors.

Template parameter ``SV``:
    The type of the more specialized spatial vector class. It must be
    a template on the scalar type T.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::SpatialVector::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:27
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialVector::GetMaximumAbsoluteDifferences
        struct /* GetMaximumAbsoluteDifferences */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:139
          const char* doc =
R"""(Returns the maximum absolute values of the differences in the
rotational and translational components of `this` and `other` (i.e.,
the infinity norms of the difference in rotational and translational
components). These quantities are returned in a tuple, in the order
below. std::tuple | Description
-----------------|-------------------------------------------------
w_max_difference | Maximum absolute difference in rotation components
v_max_difference | Maximum absolute difference in translation
components)""";

        } GetMaximumAbsoluteDifferences;

        // drake::multibody::SpatialVector::IsApprox
        struct /* IsApprox */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:176
          const char* doc =
R"""(Compares `this` spatial vector to the provided spatial vector `other`
within a specified tolerance. Mathematically, if `this` is the spatial
vector U and `other` is the spatial vector V, then this method returns
`true` if `‖U-V‖∞ < ε` and `false` otherwise.)""";

        } IsApprox;

        // drake::multibody::SpatialVector::IsNearlyEqualWithinAbsoluteTolerance
        struct /* IsNearlyEqualWithinAbsoluteTolerance */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:161
          const char* doc =
R"""(Compares the rotational and translational parts of `this` and `other`
to check if they are the same to within specified absolute
differences.

Parameter ``rotational_tolerance``:
    maximum allowable absolute difference between the rotational parts
    of `this` and `other`. The units depend on the underlying class.
    For example, spatial velocity, acceleration, and force have units
    of rad/sec, rad/sec^2, and N*m, respectively.

Parameter ``translational_tolerance``:
    maximum allowable absolute difference between the translational
    parts of `this` and `other`. The units depend on the underlying
    class. For example, spatial velocity, acceleration, and force have
    units of meter/sec, meter/sec^2, and Newton, respectively.

Returns:
    `true` if the rotational part of `this` and `other` are equal
    within ``rotational_tolerance`` and the translational part of
    `this` and `other` are equal within ``translational_tolerance``.)""";

        } IsNearlyEqualWithinAbsoluteTolerance;

        // drake::multibody::SpatialVector::SetNaN
        struct /* SetNaN */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:185
          const char* doc =
R"""(Sets all entries in `this` SpatialVector to NaN. Typically used to
quickly detect uninitialized values since NaN will trigger a chain of
invalid computations that can then be tracked back to the source.)""";

        } SetNaN;

        // drake::multibody::SpatialVector::SetZero
        struct /* SetZero */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:192
          const char* doc =
R"""(Sets both rotational and translational components of `this`
SpatialVector to zero.)""";

        } SetZero;

        // drake::multibody::SpatialVector::SpatialVector<SV, T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:27
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:27
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:51
          const char* doc_3 =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial vector are left uninitialized resulting in a zero
cost operation. However in Debug builds those entries are set to NaN
so that operations using this uninitialized spatial vector fail fast,
allowing fast bug detection.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:57
          const char* doc_4 =
R"""(SpatialVector constructor from an rotational component ``w`` and a
linear component ``v``.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:69
          const char* doc_5 =
R"""(SpatialVector constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at run-
time for dynamic sized Eigen expressions.)""";

        } ctor;

        // drake::multibody::SpatialVector::Zero
        struct /* Zero */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:236
          const char* doc =
R"""(Factory to create a _zero_ SpatialVector, i.e. rotational and
translational components are both zero.)""";

        } Zero;

        // drake::multibody::SpatialVector::data
        struct /* data */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:124
          const char* doc =
R"""(Returns a (const) bare pointer to the underlying data. It is
guaranteed that there will be six (6) T's densely packed at data[0],
data[1], etc.)""";

        } data;

        // drake::multibody::SpatialVector::get_coeffs
        struct /* get_coeffs */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:198
          const char* doc =
R"""(Returns a reference to the underlying storage.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:201
          const char* doc_2 =
R"""(Returns a constant reference to the underlying storage.)""";

        } get_coeffs;

        // drake::multibody::SpatialVector::kRotationSize
        struct /* kRotationSize */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:36
          const char* doc = R"""()""";

        } kRotationSize;

        // drake::multibody::SpatialVector::kSpatialVectorSize
        struct /* kSpatialVectorSize */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:35
          const char* doc = R"""()""";

        } kSpatialVectorSize;

        // drake::multibody::SpatialVector::kTranslationSize
        struct /* kTranslationSize */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:37
          const char* doc = R"""()""";

        } kTranslationSize;

        // drake::multibody::SpatialVector::mutable_data
        struct /* mutable_data */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:129
          const char* doc =
R"""(Returns a (mutable) bare pointer to the underlying data. It is
guaranteed that there will be six (6) T's densely packed at data[0],
data[1], etc.)""";

        } mutable_data;

        // drake::multibody::SpatialVector::operator-
        struct /* operator_sub */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:230
          const char* doc = R"""(Unary minus operator.)""";

        } operator_sub;

        // drake::multibody::SpatialVector::operator[]
        struct /* operator_array */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:78
          const char* doc =
R"""(Const access to the i-th component of this spatial vector. Bounds are
only checked in Debug builds for a zero overhead implementation in
Release builds.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:86
          const char* doc_2 =
R"""(Mutable access to the i-th component of this spatial vector. Bounds
are only checked in Debug builds for a zero overhead implementation in
Release builds.)""";

        } operator_array;

        // drake::multibody::SpatialVector::rotational
        struct /* rotational */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:92
          const char* doc =
R"""(Const access to the rotational component of this spatial vector.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:99
          const char* doc_2 =
R"""(Mutable access to the rotational component of this spatial vector.)""";

        } rotational;

        // drake::multibody::SpatialVector::size
        struct /* size */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:73
          const char* doc =
R"""(The total size of the concatenation of the angular and linear
components. In three dimensions this is six (6) and it is known at
compile time.)""";

        } size;

        // drake::multibody::SpatialVector::translational
        struct /* translational */ {

          // drake/multibody/multibody_tree/math/spatial_vector.h:106
          const char* doc =
R"""(Const access to the translational component of this spatial vector.)""";

          // drake/multibody/multibody_tree/math/spatial_vector.h:114
          const char* doc_2 =
R"""(Mutable access to the translational component of this spatial vector.)""";

        } translational;

      } SpatialVector;

      // drake::multibody::SpatialVelocity
      struct /* SpatialVelocity */ {

        // drake/multibody/multibody_tree/math/spatial_force.h:14
        const char* doc =
R"""(This class is used to represent a _spatial velocity_ (also called a
_twist_) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a "moving frame" B measured with
respect to a "measured-in" frame A. In addition, the two contained
vectors must be expressed in the same "expressed-in" frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as $B_P$ which appears in code and comments as `Bp`.
Then we write a particular spatial velocity as `V_ABp_E` where the
`_E` suffix indicates that the expressed-in frame is E. This symbol
represents the angular velocity of frame B in frame A, and the
translational velocity of point P in A, where P is fixed to frame B,
with both vectors expressed in E. Very often the point of interest
will be the body origin `Bo`; if no point is shown the origin is
understood, so `V_AB_E` means `V_ABo_E`. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/math/spatial_momentum.h:14
        const char* doc_2 =
R"""(This class is used to represent a _spatial velocity_ (also called a
_twist_) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a "moving frame" B measured with
respect to a "measured-in" frame A. In addition, the two contained
vectors must be expressed in the same "expressed-in" frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as $B_P$ which appears in code and comments as `Bp`.
Then we write a particular spatial velocity as `V_ABp_E` where the
`_E` suffix indicates that the expressed-in frame is E. This symbol
represents the angular velocity of frame B in frame A, and the
translational velocity of point P in A, where P is fixed to frame B,
with both vectors expressed in E. Very often the point of interest
will be the body origin `Bo`; if no point is shown the origin is
understood, so `V_AB_E` means `V_ABo_E`. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake/multibody/multibody_tree/math/spatial_velocity.h:49
        const char* doc_3 =
R"""(This class is used to represent a _spatial velocity_ (also called a
_twist_) that combines rotational (angular) and translational (linear)
velocity components. Spatial velocities are 6-element quantities that
are pairs of ordinary 3-vectors. Elements 0-2 are the angular velocity
component while elements 3-5 are the translational velocity. Spatial
velocities represent the motion of a "moving frame" B measured with
respect to a "measured-in" frame A. In addition, the two contained
vectors must be expressed in the same "expressed-in" frame E, which
may be distinct from either A or B. Finally, while angular velocity is
identical for any frame fixed to a rigid body, translational velocity
refers to a particular point. Only the vector values are stored in a
SpatialVelocity object; the three frames and the point must be
understood from context. It is the responsibility of the user to keep
track of them. That is best accomplished through disciplined notation.
In source code we use monogram notation where capital V is used to
designate a spatial velocity quantity. We write a point P fixed to
body (or frame) B as $B_P$ which appears in code and comments as `Bp`.
Then we write a particular spatial velocity as `V_ABp_E` where the
`_E` suffix indicates that the expressed-in frame is E. This symbol
represents the angular velocity of frame B in frame A, and the
translational velocity of point P in A, where P is fixed to frame B,
with both vectors expressed in E. Very often the point of interest
will be the body origin `Bo`; if no point is shown the origin is
understood, so `V_AB_E` means `V_ABo_E`. For a more detailed
introduction on spatial vectors and the monogram notation please refer
to section multibody_spatial_vectors.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.)""";

        // drake::multibody::SpatialVelocity::ComposeWithMovingFrameVelocity
        struct /* ComposeWithMovingFrameVelocity */ {

          // drake/multibody/multibody_tree/math/spatial_velocity.h:196
          const char* doc =
R"""(This method composes `this` spatial velocity `V_WP` of a frame P
measured in a frame W, with that of a third frame B moving in P with
spatial velocity `V_PB`. The result is the spatial velocity `V_WB` of
frame B measured in W. At the instant in which the velocities are
composed, frame B is located with its origin `Bo` at `p_PoBo` from P's
origin Po.

The composition cannot be performed directly since frames P and B do
not have the same origins. To perform the composition `V_WB`, the
velocity of P needs to be shifted to point `Bo`:

```
V_WB_E = V_WPb_E + V_PB_E = V_WP_E.Shift(p_PoBo_E) + V_PB_E
```

where p_PoBo is the position vector from P's origin to B's origin and
`V_WPb` is the spatial velocity of a new frame `Pb` which is an offset
frame rigidly aligned with P, but with its origin shifted to B's
origin. The key is that in the expression above, the two spatial
velocities being added must be for frames with the same origin point,
in this case Bo.

For computation, all quantities above must be expressed in a common
frame E; we add an `_E` suffix to each symbol to indicate that.

Note:
    If frame B moves rigidly together with frame P, as in a rigid
    body, `V_PB = 0` and the result of this method equals that of the
    Shift() operation.

Parameter ``p_PoBo_E``:
    Shift vector from P's origin to B's origin, expressed in frame E.
    The "from" point `Po` must be the point whose velocity is
    currently represented in `this` spatial velocity, and E must be
    the same expressed-in frame as for `this` spatial velocity.

Parameter ``V_PB_E``:
    The spatial velocity of a third frame B in motion with respect to
    P, expressed in the same frame E as `this` spatial velocity.

Returns ``V_WB_E``:
    The spatial velocity of frame B in W resulting from the
    composition of `this` spatial velocity `V_WP` and B's velocity in
    P, `V_PB`. The result is expressed in the same frame E as `this`
    spatial velocity.)""";

        } ComposeWithMovingFrameVelocity;

        // drake::multibody::SpatialVelocity::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/math/spatial_velocity.h:57
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::SpatialVelocity::Shift
        struct /* Shift */ {

          // drake/multibody/multibody_tree/math/spatial_velocity.h:156
          const char* doc =
R"""(Shift of a SpatialVelocity from one point on a rigid body or frame to
another point on the same body or frame. This is an alternate
signature for shifting a spatial velocity's point that does not change
the original object. See ShiftInPlace() for more information.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point `Bp` must be the point whose velocity is
    currently represented in this spatial velocity, and E must be the
    same expressed-in frame as for this spatial velocity.

Returns ``V_ABq_E``:
    The spatial velocity of frame B at point Q, measured in frame A
    and expressed in frame E.

See also:
    ShiftInPlace() to compute the shifted spatial velocity in-place
    modifying the original object.)""";

        } Shift;

        // drake::multibody::SpatialVelocity::ShiftInPlace
        struct /* ShiftInPlace */ {

          // drake/multibody/multibody_tree/math/spatial_velocity.h:132
          const char* doc =
R"""(In-place shift of a SpatialVelocity from one point on a rigid body or
frame to another point on the same body or frame. `this` spatial
velocity `V_ABp_E` of a frame B at a point P fixed on B, measured in a
frame A, and expressed in a frame E, is modified to become `V_ABq_E`,
representing the velocity of another point Q on B instead (see class
comment for more about this notation). This requires adjusting the
translational (linear) velocity component to account for the velocity
difference between P and Q due to the angular velocity of B in A.

We are given the vector from point P to point Q, as a position vector
`p_BpBq_E` (or `p_PQ_E`) expressed in the same frame E as the spatial
velocity. The operation performed, in coordinate-free form, is:

```
w_AB  = w_AB,  i.e. the angular velocity is unchanged.
  v_ABq = v_ABp + w_AB x p_BpBq
```

where w and v represent the angular and linear velocity components
respectively. Notice this operation is linear. [Jain 2010], (§1.4,
page 12) uses the "rigid body transformation operator" to write this
as:

```
V_ABq = Φᵀ(p_BpBq)V_ABp
```

where `Φᵀ(p_PQ)` is the linear operator:

```
Φᵀ(p_PQ) = |  I₃    0  |
             | -p_PQx I₃ |
```

where `p_PQx` denotes the cross product, skew-symmetric, matrix such
that `p_PQx v = p_PQ x v`. This same operator (not its transpose as
for spatial velocities) allow us to shift spatial forces, see
SpatialForce::Shift().

- [Jain 2010] Jain, A., 2010. Robot and multibody dynamics: analysis
and algorithms. Springer Science & Business Media, pp. 123-130.

For computation, all quantities above must be expressed in a common
frame E; we add an `_E` suffix to each symbol to indicate that.

This operation is performed in-place modifying the original object.

Parameter ``p_BpBq_E``:
    Shift vector from point P of body B to point Q of B, expressed in
    frame E. The "from" point `Bp` must be the point whose velocity is
    currently represented in this spatial velocity, and E must be the
    same expressed-in frame as for this spatial velocity.

Returns:
    A reference to `this` spatial velocity which is now `V_ABq_E`,
    that is, the spatial velocity of frame B at point Q, still
    measured in frame A and expressed in frame E.

See also:
    Shift() to compute the shifted spatial velocity without modifying
    this original object.)""";

        } ShiftInPlace;

        // drake::multibody::SpatialVelocity::SpatialVelocity<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/math/spatial_velocity.h:57
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:57
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:64
          const char* doc_3 =
R"""(Default constructor. In Release builds the elements of the newly
constructed spatial velocity are left uninitialized resulting in a
zero cost operation. However in Debug builds those entries are set to
NaN so that operations using this uninitialized spatial velocity fail
fast, allowing fast bug detection.)""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:68
          const char* doc_4 =
R"""(SpatialVelocity constructor from an angular velocity ``w`` and a
linear velocity ``v``.)""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:77
          const char* doc_5 =
R"""(SpatialVelocity constructor from an Eigen expression that represents a
six-dimensional vector. This constructor will assert the size of V is
six (6) at compile-time for fixed sized Eigen expressions and at run-
time for dynamic sized Eigen expressions.)""";

        } ctor;

        // drake::multibody::SpatialVelocity::dot
        struct /* dot */ {

          // drake/multibody/multibody_tree/math/spatial_algebra.h:23
          const char* doc =
R"""(Given `this` spatial velocity `V_IBp_E` of point P of body B, measured
in an inertial frame I and expressed in a frame E, this method
computes the 6-dimensional dot product with the spatial force `F_Bp_E`
applied to point P, and expressed in the same frame E in which the
spatial velocity is expressed. This dot-product represents the power
generated by the spatial force when its body and application point
have `this` spatial velocity. Although the two spatial vectors must be
expressed in the same frame, the result is independent of that frame.

@warning The result of this method cannot be interpreted as power
unless `this` spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.)""";

          // drake/multibody/multibody_tree/math/spatial_algebra.h:38
          const char* doc_2 =
R"""(Given `this` spatial velocity `V_NBp_E` of rigid body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and,
expressed in a frame E this method computes the dot product with the
spatial momentum `L_NBp_E` of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy `ke_NB` of body B in reference frame N. The kinetic energy
`ke_NB` is independent of the about-point P and so is this dot
product. Therefore it is always true that:

```
ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
```

where `L_NBcm` is the spatial momentum about the center of mass of
body B and `V_NBcm` is the spatial velocity of frame B shifted to its
center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:215
          const char* doc_3 =
R"""(Given `this` spatial velocity `V_IBp_E` of point P of body B, measured
in an inertial frame I and expressed in a frame E, this method
computes the 6-dimensional dot product with the spatial force `F_Bp_E`
applied to point P, and expressed in the same frame E in which the
spatial velocity is expressed. This dot-product represents the power
generated by the spatial force when its body and application point
have `this` spatial velocity. Although the two spatial vectors must be
expressed in the same frame, the result is independent of that frame.

@warning The result of this method cannot be interpreted as power
unless `this` spatial velocity is measured in an inertial frame I,
which cannot be enforced by this class.)""";

          // drake/multibody/multibody_tree/math/spatial_velocity.h:233
          const char* doc_4 =
R"""(Given `this` spatial velocity `V_NBp_E` of rigid body B frame shifted
to point P, measured in an inertial (or Newtonian) frame N and,
expressed in a frame E this method computes the dot product with the
spatial momentum `L_NBp_E` of rigid body B, about point P, and
expressed in the same frame E. This dot-product is twice the kinetic
energy `ke_NB` of body B in reference frame N. The kinetic energy
`ke_NB` is independent of the about-point P and so is this dot
product. Therefore it is always true that:

```
ke_NB = 1/2 (L_NBp⋅V_NBp) = 1/2 (L_NBcm⋅V_NBcm)
```

where `L_NBcm` is the spatial momentum about the center of mass of
body B and `V_NBcm` is the spatial velocity of frame B shifted to its
center of mass. The above is true due to how spatial momentum and
velocity shift when changing point P, see SpatialMomentum::Shift() and
SpatialVelocity::Shift().)""";

        } dot;

      } SpatialVelocity;

      // drake::multibody::UniformGravityFieldElement
      struct /* UniformGravityFieldElement */ {

        // drake/multibody/multibody_tree/uniform_gravity_field_element.h:26
        const char* doc =
R"""(This ForceElement allows modeling the effect of a uniform gravity
field as felt by bodies on the surface of the Earth. This gravity
fields acts on all bodies in the MultibodyTree model.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::UniformGravityFieldElement::CalcConservativePower
        struct /* CalcConservativePower */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:74
          const char* doc = R"""()""";

        } CalcConservativePower;

        // drake::multibody::UniformGravityFieldElement::CalcGravityGeneralizedForces
        struct /* CalcGravityGeneralizedForces */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:61
          const char* doc =
R"""(Computes the generalized forces `tau_g(q)` due to `this` gravity field
element as a function of the generalized positions `q` stored in the
input `context`, for the multibody model to which `this` element
belongs. `tau_g(q)` is defined such that it appears on the right hand
side of the equations of motion together with any other generalized
forces, like so:

```
Mv̇ + C(q, v)v = tau_g(q) + tau_app
```

where `tau_app` includes any other generalized forces applied on the
system.

Parameter ``context``:
    The context storing the state of the multibody model to which this
    element belongs.

Returns:
    tau_g A vector containing the generalized forces due to this
    gravity field force element. The generalized forces are consistent
    with the vector of generalized velocities `v` for the parent
    MultibodyTree model so that the inner product `v⋅tau_g`
    corresponds to the power applied by the gravity forces on the
    mechanical system. That is, `v⋅tau_g > 0` corresponds to potential
    energy going into the system, as either mechanical kinetic energy,
    some other potential energy, or heat, and therefore to a decrease
    of potential energy.)""";

        } CalcGravityGeneralizedForces;

        // drake::multibody::UniformGravityFieldElement::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:79
          const char* doc = R"""()""";

        } CalcNonConservativePower;

        // drake::multibody::UniformGravityFieldElement::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:70
          const char* doc =
R"""(Computes the total potential energy of all bodies in the model in this
uniform gravity field. The definition of potential energy allows to
arbitrarily choose the zero energy height. This element takes the zero
energy height to be the same as the world's height. That is, a body
will have zero potential energy when its the height of its center of
mass is at the world's origin.)""";

        } CalcPotentialEnergy;

        // drake::multibody::UniformGravityFieldElement::DoCalcAndAddForceContribution
        struct /* DoCalcAndAddForceContribution */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:85
          const char* doc = R"""()""";

        } DoCalcAndAddForceContribution;

        // drake::multibody::UniformGravityFieldElement::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:91
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:94
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::UniformGravityFieldElement::UniformGravityFieldElement<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:28
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:28
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:32
          const char* doc_3 =
R"""(Constructs a uniform gravity field element with a strength given by
the acceleration of gravity vector `g_W`, expressed in the world frame
W.)""";

        } ctor;

        // drake::multibody::UniformGravityFieldElement::gravity_vector
        struct /* gravity_vector */ {

          // drake/multibody/multibody_tree/uniform_gravity_field_element.h:36
          const char* doc =
R"""(Returns the acceleration of gravity vector, expressed in the world
frame W.)""";

        } gravity_vector;

      } UniformGravityFieldElement;

      // drake::multibody::UnitInertia
      struct /* UnitInertia */ {

        // drake/multibody/multibody_tree/unit_inertia.h:44
        const char* doc =
R"""(This class is used to represent rotational inertias for unit mass
bodies. Therefore, unlike RotationalInertia whose units are kg⋅m², the
units of a UnitInertia are those of length squared. A unit inertia is
a useful concept to represent the geometric distribution of mass in a
body regardless of the actual value of the body mass. The rotational
inertia of a body can therefore be obtained by multiplying its unit
inertia by its mass. Unit inertia matrices can also be called
**gyration** matrices and therefore we choose to represent them in
source code notation with the capital letter G. In contrast, the
capital letter I is used to represent non-unit mass rotational
inertias. This class restricts the set of allowed operations on a unit
inertia to ensure the unit-mass invariant. For instance,
multiplication by a scalar can only return a general RotationalInertia
but not a UnitInertia.

Note:
    This class has no means to check at construction from user
    provided parameters whether it actually represents the unit
    inertia or gyration matrix of a unit-mass body. However, as
    previously noted, once a unit inertia is created, a number of
    operations are disallowed to ensure the unit-mass invariant. Also
    notice that once a unit inertia is created, it _is_ the unit
    inertia of _some_ body, perhaps with scaled geometry from the
    user's intention.

Template parameter ``T``:
    The underlying scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::multibody::UnitInertia::AxiallySymmetric
        struct /* AxiallySymmetric */ {

          // drake/multibody/multibody_tree/unit_inertia.h:358
          const char* doc =
R"""(Returns the unit inertia for a unit-mass body B for which there exists
a line L passing through the body's center of mass `Bcm` having the
property that the body's moment of inertia about all lines
perpendicular to L are equal. Examples of bodies with an axially
symmetric inertia include axisymmetric objects such as cylinders and
cones. Other commonly occurring geometries with this property are, for
instance, propellers with 3+ evenly spaced blades. Given a unit vector
b defining the symmetry line L, the moment of inertia J about this
line L and the moment of inertia K about any line perpendicular to L,
the axially symmetric unit inertia G is computed as:

```
G = K * Id + (J - K) * b ⊗ b
```

where `Id` is the identity matrix and ⊗ denotes the tensor product
operator. See Mitiguy, P., 2016. Advanced Dynamics & Motion
Simulation.

Throws:
    s std::runtime_error - J is negative. J can be zero. - K is
    negative. K can be zero. - J ≤ 2 * K, this corresponds to the
    triangle inequality, see CouldBePhysicallyValid(). - `b_E` is the
    zero vector. That is if `‖b_E‖₂ ≤ ε`, where ε is the machine
    epsilon.

Note:
    J is a principal moment of inertia with principal axis equal to b.
    K is a principal moment with multiplicity of two. Any two axes
    perpendicular to b are principal axes with principal moment K.

Parameter ``J``:
    Unit inertia about axis b.

Parameter ``K``:
    Unit inertia about any axis perpendicular to b.

Parameter ``b_E``:
    Vector defining the symmetry axis, expressed in a frame E. `b_E`
    can have a norm different from one; however, it will be normalized
    before using it. Therefore its norm is ignored and only its
    direction is used.

Returns ``G_Bcm_E``:
    An axially symmetric unit inertia about body B's center of mass,
    expressed in the same frame E as the input unit vector `b_E`.)""";

        } AxiallySymmetric;

        // drake::multibody::UnitInertia::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/unit_inertia.h:46
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::UnitInertia::HollowSphere
        struct /* HollowSphere */ {

          // drake/multibody/multibody_tree/unit_inertia.h:248
          const char* doc =
R"""(Computes the unit inertia for a unit-mass hollow sphere of radius `r`
consisting of an infinitesimally thin shell of uniform density. The
unit inertia is taken about the center of the sphere.)""";

        } HollowSphere;

        // drake::multibody::UnitInertia::PointMass
        struct /* PointMass */ {

          // drake/multibody/multibody_tree/unit_inertia.h:228
          const char* doc =
R"""(Construct a unit inertia for a point mass of unit mass located at
point Q, whose location in a frame F is given by the position vector
`p_FQ` (that is, p_FoQ_F). The unit inertia `G_QFo_F` of point mass Q
about the origin `Fo` of frame F and expressed in F for this unit mass
point equals the square of the cross product matrix of `p_FQ`. In
coordinate-free form: \f[ G^{Q/F_o} = (^Fp^Q_\times)^2 =
(^Fp^Q_\times)^T \, ^Fp^Q_\times = -^Fp^Q_\times \, ^Fp^Q_\times \f]
where $ ^Fp^Q_\times $ is the cross product matrix of vector $ ^Fp^Q
$. In source code the above expression is written as:

```
G_QFo_F = px_FQ² = px_FQᵀ * px_FQ = -px_FQ * px_FQ
```

where `px_FQ` denotes the cross product matrix of the position vector
`p_FQ` (expressed in F) such that the cross product with another
vector `a` can be obtained as `px.cross(a) = px * a`. The cross
product matrix `px` is skew-symmetric. The square of the cross product
matrix is a symmetric matrix with non-negative diagonals and obeys the
triangle inequality. Matrix `px²` can be used to compute the triple
vector product as `-p x (p x a) = -p.cross(p.cross(a)) = px² * a`.)""";

        } PointMass;

        // drake::multibody::UnitInertia::ReExpress
        struct /* ReExpress */ {

          // drake/multibody/multibody_tree/unit_inertia.h:121
          const char* doc =
R"""(Given `this` unit inertia `G_BP_E` of a body B about a point P and
expressed in frame E, this method computes the same unit inertia re-
expressed in another frame F as `G_BP_F = R_FE * G_BP_E * (R_FE)ᵀ`.

Parameter ``R_FE``:
    Rotation matrix from the basis of frame E to the basis of frame F.

Returns ``G_BP_F``:
    The same unit inertia for body B about point P but now re-
    expressed in frameF. @warning This method does not check whether
    the input matrix `R_FE` represents a valid rotation or not. It is
    the responsibility of users to provide valid rotation matrices.)""";

        } ReExpress;

        // drake::multibody::UnitInertia::ReExpressInPlace
        struct /* ReExpressInPlace */ {

          // drake/multibody/multibody_tree/unit_inertia.h:106
          const char* doc =
R"""(Re-express a unit inertia in a different frame, performing the
operation in place and modifying the original object.

See also:
    ReExpress() for details.)""";

        } ReExpressInPlace;

        // drake::multibody::UnitInertia::SetFromRotationalInertia
        struct /* SetFromRotationalInertia */ {

          // drake/multibody/multibody_tree/unit_inertia.h:97
          const char* doc =
R"""(Sets `this` unit inertia from a generally non-unit inertia I
corresponding to a body with a given `mass`.

Note:
    In Debug builds, this operation aborts if the provided `mass` is
    not strictly positive.)""";

        } SetFromRotationalInertia;

        // drake::multibody::UnitInertia::ShiftFromCenterOfMass
        struct /* ShiftFromCenterOfMass */ {

          // drake/multibody/multibody_tree/unit_inertia.h:147
          const char* doc =
R"""(Shifts this central unit inertia to a different point, and returns the
result. See ShiftFromCenterOfMassInPlace() for details.

Parameter ``p_BcmQ_E``:
    A vector from the body's centroid `Bcm` to point Q expressed in
    the same frame E in which `this` inertia is expressed.

Returns ``G_BQ_E``:
    This same unit inertia taken about a point Q instead of the
    centroid `Bcm`.)""";

        } ShiftFromCenterOfMass;

        // drake::multibody::UnitInertia::ShiftFromCenterOfMassInPlace
        struct /* ShiftFromCenterOfMassInPlace */ {

          // drake/multibody/multibody_tree/unit_inertia.h:135
          const char* doc =
R"""(For a central unit inertia `G_Bcm_E` computed about a body's center of
mass (or centroid) `Bcm` and expressed in a frame E, this method
shifts this inertia using the parallel axis theorem to be computed
about a point Q. This operation is performed in place, modifying the
original object which is no longer a central inertia.

Parameter ``p_BcmQ_E``:
    A vector from the body's centroid `Bcm` to point Q expressed in
    the same frame E in which `this` inertia is expressed.

Returns:
    A reference to `this` unit inertia, which has now been taken about
    point Q so can be written as `G_BQ_E`.)""";

        } ShiftFromCenterOfMassInPlace;

        // drake::multibody::UnitInertia::ShiftToCenterOfMass
        struct /* ShiftToCenterOfMass */ {

          // drake/multibody/multibody_tree/unit_inertia.h:189
          const char* doc =
R"""(For the unit inertia `G_BQ_E` of a body or composite body B computed
about a point Q and expressed in a frame E, this method shifts this
inertia using the parallel axis theorem to be computed about the
center of mass `Bcm` of B. See ShiftToCenterOfMassInPlace() for
details.

Parameter ``p_QBcm_E``:
    A position vector from the about point Q to the body's centroid
    `Bcm` expressed in the same frame E in which `this` inertia is
    expressed.

Returns ``G_Bcm_E``:
    This same unit which has now been taken about point `Bcm` so that
    it can be written as `G_BBcm_E`, or `G_Bcm_E`.

@warning This operation could result in a non-physical rotational
inertia. Use with care. See ShiftToCenterOfMassInPlace() for details.)""";

        } ShiftToCenterOfMass;

        // drake::multibody::UnitInertia::ShiftToCenterOfMassInPlace
        struct /* ShiftToCenterOfMassInPlace */ {

          // drake/multibody/multibody_tree/unit_inertia.h:172
          const char* doc = R"""()""";

        } ShiftToCenterOfMassInPlace;

        // drake::multibody::UnitInertia::SolidBox
        struct /* SolidBox */ {

          // drake/multibody/multibody_tree/unit_inertia.h:259
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid box of uniform density
taken about its geometric center. If one length is zero the inertia
corresponds to that of a thin rectangular sheet. If two lengths are
zero the inertia corresponds to that of a thin rod in the remaining
direction.

Parameter ``Lx``:
    The length of the box edge in the principal x-axis.

Parameter ``Ly``:
    The length of the box edge in the principal y-axis.

Parameter ``Lz``:
    The length of the box edge in the principal z-axis.)""";

        } SolidBox;

        // drake::multibody::UnitInertia::SolidCube
        struct /* SolidCube */ {

          // drake/multibody/multibody_tree/unit_inertia.h:271
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid cube (a box with
equal-sized sides) of uniform density taken about its geometric
center.

Parameter ``L``:
    The length of each of the cube's sides.)""";

        } SolidCube;

        // drake::multibody::UnitInertia::SolidCylinder
        struct /* SolidCylinder */ {

          // drake/multibody/multibody_tree/unit_inertia.h:298
          const char* doc =
R"""(Computes the unit inertia for a unit-mass cylinder B, of uniform
density, having its axis of revolution along input vector `b_E`. The
resulting unit inertia is computed about the cylinder's center of mass
`Bcm` and is expressed in the same frame E as the input axis of
revolution `b_E`.

Parameter ``r``:
    The radius of the cylinder, it must be non-negative.

Parameter ``L``:
    The length of the cylinder, it must be non-negative.

Parameter ``b_E``:
    Vector defining the axis of revolution of the cylinder, expressed
    in a frame E. `b_E` can have a norm different from one; however,
    it will be normalized before using it. Therefore its norm is
    ignored and only its direction is used. It defaults to
    `Vector3<T>::UnitZ()`.

Returns ``G_Bcm_E``:
    The unit inertia for a solid cylinder B, of uniform density, with
    axis of revolution along `b_E`, computed about the cylinder's
    center of mass `Bcm`, and expressed in the same frame E as the
    input axis of rotation `b_E`.

Throws:
    s std::runtime_error - Radius r is negative. - Length L is
    negative. - `b_E` is the zero vector. That is if `‖b_E‖₂ ≤ ε`,
    where ε is the machine epsilon.)""";

        } SolidCylinder;

        // drake::multibody::UnitInertia::SolidCylinderAboutEnd
        struct /* SolidCylinderAboutEnd */ {

          // drake/multibody/multibody_tree/unit_inertia.h:313
          const char* doc =
R"""(Computes the unit inertia for a unit-mass cylinder of uniform density
oriented along the z-axis computed about a point at the center of its
base.

Parameter ``r``:
    The radius of the cylinder.

Parameter ``L``:
    The length of the cylinder.)""";

        } SolidCylinderAboutEnd;

        // drake::multibody::UnitInertia::SolidSphere
        struct /* SolidSphere */ {

          // drake/multibody/multibody_tree/unit_inertia.h:241
          const char* doc =
R"""(Computes the unit inertia for a unit-mass solid sphere of uniform
density and radius `r` taken about its center.)""";

        } SolidSphere;

        // drake::multibody::UnitInertia::StraightLine
        struct /* StraightLine */ {

          // drake/multibody/multibody_tree/unit_inertia.h:397
          const char* doc =
R"""(Computes the unit inertia for a body B of unit-mass uniformly
distributed along a straight, finite, line L with direction `b_E` and
with moment of inertia K about any axis perpendicular to this line.
Since the mass of the body is uniformly distributed on this line L,
its center of mass is located right at the center. As an example,
consider the inertia of a thin rod for which its transversal
dimensions can be neglected, see ThinRod().

This method aborts if K is not positive.

Note:
    This is the particular case for an axially symmetric unit inertia
    with zero moment about its axis, see AxiallySymmetric().

Parameter ``K``:
    Unit inertia about any axis perpendicular to the line.

Parameter ``b_E``:
    Vector defining the direction of the line, expressed in a frame E.
    `b_E` can have a norm different from one. Its norm is ignored and
    only its direction is needed.

Returns ``G_Bcm_E``:
    The unit inertia for a body B of unit mass uniformly distributed
    along a straight line L, about its center of mass `Bcm` which is
    located at the center of the line, expressed in the same frame E
    as the input unit vector `b_E`.)""";

        } StraightLine;

        // drake::multibody::UnitInertia::ThinRod
        struct /* ThinRod */ {

          // drake/multibody/multibody_tree/unit_inertia.h:417
          const char* doc =
R"""(Computes the unit inertia for a unit mass rod B of length L, about its
center of mass, with its mass uniformly distributed along a line
parallel to vector `b_E`.

This method aborts if L is not positive.

Parameter ``L``:
    The length of the rod. It must be positive.

Parameter ``b_E``:
    Vector defining the axis of the rod, expressed in a frame E. `b_E`
    can have a norm different from one. Its norm is ignored and only
    its direction is needed.

Returns ``G_Bcm_E``:
    The unit inertia of the rod B about its center of mass `Bcm`,
    expressed in the same frame E as the input unit vector `b_E`.)""";

        } ThinRod;

        // drake::multibody::UnitInertia::TriaxiallySymmetric
        struct /* TriaxiallySymmetric */ {

          // drake/multibody/multibody_tree/unit_inertia.h:428
          const char* doc = R"""()""";

        } TriaxiallySymmetric;

        // drake::multibody::UnitInertia::UnitInertia<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/unit_inertia.h:46
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/unit_inertia.h:46
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/unit_inertia.h:50
          const char* doc_3 =
R"""(Default UnitInertia constructor sets all entries to NaN for quick
detection of uninitialized values.)""";

          // drake/multibody/multibody_tree/unit_inertia.h:56
          const char* doc_4 =
R"""(Creates a unit inertia with moments of inertia `Ixx`, `Iyy`, `Izz`,
and with each product of inertia set to zero. In debug builds, throws
std::logic_error if unit inertia constructed from these arguments
violates RotationalInertia::CouldBePhysicallyValid().)""";

          // drake/multibody/multibody_tree/unit_inertia.h:63
          const char* doc_5 =
R"""(Creates a unit inertia with moments of inertia `Ixx`, `Iyy`, `Izz`,
and with products of inertia `Ixy`, `Ixz`, `Iyz`. In debug builds,
throws std::logic_error if unit inertia constructed from these
arguments violates RotationalInertia::CouldBePhysicallyValid().)""";

          // drake/multibody/multibody_tree/unit_inertia.h:73
          const char* doc_6 =
R"""(Constructs a UnitInertia from a RotationalInertia. This constructor
has no way to verify that the input rotational inertia actually is a
unit inertia. But the construction will nevertheless succeed, and the
values of the input rotational inertia will henceforth be considered a
valid unit inertia. It is the responsibility of the user to pass a
valid unit inertia.)""";

        } ctor;

        // drake::multibody::UnitInertia::cast
        struct /* cast */ {

          // drake/multibody/multibody_tree/unit_inertia.h:89
          const char* doc =
R"""(Returns a new UnitInertia object templated on `Scalar` initialized
from the value of `this` unit inertia.

Template parameter ``Scalar``:
    The scalar type on which the new unit inertia will be templated.

Note:
    `UnitInertia<From>::cast<To>()` creates a new `UnitInertia<To>`
    from a `UnitInertia<From>` but only if type `To` is constructible
    from type `From`. As an example of this,
    `UnitInertia<double>::cast<AutoDiffXd>()` is valid since
    `AutoDiffXd a(1.0)` is valid. However,
    `UnitInertia<AutoDiffXd>::cast<double>()` is not.)""";

        } cast;

        // drake::multibody::UnitInertia::operator*=
        struct /* operator_imul */ {

          // drake/multibody/multibody_tree/unit_inertia.h:448
          const char* doc = R"""()""";

        } operator_imul;

        // drake::multibody::UnitInertia::operator+=
        struct /* operator_iadd */ {

          // drake/multibody/multibody_tree/unit_inertia.h:446
          const char* doc = R"""()""";

        } operator_iadd;

        // drake::multibody::UnitInertia::operator-=
        struct /* operator_isub */ {

          // drake/multibody/multibody_tree/unit_inertia.h:447
          const char* doc = R"""()""";

        } operator_isub;

        // drake::multibody::UnitInertia::operator/=
        struct /* operator_idiv */ {

          // drake/multibody/multibody_tree/unit_inertia.h:449
          const char* doc = R"""()""";

        } operator_idiv;

      } UnitInertia;

      // drake::multibody::VelocityKinematicsCache
      struct /* VelocityKinematicsCache */ {

        // drake/multibody/multibody_tree/velocity_kinematics_cache.h:37
        const char* doc =
R"""(This class is one of the cache entries in MultibodyTreeContext. It
holds the kinematics results of computations that depend not only on
the generalized positions of the system, but also on its generalized
velocities. Velocity kinematics results include: - Spatial velocity
`V_WB` for each body B in the model as measured and expressed in the
world frame W. - Spatial velocity `V_PB` for each body B in the model
as measured and expressed in the inboard (or parent) body frame P. -
Spatial velocity `V_FMb_W` of frame Mb measured in the inboard frame F
and expressed in W. Mb is an "offset" frame rigidly fixed to M, whose
axes are parallel to M but whose origin is at Bo rather than Mo.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.)""";

        // drake::multibody::VelocityKinematicsCache::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:39
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::multibody::VelocityKinematicsCache::InitializeToZero
        struct /* InitializeToZero */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:59
          const char* doc =
R"""(Initializes `this` VelocityKinematicsCache as if all generalized
velocities of the corresponding MultibodyTree model were zero.)""";

        } InitializeToZero;

        // drake::multibody::VelocityKinematicsCache::VelocityKinematicsCache<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:39
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:39
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:47
          const char* doc_3 =
R"""(Constructs a velocity kinematics cache entry for the given
MultibodyTreeTopology. In Release builds specific entries are left
uninitialized resulting in a zero cost operation. However in Debug
builds those entries are set to NaN so that operations using this
uninitialized cache entry fail fast, easing bug detection.)""";

        } ctor;

        // drake::multibody::VelocityKinematicsCache::get_V_FM
        struct /* get_V_FM */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:89
          const char* doc =
R"""(Returns a const reference to the across-mobilizer (associated with
node `body_node_index`) spatial velocity `V_FM` of the outboard frame
M in the inboard frame F.)""";

        } get_V_FM;

        // drake::multibody::VelocityKinematicsCache::get_V_PB_W
        struct /* get_V_PB_W */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:103
          const char* doc =
R"""(Returns a const reference to the spatial velocity `V_PB_W` of the body
B associated with node `body_node_index` in the parent node's body
frame P, expressed in the world frame W.)""";

        } get_V_PB_W;

        // drake::multibody::VelocityKinematicsCache::get_V_WB
        struct /* get_V_WB */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:75
          const char* doc =
R"""(Returns a constant reference to the spatial velocity `V_WB` of the
body B (associated with node `body_node_index`) as measured and
expressed in the world frame W.

Parameter ``body_node_index``:
    The unique index for the computational BodyNode object associated
    with body B.

Returns:
    `V_WB` the spatial velocity of the body frame B measured and
    expressed in the world frame W.)""";

        } get_V_WB;

        // drake::multibody::VelocityKinematicsCache::get_mutable_V_FM
        struct /* get_mutable_V_FM */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:95
          const char* doc = R"""(Mutable version of get_V_FM().)""";

        } get_mutable_V_FM;

        // drake::multibody::VelocityKinematicsCache::get_mutable_V_PB_W
        struct /* get_mutable_V_PB_W */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:109
          const char* doc = R"""(Mutable version of get_V_PB_W().)""";

        } get_mutable_V_PB_W;

        // drake::multibody::VelocityKinematicsCache::get_mutable_V_WB
        struct /* get_mutable_V_WB */ {

          // drake/multibody/multibody_tree/velocity_kinematics_cache.h:81
          const char* doc = R"""(Mutable version of get_V_WB().)""";

        } get_mutable_V_WB;

      } VelocityKinematicsCache;

      // drake::multibody::WeldJoint
      struct /* WeldJoint */ {

        // drake/multibody/multibody_tree/joints/weld_joint.h:29
        const char* doc =
R"""(This Joint fixes the relative pose between two frames as if "welding"
them together.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::WeldJoint::DoAddInOneForce
        struct /* DoAddInOneForce */ {

          // drake/multibody/multibody_tree/joints/weld_joint.h:56
          const char* doc =
R"""(Joint<T> override called through public NVI, Joint::AddInForce().
Since frame P and C are welded together, it is physically not possible
to apply forces between them. Therefore this method throws an
exception if invoked.)""";

        } DoAddInOneForce;

        // drake::multibody::WeldJoint::WeldJoint<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/joints/weld_joint.h:31
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/joints/weld_joint.h:31
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/joints/weld_joint.h:39
          const char* doc_3 =
R"""(Constructor for a WeldJoint between a `parent_frame_P` and a
`child_frame_C` so that their relative pose `X_PC` is fixed as if they
were "welded" together.)""";

        } ctor;

        // drake::multibody::WeldJoint::X_PC
        struct /* X_PC */ {

          // drake/multibody/multibody_tree/joints/weld_joint.h:47
          const char* doc = R"""(Returns the pose X_PC of frame C in P.)""";

        } X_PC;

      } WeldJoint;

      // drake::multibody::WeldMobilizer
      struct /* WeldMobilizer */ {

        // drake/multibody/multibody_tree/weld_mobilizer.h:32
        const char* doc =
R"""(This mobilizer fixes the relative pose `X_FM` of an outboard frame M
in an inboard frame F as if "welding" them together at this fixed
relative pose. Therefore, this mobilizer has no associated state with
it.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::multibody::WeldMobilizer::CalcAcrossMobilizerSpatialAcceleration
        struct /* CalcAcrossMobilizerSpatialAcceleration */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:65
          const char* doc =
R"""(Computes the across-mobilizer acceleration `A_FM` which for this
mobilizer is always zero since the outboard frame M is fixed to the
inboard frame F.)""";

        } CalcAcrossMobilizerSpatialAcceleration;

        // drake::multibody::WeldMobilizer::CalcAcrossMobilizerSpatialVelocity
        struct /* CalcAcrossMobilizerSpatialVelocity */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:59
          const char* doc =
R"""(Computes the across-mobilizer velocity `V_FM` which for this mobilizer
is always zero since the outboard frame M is fixed to the inboard
frame F.)""";

        } CalcAcrossMobilizerSpatialVelocity;

        // drake::multibody::WeldMobilizer::CalcAcrossMobilizerTransform
        struct /* CalcAcrossMobilizerTransform */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:54
          const char* doc =
R"""(Computes the across-mobilizer transform `X_FM`, which for this
mobilizer is independent of the state stored in `context`.)""";

        } CalcAcrossMobilizerTransform;

        // drake::multibody::WeldMobilizer::DoCloneToScalar
        struct /* DoCloneToScalar */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:91
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/weld_mobilizer.h:94
          const char* doc_2 = R"""()""";

        } DoCloneToScalar;

        // drake::multibody::WeldMobilizer::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:85
          const char* doc =
R"""(This override is a no-op since this mobilizer has no generalized
velocities associated with it.)""";

        } MapQDotToVelocity;

        // drake::multibody::WeldMobilizer::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:78
          const char* doc =
R"""(This override is a no-op since this mobilizer has no generalized
velocities associated with it.)""";

        } MapVelocityToQDot;

        // drake::multibody::WeldMobilizer::ProjectSpatialForce
        struct /* ProjectSpatialForce */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:71
          const char* doc =
R"""(Since this mobilizer has no generalized velocities associated with it,
this override is a no-op.)""";

        } ProjectSpatialForce;

        // drake::multibody::WeldMobilizer::WeldMobilizer<T>
        struct /* ctor */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:34
          const char* doc = R"""()""";

          // drake/multibody/multibody_tree/weld_mobilizer.h:34
          const char* doc_2 = R"""()""";

          // drake/multibody/multibody_tree/weld_mobilizer.h:39
          const char* doc_3 =
R"""(Constructor for a WeldMobilizer between the `inboard_frame_F` and
`outboard_frame_M`.

Parameter ``X_FM``:
    Pose of `outboard_frame_M` in the `inboard_frame_F`.)""";

        } ctor;

        // drake::multibody::WeldMobilizer::get_X_FM
        struct /* get_X_FM */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:45
          const char* doc =
R"""(Returns ``X_FM``:
    The pose of the outboard frame M in the inboard frame F.)""";

        } get_X_FM;

        // drake::multibody::WeldMobilizer::set_zero_state
        struct /* set_zero_state */ {

          // drake/multibody/multibody_tree/weld_mobilizer.h:49
          const char* doc =
R"""(This override is a no-op for this mobilizer since it has no state
associated with it.)""";

        } set_zero_state;

      } WeldMobilizer;

      // benchmarks
      struct /* benchmarks */ {

        // drake::multibody::benchmarks::Acrobot
        struct /* Acrobot */ {

          // drake/multibody/benchmarks/acrobot/acrobot.h:26
          const char* doc =
R"""("elbow" revolute joint parameterized by angle theta2.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd)""";

          // drake::multibody::benchmarks::Acrobot::Acrobot<T>
          struct /* ctor */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:52
            const char* doc =
R"""(Creates an acrobot model in a plane passing through the world's origin
and normal to ``normal``. Vector ``up`` defines the upwards direction
on this plane. Both ``normal`` and ``up`` are expressed in the world's
frame. Essentially the two dimensional equations of the acrobot are
described in a model frame D within a x-y plane with y the vertical
direction and gravity pointing downwards. Therefore the axes defining
the model frame D are:

```
z_W = normal_W.normalized()
  y_W = (up - up.dot(z_W) * z_W).normalized()
  x_W = y_W.cross(z_W)
```

The remaining arguments define the properties of the double pendulum
system: - m1: mass of the first link. - m2: mass of the second link. -
l1: length of the first link. - l2: length of the second link. - lc1:
length from the shoulder to the center of mass of the first link. -
lc2: length from the elbow to the center of mass of the second link. -
Ic1: moment of inertia about the center of mass for the first link. -
Ic2: moment of inertia about the center of mass for the second link. -
b1: damping coefficient of the shoulder joint. - b2: damping
coefficient of the elbow joint. - g: acceleration of gavity.)""";

          } ctor;

          // drake::multibody::benchmarks::Acrobot::CalcCoriolisVector
          struct /* CalcCoriolisVector */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:72
            const char* doc =
R"""(Computes the bias term `C(q, v) * v` containing Coriolis and
gyroscopic effects as a function of the state of the pendulum.)""";

          } CalcCoriolisVector;

          // drake::multibody::benchmarks::Acrobot::CalcElbowOutboardFramePoseInWorldFrame
          struct /* CalcElbowOutboardFramePoseInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:104
            const char* doc =
R"""(Computes the pose of the elbow outboard frame `Eo` in the world frame
W.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WEo the pose of the elbow frame Eo in the world frame W.)""";

          } CalcElbowOutboardFramePoseInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcGravityVector
          struct /* CalcGravityVector */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:81
            const char* doc =
R"""(Computes the effective joint-space torques induced by gravity
`tau_g(q)` containing the effect of gravity as a function of the
configuration of the pendulum. Unlike
http://underactuated.mit.edu/underactuated.html?chapter=3, cited in
this class's documentation, we define `tau_g(q)` to be on the right
hand side of the equations of motion, that is, `Mv̇ + C(q, v)v =
tau_g(q)`.)""";

          } CalcGravityVector;

          // drake::multibody::benchmarks::Acrobot::CalcLink1PoseInWorldFrame
          struct /* CalcLink1PoseInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:89
            const char* doc =
R"""(Computes the pose of the center of mass of link 1 measured and
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WL1 the pose of link 1 measured and expressed in the world
    frame.)""";

          } CalcLink1PoseInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcLink1SpatialAccelerationInWorldFrame
          struct /* CalcLink1SpatialAccelerationInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:139
            const char* doc =
R"""(Computes the spatial acceleration of the center of mass of link 1
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta1dotdot``:
    The elbow angular acceleration in radians per second squared.

Returns ``A_WL1_W``:
    the spatial acceleration of the center of mass of link 1 with
    respect to the world and expressed in the world frame.)""";

          } CalcLink1SpatialAccelerationInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcLink1SpatialVelocityInWorldFrame
          struct /* CalcLink1SpatialVelocityInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:113
            const char* doc =
R"""(Computes the spatial velocity of the center of mass of link 1
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Returns:
    V_WL1_W the spatial velocity of the center of mass of link 1 with
    respect to the world and expressed in the world frame.)""";

          } CalcLink1SpatialVelocityInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcLink2PoseInWorldFrame
          struct /* CalcLink2PoseInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:97
            const char* doc =
R"""(Computes the pose of the center of mass of link 2 measured and
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Returns:
    X_WL2 the pose of link 2 measured and expressed in the world
    frame.)""";

          } CalcLink2PoseInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcLink2SpatialAccelerationInWorldFrame
          struct /* CalcLink2SpatialAccelerationInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:159
            const char* doc =
R"""(Computes the spatial acceleration of the center of mass of link 2
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta2dot``:
    The elbow angular velocity in radians per second.

Parameter ``theta1dotdot``:
    The shoulder angular acceleration in radians per second squared.

Parameter ``theta2dotdot``:
    The elbow angular acceleration in radians per second squared.

Returns ``A_WL2_W``:
    the spatial acceleration of the center of mass of link 2 with
    respect to the world and expressed in the world frame.)""";

          } CalcLink2SpatialAccelerationInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcLink2SpatialVelocityInWorldFrame
          struct /* CalcLink2SpatialVelocityInWorldFrame */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:124
            const char* doc =
R"""(Computes the spatial velocity of the center of mass of link 2
expressed in the world frame.

Parameter ``theta1``:
    The shoulder angle in radians.

Parameter ``theta2``:
    The elbow angle in radians.

Parameter ``theta1dot``:
    The shoulder angular velocity in radians per second.

Parameter ``theta2dot``:
    The elbow angular velocity in radians per second.

Returns:
    V_WL2_W the spatial velocity of the center of mass of link 2 with
    respect to the world and expressed in the world frame.)""";

          } CalcLink2SpatialVelocityInWorldFrame;

          // drake::multibody::benchmarks::Acrobot::CalcMassMatrix
          struct /* CalcMassMatrix */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:68
            const char* doc =
R"""(Computes the mass matrix `H(q)` for the double pendulum system. It
turns out that for this system the mass matrix is independent of the
shoulder angle `theta1`.)""";

          } CalcMassMatrix;

          // drake::multibody::benchmarks::Acrobot::CalcPotentialEnergy
          struct /* CalcPotentialEnergy */ {

            // drake/multibody/benchmarks/acrobot/acrobot.h:167
            const char* doc =
R"""(Computes the total potential energy due to gravity of the acrobot
system for the state given by angles `theta1` and `theta2`. The zero
potential energy is defined for `y = 0`.)""";

          } CalcPotentialEnergy;

        } Acrobot;

        // acrobot
        struct /* acrobot */ {

          // drake::multibody::benchmarks::acrobot::AcrobotParameters
          struct /* AcrobotParameters */ {

            // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:25
            const char* doc =
R"""(This class is used to store the numerical parameters defining the
model of an acrobot with the method MakeAcrobotPlant(). Refer to this
the documentation of this class's constructor for further details on
the parameters stored by this class and their default values.

Note:
    The default constructor initializes the parameters in accordance
    to the `acrobot.sdf` file in this same directory. Therefore this
    file and `acrobot.sdf` MUST be kept in sync.)""";

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::AcrobotParameters
            struct /* ctor */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:27
              const char* doc = R"""()""";

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:27
              const char* doc_2 = R"""()""";

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:59
              const char* doc_3 =
R"""(Constructor used to initialize the physical parameters for an acrobot
model. The parameters are defaulted to values in Spong's paper [Spong
1994].

Parameter ``m1``:
    Mass of link 1 (kg).

Parameter ``m2``:
    Mass of link 2 (kg).

Parameter ``l1``:
    Length of link 1 (m).

Parameter ``l2``:
    Length of link 2 (m).

Parameter ``lc1``:
    Vertical distance from shoulder joint to center of mass of link 1
    (m).

Parameter ``lc2``:
    Vertical distance from elbow joint to center of mass of link 2
    (m).

Parameter ``Ic1``:
    Inertia of link 1 about the center of mass of link 1 (kg⋅m²).

Parameter ``Ic2``:
    Inertia of link 2 about the center of mass of link 2 (kg*m^2).

Parameter ``b1``:
    Damping coefficient of the shoulder joint (N⋅m⋅s).

Parameter ``b2``:
    Damping coefficient of the elbow joint (N⋅m⋅s).

Parameter ``g``:
    Gravitational constant (m/s²).

- [Spong 1994] Spong, M.W., 1994. Swing up control of the acrobot. In
Robotics and Automation, 1994. Proceedings., 1994 IEEE International
Conference on (pp. 2356-2361). IEEE.)""";

            } ctor;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
            struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:27
              const char* doc = R"""()""";

            } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::Ic1
            struct /* Ic1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:90
              const char* doc = R"""()""";

            } Ic1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::Ic2
            struct /* Ic2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:91
              const char* doc = R"""()""";

            } Ic2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::actuator_name
            struct /* actuator_name */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:110
              const char* doc = R"""()""";

            } actuator_name;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::b1
            struct /* b1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:92
              const char* doc = R"""()""";

            } b1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::b2
            struct /* b2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:93
              const char* doc = R"""()""";

            } b2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::elbow_joint_name
            struct /* elbow_joint_name */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:107
              const char* doc = R"""()""";

            } elbow_joint_name;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::g
            struct /* g */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:94
              const char* doc = R"""()""";

            } g;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::l1
            struct /* l1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:86
              const char* doc = R"""()""";

            } l1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::l2
            struct /* l2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:87
              const char* doc = R"""()""";

            } l2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::lc1
            struct /* lc1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:88
              const char* doc = R"""()""";

            } lc1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::lc2
            struct /* lc2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:89
              const char* doc = R"""()""";

            } lc2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::link1_name
            struct /* link1_name */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:102
              const char* doc = R"""()""";

            } link1_name;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::link2_name
            struct /* link2_name */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:103
              const char* doc = R"""()""";

            } link2_name;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::m1
            struct /* m1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:84
              const char* doc = R"""()""";

            } m1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::m2
            struct /* m2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:85
              const char* doc = R"""()""";

            } m2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::r1
            struct /* r1 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:98
              const char* doc = R"""()""";

            } r1;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::r2
            struct /* r2 */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:99
              const char* doc = R"""()""";

            } r2;

            // drake::multibody::benchmarks::acrobot::AcrobotParameters::shoulder_joint_name
            struct /* shoulder_joint_name */ {

              // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:104
              const char* doc = R"""()""";

            } shoulder_joint_name;

          } AcrobotParameters;

          // drake::multibody::benchmarks::acrobot::MakeAcrobotPlant
          struct /* MakeAcrobotPlant */ {

            // drake/multibody/benchmarks/acrobot/make_acrobot_plant.h:152
            const char* doc =
R"""(This method makes a MultibodyPlant model of the Acrobot - a canonical
underactuated system as described in <a href="http://underactuated.mit
.edu/underactuated.html?chapter=3">Chapter 3 of Underactuated
Robotics</a>.

Parameter ``default_parameters``:
    Default parameters of the model set at construction. These
    parameters include masses, link lengths, rotational inertias, etc.
    Refer to the documentation of AcrobotParameters for further
    details.

Parameter ``finalize``:
    If `true`, MultibodyPlant::Finalize() gets called on the new
    plant.

Parameter ``scene_graph``:
    If a SceneGraph is provided with this argument, this factory
    method will register the new multibody plant to be a source for
    that geometry system and it will also register geometry for
    visualization. If this argument is omitted, no geometry will be
    registered.)""";

          } MakeAcrobotPlant;

        } acrobot;

      } benchmarks;

      // collision
      struct /* collision */ {

        // drake::multibody::collision::BulletCollisionWorldWrapper
        struct /* BulletCollisionWorldWrapper */ {

          // drake/multibody/collision/bullet_model.h:34
          const char* doc = R"""()""";

          // drake::multibody::collision::BulletCollisionWorldWrapper::BulletCollisionWorldWrapper
          struct /* ctor */ {

            // drake/multibody/collision/bullet_model.h:35
            const char* doc = R"""()""";

          } ctor;

          // drake::multibody::collision::BulletCollisionWorldWrapper::bt_collision_broadphase
          struct /* bt_collision_broadphase */ {

            // drake/multibody/collision/bullet_model.h:39
            const char* doc = R"""()""";

          } bt_collision_broadphase;

          // drake::multibody::collision::BulletCollisionWorldWrapper::bt_collision_configuration
          struct /* bt_collision_configuration */ {

            // drake/multibody/collision/bullet_model.h:38
            const char* doc = R"""()""";

          } bt_collision_configuration;

          // drake::multibody::collision::BulletCollisionWorldWrapper::bt_collision_dispatcher
          struct /* bt_collision_dispatcher */ {

            // drake/multibody/collision/bullet_model.h:42
            const char* doc = R"""()""";

          } bt_collision_dispatcher;

          // drake::multibody::collision::BulletCollisionWorldWrapper::bt_collision_objects
          struct /* bt_collision_objects */ {

            // drake/multibody/collision/bullet_model.h:36
            const char* doc = R"""()""";

          } bt_collision_objects;

          // drake::multibody::collision::BulletCollisionWorldWrapper::bt_collision_world
          struct /* bt_collision_world */ {

            // drake/multibody/collision/bullet_model.h:43
            const char* doc = R"""()""";

          } bt_collision_world;

          // drake::multibody::collision::BulletCollisionWorldWrapper::filter_callback
          struct /* filter_callback */ {

            // drake/multibody/collision/bullet_model.h:40
            const char* doc = R"""()""";

          } filter_callback;

        } BulletCollisionWorldWrapper;

        // drake::multibody::collision::BulletModel
        struct /* BulletModel */ {

          // drake/multibody/collision/bullet_model.h:21
          const char* doc = R"""()""";

          // drake/multibody/collision/bullet_model.h:51
          const char* doc_2 = R"""()""";

          // drake::multibody::collision::BulletModel::BulletModel
          struct /* ctor */ {

            // drake/multibody/collision/bullet_model.h:53
            const char* doc = R"""()""";

            // drake/multibody/collision/bullet_model.h:53
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/bullet_model.h:55
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::multibody::collision::BulletModel::ClearCachedResults
          struct /* ClearCachedResults */ {

            // drake/multibody/collision/bullet_model.h:126
            const char* doc = R"""()""";

          } ClearCachedResults;

          // drake::multibody::collision::BulletModel::ClosestPointsAllToAll
          struct /* ClosestPointsAllToAll */ {

            // drake/multibody/collision/bullet_model.h:76
            const char* doc =
R"""(Finds the points where each pair of the elements in ids_to_check are
closest. Inserts those points in closest_points.

Returns:
    true if any points are found.)""";

          } ClosestPointsAllToAll;

          // drake::multibody::collision::BulletModel::ClosestPointsPairwise
          struct /* ClosestPointsPairwise */ {

            // drake/multibody/collision/bullet_model.h:89
            const char* doc =
R"""(Finds the points where each pair of elements in id_pairs are closest.
Inserts those points in closest_points.

Returns:
    true if any points are found.)""";

          } ClosestPointsPairwise;

          // drake::multibody::collision::BulletModel::CollidingPoints
          struct /* CollidingPoints */ {

            // drake/multibody/collision/bullet_model.h:137
            const char* doc = R"""()""";

          } CollidingPoints;

          // drake::multibody::collision::BulletModel::CollidingPointsCheckOnly
          struct /* CollidingPointsCheckOnly */ {

            // drake/multibody/collision/bullet_model.h:133
            const char* doc = R"""()""";

          } CollidingPointsCheckOnly;

          // drake::multibody::collision::BulletModel::CollisionDetectFromPoints
          struct /* CollisionDetectFromPoints */ {

            // drake/multibody/collision/bullet_model.h:122
            const char* doc =
R"""(Computes the closest point in the collision world to each of a set of
points. For each query point, a PointPair instance, `p`, is returned
with the following semantics: - p.elementA = p.elementB = pointer to
the closest element. - p.idA = p.idB = ElementId of closest element. -
p.ptA = the point on the closest element's surface expressed and
measured in the element's local frame. - p.ptB = the point on the
closest element's surface expressed and measured in the world frame. -
p.normal = the normal direction from the nearest object to the query
point, expressed in the world frame. - p.distance = The *signed*
distance between the query point and the nearest point. Negative
values indicate penetration. If there are no objects in the scene,
then the pointers will be nullptr, the ids, 0, the distance infinite,
and the nearest points, infinitely far away.

This query will *not* determine the distance to non-convex geometry. A
scene with only non-convex geometry is effectively empty to this
method.

Parameter ``points``:
    A set of points measured and expressed in the world frame. One per
    column.

Parameter ``use_margins``:
    Determines whether margins are used (true) or not.

Parameter ``closest_points``:
    The vector for which all the closest point data will be returned.)""";

          } CollisionDetectFromPoints;

          // drake::multibody::collision::BulletModel::CollisionRaycast
          struct /* CollisionRaycast */ {

            // drake/multibody/collision/bullet_model.h:128
            const char* doc = R"""()""";

          } CollisionRaycast;

          // drake::multibody::collision::BulletModel::ComputeMaximumDepthCollisionPoints
          struct /* ComputeMaximumDepthCollisionPoints */ {

            // drake/multibody/collision/bullet_model.h:80
            const char* doc = R"""()""";

          } ComputeMaximumDepthCollisionPoints;

          // drake::multibody::collision::BulletModel::DoAddElement
          struct /* DoAddElement */ {

            // drake/multibody/collision/bullet_model.h:63
            const char* doc = R"""()""";

          } DoAddElement;

          // drake::multibody::collision::BulletModel::DoRemoveElement
          struct /* DoRemoveElement */ {

            // drake/multibody/collision/bullet_model.h:65
            const char* doc = R"""()""";

          } DoRemoveElement;

          // drake::multibody::collision::BulletModel::NotifyFilterCriteriaChanged
          struct /* NotifyFilterCriteriaChanged */ {

            // drake/multibody/collision/bullet_model.h:59
            const char* doc = R"""()""";

          } NotifyFilterCriteriaChanged;

          // drake::multibody::collision::BulletModel::UpdateElementWorldTransform
          struct /* UpdateElementWorldTransform */ {

            // drake/multibody/collision/bullet_model.h:67
            const char* doc = R"""()""";

          } UpdateElementWorldTransform;

          // drake::multibody::collision::BulletModel::UpdateModel
          struct /* UpdateModel */ {

            // drake/multibody/collision/bullet_model.h:61
            const char* doc = R"""()""";

          } UpdateModel;

          // drake::multibody::collision::BulletModel::newBulletBoxShape
          struct /* newBulletBoxShape */ {

            // drake/multibody/collision/bullet_model.h:141
            const char* doc = R"""()""";

          } newBulletBoxShape;

        } BulletModel;

        // drake::multibody::collision::CollisionFilterGroup
        struct /* CollisionFilterGroup */ {

          // drake/multibody/collision/collision_filter.h:63
          const char* doc =
R"""(The specification of a collision filter group: its name, bodies that
belong to it, and the names of collision filter groups that it
ignores. This class is used for initialization and not run-time
calculations.

A collision filter group is a mechanism for cheaply culling pairs of
collision elements from consideration during collision detection. One
collision filter group associates a set of bodies with a set of
*ignored* collision filter groups. At runtime, when a pair of bodies
$(A, B)$ are determined to be a collision candidate, their collision
filter group membership is examined.

Given the following definitions:

- $G(A) ≜ \{g^A_0, g^A_1, ..., g^A_n\}$ is the set of all groups to
which $A$ belongs, - $I(f) ≜ \{g^f_0, g^f_1, ..., g^f_m\}$ is the set
set of all groups that group $f$ ignores, - $I(A) ≜ \{I(g^A_0) \cap
I(g^A_1) \cap ... \cap I(g^A_n)\}$ such that $g^A_i \in G(A)$ is the
set of all groups that $A$ ignores.

Then, the pair $(A, B)$ will be filtered if:

I(A) \cap G(B) \ne \emptyset \lor I(B) \cap G(A) \ne \emptyset$.
    In other words, if either body belongs to a group which is ignored
    by *any* group the other body belongs to.

Template parameter ``T``:
    A valid Eigen scalar type.)""";

          // drake::multibody::collision::CollisionFilterGroup::CollisionFilterGroup<T>
          struct /* ctor */ {

            // drake/multibody/collision/collision_filter.h:65
            const char* doc = R"""()""";

            // drake/multibody/collision/collision_filter.h:65
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/collision_filter.h:70
            const char* doc_3 =
R"""(Default constructor required by use in std::unordered_map.)""";

            // drake/multibody/collision/collision_filter.h:76
            const char* doc_4 =
R"""(Parameter ``name``:
    The name for the collision filter group.

Parameter ``id``:
    The bit id for this collision filter group.)""";

          } ctor;

          // drake::multibody::collision::CollisionFilterGroup::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/multibody/collision/collision_filter.h:65
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::multibody::collision::CollisionFilterGroup::add_body
          struct /* add_body */ {

            // drake/multibody/collision/collision_filter.h:80
            const char* doc = R"""()""";

          } add_body;

          // drake::multibody::collision::CollisionFilterGroup::add_ignore_group
          struct /* add_ignore_group */ {

            // drake/multibody/collision/collision_filter.h:88
            const char* doc = R"""()""";

          } add_ignore_group;

          // drake::multibody::collision::CollisionFilterGroup::get_bodies
          struct /* get_bodies */ {

            // drake/multibody/collision/collision_filter.h:82
            const char* doc = R"""()""";

          } get_bodies;

          // drake::multibody::collision::CollisionFilterGroup::get_ignore_groups
          struct /* get_ignore_groups */ {

            // drake/multibody/collision/collision_filter.h:84
            const char* doc = R"""()""";

          } get_ignore_groups;

          // drake::multibody::collision::CollisionFilterGroup::get_mask_id
          struct /* get_mask_id */ {

            // drake/multibody/collision/collision_filter.h:78
            const char* doc = R"""()""";

          } get_mask_id;

        } CollisionFilterGroup;

        // drake::multibody::collision::CollisionFilterGroupManager
        struct /* CollisionFilterGroupManager */ {

          // drake/multibody/collision/collision_filter.h:142
          const char* doc =
R"""(This class provides management utilities for the definition of
collision filter groups for RigidBodyTree instances.

The intent of the manager is to serve as an accumulator during the
construction* process. It serves as an intermediate representation of
the collision filter group semantics. A unique instance should be
owned by each RigidBodyTree instance.

The manager is used in construction *sessions*. The first session
begins upon construction and ends with a call to Clear(). Each call to
Clear() implicitly marks the beginning of the next session. Collision
filter groups defined during a single session must all have unique
group *names*. Names repeated in different sessions are treated as
being *different* collision filter groups. The names of the groups are
only maintained during the session. During RigidBodyTree compilation,
the names are replaced with integers in the filter mechanism
identifiers.

The group manager can only handle a finite number of groups
(kMaxNumCollisionFilterGroups). Each session contributes towards
reaching that total. If the maximum number of groups has been reached,
subsequent efforts to define a new collision filter group will cause
exceptions to be thrown.

There are several implications of this design:

- Collision filter groups have a scope limited to a single URDF file.
That means a collision filter group *cannot* be configured between
bodies defined in different URDF files. - Even if the same file is
parsed multiple times, leading to collision filter groups with
identical names in each session, the groups will be considered
different. Bodies from one parsing of the file will not be in groups
visible to another parsing. - A user cannot change the collision
filter groups a body belongs to or which groups it ignores outside of
the URDF specification.

Template parameter ``T``:
    A valid Eigen scalar type.)""";

          // drake::multibody::collision::CollisionFilterGroupManager::AddCollisionFilterGroupMember
          struct /* AddCollisionFilterGroupMember */ {

            // drake/multibody/collision/collision_filter.h:180
            const char* doc =
R"""(Adds a RigidBody to a collision filter group. The process will fail if
the group cannot be found.

Parameter ``group_name``:
    The name of the collision filter group to add the body to.

Parameter ``body``:
    The body to add.

Returns:
    False if the group could not be found.)""";

          } AddCollisionFilterGroupMember;

          // drake::multibody::collision::CollisionFilterGroupManager::AddCollisionFilterIgnoreTarget
          struct /* AddCollisionFilterIgnoreTarget */ {

            // drake/multibody/collision/collision_filter.h:192
            const char* doc =
R"""(Adds a collision group to the set of groups ignored by the specified
collision filter group. Will fail if the specified group name does not
refer to an existing collision filter group. (Although, the target
group name need not exist at this time.)

Parameter ``group_name``:
    The name of the group to modify.

Parameter ``target_group_name``:
    The name of the group to ignore.

Throws:
    s std::logic_error in response to failure conditions.)""";

          } AddCollisionFilterIgnoreTarget;

          // drake::multibody::collision::CollisionFilterGroupManager::Clear
          struct /* Clear */ {

            // drake/multibody/collision/collision_filter.h:226
            const char* doc =
R"""(Clears the cached collision filter group specification data from the
current session. It does *not* reset the counter for available
collision filter groups. This is what makes it possible for a file to
be read multiple times in sequence, but to have each parsing produce a
unique set of collision filter groups. Or if two files are parsed, and
both use a common name for a collision filter group. They are treated
as unique collision filter groups and all of those groups count
against the *total* number of groups supported by a single instance of
the manager.)""";

          } Clear;

          // drake::multibody::collision::CollisionFilterGroupManager::CollisionFilterGroupManager<T>
          struct /* ctor */ {

            // drake/multibody/collision/collision_filter.h:144
            const char* doc = R"""()""";

            // drake/multibody/collision/collision_filter.h:144
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/collision_filter.h:147
            const char* doc_3 = R"""(Default constructor. */)""";

          } ctor;

          // drake::multibody::collision::CollisionFilterGroupManager::CompileGroups
          struct /* CompileGroups */ {

            // drake/multibody/collision/collision_filter.h:153
            const char* doc =
R"""(Based on the current specification, builds the appropriate collision
filter bitmasks and assigns them to the previously provided rigid
bodies.)""";

          } CompileGroups;

          // drake::multibody::collision::CollisionFilterGroupManager::DefineCollisionFilterGroup
          struct /* DefineCollisionFilterGroup */ {

            // drake/multibody/collision/collision_filter.h:162
            const char* doc =
R"""(Attempts to define a new collision filter group. The given name *must*
be unique in this session. Duplicate names or attempting to add more
collision filter groups than the system can handle will lead to
failure.

Parameter ``name``:
    The unique name of the new group.

Throws:
    s std::logic_error in response to failure conditions.)""";

          } DefineCollisionFilterGroup;

          // drake::multibody::collision::CollisionFilterGroupManager::GetGroupId
          struct /* GetGroupId */ {

            // drake/multibody/collision/collision_filter.h:200
            const char* doc =
R"""(Reports the collision filter group assigned to the given group name.

Parameter ``group_name``:
    The group name to query.

Returns:
    the assigned group id (kInvalidGroupId if an valid group name).)""";

          } GetGroupId;

          // drake::multibody::collision::CollisionFilterGroupManager::body_groups
          struct /* body_groups */ {

            // drake/multibody/collision/collision_filter.h:229
            const char* doc = R"""()""";

          } body_groups;

          // drake::multibody::collision::CollisionFilterGroupManager::get_group_mask
          struct /* get_group_mask */ {

            // drake/multibody/collision/collision_filter.h:207
            const char* doc =
R"""(Returns the group membership bitmask for the given ``body``. If there
is no information for this body, the zero bitmask will be returned.
This should only be called *after* CompileGroups.)""";

          } get_group_mask;

          // drake::multibody::collision::CollisionFilterGroupManager::get_ignore_mask
          struct /* get_ignore_mask */ {

            // drake/multibody/collision/collision_filter.h:214
            const char* doc =
R"""(Returns the ignored group bitmask for the given ``body``. If there is
no information for this body, the zero bitmask will be returned. This
should only be called *after* CompileGroups.)""";

          } get_ignore_mask;

        } CollisionFilterGroupManager;

        // drake::multibody::collision::Element
        struct /* Element */ {

          // drake/multibody/collision/element.h:43
          const char* doc =
R"""(The underyling primitive class used for collision analysis. Collisions
between `RigidBody` instances are determined by performing geometry
analysis on the `RigidBody` instances' corresponding collision
`Element`s. As such, The `Element` combines three pieces of data: -
the geometric definition of the element's colliding shape (a
`Geometry` instance referred to as its "geometry"). - the transform
`T_element_to_local` (T_LE) giving the pose of the element's frame E
in the body's local frame L, with the sense that p_L = T_LE * p_E for
points measured and expressed in frames L and E, respectively. - the
`RigidBody` instance to which this element belongs (its "body"). A
`RigidBody` *can* possess multiple collision `Element`s, but an
`Element` can only belong to a single `RigidBody`.)""";

          // drake::multibody::collision::Element::AddCliquesFromElement
          struct /* AddCliquesFromElement */ {

            // drake/multibody/collision/element.h:121
            const char* doc =
R"""(Adds the cliques of the given `element` to `this` element's cliques.

Parameter ``element``:
    The element whose cliques will be copied.)""";

          } AddCliquesFromElement;

          // drake::multibody::collision::Element::AddToCollisionClique
          struct /* AddToCollisionClique */ {

            // drake/multibody/collision/element.h:114
            const char* doc =
R"""(Adds this element to the clique specified by the given clique id.

The clique may be a previously existing clique or a new clique. If the
element already belongs to the clique, there will be no change.

Parameter ``clique_id``:
    The clique to which this element will belong to.)""";

          } AddToCollisionClique;

          // drake::multibody::collision::Element::CanCollideWith
          struct /* CanCollideWith */ {

            // drake/multibody/collision/element.h:104
            const char* doc =
R"""(Returns true if this element should be checked for collisions with the
``other`` object. CanCollideWith() is commutative; A can collide with
B implies B can collide with A.)""";

          } CanCollideWith;

          // drake::multibody::collision::Element::Element
          struct /* ctor */ {

            // drake/multibody/collision/element.h:49
            const char* doc =
R"""(Default constructor. The element's pose will be the identity with no
geometry or rigid body.)""";

            // drake/multibody/collision/element.h:56
            const char* doc_2 =
R"""(Geometry constructor. Defines geometry and pose but no body.

Parameter ``geometry``:
    The colliding geometry.

Parameter ``T_element_to_local``:
    The pose (defaults to identity).)""";

            // drake/multibody/collision/element.h:65
            const char* doc_3 =
R"""(Body constructor. Defines body and pose but no geometry.

Parameter ``T_element_to_local``:
    The pose (defaults to identity).

Parameter ``body``:
    The associated rigid body.)""";

            // drake/multibody/collision/element.h:74
            const char* doc_4 =
R"""(Full constructor.

Parameter ``geometry``:
    The colliding geometry.

Parameter ``T_element_to_local``:
    The pose.

Parameter ``body``:
    The associated rigid body.)""";

          } ctor;

          // drake::multibody::collision::Element::clone
          struct /* clone */ {

            // drake/multibody/collision/element.h:80
            const char* doc = R"""()""";

          } clone;

          // drake::multibody::collision::Element::collision_cliques
          struct /* collision_cliques */ {

            // drake/multibody/collision/element.h:134
            const char* doc =
R"""(Provides access to the set of cliques to which this element belongs.

Returns:
    A reference to the clique set (as a monotonically increasing
    ordered list).)""";

          } collision_cliques;

          // drake::multibody::collision::Element::compliant_material
          struct /* compliant_material */ {

            // drake/multibody/collision/element.h:166
            const char* doc = R"""()""";

          } compliant_material;

          // drake::multibody::collision::Element::getId
          struct /* getId */ {

            // drake/multibody/collision/element.h:82
            const char* doc = R"""()""";

          } getId;

          // drake::multibody::collision::Element::get_body
          struct /* get_body */ {

            // drake/multibody/collision/element.h:139
            const char* doc =
R"""(Returns a pointer to the `RigidBody` to which this `Element` is
attached.)""";

          } get_body;

          // drake::multibody::collision::Element::get_collision_filter_group
          struct /* get_collision_filter_group */ {

            // drake/multibody/collision/element.h:153
            const char* doc = R"""()""";

          } get_collision_filter_group;

          // drake::multibody::collision::Element::get_collision_filter_ignores
          struct /* get_collision_filter_ignores */ {

            // drake/multibody/collision/element.h:157
            const char* doc = R"""()""";

          } get_collision_filter_ignores;

          // drake::multibody::collision::Element::get_num_cliques
          struct /* get_num_cliques */ {

            // drake/multibody/collision/element.h:127
            const char* doc =
R"""(Reports the number of cliques to which this element belongs.

Returns:
    The number of cliques.)""";

          } get_num_cliques;

          // drake::multibody::collision::Element::is_anchored
          struct /* is_anchored */ {

            // drake/multibody/collision/element.h:97
            const char* doc =
R"""(Returns `true` if the shape does not move relative to the world frame.
For instance, terrain geometry would commonly be anchored. This
property allows the collision engine to perform certain optimizations
not generally possible for moving objects.)""";

          } is_anchored;

          // drake::multibody::collision::Element::merge_collision_filter
          struct /* merge_collision_filter */ {

            // drake/multibody/collision/element.h:151
            const char* doc =
R"""(Updates the collision filter state of the element; *adds* the groups
to which this element belongs and the groups it ignores.)""";

          } merge_collision_filter;

          // drake::multibody::collision::Element::set_anchored
          struct /* set_anchored */ {

            // drake/multibody/collision/element.h:89
            const char* doc =
R"""(Flags this collision element to be anchored, i.e. it does not move
relative to the world frame.

See also:
    Element::is_anchored().)""";

          } set_anchored;

          // drake::multibody::collision::Element::set_body
          struct /* set_body */ {

            // drake/multibody/collision/element.h:142
            const char* doc =
R"""(Sets the `RigidBody` this collision element is attached to. */)""";

          } set_body;

          // drake::multibody::collision::Element::set_collision_filter
          struct /* set_collision_filter */ {

            // drake/multibody/collision/element.h:147
            const char* doc =
R"""(Sets the collision filter state of the element: the groups to which
this element belongs and the groups that it should ignore.)""";

          } set_collision_filter;

          // drake::multibody::collision::Element::set_compliant_material
          struct /* set_compliant_material */ {

            // drake/multibody/collision/element.h:170
            const char* doc = R"""()""";

          } set_compliant_material;

        } Element;

        // drake::multibody::collision::FclModel
        struct /* FclModel */ {

          // drake/multibody/collision/fcl_model.h:19
          const char* doc = R"""()""";

          // drake::multibody::collision::FclModel::ClearCachedResults
          struct /* ClearCachedResults */ {

            // drake/multibody/collision/fcl_model.h:46
            const char* doc = R"""()""";

          } ClearCachedResults;

          // drake::multibody::collision::FclModel::ClosestPointsAllToAll
          struct /* ClosestPointsAllToAll */ {

            // drake/multibody/collision/fcl_model.h:28
            const char* doc = R"""()""";

          } ClosestPointsAllToAll;

          // drake::multibody::collision::FclModel::ClosestPointsPairwise
          struct /* ClosestPointsPairwise */ {

            // drake/multibody/collision/fcl_model.h:31
            const char* doc = R"""()""";

          } ClosestPointsPairwise;

          // drake::multibody::collision::FclModel::CollidingPoints
          struct /* CollidingPoints */ {

            // drake/multibody/collision/fcl_model.h:43
            const char* doc = R"""()""";

          } CollidingPoints;

          // drake::multibody::collision::FclModel::CollidingPointsCheckOnly
          struct /* CollidingPointsCheckOnly */ {

            // drake/multibody/collision/fcl_model.h:34
            const char* doc = R"""()""";

          } CollidingPointsCheckOnly;

          // drake::multibody::collision::FclModel::CollisionDetectFromPoints
          struct /* CollisionDetectFromPoints */ {

            // drake/multibody/collision/fcl_model.h:47
            const char* doc = R"""()""";

          } CollisionDetectFromPoints;

          // drake::multibody::collision::FclModel::CollisionRaycast
          struct /* CollisionRaycast */ {

            // drake/multibody/collision/fcl_model.h:37
            const char* doc = R"""()""";

          } CollisionRaycast;

          // drake::multibody::collision::FclModel::ComputeMaximumDepthCollisionPoints
          struct /* ComputeMaximumDepthCollisionPoints */ {

            // drake/multibody/collision/fcl_model.h:41
            const char* doc = R"""()""";

          } ComputeMaximumDepthCollisionPoints;

          // drake::multibody::collision::FclModel::DoAddElement
          struct /* DoAddElement */ {

            // drake/multibody/collision/fcl_model.h:26
            const char* doc = R"""()""";

          } DoAddElement;

          // drake::multibody::collision::FclModel::DoRemoveElement
          struct /* DoRemoveElement */ {

            // drake/multibody/collision/fcl_model.h:27
            const char* doc = R"""()""";

          } DoRemoveElement;

          // drake::multibody::collision::FclModel::FclModel
          struct /* ctor */ {

            // drake/multibody/collision/fcl_model.h:21
            const char* doc = R"""()""";

            // drake/multibody/collision/fcl_model.h:21
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/fcl_model.h:23
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::multibody::collision::FclModel::UpdateElementWorldTransform
          struct /* UpdateElementWorldTransform */ {

            // drake/multibody/collision/fcl_model.h:51
            const char* doc = R"""()""";

          } UpdateElementWorldTransform;

          // drake::multibody::collision::FclModel::UpdateModel
          struct /* UpdateModel */ {

            // drake/multibody/collision/fcl_model.h:50
            const char* doc = R"""()""";

          } UpdateModel;

        } FclModel;

        // drake::multibody::collision::Model
        struct /* Model */ {

          // drake/multibody/collision/model.h:21
          const char* doc =
R"""(Model is an abstract base class of a collision model. Child classes of
Model implement the actual collision detection logic.)""";

          // drake::multibody::collision::Model::AddElement
          struct /* AddElement */ {

            // drake/multibody/collision/model.h:44
            const char* doc =
R"""(Adds a collision element to this model.

This operation is frequently referred to as "registering" the
collision element. This is the process by which a fully-realized Drake
collision element is fed to a specific
drake::multibody::collision::Model implementation. Prior to this
*registration*, the collision model knows nothing about the collision
element. After registration, it owns the collision element.

Parameter ``element``:
    The element to add.

Returns:
    A pointer to the added element.

Throws:
    s A runtime_error if there was a problem (e.g., duplicate element
    id, error configuring collision model, etc.))""";

          } AddElement;

          // drake::multibody::collision::Model::ClearCachedResults
          struct /* ClearCachedResults */ {

            // drake/multibody/collision/model.h:163
            const char* doc =
R"""(Clears possibly cached results so that a fresh computation can be
performed.

Parameter ``use_margins``:
    If `true`, the cache of the model with margins is cleared. If
    `false`, the cache of the model without margins is cleared.

Depending on the implementation, the collision model may cache results
on each dispatch. For instance, Bullet uses cached results to warm-
start its LCP solvers.

Clearing cached results allows the collision model to perform a fresh
computation without any coupling with previous history.

See also:
    drake/multibody/collision/test/model_test.cc.)""";

          } ClearCachedResults;

          // drake::multibody::collision::Model::ClosestPointsAllToAll
          struct /* ClosestPointsAllToAll */ {

            // drake/multibody/collision/model.h:114
            const char* doc =
R"""(Computes the points of closest approach between all eligible pairs of
collision elements drawn from a specified set of elements

Parameter ``ids_to_check``:
    The vector of ElementId for which the all-to-all collision
    detection should be performed

Parameter ``use_margins``:
    A flag indicating whether or not to use the version of this model
    with collision margins

Parameter ``closest_points``:
    A reference to a vector of PointPair objects that contains the
    closest point information after this method is called

Returns:
    Whether this method successfully ran.)""";

          } ClosestPointsAllToAll;

          // drake::multibody::collision::Model::ClosestPointsPairwise
          struct /* ClosestPointsPairwise */ {

            // drake/multibody/collision/model.h:145
            const char* doc =
R"""(Computes the points of closest approach between specified pairs of
collision elements.

Parameter ``id_pairs``:
    A vector of ElementIdPair specifying which pairs of elements to
    consider

Parameter ``use_margins``:
    A flag indicating whether or not to use the version of this model
    with collision margins

Parameter ``closest_points``:
    A reference to a vector of PointPair objects that contains the
    closest point information after this method is called

Returns:
    Whether this method successfully ran.)""";

          } ClosestPointsPairwise;

          // drake::multibody::collision::Model::CollidingPoints
          struct /* CollidingPoints */ {

            // drake/multibody/collision/model.h:202
            const char* doc =
R"""(Given a vector of points in the world coordinate frame, returns the
indices of those points that are within the provided
`collision_threshold` distance of any collision geometry in the model.

In other words, the index `i` is included in the returned vector of
indices iff a sphere of radius `collision_threshold`, located at
`input_points[i]` collides with any collision element in the model.

Parameter ``input_points``:
    The list of points to check for collisions against the model.

Parameter ``collision_threshold``:
    The radius of a control sphere around each point used to check for
    collisions with the model.

Returns:
    A vector with indexes in input_points of all those points that do
    collide with the model within the specified threshold.

See also:
    drake/matlab/systems/plants/test/collidingPointsTest.m for a
    MATLAB test.)""";

          } CollidingPoints;

          // drake::multibody::collision::Model::CollidingPointsCheckOnly
          struct /* CollidingPointsCheckOnly */ {

            // drake/multibody/collision/model.h:223
            const char* doc =
R"""(Given a vector of points in the world coordinate frame, reports if
_any_ of those points lie within a specified distance of any collision
geometry in the model.

In other words, this method tests if any of the spheres of radius
`collision_threshold` located at `input_points[i]` collides with any
part of the model. This method returns as soon as any of these spheres
collides with the model. Points are not checked against one another
but only against the existing model.

Parameter ``input_points``:
    The list of points to check for collisions against the model.

Parameter ``collision_threshold``:
    The radius of a control sphere around each point used to check for
    collisions with the model.

Returns:
    Whether any of the points positively checks for collision.)""";

          } CollidingPointsCheckOnly;

          // drake::multibody::collision::Model::CollisionDetectFromPoints
          struct /* CollisionDetectFromPoints */ {

            // drake/multibody/collision/model.h:176
            const char* doc =
R"""(Computes the closest distance from each point to any surface in the
collision model utilizing Bullet's collision detection code.

Parameter ``points``:
    An ordered list of `N` points represented column-wise by a `3 x N`
    Matrix.

Parameter ``use_margins``:
    A flag indicating whether to use the version of this model with
    collision margins.

Parameter ``closest_points``:
    A vector of `N` PointPair instances such that the i'th instance
    reports the query result for the i'th input point.)""";

          } CollisionDetectFromPoints;

          // drake::multibody::collision::Model::CollisionRaycast
          struct /* CollisionRaycast */ {

            // drake/multibody/collision/model.h:243
            const char* doc =
R"""(Performs a raycast intersection test (like a LIDAR / laser range
finder).

Parameter ``origin``:
    A 3 x N matrix where each column specifies the position of a ray's
    origin in the world coordinate frame. If `origin` has dimensions
    of 3 x 1, the same origin is used for all rays.

Parameter ``ray_endpoint``:
    A 3 x N matrix where each column specifies a second point on the
    corresponding ray.

Parameter ``use_margins``:
    A flag indicating whether or not to use the version of this model
    with collision margins.

Parameter ``distance``:
    The distance to the first collision, or -1 if no collision occurs.

Returns:
    Whether this method successfully ran.)""";

          } CollisionRaycast;

          // drake::multibody::collision::Model::ComputeMaximumDepthCollisionPoints
          struct /* ComputeMaximumDepthCollisionPoints */ {

            // drake/multibody/collision/model.h:128
            const char* doc =
R"""(Computes the point of closest approach between collision elements that
are in contact.

Parameter ``use_margins``:
    If `true` the model uses the representation with margins. If
    `false`, the representation without margins is used instead.

Parameter ``closest_points``:
    A reference to a vector of PointPair objects that contains the
    closest point information after this method is called.

Returns:
    Whether this method successfully ran.)""";

          } ComputeMaximumDepthCollisionPoints;

          // drake::multibody::collision::Model::DoAddElement
          struct /* DoAddElement */ {

            // drake/multibody/collision/model.h:272
            const char* doc =
R"""(Allows sub-classes to do additional processing on elements added to
the collision model. This is called each time Model::AddElement is
called.

Parameter ``element``:
    The element that has been added.

Throws:
    s std::runtime_error If there was a problem processing the
    element.)""";

          } DoAddElement;

          // drake::multibody::collision::Model::DoRemoveElement
          struct /* DoRemoveElement */ {

            // drake/multibody/collision/model.h:280
            const char* doc =
R"""(Allows sub-classes to do additional processing when elements are
removed from the collision model. This is called by
Model::RemoveElement() prior to removing id from elements. The derived
class should not do this removal.

Parameter ``id``:
    The id of the element that will be removed.)""";

          } DoRemoveElement;

          // drake::multibody::collision::Model::FindElement
          struct /* FindElement */ {

            // drake/multibody/collision/model.h:61
            const char* doc =
R"""(Gets a read-only pointer to a collision element in this model.

Parameter ``id``:
    An ElementId corresponding to the desired collision element

Returns:
    A read-only pointer to the collision element corresponding to the
    given `id` or `nullptr` if no such collision element is present in
    the model.)""";

          } FindElement;

          // drake::multibody::collision::Model::FindMutableElement
          struct /* FindMutableElement */ {

            // drake/multibody/collision/model.h:71
            const char* doc =
R"""(Gets a pointer to a mutable collision element in this model.

Parameter ``id``:
    An ElementId corresponding to the desired collision element.

Returns:
    A pointer to a mutable collision element corresponding to the
    given `id` or `nullptr` if no such collision element is present in
    the model.)""";

          } FindMutableElement;

          // drake::multibody::collision::Model::GetTerrainContactPoints
          struct /* GetTerrainContactPoints */ {

            // drake/multibody/collision/model.h:73
            const char* doc = R"""()""";

          } GetTerrainContactPoints;

          // drake::multibody::collision::Model::Model
          struct /* ctor */ {

            // drake/multibody/collision/model.h:23
            const char* doc = R"""()""";

            // drake/multibody/collision/model.h:23
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/model.h:25
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::multibody::collision::Model::NotifyFilterCriteriaChanged
          struct /* NotifyFilterCriteriaChanged */ {

            // drake/multibody/collision/model.h:81
            const char* doc =
R"""(Informs the model that the collision filter criteria for the given
`id` has changed (or *may* have changed -- it can be called
conservatively). The model has the opportunity to perform whatever is
necessary to respond.

Parameter ``id``:
    The id of the element whose filter criteria may have changed.)""";

          } NotifyFilterCriteriaChanged;

          // drake::multibody::collision::Model::RemoveElement
          struct /* RemoveElement */ {

            // drake/multibody/collision/model.h:52
            const char* doc =
R"""(Removes a collision element from this model.

Parameter ``id``:
    The id of the element that will be removed.

Returns:
    True if the element is successfully removed, false if the model
    does not contain an element with the given id.)""";

          } RemoveElement;

          // drake::multibody::collision::Model::TransformCollisionFrame
          struct /* TransformCollisionFrame */ {

            // drake/multibody/collision/model.h:258
            const char* doc =
R"""(Modifies a collision element's local transform to be relative to a
joint's frame rather than a link's frame. This is necessary because
Drake requires that link frames be defined by their parent joint
frames.

Parameter ``eid``:
    The ID of the collision element to update.

Parameter ``transform_body_to_joint``:
    The transform from the collision element's link's frame to the
    joint's coordinate frame.

Returns:
    Whether the collision element was successfully updated.)""";

          } TransformCollisionFrame;

          // drake::multibody::collision::Model::UpdateElementWorldTransform
          struct /* UpdateElementWorldTransform */ {

            // drake/multibody/collision/model.h:98
            const char* doc =
R"""(Updates the stored transformation from a collision element's canonical
space to world space (`X_WE`), where `X_WE = X_WL * X_LE`. `X_LE` is
the transform that maps the element to its parent body's space,
referred to as "local". `X_WL` maps the body/local space to the world.

Parameter ``id``:
    The ID of the element being updated.

Parameter ``X_WL``:
    The new value for the local-to-world transform. It reflects the
    current world pose of the parent body in a given context.

Returns:
    Whether the update was successful.)""";

          } UpdateElementWorldTransform;

          // drake::multibody::collision::Model::UpdateModel
          struct /* UpdateModel */ {

            // drake/multibody/collision/model.h:85
            const char* doc =
R"""(Updates the collision model. This method is typically called after
changes are made to its collision elements.)""";

          } UpdateModel;

          // drake::multibody::collision::Model::elements
          struct /* elements */ {

            // drake/multibody/collision/model.h:285
            const char* doc = R"""()""";

          } elements;

        } Model;

        // drake::multibody::collision::ModelType
        struct /* ModelType */ {

          // drake/multibody/collision/drake_collision.h:11
          const char* doc = R"""()""";

          // drake::multibody::collision::ModelType::kBullet
          struct /* kBullet */ {

            // drake/multibody/collision/drake_collision.h:17
            const char* doc = R"""()""";

          } kBullet;

          // drake::multibody::collision::ModelType::kFcl
          struct /* kFcl */ {

            // drake/multibody/collision/drake_collision.h:14
            const char* doc = R"""()""";

          } kFcl;

          // drake::multibody::collision::ModelType::kUnusable
          struct /* kUnusable */ {

            // drake/multibody/collision/drake_collision.h:12
            const char* doc = R"""()""";

          } kUnusable;

        } ModelType;

        // drake::multibody::collision::OverlapFilterCallback
        struct /* OverlapFilterCallback */ {

          // drake/multibody/collision/bullet_model.h:26
          const char* doc = R"""()""";

          // drake::multibody::collision::OverlapFilterCallback::needBroadphaseCollision
          struct /* needBroadphaseCollision */ {

            // drake/multibody/collision/bullet_model.h:28
            const char* doc = R"""()""";

          } needBroadphaseCollision;

          // drake::multibody::collision::OverlapFilterCallback::parent_model
          struct /* parent_model */ {

            // drake/multibody/collision/bullet_model.h:31
            const char* doc = R"""()""";

          } parent_model;

        } OverlapFilterCallback;

        // drake::multibody::collision::PointPair
        struct /* PointPair */ {

          // drake/multibody/collision/point_pair.h:14
          const char* doc =
R"""(Structure containing the results of a collision query. **/)""";

          // drake::multibody::collision::PointPair::PointPair<T>
          struct /* ctor */ {

            // drake/multibody/collision/point_pair.h:15
            const char* doc = R"""()""";

            // drake/multibody/collision/point_pair.h:17
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/point_pair.h:28
            const char* doc_3 = R"""(Scalar-converting copy constructor. **/)""";

          } ctor;

          // drake::multibody::collision::PointPair::distance
          struct /* distance */ {

            // drake/multibody/collision/point_pair.h:55
            const char* doc =
R"""(Distance between the point on body A and the point on body B. **/)""";

          } distance;

          // drake::multibody::collision::PointPair::elementA
          struct /* elementA */ {

            // drake/multibody/collision/point_pair.h:33
            const char* doc =
R"""(Element A in the pair participating in the collision. **/)""";

          } elementA;

          // drake::multibody::collision::PointPair::elementB
          struct /* elementB */ {

            // drake/multibody/collision/point_pair.h:36
            const char* doc =
R"""(Element B in the pair participating in the collision. **/)""";

          } elementB;

          // drake::multibody::collision::PointPair::idA
          struct /* idA */ {

            // drake/multibody/collision/point_pair.h:39
            const char* doc =
R"""(Id of element A participating in the collision. **/)""";

          } idA;

          // drake::multibody::collision::PointPair::idB
          struct /* idB */ {

            // drake/multibody/collision/point_pair.h:42
            const char* doc =
R"""(Id of element B participating in the collision. **/)""";

          } idB;

          // drake::multibody::collision::PointPair::normal
          struct /* normal */ {

            // drake/multibody/collision/point_pair.h:52
            const char* doc =
R"""(Outwards normal on body B. On body A it points in the opposite
direction.)""";

          } normal;

          // drake::multibody::collision::PointPair::ptA
          struct /* ptA */ {

            // drake/multibody/collision/point_pair.h:45
            const char* doc =
R"""(Collision point on the surface of body A. **/)""";

          } ptA;

          // drake::multibody::collision::PointPair::ptB
          struct /* ptB */ {

            // drake/multibody/collision/point_pair.h:48
            const char* doc =
R"""(Collision point on the surface of body B. **/)""";

          } ptB;

        } PointPair;

        // drake::multibody::collision::UnknownShapeException
        struct /* UnknownShapeException */ {

          // drake/multibody/collision/bullet_model.h:46
          const char* doc = R"""()""";

          // drake::multibody::collision::UnknownShapeException::UnknownShapeException
          struct /* ctor */ {

            // drake/multibody/collision/bullet_model.h:48
            const char* doc = R"""()""";

          } ctor;

        } UnknownShapeException;

        // drake::multibody::collision::UnusableModel
        struct /* UnusableModel */ {

          // drake/multibody/collision/unusable_model.h:15
          const char* doc =
R"""(An unusable model, used when no collision detection backend is
available.)""";

          // drake::multibody::collision::UnusableModel::ClearCachedResults
          struct /* ClearCachedResults */ {

            // drake/multibody/collision/unusable_model.h:43
            const char* doc = R"""()""";

          } ClearCachedResults;

          // drake::multibody::collision::UnusableModel::ClosestPointsAllToAll
          struct /* ClosestPointsAllToAll */ {

            // drake/multibody/collision/unusable_model.h:28
            const char* doc = R"""()""";

          } ClosestPointsAllToAll;

          // drake::multibody::collision::UnusableModel::ClosestPointsPairwise
          struct /* ClosestPointsPairwise */ {

            // drake/multibody/collision/unusable_model.h:35
            const char* doc = R"""()""";

          } ClosestPointsPairwise;

          // drake::multibody::collision::UnusableModel::CollidingPoints
          struct /* CollidingPoints */ {

            // drake/multibody/collision/unusable_model.h:54
            const char* doc = R"""()""";

          } CollidingPoints;

          // drake::multibody::collision::UnusableModel::CollidingPointsCheckOnly
          struct /* CollidingPointsCheckOnly */ {

            // drake/multibody/collision/unusable_model.h:50
            const char* doc = R"""()""";

          } CollidingPointsCheckOnly;

          // drake::multibody::collision::UnusableModel::CollisionDetectFromPoints
          struct /* CollisionDetectFromPoints */ {

            // drake/multibody/collision/unusable_model.h:39
            const char* doc = R"""()""";

          } CollisionDetectFromPoints;

          // drake::multibody::collision::UnusableModel::CollisionRaycast
          struct /* CollisionRaycast */ {

            // drake/multibody/collision/unusable_model.h:45
            const char* doc = R"""()""";

          } CollisionRaycast;

          // drake::multibody::collision::UnusableModel::ComputeMaximumDepthCollisionPoints
          struct /* ComputeMaximumDepthCollisionPoints */ {

            // drake/multibody/collision/unusable_model.h:32
            const char* doc = R"""()""";

          } ComputeMaximumDepthCollisionPoints;

          // drake::multibody::collision::UnusableModel::UnusableModel
          struct /* ctor */ {

            // drake/multibody/collision/unusable_model.h:17
            const char* doc = R"""()""";

            // drake/multibody/collision/unusable_model.h:17
            const char* doc_2 = R"""()""";

            // drake/multibody/collision/unusable_model.h:19
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::multibody::collision::UnusableModel::UpdateElementWorldTransform
          struct /* UpdateElementWorldTransform */ {

            // drake/multibody/collision/unusable_model.h:25
            const char* doc = R"""()""";

          } UpdateElementWorldTransform;

          // drake::multibody::collision::UnusableModel::UpdateModel
          struct /* UpdateModel */ {

            // drake/multibody/collision/unusable_model.h:23
            const char* doc = R"""()""";

          } UpdateModel;

        } UnusableModel;

        // drake::multibody::collision::newModel
        struct /* newModel */ {

          // drake/multibody/collision/drake_collision.h:24
          const char* doc = R"""()""";

        } newModel;

      } collision;

      // drake::multibody::default_model_instance
      struct /* default_model_instance */ {

        // drake/multibody/multibody_tree/model_instance.h:68
        const char* doc =
R"""(Returns the model instance which contains all tree elements with no
explicit model instance specified.)""";

      } default_model_instance;

      // joints
      struct /* joints */ {

        // drake::multibody::joints::FloatingBaseType
        struct /* FloatingBaseType */ {

          // drake/multibody/joints/floating_base_types.h:7
          const char* doc = R"""()""";

          // drake::multibody::joints::FloatingBaseType::kFixed
          struct /* kFixed */ {

            // drake/multibody/joints/floating_base_types.h:7
            const char* doc = R"""()""";

          } kFixed;

          // drake::multibody::joints::FloatingBaseType::kQuaternion
          struct /* kQuaternion */ {

            // drake/multibody/joints/floating_base_types.h:7
            const char* doc = R"""()""";

          } kQuaternion;

          // drake::multibody::joints::FloatingBaseType::kRollPitchYaw
          struct /* kRollPitchYaw */ {

            // drake/multibody/joints/floating_base_types.h:7
            const char* doc = R"""()""";

          } kRollPitchYaw;

        } FloatingBaseType;

      } joints;

      // multibody_plant
      struct /* multibody_plant */ {

        // drake::multibody::multibody_plant::CalcContactFrictionFromSurfaceProperties
        struct /* CalcContactFrictionFromSurfaceProperties */ {

          // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:127
          const char* doc =
R"""(Given the surface properties of two different surfaces, this method
computes the Coulomb's law coefficients of friction characterizing the
interaction by friction of the given surface pair. The surface
properties are specified by individual Coulomb's law coefficients of
friction. As outlined in the class's documentation for
CoulombFriction, friction coefficients characterize a surface pair and
not individual surfaces. However, we find it useful in practice to
associate the abstract __idea__ of friction coefficients to a single
surface. Please refer to the documentation for CoulombFriction for
details on this topic.

More specifically, this method computes the contact coefficients for
the given surface pair as:

```
μ = 2μₘμₙ/(μₘ + μₙ)
```

where the operation above is performed separately on the static and
dynamic friction coefficients.

Parameter ``surface_properties1``:
    Surface properties for surface 1. Specified as an individual set
    of Coulomb's law coefficients of friction.

Parameter ``surface_properties2``:
    Surface properties for surface 2. Specified as an individual set
    of Coulomb's law coefficients of friction.

Returns:
    the combined friction coefficients for the interacting surfaces.)""";

        } CalcContactFrictionFromSurfaceProperties;

        // drake::multibody::multibody_plant::ContactResults
        struct /* ContactResults */ {

          // drake/multibody/multibody_tree/multibody_plant/contact_results.h:24
          const char* doc =
R"""(A container class storing the contact results information for each
contact pair for a given state of the simulation.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

          // drake::multibody::multibody_plant::ContactResults::AddContactInfo
          struct /* AddContactInfo */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:40
            const char* doc =
R"""(Add a new contact pair result to the set of contact pairs stored by
`this` class.)""";

          } AddContactInfo;

          // drake::multibody::multibody_plant::ContactResults::Clear
          struct /* Clear */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:32
            const char* doc =
R"""(Clears the set of contact information for when the old data becomes
invalid.)""";

          } Clear;

          // drake::multibody::multibody_plant::ContactResults::ContactResults<T>
          struct /* ctor */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:26
            const char* doc = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:26
            const char* doc_2 = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:28
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::multibody::multibody_plant::ContactResults::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:26
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::multibody::multibody_plant::ContactResults::contact_info
          struct /* contact_info */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:44
            const char* doc =
R"""(Retrieves the ith PointPairContactInfo instance. The input index `i`
must be in the range [0, get_num_contacts() - 1] or this method
aborts.)""";

          } contact_info;

          // drake::multibody::multibody_plant::ContactResults::num_contacts
          struct /* num_contacts */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_results.h:36
            const char* doc =
R"""(Returns the number of unique collision element pairs in contact. */)""";

          } num_contacts;

        } ContactResults;

        // drake::multibody::multibody_plant::CoulombFriction
        struct /* CoulombFriction */ {

          // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:66
          const char* doc =
R"""(Parameters for Coulomb's Law of Friction, namely: - Static friction
coefficient, for a pair of surfaces at rest relative to each other. -
Dynamic (or kinematic) friction coefficient, for a pair of surfaces in
relative motion. These coefficients are an empirical property
characterizing the interaction by friction between a pair of
contacting surfaces. Friction coefficients depend upon the mechanical
properties of the surfaces' materials and on the roughness of the
surfaces. They are determined experimentally.

Even though the Coulomb's law coefficients of friction characterize a
pair of surfaces interacting by friction, we associate the abstract
__idea__ of friction coefficients to a single surface by considering
the coefficients for contact between two identical surfaces. For this
case of two identical surfaces, the friction coefficients that
describe the surface pair are taken to equal those of one of the
identical surfaces. We extend this idea to the case of different
surfaces by defining a __combination law__ that allow us to obtain the
Coulomb's law coefficients of friction characterizing the pair of
surfaces, given the individual friction coefficients of each surface.
We would like this __combination law__ to satisfy: - The friction
coefficient of two identical surfaces is the friction coefficient of
one of the surfaces. - The combination law is commutative. That is,
surface A combined with surface B gives the same results as surface B
combined with surface A. - For two surfaces M and N with very
different friction coefficients, say `μₘ ≪ μₙ`, the combined friction
coefficient should be in the order of magnitude of the smallest
friction coefficient (in the example μₘ). To understand this
requirement, consider rubber (high friction coefficient) sliding on
ice (low friction coefficient). We'd like the surface pair to be
defined by a friction coefficient close to that of ice, since rubber
will easily slide on ice. These requirements are met by the following
ad-hoc combination law:

```
μ = 2μₘμₙ/(μₘ + μₙ)
```

See CalcContactFrictionFromSurfaceProperties(), which implements this
law. More complex combination laws could also be a function of other
parameters such as the mechanical properties of the interacting
surfaces or even their roughnesses. For instance, if the the rubber
surface above has metal studs (somehow making the surface "rougher"),
it will definitely have a better grip on an ice surface. Therefore
this new variable should be taken into account in the combination law.
Notice that in this example, this new combination law model for tires,
will have a different set of requirements from the ones stated above.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

          // drake::multibody::multibody_plant::CoulombFriction::CoulombFriction<T>
          struct /* ctor */ {

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:68
            const char* doc = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:68
            const char* doc_2 = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:72
            const char* doc_3 =
R"""(Default constructor for a frictionless surface, i.e. with zero static
and dynamic coefficients of friction.)""";

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:78
            const char* doc_4 =
R"""(Specifies both the static and dynamic friction coefficients for a
given surface.

Throws:
    s std::logic_error if any of the friction coefficients are
    negative or if `dynamic_friction > static_friction` (they can be
    equal.))""";

          } ctor;

          // drake::multibody::multibody_plant::CoulombFriction::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:68
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::multibody::multibody_plant::CoulombFriction::dynamic_friction
          struct /* dynamic_friction */ {

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:84
            const char* doc =
R"""(Returns the coefficient of dynamic friction.)""";

          } dynamic_friction;

          // drake::multibody::multibody_plant::CoulombFriction::static_friction
          struct /* static_friction */ {

            // drake/multibody/multibody_tree/multibody_plant/coulomb_friction.h:81
            const char* doc =
R"""(Returns the coefficient of static friction.)""";

          } static_friction;

        } CoulombFriction;

        // drake::multibody::multibody_plant::MultibodyPlant
        struct /* MultibodyPlant */ {

          // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:188
          const char* doc =
R"""(Before any geometry registration takes place, a user **must** first
make a call to RegisterAsSourceForSceneGraph() in order to register
the MultibodyPlant as a client of a SceneGraph instance, point at
which the plant will have assigned a valid geometry::SourceId. At
Finalize(), MultibodyPlant will declare input/output ports as
appropriate to communicate with the SceneGraph instance on which
registrations took place. All geometry registration **must** be
performed pre-finalize.

If MultibodyPlant registers geometry with a SceneGraph via calls to
RegisterCollisionGeometry(), an input port for geometric queries will
be declared at Finalize() time, see get_geometry_query_input_port().
Users must connect this input port to the output port for geometric
queries of the SceneGraph used for registration, which can be obtained
with SceneGraph::get_query_output_port(). In summary, if
MultibodyPlant registers collision geometry, the setup process will
include: 1. Call to RegisterAsSourceForSceneGraph(). 2. Calls to
RegisterCollisionGeometry(), as many as needed. 3. Call to Finalize(),
user is done specifying the model. 4. Connect
SceneGraph::get_query_output_port() to
get_geometry_query_input_port(). Refer to the documentation provided
in each of the methods above for further details.

@section Finalize() stage

Once the user is done adding modeling elements and registering
geometry, a call to Finalize() must be performed. This call will: -
Build the underlying MultibodyTree topology, see
MultibodyTree::Finalize() for details, - declare the plant's state, -
declare the plant's input and output ports, - declare input and output
ports for communication with a SceneGraph. @cond TODO(amcastro-tri):
Consider making the actual geometry registration with GS AFTER
Finalize() so that we can tell if there are any bodies welded to the
world to which we could just assign anchored geometry instead of
dynamic geometry. This is an optimization and the API, and pre/post-
finalize conditions should not change. @endcond

<h3> References </h3> - [Featherstone 2008] Featherstone, R., 2008.
Rigid body dynamics algorithms. Springer. - [Jain 2010] Jain, A.,
2010. Robot and multibody dynamics: analysis and algorithms. Springer
Science & Business Media. - [Seth 2010] Seth, A., Sherman, M.,
Eastman, P. and Delp, S., 2010. Minimal formulation of joint motion
for biomechanisms. Nonlinear dynamics, 62(1), pp.291-303.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

          // drake::multibody::multibody_plant::MultibodyPlant::AddForceElement
          struct /* AddForceElement */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:508
            const char* doc =
R"""(Adds a new force element model of type `ForceElementType` to `this`
MultibodyPlant. The arguments to this method `args` are forwarded to
`ForceElementType`'s constructor.

Parameter ``args``:
    Zero or more parameters provided to the constructor of the new
    force element. It must be the case that `JointType<T>(args)` is a
    valid constructor.

Template parameter ``ForceElementType``:
    The type of the ForceElement to add. This method can only be
    called once for elements of type UniformGravityFieldElement. That
    is, gravity can only be specified once.

Returns:
    A constant reference to the new ForceElement just added, of type
    `ForceElementType<T>` specialized on the scalar type T of `this`
    MultibodyPlant. It will remain valid for the lifetime of `this`
    MultibodyPlant.

See also:
    The ForceElement class's documentation for further details on how
    a force element is defined.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:520
            const char* doc_2 = R"""()""";

          } AddForceElement;

          // drake::multibody::multibody_plant::MultibodyPlant::AddFrame
          struct /* AddFrame */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:389
            const char* doc =
R"""(This method adds a Frame of type `FrameType<T>`. For more information,
please see the corresponding constructor of `FrameType`.

Template parameter ``FrameType``:
    Template which will be instantiated on `T`.

Parameter ``frame``:
    Unique pointer frame instance.

Returns:
    A constant reference to the new Frame just added, which will
    remain valid for the lifetime of `this` MultibodyPlant.)""";

          } AddFrame;

          // drake::multibody::multibody_plant::MultibodyPlant::AddJoint
          struct /* AddJoint */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:397
            const char* doc =
R"""(This method adds a Joint of type `JointType` between two bodies. For
more information, see the below overload of `AddJoint<>`, and the
related `MultibodyTree::AddJoint<>` method.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:474
            const char* doc_2 =
R"""(This method adds a Joint of type `JointType` between two bodies. The
two bodies connected by this Joint object are referred to as the
_parent_ and _child_ bodies. Although the terms _parent_ and _child_
are sometimes used synonymously to describe the relationship between
inboard and outboard bodies in multibody models, this usage is wholly
unrelated and implies nothing about the inboard-outboard relationship
between the bodies. As explained in the Joint class's documentation,
in Drake we define a frame F attached to the parent body P with pose
`X_PF` and a frame M attached to the child body B with pose `X_BM`.
This method helps creating a joint between two bodies with fixed poses
`X_PF` and `X_BM`. Refer to the Joint class's documentation for more
details.

Parameter ``name``:
    A string that uniquely identifies the new joint to be added to
    `this` model. A std::runtime_error is thrown if a joint named
    `name` already is part of the model. See HasJointNamed(),
    Joint::name().

Parameter ``parent``:
    The parent body connected by the new joint.

Parameter ``X_PF``:
    The fixed pose of frame F attached to the parent body, measured in
    the frame P of that body. `X_PF` is an optional parameter; empty
    curly braces `{}` imply that frame F **is** the same body frame P.
    If instead your intention is to make a frame F with pose `X_PF`
    equal to the identity pose, provide
    `Isometry3<double>::Identity()` as your input.

Parameter ``child``:
    The child body connected by the new joint.

Parameter ``X_BM``:
    The fixed pose of frame M attached to the child body, measured in
    the frame B of that body. `X_BM` is an optional parameter; empty
    curly braces `{}` imply that frame M **is** the same body frame B.
    If instead your intention is to make a frame M with pose `X_BM`
    equal to the identity pose, provide
    `Isometry3<double>::Identity()` as your input.

Parameter ``args``:
    Zero or more parameters provided to the constructor of the new
    joint. It must be the case that `JointType<T>( const std::string&,
    const Frame<T>&, const Frame<T>&, args)` is a valid constructor.

Template parameter ``JointType``:
    The type of the Joint to add.

Returns:
    A constant reference to the new joint just added, of type
    `JointType<T>` specialized on the scalar type T of `this`
    MultibodyPlant. It will remain valid for the lifetime of `this`
    MultibodyPlant.

Example of usage:

```
MultibodyPlant<T> plant;
   // Code to define bodies serving as the joint's parent and child bodies.
   const RigidBody<double>& body_1 =
     plant.AddRigidBody("Body1", SpatialInertia<double>(...));
   const RigidBody<double>& body_2 =
     plant.AddRigidBody("Body2", SpatialInertia<double>(...));
   // Body 1 serves as parent, Body 2 serves as child.
   // Define the pose X_BM of a frame M rigidly atached to child body B.
   const RevoluteJoint<double>& elbow =
     plant.AddJoint<RevoluteJoint>(
///       "Elbow",                /* joint name 
///       body_1,                 /* parent body 
///       {},                     /* frame F IS the parent body frame P 
///       body_2,                 /* child body, the pendulum 
///       X_BM,                   /* pose of frame M in the body frame B 
///       Vector3d::UnitZ());     /* revolute axis in this case
```

Throws:
    s if `this` MultibodyPlant already contains a joint with the given
    `name`. See HasJointNamed(), Joint::name().

See also:
    The Joint class's documentation for further details on how a Joint
    is defined.)""";

          } AddJoint;

          // drake::multibody::multibody_plant::MultibodyPlant::AddJointActuator
          struct /* AddJointActuator */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:546
            const char* doc =
R"""(Creates and adds a JointActuator model for an actuator acting on a
given `joint`. This method returns a constant reference to the
actuator just added, which will remain valid for the lifetime of
`this` plant.

Parameter ``name``:
    A string that uniquely identifies the new actuator to be added to
    `this` model. A std::runtime_error is thrown if an actuator with
    the same name already exists in the model. See
    HasJointActuatorNamed().

Parameter ``joint``:
    The Joint to be actuated by the new JointActuator.

Returns:
    A constant reference to the new JointActuator just added, which
    will remain valid for the lifetime of `this` plant.

Throws:
    s if `joint.num_velocities() > 1` since for now we only support
    actuators for single dof joints.)""";

          } AddJointActuator;

          // drake::multibody::multibody_plant::MultibodyPlant::AddModelInstance
          struct /* AddModelInstance */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:559
            const char* doc =
R"""(Creates a new model instance. Returns the index for the model
instance.

Parameter ``name``:
    A string that uniquely identifies the new instance to be added to
    `this` model. An exception is thrown if an instance with the same
    name already exists in the model. See HasModelInstanceNamed().)""";

          } AddModelInstance;

          // drake::multibody::multibody_plant::MultibodyPlant::AddRigidBody
          struct /* AddRigidBody */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:326
            const char* doc =
R"""(Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of `this` MultibodyPlant.

Example of usage:

```
MultibodyPlant<T> plant;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  ModelInstanceIndex model_instance = plant.AddModelInstance("instance");
  const RigidBody<T>& body =
    plant.AddRigidBody("BodyName", model_instance, spatial_inertia);
```

Parameter ``name``:
    A string that identifies the new body to be added to `this` model.
    A std::runtime_error is thrown if a body named `name` already is
    part of ``model_instance``. See HasBodyNamed(), Body::name().

Parameter ``model_instance``:
    A model instance index which this body is part of.

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to `this`
    MultibodyPlant, computed about the body frame origin `Bo` and
    expressed in the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of `this` MultibodyPlant.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:371
            const char* doc_2 =
R"""(Creates a rigid body with the provided name and spatial inertia. This
method returns a constant reference to the body just added, which will
remain valid for the lifetime of `this` MultibodyPlant. The body will
use the default model instance (model_instance "more on model
instances").

Example of usage:

```
MultibodyPlant<T> plant;
  // ... Code to define spatial_inertia, a SpatialInertia<T> object ...
  const RigidBody<T>& body =
    plant.AddRigidBody("BodyName", spatial_inertia);
```

Parameter ``name``:
    A string that identifies the new body to be added to `this` model.
    A std::runtime_error is thrown if a body named `name` already is
    part of the model in the default model instance. See
    HasBodyNamed(), Body::name().

Parameter ``M_BBo_B``:
    The SpatialInertia of the new rigid body to be added to `this`
    MultibodyPlant, computed about the body frame origin `Bo` and
    expressed in the body frame B.

Returns:
    A constant reference to the new RigidBody just added, which will
    remain valid for the lifetime of `this` MultibodyPlant.

Throws:
    s std::logic_error if additional model instances have been created
    beyond the world and default instances.)""";

          } AddRigidBody;

          // drake::multibody::multibody_plant::MultibodyPlant::CollectRegisteredGeometries
          struct /* CollectRegisteredGeometries */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:936
            const char* doc =
R"""(For each of the provided `bodies`, collects up all geometries that
have been registered to that body. Intended to be used in conjunction
with SceneGraph::ExcludeCollisionsWithin() and
SceneGraph::ExcludeCollisionsBetween() to filter collisions between
the geometries registered to the bodies.

For example:

```
// Don't report on collisions between geometries affixed to `body1`,
// `body2`, or `body3`.
std::vector<const RigidBody<T>*> bodies{&body1, &body2, &body3};
geometry::GeometrySet set = plant.CollectRegisteredGeometries(bodies);
scene_graph.ExcludeCollisionsWithin(set);
```

Note: There is a *very* specific order of operations. 1. Bodies and
geometries must be added to the MultibodyPlant. 2. The MultibodyPlant
must be finalized (via Finalize()). 3. Create GeometrySet instances
from bodies (via this method). 4. Invoke
SceneGraph::ExcludeCollisions*() to filter collisions. 5. Allocate
context. Changing the order will cause exceptions to be thrown.

Throws:
    s RuntimeError if called pre-finalize.)""";

          } CollectRegisteredGeometries;

          // drake::multibody::multibody_plant::MultibodyPlant::Finalize
          struct /* Finalize */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1163
            const char* doc =
R"""(This method must be called after all elements in the model (joints,
bodies, force elements, constraints, etc.) are added and before any
computations are performed. It essentially compiles all the necessary
"topological information", i.e. how bodies, joints and, any other
elements connect with each other, and performs all the required pre-
processing to enable computations at a later stage.

If the finalize stage is successful, the topology of this
MultibodyPlant is valid, meaning that the topology is up-to-date after
this call. No more multibody elements can be added after a call to
Finalize().

At Finalize(), state and input/output ports for `this` plant are
declared. If `this` plant registered geometry with a SceneGraph, input
and output ports to enable communication with that SceneGraph are
declared as well.

If geometry has been registered on a SceneGraph instance, that
instance must be provided to the Finalize() method so that any
geometric implications of the finalization process can be
appropriately handled.

See also:
    is_finalized().

Throws:
    s std::logic_error if 1. the MultibodyPlant has already been
    finalized, 2. `scene_graph` isn't provided when required, or 3. a
    different scene_graph instance is provided than the one for which
    this plant is a geometry source.)""";

          } Finalize;

          // drake::multibody::multibody_plant::MultibodyPlant::GetBodyByName
          struct /* GetBodyByName */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:670
            const char* doc =
R"""(Returns a constant reference to a body that is identified by the
string `name` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no body with the requested name.

Throws:
    s std::logic_error if the body name occurs in multiple model
    instances.

See also:
    HasBodyNamed() to query if there exists a body in `this`
    MultibodyPlant with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:679
            const char* doc_2 =
R"""(Returns a constant reference to the body that is uniquely identified
by the string `name` and ``model_instance`` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no body with the requested name.

See also:
    HasBodyNamed() to query if there exists a body in `this`
    MultibodyPlant with a given specified name.)""";

          } GetBodyByName;

          // drake::multibody::multibody_plant::MultibodyPlant::GetBodyFrameIdIfExists
          struct /* GetBodyFrameIdIfExists */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1001
            const char* doc =
R"""(If the body with `body_index` has geometry registered with it, it
returns the geometry::FrameId associated with it. Otherwise, it
returns nullopt.

Throws:
    s if called pre-finalize.)""";

          } GetBodyFrameIdIfExists;

          // drake::multibody::multibody_plant::MultibodyPlant::GetBodyFrameIdOrThrow
          struct /* GetBodyFrameIdOrThrow */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1017
            const char* doc =
R"""(If the body with `body_index` has geometry registered with it, it
returns the geometry::FrameId associated with it. Otherwise this
method throws an exception.

Throws:
    s if no geometry has been registered with the body indicated by
    `body_index`.

Throws:
    s if called pre-finalize.)""";

          } GetBodyFrameIdOrThrow;

          // drake::multibody::multibody_plant::MultibodyPlant::GetCollisionGeometriesForBody
          struct /* GetCollisionGeometriesForBody */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:901
            const char* doc =
R"""(Returns an array of GeometryId's identifying the different contact
geometries for `body` previously registered with a SceneGraph.

Note:
    This method can be called at any time during the lifetime of
    `this` plant, either pre- or post-finalize, see Finalize(). Post-
    finalize calls will always return the same value.

See also:
    RegisterCollisionGeometry(), Finalize())""";

          } GetCollisionGeometriesForBody;

          // drake::multibody::multibody_plant::MultibodyPlant::GetFrameByName
          struct /* GetFrameByName */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:691
            const char* doc =
R"""(Returns a constant reference to a frame that is identified by the
string `name` in `this` model.

Throws:
    s std::logic_error if there is no frame with the requested name.

Throws:
    s std::logic_error if the frame name occurs in multiple model
    instances.

See also:
    HasFrameNamed() to query if there exists a frame in `this` model
    with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:702
            const char* doc_2 =
R"""(Returns a constant reference to the frame that is uniquely identified
by the string `name` in ``model_instance``.

Throws:
    s std::logic_error if there is no frame with the requested name.

Throws:
    s std::runtime_error if ``model_instance`` is not valid for this
    model.

See also:
    HasFrameNamed() to query if there exists a frame in `this` model
    with a given specified name.)""";

          } GetFrameByName;

          // drake::multibody::multibody_plant::MultibodyPlant::GetJointActuatorByName
          struct /* GetJointActuatorByName */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:768
            const char* doc =
R"""(Returns a constant reference to an actuator that is identified by the
string `name` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no actuator with the requested
    name.

Throws:
    s std::logic_error if the actuator name occurs in multiple model
    instances.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    `this` MultibodyPlant with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:779
            const char* doc_2 =
R"""(Returns a constant reference to the actuator that is uniquely
identified by the string `name` and ``model_instance`` in `this`
MultibodyPlant.

Throws:
    s std::logic_error if there is no actuator with the requested
    name.

Throws:
    s if ``model_instance`` is not valid for this model.

See also:
    HasJointActuatorNamed() to query if there exists an actuator in
    `this` MultibodyPlant with a given specified name.)""";

          } GetJointActuatorByName;

          // drake::multibody::multibody_plant::MultibodyPlant::GetJointByName
          struct /* GetJointByName */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:714
            const char* doc =
R"""(Returns a constant reference to a joint that is identified by the
string `name` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no joint with the requested name.

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.

See also:
    HasJointNamed() to query if there exists a joint in `this`
    MultibodyPlant with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:724
            const char* doc_2 =
R"""(Returns a constant reference to the joint that is uniquely identified
by the string `name` and ``model_instance`` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no joint with the requested name.

Throws:
    s if ``model_instance`` is not valid for this model.

See also:
    HasJointNamed() to query if there exists a joint in `this`
    MultibodyPlant with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:741
            const char* doc_3 =
R"""(A templated version of GetJointByName() to return a constant reference
of the specified type `JointType` in place of the base Joint class.
See GetJointByName() for details.

Template parameter ``JointType``:
    The specific type of the Joint to be retrieved. It must be a
    subclass of Joint.

Throws:
    s std::logic_error if the named joint is not of type `JointType`
    or if there is no Joint with that name.

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.

See also:
    HasJointNamed() to query if there exists a joint in `this`
    MultibodyPlant with a given specified name.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:756
            const char* doc_4 =
R"""(A templated version of GetJointByName() to return a constant reference
of the specified type `JointType` in place of the base Joint class.
See GetJointByName() for details.

Template parameter ``JointType``:
    The specific type of the Joint to be retrieved. It must be a
    subclass of Joint.

Throws:
    s std::logic_error if the named joint is not of type `JointType`
    or if there is no Joint with that name.

Throws:
    s if ``model_instance`` is not valid for this model.

See also:
    HasJointNamed() to query if there exists a joint in `this`
    MultibodyPlant with a given specified name.)""";

          } GetJointByName;

          // drake::multibody::multibody_plant::MultibodyPlant::GetModelInstanceByName
          struct /* GetModelInstanceByName */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:789
            const char* doc =
R"""(Returns the index to the model instance that is uniquely identified by
the string `name` in `this` MultibodyPlant.

Throws:
    s std::logic_error if there is no instance with the requested
    name.

See also:
    HasModelInstanceNamed() to query if there exists an instance in
    `this` MultibodyPlant with a given specified name.)""";

          } GetModelInstanceByName;

          // drake::multibody::multibody_plant::MultibodyPlant::GetVisualGeometriesForBody
          struct /* GetVisualGeometriesForBody */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:855
            const char* doc =
R"""(Returns an array of GeometryId's identifying the different visual
geometries for `body` previously registered with a SceneGraph.

Note:
    This method can be called at any time during the lifetime of
    `this` plant, either pre- or post-finalize, see Finalize(). Post-
    finalize calls will always return the same value.

See also:
    RegisterVisualGeometry(), Finalize())""";

          } GetVisualGeometriesForBody;

          // drake::multibody::multibody_plant::MultibodyPlant::HasBodyNamed
          struct /* HasBodyNamed */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:587
            const char* doc =
R"""(Returns:
    `true` if a body named `name` was added to the MultibodyPlant.

See also:
    AddRigidBody().

Throws:
    s std::logic_error if the body name occurs in multiple model
    instances.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:596
            const char* doc_2 =
R"""(Returns:
    `true` if a body named `name` was added to the MultibodyPlant in
    ``model_instance``.

See also:
    AddRigidBody().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

          } HasBodyNamed;

          // drake::multibody::multibody_plant::MultibodyPlant::HasJointActuatorNamed
          struct /* HasJointActuatorNamed */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:626
            const char* doc =
R"""(Returns:
    `true` if an actuator named `name` was added to the
    MultibodyPlant.

See also:
    AddJointActuator().

Throws:
    s std::logic_error if the actuator name occurs in multiple model
    instances.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:635
            const char* doc_2 =
R"""(Returns:
    `true` if an actuator named `name` was added to the MultibodyPlant
    in ``model_instance``.

See also:
    AddJointActuator().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

          } HasJointActuatorNamed;

          // drake::multibody::multibody_plant::MultibodyPlant::HasJointNamed
          struct /* HasJointNamed */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:606
            const char* doc =
R"""(Returns:
    `true` if a joint named `name` was added to the MultibodyPlant.

See also:
    AddJoint().

Throws:
    s std::logic_error if the joint name occurs in multiple model
    instances.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:615
            const char* doc_2 =
R"""(Returns:
    `true` if a joint named `name` was added to the MultibodyPlant in
    ``model_instance``.

See also:
    AddJoint().

Throws:
    s if ``model_instance`` is not valid for this model.)""";

          } HasJointNamed;

          // drake::multibody::multibody_plant::MultibodyPlant::HasModelInstanceNamed
          struct /* HasModelInstanceNamed */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:643
            const char* doc =
R"""(Returns:
    `true` if a model instance named `name` was added to the
    MultibodyPlant.

See also:
    AddModelInstance().)""";

          } HasModelInstanceNamed;

          // drake::multibody::multibody_plant::MultibodyPlant::MultibodyPlant<T>
          struct /* ctor */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:190
            const char* doc = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:190
            const char* doc_2 = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:199
            const char* doc_3 =
R"""(Default constructor creates a plant with a single "world" body.
Therefore, right after creation, num_bodies() returns one.

Parameter ``time_step``:
    An optional parameter indicating whether `this` plant is modeled
    as a continuous system (`time_step = 0`) or as a discrete system
    with periodic updates of period `time_step > 0`. @default 0.0.

Throws:
    s RuntimeError if `time_step` is negative.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:203
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::multibody::multibody_plant::MultibodyPlant::RegisterAsSourceForSceneGraph
          struct /* RegisterAsSourceForSceneGraph */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:810
            const char* doc =
R"""(Registers `this` plant to serve as a source for an instance of
SceneGraph. This registration allows MultibodyPlant to register
geometry with `scene_graph` for visualization and/or collision
queries. Successive registration calls with SceneGraph **must** be
performed on the same instance to which the pointer argument
`scene_graph` points to. Failure to do so will result in runtime
exceptions.

Parameter ``scene_graph``:
    A valid non nullptr to the SceneGraph instance for which `this`
    plant will sever as a source, see SceneGraph documentation for
    further details.

Returns:
    the SourceId of `this` plant in `scene_graph`. It can also later
    on be retrieved with get_source_id().

Throws:
    s if called post-finalize.

Throws:
    s if `scene_graph` is the nullptr.

Throws:
    s if called more than once.)""";

          } RegisterAsSourceForSceneGraph;

          // drake::multibody::multibody_plant::MultibodyPlant::RegisterCollisionGeometry
          struct /* RegisterCollisionGeometry */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:889
            const char* doc =
R"""(Registers geometry in a SceneGraph with a given geometry::Shape to be
used for the contact modeling of a given `body`. More than one
geometry can be registered with a body, in which case the body's
contact geometry is the union of all geometries registered to that
body.

Parameter ``body``:
    The body for which geometry is being registered.

Parameter ``X_BG``:
    The fixed pose of the geometry frame G in the body frame B.

Parameter ``shape``:
    The geometry::Shape used for visualization. E.g.:
    geometry::Sphere, geometry::Cylinder, etc.

Parameter ``coulomb_friction``:
    Coulomb's law of friction coefficients to model friction on the
    surface of `shape` for the given `body`.

Parameter ``scene_graph``:
    A valid, non-null pointer to a SceneGraph on which geometry will
    get registered.

Throws:
    s RuntimeError if `scene_graph` is the nullptr.

Throws:
    s RuntimeError if called post-finalize.

Throws:
    s RuntimeError if `scene_graph` does not correspond to the same
    instance with which RegisterAsSourceForSceneGraph() was called.)""";

          } RegisterCollisionGeometry;

          // drake::multibody::multibody_plant::MultibodyPlant::RegisterVisualGeometry
          struct /* RegisterVisualGeometry */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:836
            const char* doc =
R"""(Registers geometry in a SceneGraph with a given geometry::Shape to be
used for visualization of a given `body`.

Parameter ``body``:
    The body for which geometry is being registered.

Parameter ``X_BG``:
    The fixed pose of the geometry frame G in the body frame B.

Parameter ``shape``:
    The geometry::Shape used for visualization. E.g.:
    geometry::Sphere, geometry::Cylinder, etc.

Parameter ``name``:
    The name for the geometry. It must satsify the requirements
    defined in drake::geometry::GeometryInstance.

Parameter ``material``:
    The visual material to assign to the geometry.

Parameter ``scene_graph``:
    A valid non nullptr to a SceneGraph on which geometry will get
    registered.

Throws:
    s if `scene_graph` is the nullptr.

Throws:
    s if called post-finalize.

Throws:
    s if `scene_graph` does not correspond to the same instance with
    which RegisterAsSourceForSceneGraph() was called.

Returns:
    the id for the registered geometry.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:844
            const char* doc_2 =
R"""(Overload for visual geometry registration; it implicitly assigns the
default material.)""";

          } RegisterVisualGeometry;

          // drake::multibody::multibody_plant::MultibodyPlant::SetDefaultState
          struct /* SetDefaultState */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1324
            const char* doc =
R"""(Sets the state in `context` so that generalized positions and
velocities are zero.

Throws:
    s if called pre-finalize. See Finalize().)""";

          } SetDefaultState;

          // drake::multibody::multibody_plant::MultibodyPlant::WeldFrames
          struct /* WeldFrames */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:568
            const char* doc =
R"""(Welds frames A and B with relative pose `X_AB`. That is, the pose of
frame B in frame A is fixed, with value `X_AB`. The call to this
method creates and adds a new WeldJoint to the model. The new
WeldJoint is named as: A.name() + "_welds_to_" + B.name().

Returns:
    a constant reference to the WeldJoint welding frames A and B.)""";

          } WeldFrames;

          // drake::multibody::multibody_plant::MultibodyPlant::default_coulomb_friction
          struct /* default_coulomb_friction */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:948
            const char* doc =
R"""(Returns the friction coefficients provided during geometry
registration for the given geometry `id`. We call these the "default"
coefficients but note that we mean user-supplied per-geometry default,
not something more global.

Throws:
    s RuntimeError if `id` does not correspond to a geometry in `this`
    model registered for contact modeling.

See also:
    RegisterCollisionGeometry() for details on geometry registration.)""";

          } default_coulomb_friction;

          // drake::multibody::multibody_plant::MultibodyPlant::geometry_source_is_registered
          struct /* geometry_source_is_registered */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:994
            const char* doc =
R"""(Returns `true` if `this` MultibodyPlant was registered with a
SceneGraph. This method can be called at any time during the lifetime
of `this` plant to query if `this` plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize().)""";

          } geometry_source_is_registered;

          // drake::multibody::multibody_plant::MultibodyPlant::get_actuation_input_port
          struct /* get_actuation_input_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1044
            const char* doc =
R"""(Returns a constant reference to the input port for external actuation
for the case where only one model instance has actuated dofs. This
input port is a vector valued port, which can be set with
JointActuator::set_actuation_vector(). @pre Finalize() was already
called on `this` plant.

Throws:
    s if called before Finalize(), if the model does not contain any
    actuators, or if multiple model instances have actuated dofs.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1053
            const char* doc_2 =
R"""(Returns a constant reference to the input port for external actuation
for a specific model instance. This input port is a vector valued
port, which can be set with JointActuator::set_actuation_vector().
@pre Finalize() was already called on `this` plant.

Throws:
    s if called before Finalize() or if the model instance does not
    contain any actuators.

Throws:
    s if the model instance does not exist.)""";

          } get_actuation_input_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_contact_penalty_method_time_scale
          struct /* get_contact_penalty_method_time_scale */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1281
            const char* doc =
R"""(Returns a time-scale estimate `tc` based on the requested penetration
allowance δ set with set_penetration_allowance(). For the penalty
method in use to enforce non-penetration, this time scale relates to
the time it takes the relative normal velocity between two bodies to
go to zero. This time scale `tc` is artificially introduced by the
penalty method and goes to zero in the limit to ideal rigid contact.
Since numerical integration methods for continuum systems must be able
to resolve a system's dynamics, the time step used by an integrator
must in general be much smaller than the time scale `tc`. How much
smaller will depend on the details of the problem and the convergence
characteristics of the integrator and should be tuned appropriately.
Another factor to take into account for setting up the simulation's
time step is the speed of the objects in your simulation. If `vn`
represents a reference velocity scale for the normal relative velocity
between bodies, the new time scale `tn = δ / vn` represents the time
it would take for the distance between two bodies approaching with
relative normal velocity `vn` to decrease by the penetration_allowance
δ. In this case a user should choose a time step for simulation that
can resolve the smallest of the two time scales `tc` and `tn`.)""";

          } get_contact_penalty_method_time_scale;

          // drake::multibody::multibody_plant::MultibodyPlant::get_contact_results_output_port
          struct /* get_contact_results_output_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1101
            const char* doc =
R"""(Returns a constant reference to the port that outputs ContactResults.

Throws:
    s RuntimeError if `this` plant is not modeled as a discrete system
    with periodic updates.

Throws:
    s RuntimeError if called pre-finalize, see Finalize().)""";

          } get_contact_results_output_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_continuous_state_output_port
          struct /* get_continuous_state_output_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1068
            const char* doc =
R"""(Returns a constant reference to the output port for the full
continuous state of the model. @pre Finalize() was already called on
`this` plant.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1076
            const char* doc_2 =
R"""(Returns a constant reference to the output port for the continuous
state of a specific model instance. @pre Finalize() was already called
on `this` plant.

Throws:
    s if called before Finalize() or if the model instance does not
    have any state.

Throws:
    s if the model instance does not exist.)""";

          } get_continuous_state_output_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_generalized_contact_forces_output_port
          struct /* get_generalized_contact_forces_output_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1092
            const char* doc =
R"""(Returns a constant reference to the output port of generalized contact
forces for a specific model instance. This output port is only
available when modeling the plant as a discrete system with periodic
updates, see is_discrete().

@pre Finalize() was already called on `this` plant.

Throws:
    s RuntimeError if `this` plant is not modeled as a discrete system
    with periodic updates.

Throws:
    s RuntimeError if called before Finalize() or if the model
    instance does not have any generalized velocities.

Throws:
    s RuntimeError if the model instance does not exist.)""";

          } get_generalized_contact_forces_output_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_geometry_poses_output_port
          struct /* get_geometry_poses_output_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:986
            const char* doc =
R"""(Returns the output port of frames' poses to communicate with a
SceneGraph.

Throws:
    s RuntimeError if this system was not registered with a
    SceneGraph.

Throws:
    s RuntimeError if called pre-finalize. See Finalize().)""";

          } get_geometry_poses_output_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_geometry_query_input_port
          struct /* get_geometry_query_input_port */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:979
            const char* doc =
R"""(Returns a constant reference to the input port used to perform
geometric queries on a SceneGraph. See
SceneGraph::get_query_output_port(). Refer to section
geometry_registration of this class's documentation for further
details on collision geometry registration and connection with a
SceneGraph.

Throws:
    s RuntimeError if this system was not registered with a
    SceneGraph.

Throws:
    s RuntimeError if called pre-finalize. See Finalize().)""";

          } get_geometry_query_input_port;

          // drake::multibody::multibody_plant::MultibodyPlant::get_source_id
          struct /* get_source_id */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:967
            const char* doc =
R"""(Returns the unique id identifying `this` plant as a source for a
SceneGraph. Returns `nullopt` if `this` plant did not register any
geometry. This method can be called at any time during the lifetime of
`this` plant to query if `this` plant has been registered with a
SceneGraph, either pre- or post-finalize, see Finalize(). However, a
geometry::SourceId is only assigned once at the first call of any of
this plant's geometry registration methods, and it does not change
after that. Post-finalize calls will always return the same value.)""";

          } get_source_id;

          // drake::multibody::multibody_plant::MultibodyPlant::is_discrete
          struct /* is_discrete */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1168
            const char* doc =
R"""(Returns `true` if this plant is modeled as a discrete system. This
property of the plant is specified at construction and therefore this
query can be performed either pre- or post- finalize, see Finalize().)""";

          } is_discrete;

          // drake::multibody::multibody_plant::MultibodyPlant::is_finalized
          struct /* is_finalized */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1133
            const char* doc =
R"""(Returns `true` if this MultibodyPlant was finalized with a call to
Finalize().

See also:
    Finalize().)""";

          } is_finalized;

          // drake::multibody::multibody_plant::MultibodyPlant::model
          struct /* model */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1117
            const char* doc =
R"""(Returns a constant reference to the underlying MultibodyTree model for
`this` plant.

Throws:
    s if called pre-finalize. See Finalize().)""";

          } model;

          // drake::multibody::multibody_plant::MultibodyPlant::num_actuated_dofs
          struct /* num_actuated_dofs */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:281
            const char* doc =
R"""(Returns the total number of actuated degrees of freedom. That is, the
vector of actuation values u has this size. See AddJointActuator().)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:286
            const char* doc_2 =
R"""(Returns the total number of actuated degrees of freedom for a specific
model instance. That is, the vector of actuation values u has this
size. See AddJointActuator().)""";

          } num_actuated_dofs;

          // drake::multibody::multibody_plant::MultibodyPlant::num_actuators
          struct /* num_actuators */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:239
            const char* doc =
R"""(Returns the number of joint actuators in the model.

See also:
    AddJointActuator().)""";

          } num_actuators;

          // drake::multibody::multibody_plant::MultibodyPlant::num_bodies
          struct /* num_bodies */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:227
            const char* doc =
R"""(Returns the number of bodies in the model, including the "world" body,
which is always part of the model.

See also:
    AddRigidBody().)""";

          } num_bodies;

          // drake::multibody::multibody_plant::MultibodyPlant::num_collision_geometries
          struct /* num_collision_geometries */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:908
            const char* doc =
R"""(Returns the number of geometries registered for contact modeling. This
method can be called at any time during the lifetime of `this` plant,
either pre- or post-finalize, see Finalize(). Post-finalize calls will
always return the same value.)""";

          } num_collision_geometries;

          // drake::multibody::multibody_plant::MultibodyPlant::num_joints
          struct /* num_joints */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:233
            const char* doc =
R"""(Returns the number of joints in the model.

See also:
    AddJoint().)""";

          } num_joints;

          // drake::multibody::multibody_plant::MultibodyPlant::num_model_instances
          struct /* num_model_instances */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:245
            const char* doc =
R"""(Returns the number of model instances in the model.

See also:
    AddModelInstance().)""";

          } num_model_instances;

          // drake::multibody::multibody_plant::MultibodyPlant::num_multibody_states
          struct /* num_multibody_states */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:276
            const char* doc =
R"""(Returns the size of the multibody system state vector `x = [q; v]` for
`this` MultibodyPlant. This will equal the number of generalized
positions (see num_positions()) plus the number of generalized
velocities (see num_velocities()). Notice however that the state of a
MultibodyPlant, stored in its Context, can actually contain other
variables such as integrated power and discrete states.)""";

          } num_multibody_states;

          // drake::multibody::multibody_plant::MultibodyPlant::num_positions
          struct /* num_positions */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:251
            const char* doc =
R"""(Returns the size of the generalized position vector `q` for `this`
MultibodyPlant.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:255
            const char* doc_2 =
R"""(Returns the size of the generalized position vector `q` for a specific
model instance.)""";

          } num_positions;

          // drake::multibody::multibody_plant::MultibodyPlant::num_velocities
          struct /* num_velocities */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:261
            const char* doc =
R"""(Returns the size of the generalized velocity vector `v` for `this`
MultibodyPlant.)""";

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:265
            const char* doc_2 =
R"""(Returns the size of the generalized velocity vector `v` for a specific
model instance.)""";

          } num_velocities;

          // drake::multibody::multibody_plant::MultibodyPlant::num_visual_geometries
          struct /* num_visual_geometries */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:862
            const char* doc =
R"""(Returns the number of geometries registered for visualization. This
method can be called at any time during the lifetime of `this` plant,
either pre- or post-finalize, see Finalize(). Post-finalize calls will
always return the same value.)""";

          } num_visual_geometries;

          // drake::multibody::multibody_plant::MultibodyPlant::set_penetration_allowance
          struct /* set_penetration_allowance */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1260
            const char* doc =
R"""(Sets the penetration allowance used to estimate the coefficients in
the penalty method used to impose non-penetration among bodies. Refer
to the section mbp_penalty_method "Contact by penalty method" for
further details.)""";

          } set_penetration_allowance;

          // drake::multibody::multibody_plant::MultibodyPlant::set_stiction_tolerance
          struct /* set_stiction_tolerance */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1305
            const char* doc =
R"""(Sets the stiction tolerance `v_stiction` for the Stribeck model, where
`v_stiction` must be specified in m/s (meters per second.)
`v_stiction` defaults to a value of 1 millimeter per second.

Throws:
    s RuntimeError if `v_stiction` is non-positive.)""";

          } set_stiction_tolerance;

          // drake::multibody::multibody_plant::MultibodyPlant::time_step
          struct /* time_step */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1176
            const char* doc =
R"""(The time step (or period) used to model `this` plant as a discrete
system with periodic updates. Returns 0 (zero) if the plant is modeled
as a continuous system. This property of the plant is specified at
construction and therefore this query can be performed either pre- or
post- finalize, see Finalize().

See also:
    MultibodyPlant::MultibodyPlant(double))""";

          } time_step;

          // drake::multibody::multibody_plant::MultibodyPlant::tree
          struct /* tree */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1125
            const char* doc =
R"""(Returns a constant reference to the underlying MultibodyTree model for
`this` plant.

Throws:
    s if called pre-finalize. See Finalize().)""";

          } tree;

          // drake::multibody::multibody_plant::MultibodyPlant::world_body
          struct /* world_body */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1104
            const char* doc =
R"""(Returns a constant reference to the *world* body.)""";

          } world_body;

          // drake::multibody::multibody_plant::MultibodyPlant::world_frame
          struct /* world_frame */ {

            // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1109
            const char* doc =
R"""(Returns a constant reference to the *world* frame.)""";

          } world_frame;

        } MultibodyPlant;

        // drake::multibody::multibody_plant::PointPairContactInfo
        struct /* PointPairContactInfo */ {

          // drake/multibody/multibody_tree/multibody_plant/contact_info.h:32
          const char* doc =
R"""(A class containing information regarding contact response between two
bodies including: - The pair of bodies that are contacting, referenced
by their BodyIndex. - A resultant contact force. - A contact point. -
Separation speed. - Slip speed.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

          // drake::multibody::multibody_plant::PointPairContactInfo::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:34
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::multibody::multibody_plant::PointPairContactInfo::PointPairContactInfo<T>
          struct /* ctor */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:34
            const char* doc = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:34
            const char* doc_2 = R"""()""";

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:58
            const char* doc_3 =
R"""(Constructs the contact information for a given pair of two colliding
bodies.

Parameter ``bodyA_index``:
    Index that references body A in `this` contact pair.

Parameter ``bodyB_index``:
    Index that references body B in `this` contact pair.

Parameter ``f_Bc_W``:
    Force on body B applied at contact point C, expressed in the world
    frame W.

Parameter ``p_WC``:
    Position of the contact point C in the world frame W.

Parameter ``separation_speed``:
    Separation speed along the normal direction between body A and
    body B, in meters per second. A positive value indicates bodies
    are moving apart. A negative value indicates bodies are moving
    towards each other.

Parameter ``slip_speed``:
    Slip speed, that is, the magnitude of the relative tangential
    velocity at the contact point in meters per second. A non-negative
    value always.

Parameter ``point_pair``:
    Additional point pair information for `this` contact info. Refer
    to the documentation for PenetrationAsPointPair for further
    details. @pre The two body indexes must reference bodies from the
    same MultibodyPlant. Contact values should likewise be generated
    by the same MultibodyPlant.)""";

          } ctor;

          // drake::multibody::multibody_plant::PointPairContactInfo::bodyA_index
          struct /* bodyA_index */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:65
            const char* doc =
R"""(Returns the index of body A in the contact pair.)""";

          } bodyA_index;

          // drake::multibody::multibody_plant::PointPairContactInfo::bodyB_index
          struct /* bodyB_index */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:68
            const char* doc =
R"""(Returns the index of body B in the contact pair.)""";

          } bodyB_index;

          // drake::multibody::multibody_plant::PointPairContactInfo::contact_force
          struct /* contact_force */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:72
            const char* doc =
R"""(Returns the contact force `f_Bc_W` on B at contact point C expressed
in the world frame W.)""";

          } contact_force;

          // drake::multibody::multibody_plant::PointPairContactInfo::contact_point
          struct /* contact_point */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:75
            const char* doc =
R"""(Returns the position `p_WC` of the contact point C in the world frame
W.)""";

          } contact_point;

          // drake::multibody::multibody_plant::PointPairContactInfo::point_pair
          struct /* point_pair */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:87
            const char* doc =
R"""(Returns additional information for the geometric contact query for
`this` pair as a PenetrationAsPointPair.)""";

          } point_pair;

          // drake::multibody::multibody_plant::PointPairContactInfo::separation_speed
          struct /* separation_speed */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:83
            const char* doc =
R"""(Returns the separation speed between body A and B along the normal
direction (see PenetrationAsPointPair::nhat_BA_W) at the contact
point. It is defined positive for bodies moving apart in the normal
direction.)""";

          } separation_speed;

          // drake::multibody::multibody_plant::PointPairContactInfo::slip_speed
          struct /* slip_speed */ {

            // drake/multibody/multibody_tree/multibody_plant/contact_info.h:78
            const char* doc =
R"""(Returns the slip speed between body A and B at contact point C.)""";

          } slip_speed;

        } PointPairContactInfo;

      } multibody_plant;

      // drake::multibody::operator+
      struct /* operator_add */ {

        // drake/multibody/multibody_tree/math/spatial_force.h:204
        const char* doc =
R"""(Computes the resultant spatial force as the addition of two spatial
forces `F1_Sp_E` and `F2_Sp_E` on a same system or body S, at the same
point P and expressed in the same frame E.

Returns ``Fr_Sp_E``:
    The resultant spatial force on system or body S from combining
    `F1_Sp_E` and `F2_Sp_E`, applied at the same point P and in the
    same expressed-in frame E as the operand spatial forces.)""";

        // drake/multibody/multibody_tree/math/spatial_momentum.h:222
        const char* doc_2 =
R"""(Computes the resultant spatial momentum as the addition of two spatial
momenta `L1_NSp_E` and `L2_NSp_E` on a same system S, about the same
point P and expressed in the same frame E.

Returns ``Lc_NSp_E``:
    The combined spatial momentum of system S from combining
    `L1_NSp_E` and `L2_NSp_E`, applied about the same point P, and in
    the same expressed-in frame E as the operand spatial momenta.)""";

        // drake/multibody/multibody_tree/math/spatial_velocity.h:270
        const char* doc_3 =
R"""(Performs the addition of two spatial velocities. This operator returns
the spatial velocity that results from adding the operands as if they
were 6-dimensional vectors. In other words, the resulting spatial
velocity contains a rotational component which is the 3-dimensional
addition of the operand's rotational components and a translational
component which is the 3-dimensional addition of the operand's
translational components.

The addition of two spatial velocities has a clear physical meaning
but can only be performed if the operands meet strict conditions. In
addition the the usual requirement of common expressed-in frames, both
spatial velocities must be for frames with the same origin point. The
general idea is that if frame A has a spatial velocity with respect to
E, and frame B has a spatial velocity with respect to A, we want to
"compose" them so that we get frame B's spatial velocity in E. But
that can't be done directly since frames A and B don't have the same
origin. So:

Given the velocity V_EA of a frame A with respect to another frame E,
and the velocity V_AB_E of a frame B measured in frame A (both
expressed in frame E), we can calculate V_EB as their sum after
shifting A's velocity to point Bo:

```
V_EB = V_EA.Shift(p_AB_E) + V_AB_E
```

where `p_AB_E` is the position vector from A's origin to B's origin,
expressed in E. This shift can also be thought of as yielding the
spatial velocity of a new frame Ab, which is an offset frame rigidly
aligned with A, but with its origin shifted to B's origin:

```
V_EAb = V_EA.Shift(p_AB_E)
  V_EB = V_EAb + V_AB_E
```

The addition in the last expression is what is carried out by this
operator; the caller must have already performed the necessary shift.)""";

      } operator_add;

      // drake::multibody::operator<<
      struct /* operator_lshift */ {

        // drake/multibody/multibody_tree/math/spatial_vector.h:254
        const char* doc =
R"""(Stream insertion operator to write SpatialVector objects into a
`std::ostream`. Especially useful for debugging. @relates
SpatialVector.)""";

        // drake/multibody/multibody_tree/rotational_inertia.h:970
        const char* doc_2 =
R"""(Insertion operator to write RotationalInertia's into a `std::ostream`.
Especially useful for debugging. @relates RotationalInertia)""";

        // drake/multibody/multibody_tree/spatial_inertia.h:472
        const char* doc_3 =
R"""(Insertion operator to write SpatialInertia objects into a
`std::ostream`. Especially useful for debugging. @relates
SpatialInertia)""";

      } operator_lshift;

      // parsing
      struct /* parsing */ {

        // drake::multibody::parsing::AddModelFromSdfFile
        struct /* AddModelFromSdfFile */ {

          // drake/multibody/multibody_tree/parsing/multibody_plant_sdf_parser.h:40
          const char* doc =
R"""(Parses a `<model>` element from the SDF file specified by `file_name`
and adds it to `plant`. The SDF file can only contain a single
`<model>` element. `<world>` elements (used for instance to specify
gravity) are ignored by this method. A new model instance will be
added to ``plant``.

Throws:
    s std::runtime_error if the file is not in accordance with the SDF
    specification containing a message with a list of errors
    encountered while parsing the file.

Throws:
    s std::runtime_error if there is more than one `<model>` element
    or zero of them.

Throws:
    s RuntimeError if plant is nullptr or if
    MultibodyPlant::Finalize() was already called on `plant`.

Parameter ``file_name``:
    The name of the SDF file to be parsed.

Parameter ``model_name``:
    The name given to the newly created instance of this model. If
    empty, the "name" attribute from the model tag will be used.

Parameter ``plant``:
    A pointer to a mutable MultibodyPlant object to which the model
    will be added.

Parameter ``scene_graph``:
    A pointer to a mutable SceneGraph object used for geometry
    registration (either to model visual or contact geometry). May be
    nullptr.

Returns:
    The model instance index for the newly added model.)""";

          // drake/multibody/multibody_tree/parsing/multibody_plant_sdf_parser.h:48
          const char* doc_2 =
R"""(Alternate version of AddModelFromSdfFile which always uses the "name"
element from the model tag for the name of the newly created model
instance.)""";

        } AddModelFromSdfFile;

        // drake::multibody::parsing::AddModelsFromSdfFile
        struct /* AddModelsFromSdfFile */ {

          // drake/multibody/multibody_tree/parsing/multibody_plant_sdf_parser.h:74
          const char* doc =
R"""(Parses all `<model>` elements from the SDF file specified by
`file_name` and adds them to `plant`. The SDF file can contain
multiple `<model>` elements. New model instances will be added to
``plant`` for each `<model>` tag in the SDF file.

Throws:
    s std::runtime_error if the file is not in accordance with the SDF
    specification containing a message with a list of errors
    encountered while parsing the file.

Throws:
    s std::runtime_error if the file contains no models.

Throws:
    s RuntimeError if plant is nullptr or if
    MultibodyPlant::Finalize() was already called on `plant`.

Parameter ``file_name``:
    The name of the SDF file to be parsed.

Parameter ``plant``:
    A pointer to a mutable MultibodyPlant object to which the model
    will be added.

Parameter ``scene_graph``:
    A pointer to a mutable SceneGraph object used for geometry
    registration (either to model visual or contact geometry). May be
    nullptr.

Returns:
    The set of model instance indices for the newly added models.)""";

        } AddModelsFromSdfFile;

        // drake::multibody::parsing::GetFullPath
        struct /* GetFullPath */ {

          // drake/multibody/multibody_tree/parsing/parser_path_utils.h:18
          const char* doc =
R"""(Obtains the full path of @file_name. If ``file_name`` is already a
full path (i.e., it starts with a "/"), the path is not modified. If
``file_name`` is a relative path, this method converts it into an
absolute path based on the current working directory.

Throws:
    s std::runtime_error if the file does not exist or if
    ``file_name`` is empty.)""";

        } GetFullPath;

        // drake::multibody::parsing::PackageMap
        struct /* PackageMap */ {

          // drake/multibody/multibody_tree/parsing/package_map.h:15
          const char* doc =
R"""(Maps ROS package names to their full path on the local file system. It
is used by the SDF and URDF parsers when parsing files that reference
ROS packages for resources like mesh files.)""";

          // drake::multibody::parsing::PackageMap::Add
          struct /* Add */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:25
            const char* doc =
R"""(Adds package ``package_name`` and its path, ``package_path``. Aborts
if ``package_name`` is already present in this PackageMap, or if
``package_path`` does not exist.)""";

          } Add;

          // drake::multibody::parsing::PackageMap::Contains
          struct /* Contains */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:28
            const char* doc =
R"""(Returns true if and only if this PackageMap contains ``package_name``.)""";

          } Contains;

          // drake::multibody::parsing::PackageMap::GetPath
          struct /* GetPath */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:35
            const char* doc =
R"""(Obtains the path associated with package ``package_name``. Aborts if
no package named ``package_name`` exists in this PackageMap.)""";

          } GetPath;

          // drake::multibody::parsing::PackageMap::PackageMap
          struct /* ctor */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:17
            const char* doc = R"""()""";

            // drake/multibody/multibody_tree/parsing/package_map.h:17
            const char* doc_2 = R"""()""";

            // drake/multibody/multibody_tree/parsing/package_map.h:20
            const char* doc_3 =
R"""(A constructor that initializes an empty map.)""";

          } ctor;

          // drake::multibody::parsing::PackageMap::PopulateFromEnvironment
          struct /* PopulateFromEnvironment */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:53
            const char* doc =
R"""(Obtains one or more paths from environment variable
``environment_variable``. Crawls downard through the directory tree(s)
starting from the path(s) searching for `package.xml` files. For each
of these files, this method adds a new entry into this PackageMap
where the key is the package name as specified within `package.xml`
and the value is the path to the `package.xml` file. Multiple paths
can be specified by separating them using the ':' symbol. For example,
the environment variable can contain [path 1]:[path 2]:[path 3] to
search three different paths.)""";

          } PopulateFromEnvironment;

          // drake::multibody::parsing::PackageMap::PopulateFromFolder
          struct /* PopulateFromFolder */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:42
            const char* doc =
R"""(Crawls down the directory tree starting at ``path`` searching for
directories containing the file `package.xml`. For each of these
directories, this method adds a new entry into this PackageMap where
the key is the package name as specified within `package.xml` and the
directory's path is the value.)""";

          } PopulateFromFolder;

          // drake::multibody::parsing::PackageMap::PopulateUpstreamToDrake
          struct /* PopulateUpstreamToDrake */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:62
            const char* doc =
R"""(Crawls up the directory tree from ``model_file`` to `drake` searching
for `package.xml` files. Adds the packages described by these
`package.xml` files. If ``model_file`` is not in `drake`, this method
returns without doing anything.

Parameter ``model_file``:
    The model file whose directory is the start of the search for
    `package.xml` files. This file must be an SDF or URDF file.)""";

          } PopulateUpstreamToDrake;

          // drake::multibody::parsing::PackageMap::size
          struct /* size */ {

            // drake/multibody/multibody_tree/parsing/package_map.h:31
            const char* doc =
R"""(Returns the number of entries in this PackageMap.)""";

          } size;

        } PackageMap;

        // drake::multibody::parsing::ResolveFilename
        struct /* ResolveFilename */ {

          // drake/multibody/multibody_tree/parsing/parser_path_utils.h:38
          const char* doc =
R"""(Resolves the full path of a file. If ``filename`` starts with
"package:", the ROS packages specified in ``package_map`` are
searched. Otherwise, ``filename`` is appended to the end of
``root_dir`` (if it's not already an absolute path) and checked for
existence. If the file does not exist or is not found, a warning is
printed to `std::cerr` and an empty string is returned.

Parameter ``filename``:
    The name of the file to find.

Parameter ``package_map``:
    A map where the keys are ROS package names and the values are the
    paths to the packages. This is only used if ``filename`` starts
    with "package:".

Parameter ``root_dir``:
    The root directory to look in. This is only used when ``filename``
    does not start with "package:".

Returns:
    The file's full path or an empty string if the file is not found
    or does not exist.)""";

        } ResolveFilename;

        // drake::multibody::parsing::default_friction
        struct /* default_friction */ {

          // drake/multibody/multibody_tree/parsing/sdf_parser_common.h:19
          const char* doc = R"""()""";

        } default_friction;

      } parsing;

      // drake::multibody::world_index
      struct /* world_index */ {

        // drake/multibody/multibody_tree/multibody_tree_indexes.h:44
        const char* doc = R"""()""";

      } world_index;

      // drake::multibody::world_model_instance
      struct /* world_model_instance */ {

        // drake/multibody/multibody_tree/model_instance.h:62
        const char* doc =
R"""(Returns the model instance containing the *world* body. For every
MultibodyTree the **world** body _always_ has this unique model
instance and it is always zero (as described in #3088).)""";

      } world_model_instance;

    } multibody;

    // drake::never_destroyed
    struct /* never_destroyed */ {

      // drake/common/never_destroyed.h:62
      const char* doc = R"""()""";

      // drake::never_destroyed::access
      struct /* access */ {

        // drake/common/never_destroyed.h:77
        const char* doc = R"""(Returns the underlying T reference.)""";

        // drake/common/never_destroyed.h:78
        const char* doc_2 = R"""()""";

      } access;

      // drake::never_destroyed::never_destroyed<T>
      struct /* ctor */ {

        // drake/common/never_destroyed.h:64
        const char* doc = R"""()""";

        // drake/common/never_destroyed.h:64
        const char* doc_2 = R"""()""";

        // drake/common/never_destroyed.h:68
        const char* doc_3 =
R"""(Passes the constructor arguments along to T using perfect forwarding.)""";

      } ctor;

    } never_destroyed;

    // drake::operator!=
    struct /* operator_ne */ {

      // drake/common/type_safe_index.h:510
      const char* doc = R"""()""";

    } operator_ne;

    // drake::operator<
    struct /* operator_lt */ {

      // drake/common/type_safe_index.h:517
      const char* doc = R"""()""";

    } operator_lt;

    // drake::operator<=
    struct /* operator_le */ {

      // drake/common/type_safe_index.h:524
      const char* doc = R"""()""";

    } operator_le;

    // drake::operator>
    struct /* operator_gt */ {

      // drake/common/type_safe_index.h:531
      const char* doc = R"""()""";

    } operator_gt;

    // drake::operator>=
    struct /* operator_ge */ {

      // drake/common/type_safe_index.h:538
      const char* doc = R"""()""";

    } operator_ge;

    // parsers
    struct /* parsers */ {

      // drake::parsers::AddFloatingJoint
      struct /* AddFloatingJoint */ {

        // drake/multibody/parsers/parser_common.h:59
        const char* doc =
R"""(Adds a floating joint to each body specified by ``body_indices`` that
does not already have a parent.

This method is only intended to be called by parsers since parsers add
bodies to the RigidBodyTree _en masse_. The logic in this method is
necessary to identify which of the rigid bodies specified by
``body_indices`` get floating joints.

When manually adding a model instance to the RigidBodyTree, i.e.,
directly using the C++ API rather than via a parser, this method
should _not_ be necessary since floating joints can be directly added
by calling RigidBody::setJoint().

Parameter ``floating_base_type``:
    The floating joint's type.

Parameter ``body_indices``:
    A list of body indexes to check. A floating joint is added to any
    body in this list that does not have a parent joint.

Parameter ``weld_to_frame``:
    The frame to which the floating joint should attach the parent-
    less non-world bodies. This parameter may be nullptr, in which
    case the body is welded to the world with zero offset.

Parameter ``pose_map``:
    A mapping where the key is the body's name and the value is the
    transform from the frame of the body to the frame of the model to
    which the body belongs. This parameter will may be nullptr, in
    which case an identity transform is used.

Parameter ``tree``:
    The RigidBodyTree to which to add the floating joints.

Returns:
    The number of floating joint added to this rigid body tree.

Throws:
    s A std::runtime_error if the floating_base_type is unrecognized
    or zero floating joints were added to the model.)""";

      } AddFloatingJoint;

      // drake::parsers::AddModelInstancesToTable
      struct /* AddModelInstancesToTable */ {

        // drake/multibody/parsers/model_instance_id_table.h:33
        const char* doc =
R"""(Adds the model instances in ``source_table`` to ``dest_table``. Throws
a `std::runtime_error` if there is a collision in the model names.)""";

      } AddModelInstancesToTable;

      // drake::parsers::FloatingJointConstants
      struct /* FloatingJointConstants */ {

        // drake/multibody/parsers/parser_common.h:18
        const char* doc =
R"""(Defines constants used by AddFloatingJoint().)""";

      } FloatingJointConstants;

      // drake::parsers::ParseCollisionCompliance
      struct /* ParseCollisionCompliance */ {

        // drake/multibody/parsers/parser_common.h:94
        const char* doc =
R"""(Instantiates a CompliantMaterial instance from an XMLNode. It ignores
unrecognized elements, but throws an exception if a recognized
element's contents cannot be converted to a double. Omitted property
elements remain tied to the default parameter value. If either
friction coefficient is defined, _both_ must be defined. Furthermore,
the coefficient for static friction must be greater than or equal to
the dynamic friction and both must be non-negative.

Looks for the following tags in URDF and SDF:

```
xml
...
<collision ...>
  <geometry...>
  </geometry>

  <drake_compliance>
    <youngs_modulus>##</youngs_modulus>
    <dissipation>##</dissipation>
    <static_friction>##</static_friction>
    <dynamic_friction>##</dynamic_friction>
  </drake_compliance>

</collision>
...
```

Parameter ``node``:
    The *parent* node which ostensibly contains a declaration of drake
    compliance.)""";

      } ParseCollisionCompliance;

      // drake::parsers::ParseCollisionFilterGroup
      struct /* ParseCollisionFilterGroup */ {

        // drake/multibody/parsers/parser_common.h:107
        const char* doc =
R"""(Parses the Drake collision filter group specification. Attempts to add
collision filter groups (with their member lists and ignore lists) to
the tree specification. Inconsistent definitions will lead to thrown
exceptions.

See cfg_impl "this discussion" for details on the XML specification.

Parameter ``tree``:
    The rigid body tree containing the bodies to which the filters
    will be applied.

Parameter ``node``:
    The XML node containing the filter details.

Parameter ``model_instance_id``:
    The id of the current model instance.)""";

      } ParseCollisionFilterGroup;

      // sdf
      struct /* sdf */ {

        // drake::parsers::sdf::AddModelInstancesFromSdfFile
        struct /* AddModelInstancesFromSdfFile */ {

          // drake/multibody/parsers/sdf_parser.h:135
          const char* doc =
R"""(Adds the model or models defined within an SDF file to a rigid body
tree. One instance of each model is added.

This method can only be used with SDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``filename``. SDF files that contain `package://`
references to do not meet these requirements should instead use
AddModelInstancesFromSdfFileSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``filename``:
    The name of the SDF file containing the model to be added.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:141
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfFile;

        // drake::parsers::sdf::AddModelInstancesFromSdfFileSearchingInRosPackages
        struct /* AddModelInstancesFromSdfFileSearchingInRosPackages */ {

          // drake/multibody/parsers/sdf_parser.h:181
          const char* doc =
R"""(Adds the model or models defined within an SDF file to ``tree``. One
instance of each model is added.

This method has input parameter ``package_map``. This parameter is
only necessary if the SDF contains models that reference meshes and
other modeling resources using `package://`. If the models in the SDF
do not use `package://`, or if the package can be found by crawling up
the directory tree, the SDF could instead be loaded using
AddModelInstancesFromSdfFile().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``filename``:
    The name of the SDF file containing the model to be added.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when finding files referenced in the SDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:187
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfFileSearchingInRosPackages;

        // drake::parsers::sdf::AddModelInstancesFromSdfFileToWorld
        struct /* AddModelInstancesFromSdfFileToWorld */ {

          // drake/multibody/parsers/sdf_parser.h:48
          const char* doc =
R"""(Adds the model or models defined within an SDF file to a rigid body
tree. One instance of each model is added. The models in the SDF are
assumed to be described in the world frame.

This method can only be used with SDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``filename``. SDF files that contain `package://`
references to do not meet these requirements should instead use
AddModelInstancesFromSdfFileToWorldSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``filename``:
    The name of the SDF file containing the model to be added.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:54
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfFileToWorld;

        // drake::parsers::sdf::AddModelInstancesFromSdfFileToWorldSearchingInRosPackages
        struct /* AddModelInstancesFromSdfFileToWorldSearchingInRosPackages */ {

          // drake/multibody/parsers/sdf_parser.h:93
          const char* doc =
R"""(Adds the model or models defined within an SDF file to a rigid body
tree. One instance of each model is added. The models in the SDF are
assumed to be described in the world frame.

This method has input parameter ``package_map``. This parameter is
only necessary if the SDF contains models that reference meshes and
other modeling resources using `package://`. If the models in the SDF
do not use `package://`, or if the package can be found by crawling up
the directory tree, the SDF could instead be loaded using
AddModelInstancesFromSdfFileToWorld().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``filename``:
    The name of the SDF file containing the model to be added.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when finding files referenced in the SDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:99
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfFileToWorldSearchingInRosPackages;

        // drake::parsers::sdf::AddModelInstancesFromSdfString
        struct /* AddModelInstancesFromSdfString */ {

          // drake/multibody/parsers/sdf_parser.h:223
          const char* doc =
R"""(Adds the model or models defined within an SDF description to
``tree``. One instance of each model is added.

This method can only be used with SDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``filename``. SDF files that contain `package://`
references to do not meet these requirements should instead use
AddModelInstancesFromSdfStringSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``sdf_string``:
    The SDF description of one or more models.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:229
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfString;

        // drake::parsers::sdf::AddModelInstancesFromSdfStringSearchingInRosPackages
        struct /* AddModelInstancesFromSdfStringSearchingInRosPackages */ {

          // drake/multibody/parsers/sdf_parser.h:268
          const char* doc =
R"""(Adds the model or models defined within an SDF description to
``tree``. One instance of each model is added.

This method has input parameter ``package_map``. This parameter is
only necessary if the SDF contains models that reference meshes and
other modeling resources using `package://`. If the models in the SDF
do not use `package://`, or if the package can be found by crawling up
the directory tree, the SDF could instead be loaded using
AddModelInstancesFromSdfFile().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``sdf_string``:
    The SDF description of one or more models.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when finding files referenced in the SDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model's root to the existing
    rigid body tree.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model.

Parameter ``tree``:
    The rigid body tree to which to add the model.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/sdf_parser.h:274
          const char* doc_2 = R"""()""";

        } AddModelInstancesFromSdfStringSearchingInRosPackages;

      } sdf;

      // urdf
      struct /* urdf */ {

        // drake::parsers::urdf::AddModelInstanceFromUrdfFile
        struct /* AddModelInstanceFromUrdfFile */ {

          // drake/multibody/parsers/urdf_parser.h:299
          const char* doc = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:348
          const char* doc_2 = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:391
          const char* doc_3 =
R"""(Reads a URDF model specified by ``urdf_filename`` and adds an instance
of it to ``tree``. Let the "base bodies" be the bodies in the model
that do not have parent joints. This method connects the base bodies
to an existing body in the tree using joints of type
``floating_base_type``. The body in the tree to which the base bodies
are attached and the transform between this body and the base bodies
when the joints are in their zero positions is specified by
``weld_to_frame``.

This method can only be used with URDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``urdf_filename``. URDF files that contain `package://`
references that do not meet these requirements should instead use
AddModelInstanceFromUrdfFileSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_filename``:
    The name of the file containing the URDF model. A new instance of
    this model is created and added to ``tree``.

Parameter ``floating_base_type``:
    The type of joint that connects the model instance's root to the
    ``tree``.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model instance.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:397
          const char* doc_4 = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:455
          const char* doc_5 = R"""()""";

        } AddModelInstanceFromUrdfFile;

        // drake::parsers::urdf::AddModelInstanceFromUrdfFileSearchingInRosPackages
        struct /* AddModelInstanceFromUrdfFileSearchingInRosPackages */ {

          // drake/multibody/parsers/urdf_parser.h:442
          const char* doc =
R"""(This method is the same as AddModelInstanceFromUrdfFile() except it
has an additional parameter called ``package_map``. Parameter
``package_map`` contains a mapping from ROS package names to their
paths on the local file system. The mapping is used to find resources
like mesh files that are referenced within the URDF. This method may
be called from within the context of a [ROS
node](http://wiki.ros.org/Nodes) or a regular non-ROS application.

This method has input parameter ``package_map``. This parameter is
only necessary if the URDF contains a model that references meshes and
other modeling resources using `package://`. If the model in the URDF
does not use `package://`, the URDF could instead be loaded using
AddModelInstanceFromUrdfFile().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_filename``:
    The name of the file containing the URDF model. An instance of
    this model will be added to ``tree``.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when finding files referenced in the URDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model instance's root to the
    ``tree``.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model instance.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:448
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfFileSearchingInRosPackages;

        // drake::parsers::urdf::AddModelInstanceFromUrdfFileToWorld
        struct /* AddModelInstanceFromUrdfFileToWorld */ {

          // drake/multibody/parsers/urdf_parser.h:337
          const char* doc =
R"""(Reads a URDF model specified by ``urdf_filename`` and adds an instance
of it to ``tree``. Let the "base bodies" be the bodies in the model
that do not have parent joints. This method connects the model
instance's base bodies to the world via joints of type
``floating_base_type``. When these joints are at their zero positions,
the base bodies' frames are coincident with the world's coordinate
frame.

This method can only be used with URDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``urdf_filename``. URDF files that contain `package://`
references that do not meet these requirements should instead use
AddModelInstanceFromUrdfFileSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_filename``:
    The name of the file containing a URDF description of the model.
    An instance of this model will be added to ``tree``.

Parameter ``floating_base_type``:
    The type of joint that connects the model instance's root to
    ``tree``.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:342
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfFileToWorld;

        // drake::parsers::urdf::AddModelInstanceFromUrdfFileWithRpyJointToWorld
        struct /* AddModelInstanceFromUrdfFileWithRpyJointToWorld */ {

          // drake/multibody/parsers/urdf_parser.h:291
          const char* doc =
R"""(Reads a URDF model specified by ``urdf_filename`` and adds an instance
of it to ``tree``. Let the "base bodies" be the bodies in the model
that do not have parent joints. This method connects the model
instance's base bodies to the world via
multibody::joints::kRollPitchYaw joints. When this joint is at its
zero position, the base bodies' frames are coincident with the world's
coordinate frame.

This method can only be used with URDF models that either (1) do not
use `package://` to reference modeling resources like mesh files, or
(2) only reference packages that are defined up the directory tree
relative to ``urdf_filename``. URDF files that contain `package://`
references that do not meet these requirements should instead use
AddModelInstanceFromUrdfFileSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_filename``:
    The name of the file containing the URDF model.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to ``tree`` to their instance IDs, which are unique within
    ``tree``.)""";

          // drake/multibody/parsers/urdf_parser.h:294
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfFileWithRpyJointToWorld;

        // drake::parsers::urdf::AddModelInstanceFromUrdfString
        struct /* AddModelInstanceFromUrdfString */ {

          // drake/multibody/parsers/urdf_parser.h:91
          const char* doc = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:142
          const char* doc_2 = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:184
          const char* doc_3 =
R"""(Reads a URDF model specified by ``urdf_string`` and adds an instance
of it to ``tree``. Let the "base bodies" be the bodies in the model
that do not have parent joints. This method connects the base bodies
to an existing body in ``tree`` via joints of type
``floating_base_type``. The body in the tree to which to which these
joints attach and the transform between this body and the base bodies'
frames when the joints are in their zero positions is determined by
``weld_to_frame``.

This method can only be used with URDF models that do not use
`package://` to reference modeling resources like mesh files. URDF
models that contain `package://` should instead use
AddModelInstanceFromUrdfStringSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_string``:
    The URDF string of the model. This is the actual URDF text (i.e.,
    it is not the name of a file that contains the URDF text). A new
    model instance is created based on this URDF text and added to
    ``tree``.

Parameter ``root_dir``:
    The root directory in which to search for files mentioned in the
    URDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model instance's root to
    ``tree``.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:190
          const char* doc_4 = R"""()""";

          // drake/multibody/parsers/urdf_parser.h:255
          const char* doc_5 = R"""()""";

        } AddModelInstanceFromUrdfString;

        // drake::parsers::urdf::AddModelInstanceFromUrdfStringSearchingInRosPackages
        struct /* AddModelInstanceFromUrdfStringSearchingInRosPackages */ {

          // drake/multibody/parsers/urdf_parser.h:240
          const char* doc =
R"""(This method is the same as AddModelInstanceFromUrdfString() except it
has an additional parameter called ``package_map``. Parameter
``package_map`` contains a mapping from ROS package names to their
paths on the local file system. The mapping is used to find resources
like mesh files that are referenced within the URDF. This method may
be called from within the context of a [ROS
node](http://wiki.ros.org/Nodes) or a regular non-ROS application.

This method has input parameter ``package_map``. This parameter is
only necessary if the URDF contains a model that references meshes and
other modeling resources using `package://`. If the model in the URDF
does not use `package://`, the URDF could instead be loaded using
AddModelInstanceFromUrdfString().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_string``:
    The URDF string of the model. This is the actual URDF text (i.e.,
    it is not the name of a file that contains the URDF text). A new
    model instance is created based on this URDF text and added to
    ``tree``.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when finding files referenced in the URDF.

Parameter ``root_dir``:
    The root directory in which to search for files mentioned in the
    URDF.

Parameter ``floating_base_type``:
    The type of joint that connects the model instance's root to
    ``tree``.

Parameter ``weld_to_frame``:
    The frame to which to connect the new model instance.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:247
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfStringSearchingInRosPackages;

        // drake::parsers::urdf::AddModelInstanceFromUrdfStringWithRpyJointToWorld
        struct /* AddModelInstanceFromUrdfStringWithRpyJointToWorld */ {

          // drake/multibody/parsers/urdf_parser.h:82
          const char* doc =
R"""(Reads a URDF model specified by ``urdf_string`` and adds an instance
of it to ``tree``. Let the "base bodies" be the bodies in the model
that do not have parent joints. The base bodies are connected to the
world via multibody::joints::kRollPitchYaw joints. When these joints
are at their zero positions, the base body's frames are coincident
with the world's coordinate frame.

This method can only be used with URDF models that do not use
`package://` to reference modeling resources like mesh files. URDF
models that contain `package://` should instead use AddModelInstanceFr
omUrdfStringWithRpyJointToWorldSearchingInRosPackages().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_string``:
    The URDF string of the model. This is the actual URDF text (i.e.,
    it is not the name of a file that contains the URDF text). A new
    model instance is created based on this URDF text and added to
    ``tree``.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to ``tree`` to their instance IDs, which are unique within
    ``tree``.)""";

          // drake/multibody/parsers/urdf_parser.h:85
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfStringWithRpyJointToWorld;

        // drake::parsers::urdf::AddModelInstanceFromUrdfStringWithRpyJointToWorldSearchingInRosPackages
        struct /* AddModelInstanceFromUrdfStringWithRpyJointToWorldSearchingInRosPackages */ {

          // drake/multibody/parsers/urdf_parser.h:132
          const char* doc =
R"""(This method is the same as
AddModelInstanceFromUrdfStringWithRpyJointToWorld() except it has an
additional parameter called ``package_map``. Parameter ``package_map``
contains a mapping from ROS package names to their paths on the local
file system. The mapping is used to find resources like mesh files
that are referenced within the URDF. This method may be called from
within the context of a [ROS node](http://wiki.ros.org/Nodes) or a
regular non-ROS application.

This method has input parameter ``package_map``. This parameter is
only necessary if the URDF contains a model that references meshes and
other modeling resources using `package://`. If the model in the URDF
does not use `package://`, the URDF could instead be loaded using
AddModelInstanceFromUrdfStringWithRpyJointToWorld().

There are two versions: one in which the tree is automatically
"compiled" after a successful parse and one in which compilation
depends on an input parameter, `do_compile`. If `do_compile` is false,
it is the responsibility of the caller to ensure
RigdBodyTree::compile() is invoked appropriately subsequent to the
successful parse.

Parameter ``urdf_string``:
    The URDF string of the model. This is the actual URDF text (i.e.,
    it is not the name of a file that contains the URDF text). A new
    model instance is created based on this URDF text and added to
    ``tree``.

Parameter ``package_map``:
    A map of ROS package names to their paths. These are the packages
    to search through when searching for files referenced in the URDF.

Parameter ``tree``:
    The `RigidBodyTree` to which to add the model instance. This
    parameter must not be `nullptr`.

Returns:
    A table mapping the names of the models whose instances were just
    added to the `RigidBodyTree` to their instance IDs, which are
    unique within the `RigidBodyTree`.)""";

          // drake/multibody/parsers/urdf_parser.h:137
          const char* doc_2 = R"""()""";

        } AddModelInstanceFromUrdfStringWithRpyJointToWorldSearchingInRosPackages;

        // drake::parsers::urdf::MakeRigidBodyFrameFromUrdfNode
        struct /* MakeRigidBodyFrameFromUrdfNode */ {

          // drake/multibody/parsers/urdf_parser.h:47
          const char* doc =
R"""(Manufactures a `RigidBodyFrame` from the given URDF ``link`` and
``pose`` XML nodes. The link name must exist in the given ``model``.
Otherwise, a runtime error is thrown.

Parameter ``tree``:
    The rigid body tree that holds the rigid body to which the new
    `RigidBodyFrame` is attached.

Parameter ``link``:
    The URDF XML node describing the rigid body to which the new
    `RigidBodyFrame` is attached.

Parameter ``pose``:
    The URDF XML node describing the pose of the new `RigidBodyFrame`
    in the frame of the rigid body to which it is attached. If this is
    nullptr, a pose of zero (i.e., identity transform) is used.

Parameter ``name``:
    The name of the new `RigidBodyFrame`.

Parameter ``model_instance_id``:
    The instance ID of the model to which the frame belongs.

Returns:
    The new `RigidBodyFrame`.

Throws:
    s std::runtime_error if the rigid body to which the new
    `RigidBodyFrame` is attached is not found.)""";

        } MakeRigidBodyFrameFromUrdfNode;

      } urdf;

    } parsers;

    // solvers
    struct /* solvers */ {

      // drake::solvers::AddBilinearProductMcCormickEnvelopeMultipleChoice
      struct /* AddBilinearProductMcCormickEnvelopeMultipleChoice */ {

        // drake/solvers/mixed_integer_optimization_util.h:377
        const char* doc =
R"""(Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Mixed Integer constraint
with "Multiple Choice" model. To do so, we assume that the range of x
is [x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying

```
x_min = φˣ₀ < φˣ₁ < ... < φˣₘ = x_max
y_min = φʸ₀ < φʸ₁ < ... < φʸₙ = y_max
```

, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ...
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.

Parameter ``prog``:
    The optimization problem to which the constraints will be added.

Parameter ``x``:
    A variable in the bilinear product.

Parameter ``y``:
    A variable in the bilinear product.

Parameter ``w``:
    The expression that approximates the bilinear product x * y.

Parameter ``phi_x``:
    φˣ in the documentation above. Will be used to cut the range of x
    into small intervals.

Parameter ``phi_y``:
    φʸ in the documentation above. Will be used to cut the range of y
    into small intervals.

Parameter ``Bx``:
    The binary-valued expression indicating which interval x is in.
    Bx(i) = 1 => φˣᵢ ≤ x ≤ φˣᵢ₊₁.

Parameter ``By``:
    The binary-valued expression indicating which interval y is in.
    By(i) = 1 => φʸⱼ ≤ y ≤ φʸⱼ₊₁.

One formulation of the constraint is

```
x = ∑ᵢⱼ x̂ᵢⱼ
y = ∑ᵢⱼ ŷᵢⱼ
Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ
∑ᵢⱼ Bˣʸᵢⱼ = 1
φˣᵢ Bˣʸᵢⱼ ≤ x̂ᵢⱼ ≤ φˣᵢ₊₁ Bˣʸᵢⱼ
φʸⱼ Bˣʸᵢⱼ ≤ ŷᵢⱼ ≤ φʸⱼ₊₁ Bˣʸᵢⱼ
w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ   ŷᵢⱼ - φˣᵢ  φʸⱼ   Bˣʸᵢⱼ)
w ≥ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ)
w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ   + φˣᵢ₊₁ ŷᵢⱼ - φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ)
w ≤ ∑ᵢⱼ (x̂ᵢⱼ φʸⱼ₊₁ + φˣᵢ   ŷᵢⱼ - φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ)
```

The "logical and" constraint Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ can be imposed as

```
Bˣʸᵢⱼ ≥ Bˣᵢ + Bʸⱼ - 1
Bˣʸᵢⱼ ≤ Bˣᵢ
Bˣʸᵢⱼ ≤ Bʸⱼ
0 ≤ Bˣʸᵢⱼ ≤ 1
```

This formulation will introduce slack variables x̂, ŷ and Bˣʸ, in
total 3 * m * n variables.

In order to reduce the number of slack variables, we can further
simplify these constraints, by defining two vectors `x̅ ∈ ℝⁿ`, `y̅ ∈
ℝᵐ` as

```
x̅ⱼ = ∑ᵢ x̂ᵢⱼ
y̅ᵢ = ∑ⱼ ŷᵢⱼ
```

and the constraints above can be re-formulated using `x̅` and `y̅` as

```
x = ∑ⱼ x̅ⱼ
y = ∑ᵢ y̅ᵢ
Bˣʸᵢⱼ = Bˣᵢ ∧ Bʸⱼ
∑ᵢⱼ Bˣʸᵢⱼ = 1
∑ᵢ φˣᵢ Bˣʸᵢⱼ ≤ x̅ⱼ ≤ ∑ᵢ φˣᵢ₊₁ Bˣʸᵢⱼ
∑ⱼ φʸⱼ Bˣʸᵢⱼ ≤ y̅ᵢ ≤ ∑ⱼ φʸⱼ₊₁ Bˣʸᵢⱼ
w ≥ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ   Bˣʸᵢⱼ )
w ≥ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ₊₁ y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ₊₁ Bˣʸᵢⱼ )
w ≤ ∑ⱼ( x̅ⱼ φʸⱼ   ) + ∑ᵢ( φˣᵢ₊₁ y̅ⱼ ) - ∑ᵢⱼ( φˣᵢ₊₁ φʸⱼ   Bˣʸᵢⱼ )
w ≤ ∑ⱼ( x̅ⱼ φʸⱼ₊₁ ) + ∑ᵢ( φˣᵢ   y̅ᵢ ) - ∑ᵢⱼ( φˣᵢ   φʸⱼ₊₁ Bˣʸᵢⱼ ).
```

In this formulation, we introduce new continuous variables `x̅`, `y̅`,
`Bˣʸ`. The total number of new variables is m + n + m * n.

In section 3.3 of Mixed-Integer Models for Nonseparable Piecewise
Linear Optimization: Unifying Framework and Extensions by Juan P
Vielma, Shabbir Ahmed and George Nemhauser, this formulation is called
"Multiple Choice Model".

Note:
    We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
    this function. It is the user's responsibility to ensure that
    these binary constraints are enforced. The users can also add
    cutting planes ∑ᵢBx(i) = 1, ∑ⱼBy(j) = 1. Without these two cutting
    planes, (x, y, w) is still in the McCormick envelope of z = x * y,
    but these two cutting planes "might" improve the computation speed
    in the mixed-integer solver.)""";

      } AddBilinearProductMcCormickEnvelopeMultipleChoice;

      // drake::solvers::AddBilinearProductMcCormickEnvelopeSos2
      struct /* AddBilinearProductMcCormickEnvelopeSos2 */ {

        // drake/solvers/mixed_integer_optimization_util.h:223
        const char* doc =
R"""(Add constraints to the optimization program, such that the bilinear
product x * y is approximated by w, using Special Ordered Set of Type
2 (sos2) constraint. To do so, we assume that the range of x is
[x_min, x_max], and the range of y is [y_min, y_max]. We first
consider two arrays φˣ, φʸ, satisfying

```
x_min = φˣ₀ < φˣ₁ < ... < φˣₘ = x_max
y_min = φʸ₀ < φʸ₁ < ... < φʸₙ = y_max
```

, and divide the range of x into intervals [φˣ₀, φˣ₁], [φˣ₁, φˣ₂], ...
, [φˣₘ₋₁, φˣₘ] and the range of y into intervals [φʸ₀, φʸ₁], [φʸ₁,
φʸ₂], ... , [φʸₙ₋₁, φʸₙ]. The xy plane is thus cut into rectangles,
with each rectangle as [φˣᵢ, φˣᵢ₊₁] x [φʸⱼ, φʸⱼ₊₁]. The convex hull of
the surface z = x * y for x, y in each rectangle is a tetrahedron. We
then approximate the bilinear product x * y with w, such that (x, y,
w) is in one of the tetrahedrons.

We use two different encoding schemes on the binary variables, to
determine which interval is active. We can choose either linear or
logarithmic binning. When using linear binning, for a variable with N
intervals, we use N binary variables, and B(i) = 1 indicates the
variable is in the i'th interval. When using logarithmic binning, we
use ⌈log₂(N)⌉ binary variables. If these binary variables represent
integer M in the reflected Gray code, then the continuous variable is
in the M'th interval.

Parameter ``prog``:
    The program to which the bilinear product constraint is added

Parameter ``x``:
    The decision variable.

Parameter ``y``:
    The decision variable.

Parameter ``w``:
    The expression to approximate x * y

Parameter ``phi_x``:
    The end points of the intervals for `x`.

Parameter ``phi_y``:
    The end points of the intervals for `y`.

Parameter ``Bx``:
    The binary variables for the interval in which x stays encoded as
    described above.

Parameter ``By``:
    The binary variables for the interval in which y stays encoded as
    described above.

Parameter ``binning``:
    Determine whether to use linear binning or logarithmic binning.

Returns:
    lambda The auxiliary continuous variables.

The constraints we impose are

```
x = (φˣ)ᵀ * ∑ⱼ λᵢⱼ
y = (φʸ)ᵀ * ∑ᵢ λᵢⱼ
w = ∑ᵢⱼ φˣᵢ * φʸⱼ * λᵢⱼ
Both ∑ⱼ λᵢⱼ = λ.rowwise().sum() and ∑ᵢ λᵢⱼ = λ.colwise().sum() satisfy SOS2
constraint.
```

If x ∈ [φx(M), φx(M+1)] and y ∈ [φy(N), φy(N+1)], then only λ(M, N),
λ(M + 1, N), λ(M, N + 1) and λ(M+1, N+1) can be strictly positive, all
other λ(i, j) are zero.

Note:
    We DO NOT add the constraint Bx(i) ∈ {0, 1}, By(j) ∈ {0, 1} in
    this function. It is the user's responsibility to ensure that
    these constraints are enforced.)""";

      } AddBilinearProductMcCormickEnvelopeSos2;

      // drake::solvers::AddBoundingBoxConstraintsImpliedByRollPitchYawLimits
      struct /* AddBoundingBoxConstraintsImpliedByRollPitchYawLimits */ {

        // drake/solvers/rotation_constraint.h:73
        const char* doc =
R"""(Applies *very conservative* limits on the entries of R for the cases
when rotations can be limited (for instance, if you want to search
over rotations, but there is an obvious symmetry in the problem so
that e.g. 0 < pitch < PI need not be considered). A matrix so
constrained may still contain rotations outside of this envelope.
Note: For simple rotational symmetry over PI, prefer
kPitch_NegPI_2_to_PI_2 (over 0_to_PI) because it adds one more
constraint (when combined with constraints on roll and yaw). Note: The
Roll-Pitch-Yaw angles follow the convention in RollPitchYaw, namely
extrinsic rotations about Space-fixed x-y-z axes, respectively.)""";

      } AddBoundingBoxConstraintsImpliedByRollPitchYawLimits;

      // drake::solvers::AddLogarithmicSos1Constraint
      struct /* AddLogarithmicSos1Constraint */ {

        // drake/solvers/mixed_integer_optimization_util.h:133
        const char* doc =
R"""(Adds the special ordered set of type 1 (SOS1) constraint. Namely

```
λ(0) + ... + λ(n-1) = 1
  λ(i) ≥ 0 ∀i
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) = 1
```

one and only one of λ(i) is strictly positive (equals to 1 in this
case). We will need to add ⌈log₂(n)⌉ binary variables, where n is the
number of rows in λ. For more information, please refer to Modeling
Disjunctive Constraints with a Logarithmic Number of Binary Variables
and Constraints by J. Vielma and G. Nemhauser, 2011.

Parameter ``prog``:
    The program to which the SOS1 constraint is added.

Parameter ``lambda``:
    lambda is in SOS1.

Parameter ``y``:
    The binary variables indicating which λ is positive. For a given
    assignment on the binary variable `y`, if (y(0), ..., y(⌈log₂(n)⌉)
    represents integer M in `codes`, then only λ(M) is positive.
    Namely, if (y(0), ..., y(⌈log₂(n)⌉) equals to codes.row(M), then
    λ(M) = 1

Parameter ``codes``:
    A n x ⌈log₂(n)⌉ matrix. code.row(i) represents integer i. No two
    rows of `codes` can be the same.

Throws:
    s std::runtime_error if ``codes`` has a non-binary entry (0, 1).)""";

      } AddLogarithmicSos1Constraint;

      // drake::solvers::AddLogarithmicSos2Constraint
      struct /* AddLogarithmicSos2Constraint */ {

        // drake/solvers/mixed_integer_optimization_util.h:70
        const char* doc =
R"""(Adds the special ordered set 2 (SOS2) constraint,

```
λ(0) + ... + λ(n) = 1
  ∀i. λ(i) ≥ 0
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(i) = 0 if i ≠ j and i ≠ j + 1
```

Namely at most two entries in λ can be strictly positive, and these
two entries have to be adjacent. All other λ should be zero. Moreover,
the non-zero λ satisfies λ(j) + λ(j + 1) = 1. We will need to add
⌈log₂(n - 1)⌉ binary variables, where n is the number of rows in λ.
For more information, please refer to Modeling Disjunctive Constraints
with a Logarithmic Number of Binary Variables and Constraints by J.
Vielma and G. Nemhauser, 2011.

Parameter ``prog``:
    Add the SOS2 constraint to this mathematical program.

Parameter ``lambda``:
    At most two entries in λ can be strictly positive, and these two
    entries have to be adjacent. All other entries are zero.

Returns:
    y The newly added binary variables. The assignment of the binary
    variable y implies which two λ can be strictly positive. With a
    binary assignment on y, and suppose the integer M corresponds to
    (y(0), y(1), ..., y(⌈log₂(n - 1)⌉)) in Gray code, then only λ(M)
    and λ(M + 1) can be non-zero. For example, if the assignment of y
    = (1, 1), in Gray code, (1, 1) represents integer 2, so only λ(2)
    and λ(3) can be strictly positive.)""";

        // drake/solvers/mixed_integer_optimization_util.h:85
        const char* doc_2 =
R"""(Adds the special ordered set 2 (SOS2) constraint,

See also:
    AddLogarithmicSos2Constraint.)""";

      } AddLogarithmicSos2Constraint;

      // drake::solvers::AddRelaxNonConvexQuadraticConstraintInTrustRegion
      struct /* AddRelaxNonConvexQuadraticConstraintInTrustRegion */ {

        // drake/solvers/non_convex_optimization_util.h:155
        const char* doc =
R"""(For a non-convex quadratic constraint lb ≤ xᵀQ₁x - xᵀQ₂x + pᵀy ≤ ub
where Q₁, Q₂ are both positive semidefinite matrices. `y` is a vector
that can overlap with `x`. We relax this non-convex constraint by
several convex constraints. The steps are 1. Introduce two new
variables z₁, z₂, to replace xᵀQ₁x and xᵀQ₂x respectively. The
constraint becomes

```
lb ≤ z₁ - z₂ + pᵀy ≤ ub              (1)
```

2. Ideally, we would like to enforce z₁ = xᵀQ₁x and z₂ = xᵀQ₂x through
convex constraints. To this end, we first bound z₁ and z₂ from below,
as

```
z₁ ≥ xᵀQ₁x                            (2)
     z₂ ≥ xᵀQ₂x                            (3)
```

These two constraints are second order cone constraints. 3. To bound
z₁ and z₂ from above, we linearize the quadratic forms xᵀQ₁x and xᵀQ₂x
at a point x₀. Due to the convexity of the quadratic form, we know
that given a positive scalar d > 0, there exists a neighbourhood N(x₀)
around x₀, s.t ∀ x ∈ N(x₀)

```
xᵀQ₁x ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d   (4)
   xᵀQ₂x ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d   (5)
```

Notice N(x₀) is the intersection of two ellipsoids, as formulated in
(4) and (5). Therefore, we also enforce the linear constraints

```
z₁ ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d    (6)
     z₂ ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d    (7)
```

So we relax the original non-convex constraint, with the convex
constraints (1)-(3), (6) and (7).

The trust region is the neighbourhood N(x₀) around x₀, such that the
inequalities (4), (5) are satisfied ∀ x ∈ N(x₀).

The positive scalar d controls both how much the constraint relaxation
is (the original constraint can be violated by at most d), and how big
the trust region is.

If there is a solution satisfying the relaxed constraint, this
solution can violate the original non-convex constraint by at most d;
on the other hand, if there is not a solution satisfying the relaxed
constraint, it proves that the original non-convex constraint does not
have a solution in the trust region.

This approach is outlined in section III of On Time Optimization of
Centroidal Momentum Dynamics by Brahayam Ponton, Alexander Herzog,
Stefan Schaal and Ludovic Righetti, ICRA, 2018

The special cases are when Q₁ = 0 or Q₂ = 0. 1. When Q₁ = 0, the
original constraint becomes lb ≤ -xᵀQ₂x + pᵀy ≤ ub If ub = +∞, then
the original constraint is the convex rotated Lorentz cone constraint
xᵀQ₂x ≤ pᵀy - lb. The user should not call this function to relax this
convex constraint.

Throws:
    s std::runtime_error if Q₁ = 0 and ub = +∞. If ub < +∞, then we
    introduce a new variable z, with the constraints lb ≤ -z + pᵀy ≤
    ub z ≥ xᵀQ₂x z ≤ 2 x₀ᵀQ₂(x - x₀) + x₀ᵀQ₂x₀ + d 2. When Q₂ = 0, the
    constraint becomes lb ≤ xᵀQ₁x + pᵀy ≤ ub If lb = -∞, then the
    original constraint is the convex rotated Lorentz cone constraint
    xᵀQ₁x ≤ ub - pᵀy. The user should not call this function to relax
    this convex constraint.

Throws:
    s std::runtime_error if Q₂ = 0 and lb = -∞. If lb > -∞, then we
    introduce a new variable z, with the constraints lb ≤ z + pᵀy ≤ ub
    z ≥ xᵀQ₁x z ≤ 2 x₀ᵀQ₁(x - x₀) + x₀ᵀQ₁x₀ + d 3. If both Q₁ and Q₂
    are zero, then the original constraint is a convex linear
    constraint lb ≤ pᵀx ≤ ub. The user should not call this function
    to relax this convex constraint. Throw a runtime error.

Parameter ``prog``:
    The MathematicalProgram to which the relaxed constraints are
    added.

Parameter ``x``:
    The decision variables which appear in the original non-convex
    constraint.

Parameter ``Q1``:
    A positive semidefinite matrix.

Parameter ``Q2``:
    A positive semidefinite matrix.

Parameter ``y``:
    A vector, the variables in the linear term of the quadratic form.

Parameter ``p``:
    A vector, the linear coefficients of the quadratic form.

Parameter ``linearization_point``:
    The vector `x₀` in the documentation above.

Parameter ``lower_bound``:
    The left-hand side of the original non-convex constraint.

Parameter ``upper_bound``:
    The right-hand side of the original non-convex constraint.

Parameter ``trust_region_gap``:
    The user-specified positive scalar, `d` in the documentation
    above. This gap determines both the maximal constraint violation
    and the size of the trust region. @retval <linear_constraint,
    rotated_lorentz_cones, z> linear_constraint includes (1)(6)(7)
    rotated_lorentz_cones are (2) (3) When either Q1 or Q2 is zero,
    rotated_lorentz_cones contains only one rotated Lorentz cone,
    either (2) or (3). z is the newly added variable. @pre 1. Q1, Q2
    are positive semidefinite. 2. d is positive. 3. Q1, Q2, x, x₀ are
    all of the consistent size. 4. p and y are of the consistent size.
    5. lower_bound ≤ upper_bound.

Throws:
    s std::runtime_error when the precondition is not satisfied.)""";

      } AddRelaxNonConvexQuadraticConstraintInTrustRegion;

      // drake::solvers::AddRotationMatrixBoxSphereIntersectionMilpConstraints
      struct /* AddRotationMatrixBoxSphereIntersectionMilpConstraints */ {

        // drake/solvers/mixed_integer_rotation_constraint.h:226
        const char* doc =
R"""(Adds binary variables that constrain the value of the column *and* row
vectors of R, in order to add the following (in some cases non-convex)
constraints as an MILP. Specifically, for column vectors Ri, we
constrain: - forall i, |Ri| = 1 ± envelope, - forall i,j. i ≠ j,
Ri.dot(Rj) = 0 ± envelope, - R2 = R0.cross(R1) ± envelope, and again
for R0=R1.cross(R2), and R1=R2.cross(R0).

Then all of the same constraints are also added to R^T. The size of
the envelope decreases quickly as num_binary_variables_per_half_axis
is is increased.

Note: Creates `9*2*num_binary_variables_per_half_axis binary`
variables named "BRpos*(*,*)" and "BRneg*(*,*)", and the same number
of continuous variables named "CRpos*(*,*)" and "CRneg*(*,*)".

Note: The particular representation/algorithm here was developed in an
attempt: - to enable efficient reuse of the variables between the
constraints between multiple rows/columns (e.g. the constraints on Rᵀ
use the same variables as the constraints on R), and - to facilitate
branch-and-bound solution techniques -- binary regions are layered so
that constraining one region establishes constraints on large portions
of SO(3), and confers hopefully "useful" constraints the on other
binary variables.

Parameter ``R``:
    The rotation matrix

Parameter ``num_intervals_per_half_axis``:
    number of intervals for a half axis.

Parameter ``prog``:
    The mathematical program to which the constraints are added.

Note:
    This method uses the same approach as
    MixedIntegerRotationConstraintGenerator with
    kBoxSphereIntersection, namely the feasible sets to both
    relaxation are the same. But they use different sets of binary
    variables, and thus the computation speed can be different inside
    optimization solvers.)""";

      } AddRotationMatrixBoxSphereIntersectionMilpConstraints;

      // drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn
      struct /* AddRotationMatrixBoxSphereIntersectionReturn */ {

        // drake/solvers/mixed_integer_rotation_constraint.h:182
        const char* doc =
R"""(Some of the newly added variables in function
AddRotationMatrixBoxSphereIntersectionMilpConstraints. CRpos, CRneg,
BRpos and BRneg can only take value 0 or 1. `CRpos` and `CRneg` are
declared as continuous variables, while `BRpos` and `BRneg` are
declared as binary variables. The definition for these variables are

```
CRpos[k](i, j) = 1 => k / N <= R(i, j) <= (k+1) / N
  CRneg[k](i, j) = 1 => -(k+1) / N <= R(i, j) <= -k / N
  BRpos[k](i, j) = 1 => R(i, j) >= k / N
  BRneg[k](i, j) = 1 => R(i, j) <= -k / N
```

where `N` is `num_intervals_per_half_axis`, one of the input argument
of AddRotationMatrixBoxSphereIntersectionMilpConstraints.)""";

        // drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::BRneg
        struct /* BRneg */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:186
          const char* doc = R"""()""";

        } BRneg;

        // drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::BRpos
        struct /* BRpos */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:185
          const char* doc = R"""()""";

        } BRpos;

        // drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::CRneg
        struct /* CRneg */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:184
          const char* doc = R"""()""";

        } CRneg;

        // drake::solvers::AddRotationMatrixBoxSphereIntersectionReturn::CRpos
        struct /* CRpos */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:183
          const char* doc = R"""()""";

        } CRpos;

      } AddRotationMatrixBoxSphereIntersectionReturn;

      // drake::solvers::AddRotationMatrixOrthonormalSocpConstraint
      struct /* AddRotationMatrixOrthonormalSocpConstraint */ {

        // drake/solvers/rotation_constraint.h:90
        const char* doc =
R"""(Adds a set of convex constraints which approximate the set of
orthogonal matrices, O(3). Adds the bilinear constraints that the each
column Ri has length <= 1 and that Ri'Rj approx 0 via -2 + |Ri|^2 +
|Rj|^2 <= 2Ri'Rj <= 2 - |Ri|^2 - |Rj|^2 (for all i!=j), using a
second-order-cone relaxation. Additionally, the same constraints are
applied to all of the rows.)""";

      } AddRotationMatrixOrthonormalSocpConstraint;

      // drake::solvers::AddRotationMatrixSpectrahedralSdpConstraint
      struct /* AddRotationMatrixSpectrahedralSdpConstraint */ {

        // drake/solvers/rotation_constraint.h:80
        const char* doc =
R"""(Adds constraint (10) from https://arxiv.org/pdf/1403.4914.pdf , which
exactly represents the convex hull of all rotation matrices in 3D.)""";

      } AddRotationMatrixSpectrahedralSdpConstraint;

      // drake::solvers::AddSos2Constraint
      struct /* AddSos2Constraint */ {

        // drake/solvers/mixed_integer_optimization_util.h:105
        const char* doc =
R"""(Adds the special ordered set 2 (SOS2) constraint. y(i) takes binary
values (either 0 or 1).

```
y(i) = 1 => λ(i) + λ(i + 1) = 1.
```

See also:
    AddLogarithmicSos2Constraint for a complete explanation on SOS2
    constraint.

Parameter ``prog``:
    The optimization program to which the SOS2 constraint is added.

Parameter ``lambda``:
    At most two entries in λ can be strictly positive, and these two
    entries have to be adjacent. All other entries are zero. Moreover,
    these two entries should sum up to 1.

Parameter ``y``:
    y(i) takes binary value, and determines which two entries in λ can
    be strictly positive. Throw a runtime error if y.rows() !=
    lambda.rows() - 1.)""";

      } AddSos2Constraint;

      // drake::solvers::Binding
      struct /* Binding */ {

        // drake/solvers/binding.h:18
        const char* doc =
R"""(A binding on constraint type C is a mapping of the decision variables
onto the inputs of C. This allows the constraint to operate on a
vector made up of different elements of the decision variables.)""";

        // drake::solvers::Binding::Binding<C>
        struct /* ctor */ {

          // drake/solvers/binding.h:20
          const char* doc = R"""()""";

          // drake/solvers/binding.h:20
          const char* doc_2 = R"""()""";

          // drake/solvers/binding.h:22
          const char* doc_3 = R"""()""";

          // drake/solvers/binding.h:33
          const char* doc_4 =
R"""(Concatenates each VectorDecisionVariable object in ``v`` into a single
column vector, binds this column vector of decision variables with the
constraint ``c``.)""";

          // drake/solvers/binding.h:41
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::solvers::Binding::ContainsVariable
        struct /* ContainsVariable */ {

          // drake/solvers/binding.h:55
          const char* doc =
R"""(Returns true iff the given ``var`` is included in this Binding.)""";

        } ContainsVariable;

        // drake::solvers::Binding::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/solvers/binding.h:20
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::solvers::Binding::GetNumElements
        struct /* GetNumElements */ {

          // drake/solvers/binding.h:64
          const char* doc = R"""()""";

        } GetNumElements;

        // drake::solvers::Binding::constraint
        struct /* constraint */ {

          // drake/solvers/binding.h:47
          const char* doc = R"""()""";

        } constraint;

        // drake::solvers::Binding::evaluator
        struct /* evaluator */ {

          // drake/solvers/binding.h:49
          const char* doc = R"""()""";

        } evaluator;

        // drake::solvers::Binding::variables
        struct /* variables */ {

          // drake/solvers/binding.h:51
          const char* doc = R"""()""";

        } variables;

      } Binding;

      // drake::solvers::BoundingBoxConstraint
      struct /* BoundingBoxConstraint */ {

        // drake/solvers/constraint.h:611
        const char* doc =
R"""(Implements a constraint of the form @f lb <= x <= ub @f

Note: the base Constraint class (as implemented at the moment) could
play this role. But this class enforces that it is ONLY a bounding box
constraint, and not something more general. Some solvers use this
information to handle bounding box constraints differently than
general constraints, so use of this form is encouraged.)""";

        // drake::solvers::BoundingBoxConstraint::BoundingBoxConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:613
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:613
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:616
          const char* doc_3 = R"""()""";

        } ctor;

      } BoundingBoxConstraint;

      // drake::solvers::CeilLog2
      struct /* CeilLog2 */ {

        // drake/solvers/mixed_integer_optimization_util.h:15
        const char* doc =
R"""(Return ⌈log₂(n)⌉, namely the minimal integer no smaller than log₂(n),
with base 2.

Parameter ``n``:
    A positive integer.

Returns:
    The minimal integer no smaller than log₂(n).)""";

      } CeilLog2;

      // drake::solvers::ConcatenateIndeterminatesRefList
      struct /* ConcatenateIndeterminatesRefList */ {

        // drake/solvers/indeterminate.h:51
        const char* doc =
R"""(Concatenates each element in ``var_list`` into a single Eigen vector
of indeterminates, returns this concatenated vector.)""";

      } ConcatenateIndeterminatesRefList;

      // drake::solvers::ConcatenateVariableRefList
      struct /* ConcatenateVariableRefList */ {

        // drake/solvers/decision_variable.h:25
        const char* doc =
R"""(Concatenates each element in ``var_list`` into a single Eigen vector
of decision variables, returns this concatenated vector.)""";

      } ConcatenateVariableRefList;

      // drake::solvers::Constraint
      struct /* Constraint */ {

        // drake/solvers/constraint.h:43
        const char* doc =
R"""(A constraint is a function + lower and upper bounds.

Solver interfaces must acknowledge that these constraints are mutable.
Parameters can change after the constraint is constructed and before
the call to Solve().

It should support evaluating the constraint, and adding it to an
optimization problem.)""";

        // drake::solvers::Constraint::CheckSatisfied
        struct /* CheckSatisfied */ {

          // drake/solvers/constraint.h:89
          const char* doc =
R"""(Return whether this constraint is satisfied by the given value, `x`.

Parameter ``x``:
    A `num_vars` x 1 vector.

Parameter ``tol``:
    A tolerance for bound checking.)""";

          // drake/solvers/constraint.h:95
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:101
          const char* doc_3 = R"""()""";

        } CheckSatisfied;

        // drake::solvers::Constraint::Constraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:45
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:45
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:58
          const char* doc_3 =
R"""(Constructs a constraint which has `num_constraints` rows, with an
input `num_vars` x 1 vector.

Parameter ``num_constraints``:
    . The number of rows in the constraint output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is
    unknown, then set `num_vars` to Eigen::Dynamic.

Parameter ``lb``:
    Lower bound, which must be a `num_constraints` x 1 vector.

Parameter ``ub``:
    Upper bound, which must be a `num_constraints` x 1 vector.

See also:
    Eval(...))""";

          // drake/solvers/constraint.h:76
          const char* doc_4 =
R"""(Constructs a constraint which has `num_constraints` rows, with an
input `num_vars` x 1 vector, with no bounds.

Parameter ``num_constraints``:
    . The number of rows in the constraint output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is
    unknown, then set `num_vars` to Eigen::Dynamic.

See also:
    Eval(...))""";

        } ctor;

        // drake::solvers::Constraint::DoCheckSatisfied
        struct /* DoCheckSatisfied */ {

          // drake/solvers/constraint.h:149
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:157
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:165
          const char* doc_3 = R"""()""";

        } DoCheckSatisfied;

        // drake::solvers::Constraint::UpdateLowerBound
        struct /* UpdateLowerBound */ {

          // drake/solvers/constraint.h:118
          const char* doc =
R"""(Updates the lower bound.

Note:
    if the users want to expose this method in a sub-class, do using
    Constraint::UpdateLowerBound, as in LinearConstraint.)""";

        } UpdateLowerBound;

        // drake::solvers::Constraint::UpdateUpperBound
        struct /* UpdateUpperBound */ {

          // drake/solvers/constraint.h:129
          const char* doc =
R"""(Updates the upper bound.

Note:
    if the users want to expose this method in a sub-class, do using
    Constraint::UpdateUpperBound, as in LinearConstraint.)""";

        } UpdateUpperBound;

        // drake::solvers::Constraint::lower_bound
        struct /* lower_bound */ {

          // drake/solvers/constraint.h:107
          const char* doc = R"""()""";

        } lower_bound;

        // drake::solvers::Constraint::num_constraints
        struct /* num_constraints */ {

          // drake/solvers/constraint.h:111
          const char* doc =
R"""(Number of rows in the output constraint. */)""";

        } num_constraints;

        // drake::solvers::Constraint::set_bounds
        struct /* set_bounds */ {

          // drake/solvers/constraint.h:143
          const char* doc =
R"""(Set the upper and lower bounds of the constraint.

Parameter ``lower_bound``:
    . A `num_constraints` x 1 vector.

Parameter ``upper_bound``:
    . A `num_constraints` x 1 vector.

Note:
    If the users want to expose this method in a sub-class, do using
    Constraint::set_bounds, as in LinearConstraint.)""";

        } set_bounds;

        // drake::solvers::Constraint::upper_bound
        struct /* upper_bound */ {

          // drake/solvers/constraint.h:108
          const char* doc = R"""()""";

        } upper_bound;

      } Constraint;

      // drake::solvers::ConstructMonomialBasis
      struct /* ConstructMonomialBasis */ {

        // drake/solvers/sos_basis_generator.h:22
        const char* doc =
R"""(Given input polynomial p, outputs a set M of monomials with the
following guarantee: if p = f1*f1 + f2*f2 + ... + fn*fn for some
(unknown) polynomials f1, f2, ..., fn, then the span of M contains f1,
f2, ..., fn, Given M, one can then find the polynomials fi using
semidefinite programming; see, e.g., Chapter 3 of Semidefinite
Optimization and Convex Algebraic Geometry by G. Blekherman, P.
Parrilo, R. Thomas.

Parameter ``p``:
    A polynomial

Returns:
    A vector whose entries are the elements of M)""";

      } ConstructMonomialBasis;

      // drake::solvers::Cost
      struct /* Cost */ {

        // drake/solvers/cost.h:20
        const char* doc =
R"""(Provides an abstract base for all costs.)""";

        // drake::solvers::Cost::Cost
        struct /* ctor */ {

          // drake/solvers/cost.h:22
          const char* doc = R"""()""";

          // drake/solvers/cost.h:22
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:30
          const char* doc_3 =
R"""(Constructs a cost evaluator.

Parameter ``num_vars``:
    Number of input variables.

Parameter ``description``:
    Human-friendly description.)""";

        } ctor;

      } Cost;

      // drake::solvers::CreateBinaryCodeMatchConstraint
      struct /* CreateBinaryCodeMatchConstraint */ {

        // drake/solvers/integer_optimization_util.h:88
        const char* doc =
R"""(Create linear constraints such that, when these constraints are
satisfied, match = 1 if and only if code == expected, otherwise match
= 0

Parameter ``code``:
    code(i) should only take binary values.

Parameter ``expected``:
    The expected matched value for code.

Parameter ``match``:
    an expression that takes binary value, representing if code ==
    expected

Returns:
    the linear constraints.

This function is useful integer optimization, for example, if we have
a constraint match = ((b1 == 0) && (b2 == 1) && (b3 == 1)), we can
call the function CreateBinaryCodeMatchConstraint({b1, b2, b3}, {0, 1,
1}, match) to create the constraint.)""";

      } CreateBinaryCodeMatchConstraint;

      // drake::solvers::CreateLogicalAndConstraint
      struct /* CreateLogicalAndConstraint */ {

        // drake/solvers/integer_optimization_util.h:26
        const char* doc =
R"""(Adds linear constraints, such that when b1, b2, b1_and_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_and_b2 = b1 ∧ b2 (b1 and b2). The constraints are

```
b1_and_b2 >= b1 + b2 - 1
  b1_and_b2 <= b1
  b1_and_b2 <= b2
  0 <= b1_and_b2 <= 1
```

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_and_b2``:
    Should be the logical and between `b1` and `b2`.

Returns:
    The newly added constraints, such that when b1, b2, b1_and_b2
    satisfy the constraints, it is guaranteed that b1_and_b2 = b1 ∧
    b2. @pre b1, b2, b1_and_b2 are all linear expressions.)""";

      } CreateLogicalAndConstraint;

      // drake::solvers::CreateLogicalOrConstraint
      struct /* CreateLogicalOrConstraint */ {

        // drake/solvers/integer_optimization_util.h:48
        const char* doc =
R"""(Adds linear constraints, such that when b1, b2, b1_or_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_or_b2 = b1 ∨ b2 (b1 or b2). The constraints are

```
b1_or_b2 <= b1 + b2
  b1_or_b2 >= b1
  b1_or_b2 >= b2
  0 <= b1_or_b2 <= 1
```

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_or_b2``:
    Should be the logical or between `b1` and `b2`.

Returns:
    The newly added constraints, such that when b1, b2, b1_or_b2
    satisfy the constraints, it is guaranteed that b1_or_b2 = b1 ∨ b2.
    @pre b1, b2, b1_or_b2 are all linear expressions.)""";

      } CreateLogicalOrConstraint;

      // drake::solvers::CreateLogicalXorConstraint
      struct /* CreateLogicalXorConstraint */ {

        // drake/solvers/integer_optimization_util.h:71
        const char* doc =
R"""(Add linear constraints, such that when b1, b2, b1_xor_b2 satisfy the
constraints, and b1, b2 take binary values, it is guaranteed that
b1_xor_b2 = b1 ⊕ b2 (b1 exclusive xor b2). The constraints are

```
b1_xor_b2 <= b1 + b2
  b1_xor_b2 >= b1 - b2
  b1_xor_b2 >= b2 - b1
  b1_xor_b2 <= 2 - b1 - b2
  0 <= b1_xor_b2 <= 1
```

Parameter ``b1``:
    An expression that should only take a binary value.

Parameter ``b2``:
    An expression that should only take a binary value.

Parameter ``b1_xor_b2``:
    Should be the logical exclusive or between `b1` and `b2`.

Returns:
    The newly added constraints, such that when b1, b2, b1_xor_b2
    satisfy the constraints, it is guaranteed that b1_xor_b2 = b1 ⊕
    b2. @pre b1, b2, b1_xor_b2 are all linear expressions.)""";

      } CreateLogicalXorConstraint;

      // drake::solvers::DecomposeNonConvexQuadraticForm
      struct /* DecomposeNonConvexQuadraticForm */ {

        // drake/solvers/non_convex_optimization_util.h:42
        const char* doc =
R"""(For a non-convex homogeneous quadratic form xᵀQx, where Q is not
necessarily a positive semidefinite matrix, we decompose it as a
difference between two convex homogeneous quadratic forms xᵀQx = xᵀQ₁x
- xᵀQ₂x, Q₁, Q₂ are positive semidefinite. To find the optimal Q₁ and
Q₂, we solve the following semidefinite programming problem min s s.t
s >= trace(Q₁) s >= trace(Q₂) Q₁ - Q₂ = (Q + Qᵀ) / 2 Q₁, Q₂ are
positive semidefinite The decomposition Q = Q₁ - Q₂ can be used later,
to solve the non-convex optimization problem involving a quadratic
form xᵀQx. For more information, please refer to the papers on
difference of convex decomposition, for example Undominated d.c
Decompositions of Quadratic Functions and Applications to Branch-and-
Bound Approaches By I.M.Bomze and M. Locatelli Computational
Optimization and Applications, 2004 DC Decomposition of Nonconvex
Polynomials with Algebraic Techniques By A. A. Ahmadi and G. Hall
Mathematical Programming, 2015

Parameter ``Q``:
    A square matrix. Throws a runtime_error if Q is not square.

Returns:
    The optimal decomposition (Q₁, Q₂) TODO(hongkai.dai): templatize
    this function, to avoid dynamic memory allocation.)""";

      } DecomposeNonConvexQuadraticForm;

      // drake::solvers::DrealSolver
      struct /* DrealSolver */ {

        // drake/solvers/dreal_solver.h:17
        const char* doc = R"""()""";

        // drake::solvers::DrealSolver::CheckSatisfiability
        struct /* CheckSatisfiability */ {

          // drake/solvers/dreal_solver.h:50
          const char* doc =
R"""(Checks the satisfiability of a given formula ``f`` with a given
precision ``delta``.

Returns:
    a model, a mapping from a variable to an interval, if ``f`` is
    δ-satisfiable.

Returns:
    a nullopt, if ``is`` unsatisfiable.)""";

        } CheckSatisfiability;

        // drake::solvers::DrealSolver::DrealSolver
        struct /* ctor */ {

          // drake/solvers/dreal_solver.h:28
          const char* doc = R"""()""";

          // drake/solvers/dreal_solver.h:28
          const char* doc_2 = R"""()""";

          // drake/solvers/dreal_solver.h:30
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::DrealSolver::LocalOptimization
        struct /* LocalOptimization */ {

          // drake/solvers/dreal_solver.h:23
          const char* doc =
R"""(Indicates whether to use dReal's --local-optimization option or not.)""";

          // drake::solvers::DrealSolver::LocalOptimization::kNotUse
          struct /* kNotUse */ {

            // drake/solvers/dreal_solver.h:25
            const char* doc =
R"""(< Do not use "--local-optimization" option.)""";

          } kNotUse;

          // drake::solvers::DrealSolver::LocalOptimization::kUse
          struct /* kUse */ {

            // drake/solvers/dreal_solver.h:24
            const char* doc = R"""(< Use "--local-optimization" option.)""";

          } kUse;

        } LocalOptimization;

        // drake::solvers::DrealSolver::Minimize
        struct /* Minimize */ {

          // drake/solvers/dreal_solver.h:62
          const char* doc =
R"""(Finds a solution to minimize ``objective`` function while satisfying a
given ``constraint`` using ``delta``. When ``local_optimization`` is
Localoptimization::kUse, enable "--local-optimization" dReal option
which uses NLopt's local-optimization algorithms to refine
counterexamples in the process of global optimization.

Returns:
    a model, a mapping from a variable to an interval, if a solution
    exists.

Returns:
    nullopt, if there is no solution.)""";

        } Minimize;

        // drake::solvers::DrealSolver::Solve
        struct /* Solve */ {

          // drake/solvers/dreal_solver.h:37
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::DrealSolver::available
        struct /* available */ {

          // drake/solvers/dreal_solver.h:35
          const char* doc = R"""()""";

        } available;

        // drake::solvers::DrealSolver::id
        struct /* id */ {

          // drake/solvers/dreal_solver.h:42
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::DrealSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/dreal_solver.h:39
          const char* doc = R"""()""";

        } solver_id;

      } DrealSolver;

      // drake::solvers::EnumerateIntegerSolutions
      struct /* EnumerateIntegerSolutions */ {

        // drake/solvers/integer_inequality_solver.h:20
        const char* doc =
R"""(Finds all integer solutions x to the linear inequalities

```
Ax <= b,
                   x <= upper_bound,
                   x >= lower_bound.
```

Parameter ``A``:
    An (m x n) integer matrix.

Parameter ``b``:
    An (m x 1) integer vector.

Parameter ``upper_bound``:
    A (n x 1) integer vector.

Parameter ``lower_bound``:
    A (n x 1) integer vector.

Returns:
    A (p x n) matrix whose rows are the solutions.)""";

      } EnumerateIntegerSolutions;

      // drake::solvers::EqualityConstrainedQPSolver
      struct /* EqualityConstrainedQPSolver */ {

        // drake/solvers/equality_constrained_qp_solver.h:11
        const char* doc = R"""()""";

        // drake::solvers::EqualityConstrainedQPSolver::EqualityConstrainedQPSolver
        struct /* ctor */ {

          // drake/solvers/equality_constrained_qp_solver.h:13
          const char* doc = R"""()""";

          // drake/solvers/equality_constrained_qp_solver.h:13
          const char* doc_2 = R"""()""";

          // drake/solvers/equality_constrained_qp_solver.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::EqualityConstrainedQPSolver::Solve
        struct /* Solve */ {

          // drake/solvers/equality_constrained_qp_solver.h:27
          const char* doc =
R"""(Solve the qudratic program with equality constraint. The user can set
the following options FeasibilityTol. The feasible solution (both
primal and dual variables) should satisfy their constraints, with
error no larger than this value. The default is
Eigen::dummy_precision().)""";

        } Solve;

        // drake::solvers::EqualityConstrainedQPSolver::available
        struct /* available */ {

          // drake/solvers/equality_constrained_qp_solver.h:18
          const char* doc = R"""()""";

        } available;

        // drake::solvers::EqualityConstrainedQPSolver::id
        struct /* id */ {

          // drake/solvers/equality_constrained_qp_solver.h:32
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::EqualityConstrainedQPSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/equality_constrained_qp_solver.h:29
          const char* doc = R"""()""";

        } solver_id;

      } EqualityConstrainedQPSolver;

      // drake::solvers::EvaluatorBase
      struct /* EvaluatorBase */ {

        // drake/solvers/evaluator_base.h:30
        const char* doc =
R"""(Provides an abstract interface to represent an expression, mapping a
fixed or dynamic number of inputs to a fixed number of outputs, that
may be evaluated on a scalar type of double or AutoDiffXd.

These objects, and its derivatives, are meant to be bound to a given
set of variables using the Binding<> class.)""";

        // drake::solvers::EvaluatorBase::DoEval
        struct /* DoEval */ {

          // drake/solvers/evaluator_base.h:119
          const char* doc =
R"""(Implements expression evaluation for scalar type double.

Parameter ``x``:
    Input vector.

Parameter ``y``:
    Output vector. @pre x must be of size `num_vars` x 1. @post y will
    be of size `num_outputs` x 1.)""";

          // drake/solvers/evaluator_base.h:129
          const char* doc_2 =
R"""(Implements expression evaluation for scalar type AutoDiffXd.

Parameter ``x``:
    Input vector.

Parameter ``y``:
    Output vector. @pre x must be of size `num_vars` x 1. @post y will
    be of size `num_outputs` x 1.)""";

          // drake/solvers/evaluator_base.h:139
          const char* doc_3 =
R"""(Implements expression evaluation for scalar type symbolic::Expression.

Parameter ``x``:
    Input vector.

Parameter ``y``:
    Output vector. @pre x must be of size `num_vars` x 1. @post y will
    be of size `num_outputs` x 1.)""";

        } DoEval;

        // drake::solvers::EvaluatorBase::Eval
        struct /* Eval */ {

          // drake/solvers/evaluator_base.h:43
          const char* doc =
R"""(Evaluates the expression with a scalar type of double.

Parameter ``x``:
    A `num_vars` x 1 input vector.

Parameter ``y``:
    A `num_outputs` x 1 output vector.)""";

          // drake/solvers/evaluator_base.h:57
          const char* doc_2 =
R"""(Evaluates the expression with a scalar type of AutoDiffXd.

Parameter ``x``:
    A `num_vars` x 1 input vector.

Parameter ``y``:
    A `num_outputs` x 1 output vector.)""";

          // drake/solvers/evaluator_base.h:67
          const char* doc_3 =
R"""(Evaluates the expression with a scalar type of symbolic::Expression.

Parameter ``x``:
    A `num_vars` x 1 input vector.

Parameter ``y``:
    A `num_outputs` x 1 output vector.)""";

        } Eval;

        // drake::solvers::EvaluatorBase::EvaluatorBase
        struct /* ctor */ {

          // drake/solvers/evaluator_base.h:32
          const char* doc = R"""()""";

          // drake/solvers/evaluator_base.h:32
          const char* doc_2 = R"""()""";

          // drake/solvers/evaluator_base.h:106
          const char* doc_3 =
R"""(Constructs a evaluator.

Parameter ``num_outputs``:
    . The number of rows in the output.

Parameter ``num_vars``:
    . The number of rows in the input. If the input dimension is not
    known, then set `num_vars` to Eigen::Dynamic.

Parameter ``description``:
    A human-friendly description.

See also:
    Eval(...))""";

        } ctor;

        // drake::solvers::EvaluatorBase::get_description
        struct /* get_description */ {

          // drake/solvers/evaluator_base.h:83
          const char* doc =
R"""(Getter for a human-friendly description for the evaluator.)""";

        } get_description;

        // drake::solvers::EvaluatorBase::num_outputs
        struct /* num_outputs */ {

          // drake/solvers/evaluator_base.h:95
          const char* doc =
R"""(Getter for the number of outputs, namely the number of rows in y, as
used in Eval(x, y).)""";

        } num_outputs;

        // drake::solvers::EvaluatorBase::num_vars
        struct /* num_vars */ {

          // drake/solvers/evaluator_base.h:89
          const char* doc =
R"""(Getter for the number of variables, namely the number of rows in x, as
used in Eval(x, y).)""";

        } num_vars;

        // drake::solvers::EvaluatorBase::set_description
        struct /* set_description */ {

          // drake/solvers/evaluator_base.h:76
          const char* doc =
R"""(Set a human-friendly description for the evaluator.)""";

        } set_description;

        // drake::solvers::EvaluatorBase::set_num_outputs
        struct /* set_num_outputs */ {

          // drake/solvers/evaluator_base.h:147
          const char* doc = R"""()""";

        } set_num_outputs;

      } EvaluatorBase;

      // drake::solvers::EvaluatorConstraint
      struct /* EvaluatorConstraint */ {

        // drake/solvers/constraint.h:394
        const char* doc =
R"""(A constraint that may be specified using another (potentially
nonlinear) evaluator.

Template parameter ``EvaluatorType``:
    The nested evaluator.)""";

        // drake::solvers::EvaluatorConstraint::EvaluatorConstraint<EvaluatorType>
        struct /* ctor */ {

          // drake/solvers/constraint.h:396
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:396
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:406
          const char* doc_3 =
R"""(Constructs an evaluator constraint, given the EvaluatorType instance
(which will specify the number of constraints and variables), and will
forward the remaining arguments to the Constraint constructor.

Parameter ``evaluator``:
    EvaluatorType instance.

Parameter ``args``:
    Arguments to be forwarded to the constraint constructor.)""";

        } ctor;

        // drake::solvers::EvaluatorConstraint::evaluator
        struct /* evaluator */ {

          // drake/solvers/constraint.h:418
          const char* doc = R"""(Reference to the nested evaluator. */)""";

        } evaluator;

      } EvaluatorConstraint;

      // drake::solvers::EvaluatorCost
      struct /* EvaluatorCost */ {

        // drake/solvers/cost.h:190
        const char* doc =
R"""(A cost that may be specified using another (potentially nonlinear)
evaluator.

Template parameter ``EvaluatorType``:
    The nested evaluator.)""";

        // drake::solvers::EvaluatorCost::DoEval
        struct /* DoEval */ {

          // drake/solvers/cost.h:201
          const char* doc = R"""()""";

          // drake/solvers/cost.h:205
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:210
          const char* doc_3 = R"""()""";

        } DoEval;

        // drake::solvers::EvaluatorCost::EvaluatorCost<EvaluatorType>
        struct /* ctor */ {

          // drake/solvers/cost.h:192
          const char* doc = R"""()""";

          // drake/solvers/cost.h:192
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:194
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::EvaluatorCost::evaluator
        struct /* evaluator */ {

          // drake/solvers/cost.h:200
          const char* doc = R"""()""";

        } evaluator;

      } EvaluatorCost;

      // drake::solvers::ExpressionConstraint
      struct /* ExpressionConstraint */ {

        // drake/solvers/constraint.h:863
        const char* doc =
R"""(Impose a generic (potentially nonlinear) constraint represented as a
vector of symbolic Expression. Expression::Evaluate is called on every
constraint evaluation.

Uses symbolic::Jacobian to provide the gradients to the AutoDiff
method.)""";

        // drake::solvers::ExpressionConstraint::DoEval
        struct /* DoEval */ {

          // drake/solvers/constraint.h:885
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:888
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:891
          const char* doc_3 = R"""()""";

        } DoEval;

        // drake::solvers::ExpressionConstraint::ExpressionConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:865
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:865
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:867
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::ExpressionConstraint::expressions
        struct /* expressions */ {

          // drake/solvers/constraint.h:880
          const char* doc =
R"""(Returns:
    the symbolic expressions. */)""";

        } expressions;

        // drake::solvers::ExpressionConstraint::vars
        struct /* vars */ {

          // drake/solvers/constraint.h:877
          const char* doc =
R"""(Returns:
    the list of the variables involved in the vector of expressions,
    in the order that they are expected to be received during DoEval.
    Any Binding that connects this constraint to decision variables
    should pass this list of variables to the Binding.)""";

        } vars;

      } ExpressionConstraint;

      // drake::solvers::FunctionEvaluator
      struct /* FunctionEvaluator */ {

        // drake/solvers/evaluator_base.h:217
        const char* doc =
R"""(An evaluator that may be specified using a callable object. Consider
constructing these instances using MakeFunctionEvaluator(...).

Template parameter ``F``:
    The function / functor's type.

See also:
    detail::FunctionTraits.)""";

        // drake::solvers::FunctionEvaluator::FunctionEvaluator<F>
        struct /* ctor */ {

          // drake/solvers/evaluator_base.h:219
          const char* doc = R"""()""";

          // drake/solvers/evaluator_base.h:219
          const char* doc_2 = R"""()""";

          // drake/solvers/evaluator_base.h:229
          const char* doc_3 =
R"""(Constructs an instance by copying from an lvalue or rvalue of `F`.

Template parameter ``FF``:
    Perfect-forwarding type of `F` (e.g., `const F&`, `F&&`).

Parameter ``f``:
    The callable object. If rvalue, this value will be std::move'd.
    Otherwise, it will be copied.

Parameter ``args``:
    Arguments to be forwarded to EvaluatorBase constructor.)""";

        } ctor;

      } FunctionEvaluator;

      // drake::solvers::GurobiSolver
      struct /* GurobiSolver */ {

        // drake/solvers/gurobi_solver.h:15
        const char* doc = R"""()""";

        // drake::solvers::GurobiSolver::AcquireLicense
        struct /* AcquireLicense */ {

          // drake/solvers/gurobi_solver.h:134
          const char* doc =
R"""(This acquires a Gurobi license environment shared among all
GurobiSolver instances; the environment will stay valid as long as at
least one shared_ptr returned by this function is alive. Call this
ONLY if you must use different MathematicalProgram instances at
different instances in time, and repeatedly acquiring the license is
costly (e.g., requires contacting a license server).

Returns:
    A shared pointer to a license environment that will stay valid as
    long as any shared_ptr returned by this function is alive. If
    Gurobi not available in your build, this will return a null
    (empty) shared_ptr.

Throws:
    s std::runtime_error if Gurobi is available but a license cannot
    be obtained.)""";

        } AcquireLicense;

        // drake::solvers::GurobiSolver::AddMipNodeCallback
        struct /* AddMipNodeCallback */ {

          // drake/solvers/gurobi_solver.h:76
          const char* doc =
R"""(Registers a callback to be called at intermediate solutions during the
solve.

Parameter ``callback``:
    User callback function.

Parameter ``user_data``:
    Arbitrary data that will be passed to the user callback function.)""";

        } AddMipNodeCallback;

        // drake::solvers::GurobiSolver::AddMipSolCallback
        struct /* AddMipSolCallback */ {

          // drake/solvers/gurobi_solver.h:103
          const char* doc =
R"""(Registers a callback to be called at feasible solutions during the
solve.

Parameter ``callback``:
    User callback function.

Parameter ``usrdata``:
    Arbitrary data that will be passed to the user callback function.)""";

        } AddMipSolCallback;

        // drake::solvers::GurobiSolver::GurobiSolver
        struct /* ctor */ {

          // drake/solvers/gurobi_solver.h:17
          const char* doc = R"""()""";

          // drake/solvers/gurobi_solver.h:17
          const char* doc_2 = R"""()""";

          // drake/solvers/gurobi_solver.h:19
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::GurobiSolver::License
        struct /* License */ {

          // drake/solvers/gurobi_solver.h:118
          const char* doc =
R"""(This type contains a valid Gurobi license environment, and is only to
be used from AcquireLicense().)""";

        } License;

        // drake::solvers::GurobiSolver::Solve
        struct /* Solve */ {

          // drake/solvers/gurobi_solver.h:107
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::GurobiSolver::SolveStatusInfo
        struct /* SolveStatusInfo */ {

          // drake/solvers/gurobi_solver.h:30
          const char* doc =
R"""(Contains info returned to a user function that handles a Node or
Solution callback.

See also:
    MipNodeCallbackFunction

See also:
    MipSolCallbackFunction)""";

          // drake::solvers::GurobiSolver::SolveStatusInfo::best_bound
          struct /* best_bound */ {

            // drake/solvers/gurobi_solver.h:38
            const char* doc = R"""(Best known objective lower bound.)""";

          } best_bound;

          // drake::solvers::GurobiSolver::SolveStatusInfo::best_objective
          struct /* best_objective */ {

            // drake/solvers/gurobi_solver.h:36
            const char* doc = R"""(Objective of best solution yet.)""";

          } best_objective;

          // drake::solvers::GurobiSolver::SolveStatusInfo::current_objective
          struct /* current_objective */ {

            // drake/solvers/gurobi_solver.h:34
            const char* doc = R"""(Objective of current solution.)""";

          } current_objective;

          // drake::solvers::GurobiSolver::SolveStatusInfo::explored_node_count
          struct /* explored_node_count */ {

            // drake/solvers/gurobi_solver.h:40
            const char* doc = R"""(Number of nodes explored so far.)""";

          } explored_node_count;

          // drake::solvers::GurobiSolver::SolveStatusInfo::feasible_solutions_count
          struct /* feasible_solutions_count */ {

            // drake/solvers/gurobi_solver.h:42
            const char* doc = R"""(Number of feasible sols found so far.)""";

          } feasible_solutions_count;

          // drake::solvers::GurobiSolver::SolveStatusInfo::reported_runtime
          struct /* reported_runtime */ {

            // drake/solvers/gurobi_solver.h:32
            const char* doc = R"""(Runtime as of this callback.)""";

          } reported_runtime;

        } SolveStatusInfo;

        // drake::solvers::GurobiSolver::available
        struct /* available */ {

          // drake/solvers/gurobi_solver.h:24
          const char* doc = R"""()""";

        } available;

        // drake::solvers::GurobiSolver::id
        struct /* id */ {

          // drake/solvers/gurobi_solver.h:112
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::GurobiSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/gurobi_solver.h:109
          const char* doc = R"""()""";

        } solver_id;

      } GurobiSolver;

      // drake::solvers::IntervalBinning
      struct /* IntervalBinning */ {

        // drake/solvers/mixed_integer_optimization_util.h:146
        const char* doc =
R"""(For a continuous variable whose range is cut into small intervals, we
will use binary variables to represent which interval the continuous
variable is in. We support two representations, either using
logarithmic number of binary variables, or linear number of binary
variables. For more details,

See also:
    AddLogarithmicSos2Constraint and AddSos2Constraint)""";

        // drake::solvers::IntervalBinning::kLinear
        struct /* kLinear */ {

          // drake/solvers/mixed_integer_optimization_util.h:148
          const char* doc = R"""()""";

        } kLinear;

        // drake::solvers::IntervalBinning::kLogarithmic
        struct /* kLogarithmic */ {

          // drake/solvers/mixed_integer_optimization_util.h:147
          const char* doc = R"""()""";

        } kLogarithmic;

      } IntervalBinning;

      // drake::solvers::IpoptSolver
      struct /* IpoptSolver */ {

        // drake/solvers/ipopt_solver.h:11
        const char* doc = R"""()""";

        // drake::solvers::IpoptSolver::IpoptSolver
        struct /* ctor */ {

          // drake/solvers/ipopt_solver.h:13
          const char* doc = R"""()""";

          // drake/solvers/ipopt_solver.h:13
          const char* doc_2 = R"""()""";

          // drake/solvers/ipopt_solver.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::IpoptSolver::Solve
        struct /* Solve */ {

          // drake/solvers/ipopt_solver.h:22
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::IpoptSolver::available
        struct /* available */ {

          // drake/solvers/ipopt_solver.h:20
          const char* doc = R"""()""";

        } available;

        // drake::solvers::IpoptSolver::id
        struct /* id */ {

          // drake/solvers/ipopt_solver.h:27
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::IpoptSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/ipopt_solver.h:24
          const char* doc = R"""()""";

        } solver_id;

      } IpoptSolver;

      // drake::solvers::LinearComplementarityConstraint
      struct /* LinearComplementarityConstraint */ {

        // drake/solvers/constraint.h:650
        const char* doc =
R"""(Implements a constraint of the form:

```
Mx + q >= 0
  x >= 0
  x'(Mx + q) == 0
```

An implied slack variable complements any 0 component of x. To get the
slack values at a given solution x, use Eval(x).)""";

        // drake::solvers::LinearComplementarityConstraint::DoCheckSatisfied
        struct /* DoCheckSatisfied */ {

          // drake/solvers/constraint.h:674
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:677
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:680
          const char* doc_3 = R"""()""";

        } DoCheckSatisfied;

        // drake::solvers::LinearComplementarityConstraint::DoEval
        struct /* DoEval */ {

          // drake/solvers/constraint.h:665
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:668
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:671
          const char* doc_3 = R"""()""";

        } DoEval;

        // drake::solvers::LinearComplementarityConstraint::LinearComplementarityConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:652
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:652
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:655
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::LinearComplementarityConstraint::M
        struct /* M */ {

          // drake/solvers/constraint.h:661
          const char* doc = R"""()""";

        } M;

        // drake::solvers::LinearComplementarityConstraint::q
        struct /* q */ {

          // drake/solvers/constraint.h:662
          const char* doc = R"""()""";

        } q;

      } LinearComplementarityConstraint;

      // drake::solvers::LinearConstraint
      struct /* LinearConstraint */ {

        // drake/solvers/constraint.h:482
        const char* doc =
R"""(Implements a constraint of the form @f lb <= Ax <= ub @f)""";

        // drake::solvers::LinearConstraint::A
        struct /* A */ {

          // drake/solvers/constraint.h:501
          const char* doc = R"""()""";

        } A;

        // drake::solvers::LinearConstraint::A_
        struct /* A_ */ {

          // drake/solvers/constraint.h:548
          const char* doc = R"""()""";

        } A_;

        // drake::solvers::LinearConstraint::DoEval
        struct /* DoEval */ {

          // drake/solvers/constraint.h:539
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:542
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:545
          const char* doc_3 = R"""()""";

        } DoEval;

        // drake::solvers::LinearConstraint::GetSparseMatrix
        struct /* GetSparseMatrix */ {

          // drake/solvers/constraint.h:496
          const char* doc = R"""()""";

        } GetSparseMatrix;

        // drake::solvers::LinearConstraint::LinearConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:484
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:484
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:487
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::LinearConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {

          // drake/solvers/constraint.h:517
          const char* doc =
R"""(Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is: new_lb <= new_A * x <= new_ub
Note that the size of constraints (number of rows) can change, but the
number of variables (number of cols) cannot.

Parameter ``new_A``:
    new linear term

Parameter ``new_lb``:
    new lower bound

Parameter ``new_up``:
    new upper bound)""";

        } UpdateCoefficients;

      } LinearConstraint;

      // drake::solvers::LinearCost
      struct /* LinearCost */ {

        // drake/solvers/cost.h:37
        const char* doc =
R"""(Implements a cost of the form @f a'x + b @f.)""";

        // drake::solvers::LinearCost::DoEval
        struct /* DoEval */ {

          // drake/solvers/cost.h:80
          const char* doc = R"""()""";

          // drake/solvers/cost.h:83
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:86
          const char* doc_3 = R"""()""";

        } DoEval;

        // drake::solvers::LinearCost::GetSparseMatrix
        struct /* GetSparseMatrix */ {

          // drake/solvers/cost.h:52
          const char* doc = R"""()""";

        } GetSparseMatrix;

        // drake::solvers::LinearCost::LinearCost
        struct /* ctor */ {

          // drake/solvers/cost.h:39
          const char* doc = R"""()""";

          // drake/solvers/cost.h:39
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:47
          const char* doc_3 =
R"""(Construct a linear cost of the form @f a'x + b @f.

Parameter ``a``:
    Linear term.

Parameter ``b``:
    (optional) Constant term.)""";

        } ctor;

        // drake::solvers::LinearCost::UpdateCoefficients
        struct /* UpdateCoefficients */ {

          // drake/solvers/cost.h:69
          const char* doc =
R"""(Updates the linear term, upper and lower bounds in the linear
constraint. The updated constraint is @f a_new' x + b_new @f. Note
that the number of variables (number of cols) cannot change.

Parameter ``new_a``:
    New linear term.

Parameter ``new_b``:
    (optional) New constant term.)""";

        } UpdateCoefficients;

        // drake::solvers::LinearCost::a
        struct /* a */ {

          // drake/solvers/cost.h:58
          const char* doc = R"""()""";

        } a;

        // drake::solvers::LinearCost::b
        struct /* b */ {

          // drake/solvers/cost.h:60
          const char* doc = R"""()""";

        } b;

      } LinearCost;

      // drake::solvers::LinearEqualityConstraint
      struct /* LinearEqualityConstraint */ {

        // drake/solvers/constraint.h:559
        const char* doc =
R"""(Implements a constraint of the form @f Ax = b @f)""";

        // drake::solvers::LinearEqualityConstraint::LinearEqualityConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:561
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:561
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:564
          const char* doc_3 = R"""()""";

          // drake/solvers/constraint.h:568
          const char* doc_4 = R"""()""";

        } ctor;

        // drake::solvers::LinearEqualityConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {

          // drake/solvers/constraint.h:582
          const char* doc = R"""()""";

        } UpdateCoefficients;

      } LinearEqualityConstraint;

      // drake::solvers::LinearMatrixInequalityConstraint
      struct /* LinearMatrixInequalityConstraint */ {

        // drake/solvers/constraint.h:808
        const char* doc =
R"""(Impose the matrix inequality constraint on variable x <!--> F₀ + x₁ *
F₁ + ... xₙ * Fₙ is p.s.d <--> @f[ F_0 + x_1 F_1 + ... + x_n F_n
\text{ is p.s.d} @f] where p.s.d stands for positive semidefinite. $
F_0, F_1, ..., F_n $ are all given symmetric matrices of the same
size.)""";

        // drake::solvers::LinearMatrixInequalityConstraint::DoEval
        struct /* DoEval */ {

          // drake/solvers/constraint.h:834
          const char* doc =
R"""(Evaluate the eigen values of the linear matrix.)""";

          // drake/solvers/constraint.h:841
          const char* doc_2 =
R"""(This function is not supported, since Eigen's eigen value solver does
not accept AutoDiffScalar type.)""";

          // drake/solvers/constraint.h:848
          const char* doc_3 =
R"""(This function is not supported, since Eigen's eigen value solver does
not accept symbolic::Expression type.)""";

        } DoEval;

        // drake::solvers::LinearMatrixInequalityConstraint::F
        struct /* F */ {

          // drake/solvers/constraint.h:824
          const char* doc = R"""()""";

        } F;

        // drake::solvers::LinearMatrixInequalityConstraint::LinearMatrixInequalityConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:810
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:810
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:817
          const char* doc_3 =
R"""(Parameter ``F``:
    Each symmetric matrix F[i] should be of the same size.

Parameter ``symmetry_tolerance``:
    The precision to determine if the input matrices Fi are all
    symmetric.

See also:
    math::IsSymmetric().)""";

        } ctor;

        // drake::solvers::LinearMatrixInequalityConstraint::matrix_rows
        struct /* matrix_rows */ {

          // drake/solvers/constraint.h:828
          const char* doc =
R"""(Gets the number of rows in the matrix inequality constraint. Namely Fi
are all matrix_rows() x matrix_rows() matrices.)""";

        } matrix_rows;

      } LinearMatrixInequalityConstraint;

      // drake::solvers::LinearSystemSolver
      struct /* LinearSystemSolver */ {

        // drake/solvers/linear_system_solver.h:11
        const char* doc = R"""()""";

        // drake::solvers::LinearSystemSolver::LinearSystemSolver
        struct /* ctor */ {

          // drake/solvers/linear_system_solver.h:13
          const char* doc = R"""()""";

          // drake/solvers/linear_system_solver.h:13
          const char* doc_2 = R"""()""";

          // drake/solvers/linear_system_solver.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::LinearSystemSolver::Solve
        struct /* Solve */ {

          // drake/solvers/linear_system_solver.h:21
          const char* doc =
R"""(Find the least-square solution to the linear system A * x = b.)""";

        } Solve;

        // drake::solvers::LinearSystemSolver::available
        struct /* available */ {

          // drake/solvers/linear_system_solver.h:18
          const char* doc = R"""()""";

        } available;

        // drake::solvers::LinearSystemSolver::id
        struct /* id */ {

          // drake/solvers/linear_system_solver.h:26
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::LinearSystemSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/linear_system_solver.h:23
          const char* doc = R"""()""";

        } solver_id;

      } LinearSystemSolver;

      // drake::solvers::LogarithmicSos2NewBinaryVariables
      struct /* LogarithmicSos2NewBinaryVariables */ {

        // drake/solvers/mixed_integer_optimization_util.h:28
        const char* doc =
R"""(The size of the new binary variables in the compile time, for Special
Ordered Set of type 2 (SOS2) constraint. The SOS2 constraint says that

```
λ(0) + ... + λ(n) = 1
  ∀i. λ(i) ≥ 0
  ∃ j ∈ {0, 1, ..., n-1}, s.t λ(j) + λ(j + 1) = 1
```

Template parameter ``NumLambda``:
    The length of the lambda vector. NumLambda = n + 1.)""";

        // drake/solvers/mixed_integer_optimization_util.h:34
        const char* doc_2 = R"""()""";

      } LogarithmicSos2NewBinaryVariables;

      // drake::solvers::LorentzConeConstraint
      struct /* LorentzConeConstraint */ {

        // drake/solvers/constraint.h:288
        const char* doc =
R"""(Constraining the linear expression $ z=Ax+b $ lies within the Lorentz
cone. A vector z ∈ ℝ ⁿ lies within Lorentz cone if @f[ z_0 \ge
\sqrt{z_1^2+...+z_{n-1}^2} @f] <!--> z₀ ≥ sqrt(z₁² + ... + zₙ₋₁²) <-->
where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. Ideally this constraint
should be handled by a second-order cone solver. In case the user
wants to enforce this constraint through general nonlinear
optimization, with smooth gradient, we alternatively impose the
following constraint, with smooth gradient everywhere @f[
a_0^Tx+b_0\ge 0\\
(a_0^Tx+b_0)^2-(a_1^Tx+b_1)^2-...-(a_{n-1}^Tx+b_{n-1})^2 \ge 0 @f]
where $ a_i^T$ is the i'th row of matrix $ A$. $ b_i $ is the i'th
entry of vector $ b $.

For more information and visualization, please refer to
https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html)""";

        // drake::solvers::LorentzConeConstraint::A
        struct /* A */ {

          // drake/solvers/constraint.h:306
          const char* doc = R"""(Getter for A. */)""";

        } A;

        // drake::solvers::LorentzConeConstraint::LorentzConeConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:290
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:290
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:292
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::LorentzConeConstraint::b
        struct /* b */ {

          // drake/solvers/constraint.h:309
          const char* doc = R"""(Getter for b. */)""";

        } b;

      } LorentzConeConstraint;

      // drake::solvers::MakeFunctionCost
      struct /* MakeFunctionCost */ {

        // drake/solvers/cost.h:257
        const char* doc =
R"""(Converts an input of type ``F`` to a nonlinear cost.

Template parameter ``FF``:
    The forwarded function type (e.g., `const F&, `F&&`, ...). The
    class `F` should have functions numInputs(), numOutputs(), and
    eval(x, y).

See also:
    detail::FunctionTraits.)""";

      } MakeFunctionCost;

      // drake::solvers::MakeFunctionEvaluator
      struct /* MakeFunctionEvaluator */ {

        // drake/solvers/evaluator_base.h:274
        const char* doc =
R"""(Creates a FunctionEvaluator instance bound to a given callable object.

Template parameter ``FF``:
    Perfect-forwarding type of `F` (e.g., `const F&`, `F&&`).

Parameter ``f``:
    Callable function object.

Returns:
    An implementation of EvaluatorBase using the callable object.

See also:
    detail::FunctionTraits. @relates FunctionEvaluator)""";

      } MakeFunctionEvaluator;

      // drake::solvers::MakeL2NormCost
      struct /* MakeL2NormCost */ {

        // drake/solvers/cost.h:180
        const char* doc =
R"""(Creates a cost term of the form | Ax - b |^2.)""";

      } MakeL2NormCost;

      // drake::solvers::MakeQuadraticErrorCost
      struct /* MakeQuadraticErrorCost */ {

        // drake/solvers/cost.h:173
        const char* doc =
R"""(Creates a cost term of the form (x-x_desired)'*Q*(x-x_desired).)""";

      } MakeQuadraticErrorCost;

      // drake::solvers::MathematicalProgram
      struct /* MathematicalProgram */ {

        // drake/multibody/inverse_kinematics_backend.h:17
        const char* doc =
R"""(MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling Solve() function, and obtain the results of the optimization.)""";

        // drake/solvers/mathematical_program.h:181
        const char* doc_2 =
R"""(MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling Solve() function, and obtain the results of the optimization.)""";

        // drake/solvers/mathematical_program.h:303
        const char* doc_3 =
R"""(MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling Solve() function, and obtain the results of the optimization.)""";

        // drake/solvers/mathematical_program_solver_interface.h:14
        const char* doc_4 =
R"""(MathematicalProgram stores the decision variables, the constraints and
costs of an optimization problem. The user can solve the problem by
calling Solve() function, and obtain the results of the optimization.)""";

        // drake::solvers::MathematicalProgram::AddBoundingBoxConstraint
        struct /* AddBoundingBoxConstraint */ {

          // drake/solvers/mathematical_program.h:1515
          const char* doc =
R"""(AddBoundingBoxConstraint

Adds bounding box constraints referencing potentially a subset of the
decision variables (defined in the vars parameter). Example

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewContinuousDecisionVariables<2>("x");
auto y = prog.NewContinuousDecisionVariables<1>("y");
Eigen::Vector3d lb(0, 1, 2);
Eigen::Vector3d ub(1, 2, 3);
// Imposes the constraint
// 0 ≤ x(0) ≤ 1
// 1 ≤ x(1) ≤ 2
// 2 ≤ y    ≤ 3
prog.AddBoundingBoxConstraint(lb, ub, {x, y});
```)""";

          // drake/solvers/mathematical_program.h:1530
          const char* doc_2 =
R"""(Adds bounding box constraints referencing potentially a subset of the
decision variables.

Parameter ``lb``:
    The lower bound.

Parameter ``ub``:
    The upper bound.

Parameter ``vars``:
    Will imposes constraint lb(i) <= vars(i) <= ub(i).

Returns:
    The newly constructed BoundingBoxConstraint.)""";

          // drake/solvers/mathematical_program.h:1541
          const char* doc_3 =
R"""(Adds bounds for a single variable.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``var``:
    The decision variable.)""";

          // drake/solvers/mathematical_program.h:1553
          const char* doc_4 =
R"""(Adds the same scalar lower and upper bound to every variable in the
list.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``vars``:
    The decision variables.)""";

          // drake/solvers/mathematical_program.h:1571
          const char* doc_5 =
R"""(Adds the same scalar lower and upper bound to every variable in
``vars``.

Template parameter ``Derived``:
    An Eigen Vector type with Variable as the scalar type.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``vars``:
    The decision variables.)""";

          // drake/solvers/mathematical_program.h:1593
          const char* doc_6 =
R"""(Adds the same scalar lower and upper bound to every variable in
``vars``.

Template parameter ``Derived``:
    An Eigen::Matrix with Variable as the scalar type. The matrix has
    unknown number of columns at compile time, or has more than one
    column.

Parameter ``lb``:
    Lower bound.

Parameter ``ub``:
    Upper bound.

Parameter ``vars``:
    The decision variables.)""";

        } AddBoundingBoxConstraint;

        // drake::solvers::MathematicalProgram::AddConstraint
        struct /* AddConstraint */ {

          // drake/solvers/mathematical_program.h:1037
          const char* doc =
R"""(Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.)""";

          // drake/solvers/mathematical_program.h:1055
          const char* doc_2 =
R"""(Adds one row of constraint lb <= e <= ub where ``e`` is a symbolic
expression. Throws an exception if 1. ``lb <= e <= ub`` is a trivial
constraint such as 1 <= 2 <= 3. 2. ``lb <= e <= ub`` is unsatisfiable
such as 1 <= -5 <= 3

Parameter ``e``:
    A symbolic expression of the the decision variables.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.

The resulting constraint may be a BoundingBoxConstraint,
LinearConstraint, LinearEqualityConstraint, or ExpressionConstraint,
depending on the arguments. Constraints of the form x == 1 (which
could be created as a BoundingBoxConstraint or
LinearEqualityConstraint) will be constructed as a
LinearEqualityConstraint.)""";

          // drake/solvers/mathematical_program.h:1066
          const char* doc_3 =
R"""(Adds constraints represented by symbolic expressions to the program.
It throws if ``lb <= v <= ub`` includes trivial/unsatisfiable
constraints.

@overload Binding<Constraint> AddConstraint(const
symbolic::Expression& e, double lb, double ub))""";

          // drake/solvers/mathematical_program.h:1097
          const char* doc_4 =
R"""(Add a constraint represented by a symbolic formula to the program. The
input formula ``f`` can be of the following forms:

1. e1 <= e2 2. e1 >= e2 3. e1 == e2 4. A conjunction of relational
formulas where each conjunct is a relational formula matched by 1, 2,
or 3.

Note that first two cases might return an object of
Binding<BoundingBoxConstraint>, Binding<LinearConstraint>, or
Binding<ExpressionConstraint>, depending on ``f``. Also the third case
might return an object of Binding<LinearEqualityConstraint> or
Binding<ExpressionConstraint>.

It throws an exception if 1. ``f`` is not matched with one of the
above patterns. Especially, strict inequalities (<, >) are not
allowed. 2. ``f`` is either a trivial constraint such as "1 <= 2" or
an unsatisfiable constraint such as "2 <= 1". 3. It is not possible to
find numerical bounds of `e1` and `e2` where ``f`` = e1 ≃ e2. We allow
`e1` and `e2` to be infinite but only if there are no other terms. For
example, `x <= ∞` is allowed. However, `x - ∞ <= 0` is not allowed
because `x ↦ ∞` introduces `nan` in the evaluation.)""";

          // drake/solvers/mathematical_program.h:1131
          const char* doc_5 =
R"""(Add a constraint represented by an Eigen::Array<symbolic::Formula> to
the program. A common use-case of this function is to add a constraint
with the element-wise comparison between two Eigen matrices, using
`A.array() <= B.array()`. See the following example.

```
MathematicalProgram prog;
  Eigen::Matrix<double, 2, 2> A;
  auto x = prog.NewContinuousVariables(2, "x");
  Eigen::Vector2d b;
  ... // set up A and b
  prog.AddConstraint((A * x).array() <= b.array());
```

A formula in ``formulas`` can be of the following forms:

1. e1 <= e2 2. e1 >= e2 3. e1 == e2

It throws an exception if AddConstraint(const symbolic::Formula& f)
throws an exception for f ∈ ``formulas``.

@overload Binding<Constraint> AddConstraint(const symbolic::Formula&
f)

Template parameter ``Derived``:
    An Eigen Array type of Formula.)""";

          // drake/solvers/mathematical_program.h:1142
          const char* doc_6 =
R"""(Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.)""";

          // drake/solvers/mathematical_program.h:1153
          const char* doc_7 =
R"""(Adds a generic constraint to the program. This should only be used if
a more specific type of constraint is not available, as it may require
the use of a significantly more expensive solver.)""";

          // drake/solvers/mathematical_program.h:1162
          const char* doc_8 =
R"""(Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).)""";

          // drake/solvers/mathematical_program.h:1318
          const char* doc_9 =
R"""(Adds linear equality constraints referencing potentially a subset of
the decision variables.)""";

          // drake/solvers/mathematical_program.h:1494
          const char* doc_10 =
R"""(Adds bounding box constraints referencing potentially a subest of the
decision variables.

Parameter ``binding``:
    Binds a BoundingBoxConstraint with some decision variables, such
    that binding.evaluator()->lower_bound()(i) <=
    binding.variables()(i) <= binding.evaluator().upper_bound()(i))""";

          // drake/solvers/mathematical_program.h:1623
          const char* doc_11 =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables. The linear expression $ z=Ax+b $ is in the Lorentz
cone. A vector $ z \in\mathbb{R}^n $ is in the Lorentz cone, if <!--
z(0) >= sqrt{z(1)² + ... + z(n-1)²} --> @f[ z_0 \ge \sqrt{z_1^2 + ...
+ z_{n-1}^2} @f])""";

          // drake/solvers/mathematical_program.h:1768
          const char* doc_12 =
R"""(Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables. The linear expression $ z=Ax+b $ is in
rotated Lorentz cone. A vector $ z \in\mathbb{R}^n $ is in the rotated
Lorentz cone, if <!-- z(0)*z(1) >= z(2)² + ... + z(n-1)² --> @f[
z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 @f])""";

          // drake/solvers/mathematical_program.h:1914
          const char* doc_13 =
R"""(Adds a linear complementarity constraints referencing a subset of the
decision variables.)""";

          // drake/solvers/mathematical_program.h:1963
          const char* doc_14 =
R"""(Adds a positive semidefinite constraint on a symmetric matrix.)""";

          // drake/solvers/mathematical_program.h:1969
          const char* doc_15 =
R"""(Adds a positive semidefinite constraint on a symmetric matrix.)""";

          // drake/solvers/mathematical_program.h:2022
          const char* doc_16 =
R"""(Adds a linear matrix inequality constraint to the program.)""";

        } AddConstraint;

        // drake::solvers::MathematicalProgram::AddCost
        struct /* AddCost */ {

          // drake/solvers/mathematical_program.h:808
          const char* doc =
R"""(Adds a generic cost to the optimization program.)""";

          // drake/solvers/mathematical_program.h:816
          const char* doc_2 =
R"""(Adds a cost type to the optimization program.

Parameter ``obj``:
    The added objective.

Parameter ``vars``:
    The decision variables on which the cost depend.)""";

          // drake/solvers/mathematical_program.h:829
          const char* doc_3 =
R"""(Adds a generic cost to the optimization program.

Parameter ``obj``:
    The added objective.

Parameter ``vars``:
    The decision variables on which the cost depend.)""";

          // drake/solvers/mathematical_program.h:852
          const char* doc_4 =
R"""(Adds a cost to the optimization program on a list of variables.

Template parameter ``F``:
    it should define functions numInputs, numOutputs and eval. Check
    drake::solvers::detail::FunctionTraits for more detail.)""";

          // drake/solvers/mathematical_program.h:865
          const char* doc_5 =
R"""(Adds a cost to the optimization program on an Eigen::Vector containing
decision variables.

Template parameter ``F``:
    Type that defines functions numInputs, numOutputs and eval.

See also:
    drake::solvers::detail::FunctionTraits.)""";

          // drake/solvers/mathematical_program.h:878
          const char* doc_6 =
R"""(Statically assert if a user inadvertently passes a binding-compatible
Constraint.

Template parameter ``F``:
    The type to check.)""";

          // drake/solvers/mathematical_program.h:887
          const char* doc_7 =
R"""(Adds a cost term of the form c'*x. Applied to a subset of the
variables and pushes onto the linear cost data structure.)""";

          // drake/solvers/mathematical_program.h:935
          const char* doc_8 =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x. Applied to subset of
the variables and pushes onto the quadratic cost data structure.)""";

          // drake/solvers/mathematical_program.h:1029
          const char* doc_9 =
R"""(Adds a cost in the symbolic form. Note that the constant part of the
cost is ignored. So if you set `e = x + 2`, then only the cost on `x`
is added, the constant term 2 is ignored.

Parameter ``e``:
    The linear or quadratic expression of the cost. @pre `e` is linear
    or `e` is quadratic. Otherwise throws a runtime error.

Returns:
    The newly created cost, together with the bound variables.)""";

        } AddCost;

        // drake::solvers::MathematicalProgram::AddDecisionVariables
        struct /* AddDecisionVariables */ {

          // drake/solvers/mathematical_program.h:561
          const char* doc =
R"""(Appends new variables to the end of the existing variables.

Parameter ``decision_variables``:
    The newly added decision_variables. @pre `decision_variables`
    should not intersect with the existing variables or indeterminates
    in the optimization program. @pre Each entry in
    `decision_variables` should not be a dummy variable.

Throws:
    runtime_error if the preconditions are not satisfied.)""";

        } AddDecisionVariables;

        // drake::solvers::MathematicalProgram::AddIndeterminates
        struct /* AddIndeterminates */ {

          // drake/solvers/mathematical_program.h:763
          const char* doc =
R"""(Adds indeterminates. This method appends some indeterminates to the
end of the program's old indeterminates.

Parameter ``new_indeterminates``:
    The indeterminates to be appended to the program's old
    indeterminates. @pre `new_indeterminates` should not intersect
    with the program's old indeterminates or decision variables. @pre
    Each entry in new_indeterminates should not be dummy. @pre Each
    entry in new_indeterminates should be of CONTINUOUS type.)""";

        } AddIndeterminates;

        // drake::solvers::MathematicalProgram::AddL2NormCost
        struct /* AddL2NormCost */ {

          // drake/solvers/mathematical_program.h:969
          const char* doc =
R"""(Adds a cost term of the form | Ax - b |^2.)""";

          // drake/solvers/mathematical_program.h:978
          const char* doc_2 =
R"""(Adds a cost term of the form | Ax - b |^2.)""";

        } AddL2NormCost;

        // drake::solvers::MathematicalProgram::AddLinearComplementarityConstraint
        struct /* AddLinearComplementarityConstraint */ {

          // drake/solvers/mathematical_program.h:1921
          const char* doc =
R"""(Adds a linear complementarity constraints referencing a subset of the
decision variables.)""";

          // drake/solvers/mathematical_program.h:1932
          const char* doc_2 =
R"""(Adds a linear complementarity constraints referencing a subset of the
decision variables.)""";

        } AddLinearComplementarityConstraint;

        // drake::solvers::MathematicalProgram::AddLinearConstraint
        struct /* AddLinearConstraint */ {

          // drake/solvers/mathematical_program.h:1169
          const char* doc =
R"""(Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).)""";

          // drake/solvers/mathematical_program.h:1181
          const char* doc_2 =
R"""(Adds linear constraints referencing potentially a subset of the
decision variables (defined in the vars parameter).)""";

          // drake/solvers/mathematical_program.h:1197
          const char* doc_3 =
R"""(Adds one row of linear constraint referencing potentially a subset of
the decision variables (defined in the vars parameter). lb <= a*vars
<= ub

Parameter ``a``:
    A row vector.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.

Parameter ``vars``:
    The decision variables on which to impose the linear constraint.)""";

          // drake/solvers/mathematical_program.h:1213
          const char* doc_4 =
R"""(Adds one row of linear constraint referencing potentially a subset of
the decision variables (defined in the vars parameter). lb <= a*vars
<= ub

Parameter ``a``:
    A row vector.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.

Parameter ``vars``:
    The decision variables on which to impose the linear constraint.)""";

          // drake/solvers/mathematical_program.h:1231
          const char* doc_5 =
R"""(Adds one row of linear constraint lb <= e <= ub where ``e`` is a
symbolic expression. Throws an exception if 1. ``e`` is a non-linear
expression. 2. ``lb <= e <= ub`` is a trivial constraint such as 1 <=
2 <= 3. 3. ``lb <= e <= ub`` is unsatisfiable such as 1 <= -5 <= 3

Parameter ``e``:
    A linear symbolic expression in the form of ``c0 + c1 * v1 + ... +
    cn * vn`` where ``c_i`` is a constant and @v_i is a variable.

Parameter ``lb``:
    A scalar, the lower bound.

Parameter ``ub``:
    A scalar, the upper bound.)""";

          // drake/solvers/mathematical_program.h:1239
          const char* doc_6 =
R"""(Adds linear constraints represented by symbolic expressions to the
program. It throws if @v includes a non-linear expression or ``lb <= v
<= ub`` includes trivial/unsatisfiable constraints.)""";

          // drake/solvers/mathematical_program.h:1269
          const char* doc_7 =
R"""(Add a linear constraint represented by a symbolic formula to the
program. The input formula ``f`` can be of the following forms:

1. e1 <= e2 2. e1 >= e2 3. e1 == e2 4. A conjunction of relational
formulas where each conjunct is a relational formula matched by 1, 2,
or 3.

Note that first two cases might return an object of
Binding<BoundingBoxConstraint> depending on ``f``. Also the third case
returns an object of Binding<LinearEqualityConstraint>.

It throws an exception if 1. ``f`` is not matched with one of the
above patterns. Especially, strict inequalities (<, >) are not
allowed. 2. ``f`` includes a non-linear expression. 3. ``f`` is either
a trivial constraint such as "1 <= 2" or an unsatisfiable constraint
such as "2 <= 1". 4. It is not possible to find numerical bounds of
`e1` and `e2` where ``f`` = e1 ≃ e2. We allow `e1` and `e2` to be
infinite but only if there are no other terms. For example, `x <= ∞`
is allowed. However, `x - ∞ <= 0` is not allowed because `x ↦ ∞`
introduces `nan` in the evaluation.)""";

          // drake/solvers/mathematical_program.h:1300
          const char* doc_8 =
R"""(Add a linear constraint represented by an
Eigen::Array<symbolic::Formula> to the program. A common use-case of
this function is to add a linear constraint with the element-wise
comparison between two Eigen matrices, using `A.array() <= B.array()`.
See the following example.

```
MathematicalProgram prog;
  Eigen::Matrix<double, 2, 2> A;
  auto x = prog.NewContinuousVariables(2, "x");
  Eigen::Vector2d b;
  ... // set up A and b
  prog.AddLinearConstraint((A * x).array() <= b.array());
```

A formula in ``formulas`` can be of the following forms:

1. e1 <= e2 2. e1 >= e2 3. e1 == e2

It throws an exception if AddLinearConstraint(const symbolic::Formula&
f) throws an exception for f ∈ ``formulas``.

Template parameter ``Derived``:
    An Eigen Array type of Formula.)""";

        } AddLinearConstraint;

        // drake::solvers::MathematicalProgram::AddLinearCost
        struct /* AddLinearCost */ {

          // drake/solvers/mathematical_program.h:897
          const char* doc =
R"""(Adds a linear cost term of the form a'*x + b.

Parameter ``e``:
    A linear symbolic expression. @pre e is a linear expression a'*x +
    b, where each entry of x is a decision variable in the
    mathematical program.

Returns:
    The newly added linear constraint, together with the bound
    variables.)""";

          // drake/solvers/mathematical_program.h:904
          const char* doc_2 =
R"""(Adds a linear cost term of the form a'*x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.)""";

          // drake/solvers/mathematical_program.h:914
          const char* doc_3 =
R"""(Adds a linear cost term of the form a'*x + b. Applied to a subset of
the variables and pushes onto the linear cost data structure.)""";

          // drake/solvers/mathematical_program.h:924
          const char* doc_4 =
R"""(Adds a linear cost term of the form a'*x. Applied to a subset of the
variables and pushes onto the linear cost data structure.)""";

        } AddLinearCost;

        // drake::solvers::MathematicalProgram::AddLinearEqualityConstraint
        struct /* AddLinearEqualityConstraint */ {

          // drake/solvers/mathematical_program.h:1333
          const char* doc =
R"""(Adds one row of linear constraint e = b where ``e`` is a symbolic
expression. Throws an exception if 1. ``e`` is a non-linear
expression. 2. ``e`` is a constant.

Parameter ``e``:
    A linear symbolic expression in the form of ``c0 + c1 * x1 + ... +
    cn * xn`` where ``c_i`` is a constant and @x_i is a variable.

Parameter ``b``:
    A scalar.

Returns:
    The newly added linear equality constraint, together with the
    bound variable.)""";

          // drake/solvers/mathematical_program.h:1345
          const char* doc_2 =
R"""(Adds a linear equality constraint represented by a symbolic formula to
the program. The input formula ``f`` is either an equality formula
(`e1 == e2`) or a conjunction of equality formulas.

It throws an exception if 1. ``f`` is neither an equality formula nor
a conjunction of equalities. 2. ``f`` includes a non-linear
expression.)""";

          // drake/solvers/mathematical_program.h:1366
          const char* doc_3 =
R"""(Adds linear equality constraints $ v = b $, where ``v``(i) is a
symbolic linear expression. Throws an exception if 1. ``v``(i) is a
non-linear expression. 2. ``v``(i) is a constant.

Template parameter ``DerivedV``:
    An Eigen Matrix type of Expression. A column vector.

Template parameter ``DerivedB``:
    An Eigen Matrix type of double. A column vector.

Parameter ``v``:
    v(i) is a linear symbolic expression in the form of `` c0 + c1 *
    x1 + ... + cn * xn `` where ci is a constant and @xi is a
    variable.

Parameter ``b``:
    A vector of doubles.

Returns:
    The newly added linear equality constraint, together with the
    bound variables.)""";

          // drake/solvers/mathematical_program.h:1394
          const char* doc_4 =
R"""(Adds a linear equality constraint for a matrix of linear expression
``V``, such that V(i, j) = B(i, j). If V is a symmetric matrix, then
the user may only want to constrain the lower triangular part of V.
This function is meant to provide convenience to the user, it incurs
additional copy and memory allocation. For faster speed, add each
column of the matrix equality in a for loop.

Template parameter ``DerivedV``:
    An Eigen Matrix type of Expression. The number of columns at
    compile time should not be 1.

Template parameter ``DerivedB``:
    An Eigen Matrix type of double.

Parameter ``V``:
    An Eigen Matrix of symbolic expressions. V(i, j) should be a
    linear expression.

Parameter ``B``:
    An Eigen Matrix of doubles.

Parameter ``lower_triangle``:
    If true, then only the lower triangular part of ``V`` is
    constrained, otherwise the whole matrix V is constrained. @default
    is false.

Returns:
    The newly added linear equality constraint, together with the
    bound variables.)""";

          // drake/solvers/mathematical_program.h:1421
          const char* doc_5 =
R"""(AddLinearEqualityConstraint

Adds linear equality constraints referencing potentially a subset of
the decision variables.

Example: to add two equality constraints which only depend on two of
the elements of x, you could use

```
{.cc}
  auto x = prog.NewContinuousDecisionVariable(6,"myvar");
  Eigen::Matrix2d Aeq;
  Aeq << -1, 2,
          1, 1;
  Eigen::Vector2d beq(1, 3);
  prog.AddLinearEqualityConstraint(Aeq, beq, {x.segment<1>(2),
                                   x.segment<1>(5)});
```

The code above imposes constraints @f[-x(2) + 2x(5) = 1 @f] @f[ x(2) +
x(5) = 3 @f])""";

          // drake/solvers/mathematical_program.h:1448
          const char* doc_6 =
R"""(AddLinearEqualityConstraint

Adds linear equality constraints referencing potentially a subset of
the decision variables.

Example: to add two equality constraints which only depend on two of
the elements of x, you could use

```
{.cc}
  auto x = prog.NewContinuousDecisionVariable(6,"myvar");
  Eigen::Matrix2d Aeq;
  Aeq << -1, 2,
          1, 1;
  Eigen::Vector2d beq(1, 3);
  // Imposes constraint
  // -x(0) + 2x(1) = 1
  //  x(0) +  x(1) = 3
  prog.AddLinearEqualityConstraint(Aeq, beq, x.head<2>());
```)""";

          // drake/solvers/mathematical_program.h:1463
          const char* doc_7 =
R"""(Adds one row of linear equality constraint referencing potentially a
subset of decision variables. @f[ ax = beq @f]

Parameter ``a``:
    A row vector.

Parameter ``beq``:
    A scalar.

Parameter ``vars``:
    The decision variables on which the constraint is imposed.)""";

          // drake/solvers/mathematical_program.h:1480
          const char* doc_8 =
R"""(Adds one row of linear equality constraint referencing potentially a
subset of decision variables. @f[ ax = beq @f]

Parameter ``a``:
    A row vector.

Parameter ``beq``:
    A scalar.

Parameter ``vars``:
    The decision variables on which the constraint is imposed.)""";

        } AddLinearEqualityConstraint;

        // drake::solvers::MathematicalProgram::AddLinearMatrixInequalityConstraint
        struct /* AddLinearMatrixInequalityConstraint */ {

          // drake/solvers/mathematical_program.h:2028
          const char* doc =
R"""(Adds a linear matrix inequality constraint to the program.)""";

          // drake/solvers/mathematical_program.h:2038
          const char* doc_2 =
R"""(Adds a linear matrix inequality constraint to the program.)""";

        } AddLinearMatrixInequalityConstraint;

        // drake::solvers::MathematicalProgram::AddLorentzConeConstraint
        struct /* AddLorentzConeConstraint */ {

          // drake/solvers/mathematical_program.h:1636
          const char* doc =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables.

Parameter ``v``:
    An Eigen::Vector of symbolic::Expression. Constraining that \f[
    v_0 \ge \sqrt{v_1^2 + ... + v_{n-1}^2} \f]

Returns:
    The newly constructed Lorentz cone constraint with the bounded
    variables.)""";

          // drake/solvers/mathematical_program.h:1668
          const char* doc_2 =
R"""(Adds Lorentz cone constraint on the linear expression v1 and quadratic
expression v2, such that v1 >= sqrt(v2)

Parameter ``linear_expression``:
    The linear expression v1.

Parameter ``quadratic_expression``:
    The quadratic expression v2.

Parameter ``tol``:
    The tolerance to determine if the matrix in v2 is positive
    semidefinite or not.

See also:
    DecomposePositiveQuadraticForm for more explanation. @default is
    0.

Returns ``binding``:
    The newly added Lorentz cone constraint, together with the bound
    variables. @pre 1. `v1` is a linear expression, in the form of
    c'*x + d. 2. `v2` is a quadratic expression, in the form of

```
x'*Q*x + b'x + a
```

Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be non-
negative for any x. Throws a runtime_error if the preconditions are
not satisfied.

Notice this constraint is equivalent to the vector [z;y] is within a
Lorentz cone, where

```
z = v1
 y = R * x + d
```

while (R, d) satisfies y'*y = x'*Q*x + b'*x + a)""";

          // drake/solvers/mathematical_program.h:1690
          const char* doc_3 =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables (defined in the vars parameter). The linear
expression $ z=Ax+b $ is in the Lorentz cone. A vector $ z
\in\mathbb{R}^n $ is in the Lorentz cone, if <!-- z(0) >= sqrt{z(1)² +
... + z(n-1)²} --> @f[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} @f]

Parameter ``A``:
    A $\mathbb{R}^{n\times m}$ matrix, whose number of columns equals
    to the size of the decision variables.

Parameter ``b``:
    A $\mathbb{R}^n$ vector, whose number of rows equals to the size
    of the decision variables.

Parameter ``vars``:
    The list of $ m $ decision variables.

Returns:
    The newly added Lorentz cone constraint.)""";

          // drake/solvers/mathematical_program.h:1714
          const char* doc_4 =
R"""(Adds Lorentz cone constraint referencing potentially a subset of the
decision variables (defined in the vars parameter). The linear
expression $ z=Ax+b $ is in the Lorentz cone. A vector $ z
\in\mathbb{R}^n $ is in the Lorentz cone, if <!-- z(0) >= sqrt{z(1)² +
... + z(n-1)²} --> @f[ z_0 \ge \sqrt{z_1^2 + ... + z_{n-1}^2} @f]

Parameter ``A``:
    A $\mathbb{R}^{n\times m}$ matrix, whose number of columns equals
    to the size of the decision variables.

Parameter ``b``:
    A $\mathbb{R}^n$ vector, whose number of rows equals to the size
    of the decision variables.

Parameter ``vars``:
    The Eigen vector of $ m $ decision variables.

Returns:
    The newly added Lorentz cone constraint.)""";

          // drake/solvers/mathematical_program.h:1730
          const char* doc_5 =
R"""(Imposes that a vector $ x\in\mathbb{R}^m $ lies in Lorentz cone.
Namely @f[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} @f] <!--> x(0) >=
sqrt(x(1)² + ... + x(m-1)²) <-->

Parameter ``vars``:
    The stacked column of vars should lie within the Lorentz cone.

Returns:
    The newly added Lorentz cone constraint.)""";

          // drake/solvers/mathematical_program.h:1747
          const char* doc_6 =
R"""(Imposes that a vector $ x\in\mathbb{R}^m $ lies in Lorentz cone.
Namely @f[ x_0 \ge \sqrt{x_1^2 + .. + x_{m-1}^2} @f] <!--> x(0) >=
sqrt(x(1)² + ... + x(m-1)²) <-->

Parameter ``vars``:
    The stacked column of vars should lie within the Lorentz cone.

Returns:
    The newly added Lorentz cone constraint.)""";

        } AddLorentzConeConstraint;

        // drake::solvers::MathematicalProgram::AddPolynomialConstraint
        struct /* AddPolynomialConstraint */ {

          // drake/solvers/mathematical_program.h:1941
          const char* doc =
R"""(Adds a polynomial constraint to the program referencing a subset of
the decision variables (defined in the vars parameter).)""";

          // drake/solvers/mathematical_program.h:1954
          const char* doc_2 =
R"""(Adds a polynomial constraint to the program referencing a subset of
the decision variables (defined in the vars parameter).)""";

        } AddPolynomialConstraint;

        // drake::solvers::MathematicalProgram::AddPolynomialCost
        struct /* AddPolynomialCost */ {

          // drake/solvers/mathematical_program.h:1018
          const char* doc =
R"""(Adds a cost term in the polynomial form.

Parameter ``e``:
    A symbolic expression in the polynomial form.

Returns:
    The newly created cost and the bound variables.)""";

        } AddPolynomialCost;

        // drake::solvers::MathematicalProgram::AddPositiveDiagonallyDominantMatrixConstraint
        struct /* AddPositiveDiagonallyDominantMatrixConstraint */ {

          // drake/solvers/mathematical_program.h:2062
          const char* doc =
R"""(Adds the constraint that a symmetric matrix is diagonally dominant
with non-negative diagonal entries. A symmetric matrix X is diagonally
dominant with non-negative diagonal entries if X(i, i) >= ∑ⱼ |X(i, j)|
∀ j ≠ i namely in each row, the diagonal entry is larger than the sum
of the absolute values of all other entries in the same row. A matrix
being diagonally dominant with non-negative diagonals is a sufficient
(but not necessary) condition of a matrix being positive semidefinite.
Internally we will create a matrix Y as slack variables, such that
Y(i, j) represents the absolute value |X(i, j)| ∀ j ≠ i. The diagonal
entries Y(i, i) = X(i, i)

Parameter ``X``:
    The symmetric matrix X in the documentation above. We will assume
    that ``X`` is already symmetric. It is the user's responsibility
    to guarantee the symmetry.

Returns:
    Y The slack variable. Y(i, j) represents |X(i, j)| ∀ j ≠ i, with
    the constraint Y(i, j) >= X(i, j) and Y(i, j) >= -X(i, j). Y is a
    symmetric matrix. The diagonal entries Y(i, i) = X(i, i))""";

        } AddPositiveDiagonallyDominantMatrixConstraint;

        // drake::solvers::MathematicalProgram::AddPositiveSemidefiniteConstraint
        struct /* AddPositiveSemidefiniteConstraint */ {

          // drake/solvers/mathematical_program.h:1979
          const char* doc =
R"""(Adds a positive semidefinite constraint on a symmetric matrix. In
Debug mode,

Throws:
    s error if ``symmetric_matrix_var`` is not symmetric.

Parameter ``symmetric_matrix_var``:
    A symmetric MatrixDecisionVariable object.)""";

          // drake/solvers/mathematical_program.h:1998
          const char* doc_2 =
R"""(Adds a positive semidefinite constraint on a symmetric matrix of
symbolic expressions ``e``. We create a new symmetric matrix of
variables M being positive semidefinite, with the linear equality
constraint e == M.

Template parameter ``Derived``:
    An Eigen Matrix of symbolic expressions.

Parameter ``e``:
    Imposes constraint "e is positive semidefinite". @pre{1. e is
    symmetric. 2. e(i, j) is linear for all i, j }

Returns:
    The newly added positive semidefinite constraint, with the bound
    variable M that are also newly added.)""";

        } AddPositiveSemidefiniteConstraint;

        // drake::solvers::MathematicalProgram::AddQuadraticCost
        struct /* AddQuadraticCost */ {

          // drake/solvers/mathematical_program.h:945
          const char* doc =
R"""(Add a quadratic cost term of the form 0.5*x'*Q*x + b'*x + c. Notice
that in the optimization program, the constant term `c` in the cost is
ignored.

Parameter ``e``:
    A quadratic symbolic expression. Throws a runtime error if the
    expression is not quadratic.

Returns:
    The newly added cost together with the bound variables.)""";

          // drake/solvers/mathematical_program.h:989
          const char* doc_2 =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x. Applied to subset of
the variables.)""";

          // drake/solvers/mathematical_program.h:999
          const char* doc_3 =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x + c Applied to subset of
the variables.)""";

          // drake/solvers/mathematical_program.h:1008
          const char* doc_4 =
R"""(Adds a cost term of the form 0.5*x'*Q*x + b'x Applied to subset of the
variables.)""";

        } AddQuadraticCost;

        // drake::solvers::MathematicalProgram::AddQuadraticErrorCost
        struct /* AddQuadraticErrorCost */ {

          // drake/solvers/mathematical_program.h:950
          const char* doc =
R"""(Adds a cost term of the form (x-x_desired)'*Q*(x-x_desired).)""";

          // drake/solvers/mathematical_program.h:961
          const char* doc_2 =
R"""(Adds a cost term of the form (x-x_desired)'*Q*(x-x_desired).)""";

        } AddQuadraticErrorCost;

        // drake::solvers::MathematicalProgram::AddRotatedLorentzConeConstraint
        struct /* AddRotatedLorentzConeConstraint */ {

          // drake/solvers/mathematical_program.h:1796
          const char* doc =
R"""(Adds rotated Lorentz cone constraint on the linear expression v1, v2
and quadratic expression u, such that v1 * v2 >= u, v1 >= 0, v2 >= 0

Parameter ``linear_expression1``:
    The linear expression v1.

Parameter ``linear_expression2``:
    The linear expression v2.

Parameter ``quadratic_expression``:
    The quadratic expression u.

Parameter ``tol``:
    The tolerance to determine if the matrix in v2 is positive
    semidefinite or not.

See also:
    DecomposePositiveQuadraticForm for more explanation. @default is
    0.

Returns ``binding``:
    The newly added rotated Lorentz cone constraint, together with the
    bound variables. @pre 1. `linear_expression1` is a linear (affine)
    expression, in the form of v1 = c1'*x + d1. 2.
    `linear_expression2` is a linear (affine) expression, in the form
    of v2 = c2'*x + d2. 2. `quadratic_expression` is a quadratic
    expression, in the form of

```
u = x'*Q*x + b'x + a
```

Also the quadratic expression has to be convex, namely Q is a positive
semidefinite matrix, and the quadratic expression needs to be non-
negative for any x. Throws a runtime_error if the preconditions are
not satisfied.)""";

          // drake/solvers/mathematical_program.h:1814
          const char* doc_2 =
R"""(Adds a constraint that a symbolic expression

Parameter ``v``:
    is in the rotated Lorentz cone, i.e., \f[ v_0v_1 \ge v_2^2 + ... +
    v_{n-1}^2\\ v_0 \ge 0, v_1 \ge 0 \f]

Parameter ``v``:
    A linear expression of variables, $ v = A x + b$, where $ A, b $
    are given matrices of the correct size, $ x $ is the vector of
    decision variables.

Returns ``binding``:
    The newly added rotated Lorentz cone constraint, together with the
    bound variables.)""";

          // drake/solvers/mathematical_program.h:1836
          const char* doc_3 =
R"""(Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables, The linear expression $ z=Ax+b $ is in
rotated Lorentz cone. A vector $ z \in\mathbb{R}^n $ is in the rotated
Lorentz cone, if <!-- z(0)*z(1) >= z(2)² + ... + z(n-1)² --> @f[
z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 @f] where $ A\in\mathbb{R}^{n\times
m}, b\in\mathbb{R}^n$ are given matrices.

Parameter ``A``:
    A matrix whose number of columns equals to the size of the
    decision variables.

Parameter ``b``:
    A vector whose number of rows equals to the size fo the decision
    variables.

Parameter ``vars``:
    The decision variables on which the constraint is imposed.)""";

          // drake/solvers/mathematical_program.h:1862
          const char* doc_4 =
R"""(Adds a rotated Lorentz cone constraint referencing potentially a
subset of decision variables, The linear expression $ z=Ax+b $ is in
rotated Lorentz cone. A vector $ z \in\mathbb{R}^n $ is in the rotated
Lorentz cone, if <!-- z(0)*z(1) >= z(2)² + ... + z(n-1)² --> @f[
z_0z_1 \ge z_2^2 + ... + z_{n-1}^2 @f] where $ A\in\mathbb{R}^{n\times
m}, b\in\mathbb{R}^n$ are given matrices.

Parameter ``A``:
    A matrix whose number of columns equals to the size of the
    decision variables.

Parameter ``b``:
    A vector whose number of rows equals to the size fo the decision
    variables.

Parameter ``vars``:
    The decision variables on which the constraint is imposed.)""";

          // drake/solvers/mathematical_program.h:1881
          const char* doc_5 =
R"""(Impose that a vector $ x\in\mathbb{R}^m $ is in rotated Lorentz cone.
Namely @f[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0
@f] <!--> x(0)*x(1) >= x(2)^2 + ... x(m-1)^2 x(0) >= 0, x(1) >= 0 <-->

Parameter ``vars``:
    The stacked column of vars lies in the rotated Lorentz cone.

Returns:
    The newly added rotated Lorentz cone constraint.)""";

          // drake/solvers/mathematical_program.h:1901
          const char* doc_6 =
R"""(Impose that a vector $ x\in\mathbb{R}^m $ is in rotated Lorentz cone.
Namely @f[ x_0 x_1 \ge x_2^2 + ... + x_{m-1}^2\\ x_0 \ge 0, x_1 \ge 0
@f] <!--> x(0)*x(1) >= x(2)^2 + ... x(m-1)^2 x(0) >= 0, x(1) >= 0 <-->

Parameter ``vars``:
    The stacked column of vars lies in the rotated Lorentz cone.

Returns:
    The newly added rotated Lorentz cone constraint.)""";

        } AddRotatedLorentzConeConstraint;

        // drake::solvers::MathematicalProgram::AddSosConstraint
        struct /* AddSosConstraint */ {

          // drake/solvers/mathematical_program.h:2074
          const char* doc =
R"""(Adds constraints that a given polynomial ``p`` is a sums-of-squares
(SOS), that is, ``p`` can be decomposed into `mᵀQm`, where m is the
``monomial_basis``. It returns a pair of constraint bindings
expressing: - The coefficients matrix Q is PSD (positive
semidefinite). - The coefficients matching conditions in linear
equality constraint.)""";

          // drake/solvers/mathematical_program.h:2088
          const char* doc_2 =
R"""(Adds constraints that a given polynomial ``p`` is a sums-of-squares
(SOS), that is, ``p`` can be decomposed into `mᵀQm`, where m is the
monomial basis of all indeterminates in the program with degree equal
to half the TotalDegree of ``p``. It returns a pair of constraint
bindings expressing: - The coefficients matrix Q is PSD (positive
semidefinite). - The coefficients matching conditions in linear
equality constraint.)""";

          // drake/solvers/mathematical_program.h:2101
          const char* doc_3 =
R"""(Adds constraints that a given symbolic expression ``e`` is a sums-of-
squares (SOS), that is, ``p`` can be decomposed into `mᵀQm`, where m
is the ``monomial_basis``. Note that it decomposes ``e`` into a
polynomial with respect to `indeterminates()` in this mathematical
program. It returns a pair of constraint bindings expressing: - The
coefficients matrix Q is PSD (positive semidefinite). - The
coefficients matching conditions in linear equality constraint.)""";

          // drake/solvers/mathematical_program.h:2116
          const char* doc_4 =
R"""(Adds constraints that a given symbolic expression ``e`` is a sums-of-
squares (SOS), that is, ``e`` can be decomposed into `mTQm`. Note that
it decomposes ``e`` into a polynomial with respect to
`indeterminates()` in this mathematical program. It returns a pair of
constraint bindings expressing: - The coefficients matrix Q is PSD
(positive semidefinite). - The coefficients matching conditions in
linear equality constraint.)""";

        } AddSosConstraint;

        // drake::solvers::MathematicalProgram::AddVisualizationCallback
        struct /* AddVisualizationCallback */ {

          // drake/solvers/mathematical_program.h:780
          const char* doc =
R"""(Adds a callback method to visualize intermediate results of the
optimization.

Note: Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support callbacks.
For instance, adding a visualization callback to a quadratic
programming problem may result in using a nonlinear programming solver
as the default solver.

Parameter ``callback``:
    a std::function that accepts an Eigen::Vector of doubles
    representing the bound decision variables.

Parameter ``vars``:
    the decision variables that should be passed to the callback.)""";

          // drake/solvers/mathematical_program.h:798
          const char* doc_2 =
R"""(Adds a callback method to visualize intermediate results of the
optimization.

Note: Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support callbacks.
For instance, adding a visualization callback to a quadratic
programming problem may result in using a nonlinear programming solver
as the default solver.

Parameter ``callback``:
    a std::function that accepts an Eigen::Vector of doubles
    representing the for the bound decision variables.

Parameter ``vars``:
    the decision variables that should be passed to the callback.)""";

        } AddVisualizationCallback;

        // drake::solvers::MathematicalProgram::Clone
        struct /* Clone */ {

          // drake/solvers/mathematical_program.h:330
          const char* doc =
R"""(Clones an optimization program. The clone will be functionally
equivalent to the source program with the same: - decision variables -
constraints - costs - solver settings - initial guess However, the
clone's x values will be initialized to NaN, and all internal solvers
will be freshly constructed.

Returns ``new_prog``:
    . The newly constructed mathematical program.)""";

        } Clone;

        // drake::solvers::MathematicalProgram::EvalBinding
        struct /* EvalBinding */ {

          // drake/solvers/mathematical_program.h:2535
          const char* doc =
R"""(Evaluates the value of some binding, for some input value for all
decision variables.

Parameter ``binding``:
    A Binding whose variables are decision variables in this program.

Parameter ``prog_var_vals``:
    The value of all the decision variables in this program.

Throws:
    a logic error if the size does not match.)""";

        } EvalBinding;

        // drake::solvers::MathematicalProgram::EvalBindingAtInitialGuess
        struct /* EvalBindingAtInitialGuess */ {

          // drake/solvers/mathematical_program.h:2601
          const char* doc =
R"""(Evaluates the evaluator in ``binding`` at the initial guess.

Returns:
    The value of ``binding`` at the initial guess.)""";

        } EvalBindingAtInitialGuess;

        // drake::solvers::MathematicalProgram::EvalBindingAtSolution
        struct /* EvalBindingAtSolution */ {

          // drake/solvers/mathematical_program.h:2592
          const char* doc =
R"""(Evaluates the evaluator in ``binding`` at the solution value.

Returns:
    The value of ``binding`` at the solution value.)""";

        } EvalBindingAtSolution;

        // drake::solvers::MathematicalProgram::EvalVisualizationCallbacks
        struct /* EvalVisualizationCallbacks */ {

          // drake/solvers/mathematical_program.h:2561
          const char* doc =
R"""(Evaluates all visualization callbacks registered with the
MathematicalProgram.

Parameter ``prog_var_vals``:
    The value of all the decision variables in this program.

Throws:
    a logic error if the size does not match.)""";

        } EvalVisualizationCallbacks;

        // drake::solvers::MathematicalProgram::FindDecisionVariableIndex
        struct /* FindDecisionVariableIndex */ {

          // drake/solvers/mathematical_program.h:2446
          const char* doc =
R"""(Returns the index of the decision variable. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver. @pre{``var`` is a decision
variable in the mathematical program, otherwise this function throws a
runtime error.})""";

        } FindDecisionVariableIndex;

        // drake::solvers::MathematicalProgram::FindDecisionVariableIndices
        struct /* FindDecisionVariableIndices */ {

          // drake/solvers/mathematical_program.h:2457
          const char* doc =
R"""(Returns the indices of the decision variables. Internally the solvers
thinks all variables are stored in an array, and it accesses each
individual variable using its index. This index is used when adding
constraints and costs for each solver. @pre{``vars`` are decision
variables in the mathematical program, otherwise this function throws
a runtime error.})""";

        } FindDecisionVariableIndices;

        // drake::solvers::MathematicalProgram::FindIndeterminateIndex
        struct /* FindIndeterminateIndex */ {

          // drake/solvers/mathematical_program.h:2470
          const char* doc =
R"""(Returns the index of the indeterminate. Internally a solver thinks all
indeterminates are stored in an array, and it accesses each individual
indeterminate using its index. This index is used when adding
constraints and costs for each solver. @pre ``var`` is a indeterminate
in the mathematical program, otherwise this function throws a runtime
error.)""";

        } FindIndeterminateIndex;

        // drake::solvers::MathematicalProgram::GetAllCosts
        struct /* GetAllCosts */ {

          // drake/solvers/mathematical_program.h:2379
          const char* doc =
R"""(Getter returning all costs (for now linear costs appended to generic
costs, then quadratic costs appended to generic costs).)""";

        } GetAllCosts;

        // drake::solvers::MathematicalProgram::GetAllLinearConstraints
        struct /* GetAllLinearConstraints */ {

          // drake/solvers/mathematical_program.h:2391
          const char* doc =
R"""(Getter returning all linear constraints (both linear equality and
inequality constraints).)""";

        } GetAllLinearConstraints;

        // drake::solvers::MathematicalProgram::GetInitialGuess
        struct /* GetInitialGuess */ {

          // drake/solvers/mathematical_program.h:2129
          const char* doc =
R"""(Gets the initial guess for a single variable. @pre
``decision_variable`` has been registered in the optimization program.

Throws:
    runtime error if the pre condition is not satisfied.)""";

          // drake/solvers/mathematical_program.h:2142
          const char* doc_2 =
R"""(Gets the initial guess for some variables. @pre Each variable in
``decision_variable_mat`` has been registered in the optimization
program.

Throws:
    runtime error if the pre condition is not satisfied.)""";

        } GetInitialGuess;

        // drake::solvers::MathematicalProgram::GetLowerBoundCost
        struct /* GetLowerBoundCost */ {

          // drake/solvers/mathematical_program.h:2303
          const char* doc =
R"""(Getter for lower bound on optimal cost. Defaults to -Infinity if a
lower bound has not been found.)""";

        } GetLowerBoundCost;

        // drake::solvers::MathematicalProgram::GetOptimalCost
        struct /* GetOptimalCost */ {

          // drake/solvers/mathematical_program.h:2297
          const char* doc =
R"""(Getter for optimal cost at the solution. If the solver finds an
optimal solution, then we return the cost evaluated at this solution.
If the program is unbounded, then the optimal cost is -∞. If the
program is globally infeasible, then the optimal cost is +∞. If the
program is locally infeasible, then the solver (e.g. SNOPT) might
return some finite value as the optimal cost. Otherwise, the optimal
cost is NaN.)""";

        } GetOptimalCost;

        // drake::solvers::MathematicalProgram::GetSolution
        struct /* GetSolution */ {

          // drake/solvers/mathematical_program.h:2483
          const char* doc =
R"""(Gets the solution of an Eigen matrix of decision variables.

Template parameter ``Derived``:
    An Eigen matrix containing Variable.

Parameter ``var``:
    The decision variables.

Returns:
    The value of the decision variable after solving the problem.)""";

          // drake/solvers/mathematical_program.h:2498
          const char* doc_2 =
R"""(Gets the value of a single decision variable.)""";

        } GetSolution;

        // drake::solvers::MathematicalProgram::GetSolverData
        struct /* GetSolverData */ {

          // drake/solvers/mathematical_program.h:2424
          const char* doc = R"""()""";

        } GetSolverData;

        // drake::solvers::MathematicalProgram::GetSolverId
        struct /* GetSolverId */ {

          // drake/solvers/mathematical_program.h:2285
          const char* doc =
R"""(Returns the ID of the solver that was used to solve this program.
Returns empty if Solve() has not been called.)""";

        } GetSolverId;

        // drake::solvers::MathematicalProgram::GetSolverOptionsDouble
        struct /* GetSolverOptionsDouble */ {

          // drake/solvers/mathematical_program.h:2254
          const char* doc = R"""()""";

        } GetSolverOptionsDouble;

        // drake::solvers::MathematicalProgram::GetSolverOptionsInt
        struct /* GetSolverOptionsInt */ {

          // drake/solvers/mathematical_program.h:2263
          const char* doc = R"""()""";

        } GetSolverOptionsInt;

        // drake::solvers::MathematicalProgram::GetSolverOptionsStr
        struct /* GetSolverOptionsStr */ {

          // drake/solvers/mathematical_program.h:2272
          const char* doc = R"""()""";

        } GetSolverOptionsStr;

        // drake::solvers::MathematicalProgram::MakeCost
        struct /* MakeCost */ {

          // drake/solvers/mathematical_program.h:840
          const char* doc =
R"""(Convert an input of type ``F`` to a FunctionCost object.

Template parameter ``F``:
    This class should have functions numInputs(), numOutputs and
    eval(x, y).

See also:
    drake::solvers::detail::FunctionTraits.)""";

        } MakeCost;

        // drake::solvers::MathematicalProgram::MathematicalProgram
        struct /* ctor */ {

          // drake/solvers/mathematical_program.h:305
          const char* doc = R"""()""";

          // drake/solvers/mathematical_program.h:305
          const char* doc_2 = R"""()""";

          // drake/solvers/mathematical_program.h:315
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::MathematicalProgram::NewBinaryVariables
        struct /* NewBinaryVariables */ {

          // drake/solvers/mathematical_program.h:464
          const char* doc =
R"""(Adds binary variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows in the new variables.

Template parameter ``Cols``:
    The number of columns in the new variables.

Parameter ``rows``:
    The number of rows in the new variables.

Parameter ``cols``:
    The number of columns in the new variables.

Parameter ``name``:
    The commonly shared name of the new variables.

Returns:
    The MatrixDecisionVariable of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto b = prog.NewBinaryVariables(2, 3, "b");
```

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";

          // drake/solvers/mathematical_program.h:484
          const char* doc_2 =
R"""(Adds a matrix of binary variables into the optimization program.

Template parameter ``Rows``:
    The number of rows in the newly added binary variables.

Template parameter ``Cols``:
    The number of columns in the new variables. The default is 1.

Parameter ``name``:
    Each newly added binary variable will share the same name. The
    default name is "b".

Returns:
    A matrix containing the newly added variables.)""";

          // drake/solvers/mathematical_program.h:495
          const char* doc_3 =
R"""(Adds binary variables to this MathematicalProgram. The new variables
are viewed as a column vector, with size ``rows`` x 1.

See also:
    NewBinaryVariables(int rows, int cols, const
    std::vector<std::string>& names);)""";

        } NewBinaryVariables;

        // drake::solvers::MathematicalProgram::NewContinuousVariables
        struct /* NewContinuousVariables */ {

          // drake/solvers/mathematical_program.h:357
          const char* doc =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Parameter ``rows``:
    The number of rows in the new variables.

Parameter ``name``:
    The name of the newly added variables

Returns:
    The VectorDecisionVariable of size rows x 1, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewContinuousVariables(2, "x");
```

This adds a 2 x 1 vector containing decision variables into the
program. The names of the variables are "x(0)" and "x(1)".

The name of the variable is only used for the user in order to ease
readability.)""";

          // drake/solvers/mathematical_program.h:394
          const char* doc_2 =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows of the new variables, in the compile time.

Template parameter ``Cols``:
    The number of columns of the new variables, in the compile time.

Parameter ``rows``:
    The number of rows in the new variables. When Rows is not
    Eigen::Dynamic, rows is ignored.

Parameter ``cols``:
    The number of columns in the new variables. When Cols is not
    Eigen::Dynamic, cols is ignored.

Parameter ``name``:
    All variables will share the same name, but different index.

Returns:
    The MatrixDecisionVariable of size Rows x Cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewContinuousVariables(2, 3, "X");
auto y = prog.NewContinuousVariables<2, 3>(2, 3, "X");
```

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";

          // drake/solvers/mathematical_program.h:431
          const char* doc_3 =
R"""(Adds continuous variables, appending them to an internal vector of any
existing vars. The initial guess values for the new variables are set
to NaN, to indicate that an initial guess has not been assigned.
Callers are expected to add costs and/or constraints to have any
effect during optimization. Callers can also set the initial guess of
the decision variables through SetInitialGuess() or
SetInitialGuessForAllVariables().

Template parameter ``Rows``:
    The number of rows in the new variables.

Template parameter ``Cols``:
    The number of columns in the new variables. The default is 1.

Parameter ``name``:
    All variables will share the same name, but different index.

Returns:
    The MatrixDecisionVariable of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewContinuousVariables<2, 3>("X");
```

This adds a 2 x 3 matrix decision variables into the program.

The name of the variable is only used for the user in order to ease
readability.)""";

        } NewContinuousVariables;

        // drake::solvers::MathematicalProgram::NewFreePolynomial
        struct /* NewFreePolynomial */ {

          // drake/solvers/mathematical_program.h:570
          const char* doc =
R"""(Returns a free polynomial in a monomial basis over ``indeterminates``
of a given ``degree``. It uses ``coeff_name`` to make new decision
variables and use them as coefficients. For example,
`NewFreePolynomial({x₀, x₁}, 2)` returns a₀x₁² + a₁x₀x₁ + a₂x₀² + a₃x₁
+ a₄x₀ + a₅.)""";

        } NewFreePolynomial;

        // drake::solvers::MathematicalProgram::NewIndeterminates
        struct /* NewIndeterminates */ {

          // drake/solvers/mathematical_program.h:621
          const char* doc =
R"""(Adds indeterminates, appending them to an internal vector of any
existing indeterminates.

Template parameter ``rows``:
    The number of rows in the new indeterminates.

Template parameter ``cols``:
    The number of columns in the new indeterminates.

Parameter ``names``:
    A vector of strings containing the name for each variable.

Returns:
    The MatrixIndeterminate of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
std::array<std::string, 6> names = {"x1", "x2", "x3", "x4", "x5", "x6"};
auto x = prog.NewIndeterminates<2, 3>(names);
```

This adds a 2 x 3 matrix indeterminates into the program.

The name of the indeterminates is only used for the user in order to
ease readability.)""";

          // drake/solvers/mathematical_program.h:649
          const char* doc_2 =
R"""(Adds indeterminates, appending them to an internal vector of any
existing indeterminates.

Template parameter ``rows``:
    The number of rows in the new indeterminates.

Template parameter ``cols``:
    The number of columns in the new indeterminates.

Parameter ``names``:
    A vector of strings containing the name for each variable.

Returns:
    The MatrixIndeterminate of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
std::array<std::string, 2> names = {"x1", "x2"};
auto x = prog.NewIndeterminates<2>(names);
```

This adds a 2 vector indeterminates into the program.

The name of the indeterminates is only used for the user in order to
ease readability.)""";

          // drake/solvers/mathematical_program.h:675
          const char* doc_3 =
R"""(Adds indeterminates, appending them to an internal vector of any
existing indeterminates.

Template parameter ``rows``:
    The number of rows in the new indeterminates.

Template parameter ``cols``:
    The number of columns in the new indeterminates.

Parameter ``names``:
    A vector of strings containing the name for each variable.

Returns:
    The MatrixIndeterminate of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewIndeterminates<2, 3>("X");
```

This adds a 2 x 3 matrix indeterminates into the program.

The name of the indeterminates is only used for the user in order to
ease readability.)""";

          // drake/solvers/mathematical_program.h:694
          const char* doc_4 =
R"""(Adds indeterminates to the program. The name for all newly added
indeterminates are set to ``name``. The default name is "x"

See also:
    NewIndeterminates(const std::array<std::string, rows>& names))""";

          // drake/solvers/mathematical_program.h:708
          const char* doc_5 =
R"""(Adds indeterminates to this MathematicalProgram.

See also:
    NewIndeterminates(int rows, int cols, const
    std::vector<std::string>& names);)""";

          // drake/solvers/mathematical_program.h:717
          const char* doc_6 =
R"""(Adds indeterminates to this MathematicalProgram, with default name
"x".

See also:
    NewIndeterminates(int rows, int cols, const
    std::vector<std::string>& names);)""";

          // drake/solvers/mathematical_program.h:740
          const char* doc_7 =
R"""(Adds indeterminates, appending them to an internal vector of any
existing vars.

Parameter ``rows``:
    The number of rows in the new indeterminates.

Parameter ``cols``:
    The number of columns in the new indeterminates.

Parameter ``names``:
    A vector of strings containing the name for each variable.

Returns:
    The MatrixIndeterminate of size rows x cols, containing the new
    vars (not all the vars stored).

Example:

```
{.cc}
MathematicalProgram prog;
auto x = prog.NewIndeterminates(2, 3, {"x1", "x2", "x3", "x4",
"x5", "x6"});
```

This adds a 2 x 3 matrix indeterminates into the program.

The name of the variable is only used for the user in order to ease
readability.)""";

          // drake/solvers/mathematical_program.h:750
          const char* doc_8 =
R"""(Adds indeterminates to this MathematicalProgram, with default name
"X". The new variables are returned and viewed as a matrix, with size
``rows`` x ``cols``.

See also:
    NewIndeterminates(int rows, int cols, const
    std::vector<std::string>& names);)""";

        } NewIndeterminates;

        // drake::solvers::MathematicalProgram::NewSosPolynomial
        struct /* NewSosPolynomial */ {

          // drake/solvers/mathematical_program.h:584
          const char* doc =
R"""(Returns a pair of a SOS polynomial p = mᵀQm and a PSD constraint for a
new coefficients matrix Q, where m is the ``monomial`` basis. For
example, `NewSosPolynomial(Vector2<Monomial>{x,y})` returns a
polynomial p = Q₍₀,₀₎x² + 2Q₍₁,₀₎xy + Q₍₁,₁₎y² and a PSD constraint
over Q. Note: Q is a symmetric monomial_basis.rows() x
monomial_basis.rows() matrix.)""";

          // drake/solvers/mathematical_program.h:598
          const char* doc_2 =
R"""(Returns a pair of a SOS polynomial p = m(x)ᵀQm(x) of degree ``degree``
and a PSD constraint for the coefficients matrix Q, where m(x) is the
result of calling `MonomialBasis(indeterminates, degree/2)`. For
example, `NewSosPolynomial({x}, 4)` returns a pair of a polynomial p =
Q₍₀,₀₎x⁴ + 2Q₍₁,₀₎ x³ + (2Q₍₂,₀₎ + Q₍₁,₁₎)x² + 2Q₍₂,₁₎x + Q₍₂,₂₎ and a
PSD constraint over Q.

Throws:
    s std::runtime_error if ``degree`` is not a positive even integer.

See also:
    MonomialBasis.)""";

        } NewSosPolynomial;

        // drake::solvers::MathematicalProgram::NewSymmetricContinuousVariables
        struct /* NewSymmetricContinuousVariables */ {

          // drake/solvers/mathematical_program.h:518
          const char* doc =
R"""(Adds a runtime sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.

Parameter ``rows``:
    The number of rows in the symmetric matrix.

Parameter ``name``:
    The name of the matrix. It is only used the for user to understand
    the optimization program. The default name is "Symmetric", and
    each variable will be named as

```
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
```

Notice that the (i,j)'th entry and (j,i)'th entry has the same name.

Returns:
    The newly added decision variables.)""";

          // drake/solvers/mathematical_program.h:540
          const char* doc_2 =
R"""(Adds a static sized symmetric matrix as decision variables to this
MathematicalProgram. The optimization will only use the stacked
columns of the lower triangular part of the symmetric matrix as
decision variables.

Template parameter ``rows``:
    The number of rows in the symmetric matrix.

Parameter ``name``:
    The name of the matrix. It is only used the for user to understand
    the optimization program. The default name is "Symmetric", and
    each variable will be named as

```
Symmetric(0, 0)     Symmetric(1, 0)     ... Symmetric(rows-1, 0)
Symmetric(1, 0)     Symmetric(1, 1)     ... Symmetric(rows-1, 1)
           ...
Symmetric(rows-1,0) Symmetric(rows-1,1) ... Symmetric(rows-1, rows-1)
```

Notice that the (i,j)'th entry and (j,i)'th entry has the same name.

Returns:
    The newly added decision variables.)""";

        } NewSymmetricContinuousVariables;

        // drake::solvers::MathematicalProgram::PrintSolution
        struct /* PrintSolution */ {

          // drake/solvers/mathematical_program.h:2209
          const char* doc = R"""()""";

        } PrintSolution;

        // drake::solvers::MathematicalProgram::SetInitialGuess
        struct /* SetInitialGuess */ {

          // drake/solvers/mathematical_program.h:2162
          const char* doc =
R"""(Sets the initial guess for a single variable ``decision_variable``.
@pre decision_variable is a registered decision variable in the
program.

Throws:
    a runtime error if precondition is not satisfied.)""";

          // drake/solvers/mathematical_program.h:2171
          const char* doc_2 =
R"""(Sets the initial guess for the decision variables stored in
``decision_variable_mat`` to be ``x0``. Variables begin with a default
initial guess of NaN to indicate that no guess is available.)""";

        } SetInitialGuess;

        // drake::solvers::MathematicalProgram::SetInitialGuessForAllVariables
        struct /* SetInitialGuessForAllVariables */ {

          // drake/solvers/mathematical_program.h:2189
          const char* doc =
R"""(Set the initial guess for ALL decision variables. Note that variables
begin with a default initial guess of NaN to indicate that no guess is
available.

Parameter ``x0``:
    A vector of appropriate size (num_vars() x 1).)""";

        } SetInitialGuessForAllVariables;

        // drake::solvers::MathematicalProgram::SetSolverOption
        struct /* SetSolverOption */ {

          // drake/solvers/mathematical_program.h:2238
          const char* doc =
R"""(Set an option for a particular solver. This interface does not do any
verification of solver parameters beyond what an individual solver
does for itself. It does not even verify that the specified solver
exists. Use this only when you have particular knowledge of what
solver is being invoked, and exactly what tuning is required.

Supported solver names/options:

"SNOPT" -- Parameter names and values as specified in SNOPT User's
Guide section 7.7 "Description of the optional parameters", used as
described in section 7.5 for snSet().

"IPOPT" -- Parameter names and values as specified in IPOPT users
guide section "Options Reference" http://www.coin-
or.org/Ipopt/documentation/node40.html

"GUROBI" -- Parameter name and values as specified in Gurobi Reference
Manual, section 10.2 "Parameter Descriptions"
https://www.gurobi.com/documentation/7.5/refman/parameters.html)""";

          // drake/solvers/mathematical_program.h:2243
          const char* doc_2 = R"""()""";

          // drake/solvers/mathematical_program.h:2248
          const char* doc_3 = R"""()""";

        } SetSolverOption;

        // drake::solvers::MathematicalProgram::SetSolverResult
        struct /* SetSolverResult */ {

          // drake/solvers/mathematical_program.h:2634
          const char* doc =
R"""(Solver reports its result back to MathematicalProgram, by passing the
solver_result, which contains the solver result.

Note:
    This method should only be called by each solver, after it solves
    the optimization problem stored in MathematicalProgram. The user
    should NOT call this method.)""";

        } SetSolverResult;

        // drake::solvers::MathematicalProgram::Solve
        struct /* Solve */ {

          // drake/solvers/mathematical_program.h:2199
          const char* doc =
R"""(Solve the MathematicalProgram.

Returns:
    SolutionResult indicating if the solution was successful.)""";

        } Solve;

        // drake::solvers::MathematicalProgram::SolverData
        struct /* SolverData */ {

          // drake/solvers/mathematical_program.h:2412
          const char* doc = R"""()""";

          // drake::solvers::MathematicalProgram::SolverData::SolverData
          struct /* ctor */ {

            // drake/solvers/mathematical_program.h:2413
            const char* doc = R"""()""";

            // drake/solvers/mathematical_program.h:2413
            const char* doc_2 = R"""()""";

            // drake/solvers/mathematical_program.h:2414
            const char* doc_3 = R"""()""";

          } ctor;

        } SolverData;

        // drake::solvers::MathematicalProgram::SubstituteSolution
        struct /* SubstituteSolution */ {

          // drake/solvers/mathematical_program.h:2510
          const char* doc =
R"""(Replaces the variables in an expression with the solutions to the
variables, returns the expression after substitution.

Throws:
    runtime error if some variables in the expression ``e`` are NOT
    decision variables or indeterminates in the optimization program.

Note:
    If the expression ``e`` contains both decision variables and
    indeterminates of the optimization program, then the decision
    variables will be substituted by its solutions in double values,
    but not the indeterminates.)""";

          // drake/solvers/mathematical_program.h:2522
          const char* doc_2 =
R"""(Replaces the decision variables in a polynomial with the solutions to
the variables, returns the polynomial after substitution.

Throws:
    runtime error if some decision variables in the polynomial ``p``
    are NOT decision variables in the optimization program.

Note:
    If the polynomial ``p`` contains both decision variables and
    indeterminates of the optimization program, then the decision
    variables will be substituted by its solutions in double values,
    but not the indeterminates.)""";

        } SubstituteSolution;

        // drake::solvers::MathematicalProgram::bounding_box_constraints
        struct /* bounding_box_constraints */ {

          // drake/solvers/mathematical_program.h:2399
          const char* doc =
R"""(Getter for all bounding box constraints */)""";

        } bounding_box_constraints;

        // drake::solvers::MathematicalProgram::decision_variable
        struct /* decision_variable */ {

          // drake/solvers/mathematical_program.h:2611
          const char* doc =
R"""(Getter for the decision variable with index ``i`` in the program. */)""";

        } decision_variable;

        // drake::solvers::MathematicalProgram::decision_variables
        struct /* decision_variables */ {

          // drake/solvers/mathematical_program.h:2606
          const char* doc =
R"""(Getter for all decision variables in the program. */)""";

        } decision_variables;

        // drake::solvers::MathematicalProgram::generic_constraints
        struct /* generic_constraints */ {

          // drake/solvers/mathematical_program.h:2323
          const char* doc = R"""(Getter for all generic constraints)""";

        } generic_constraints;

        // drake::solvers::MathematicalProgram::generic_costs
        struct /* generic_costs */ {

          // drake/solvers/mathematical_program.h:2316
          const char* doc = R"""(Getter for all generic costs.)""";

        } generic_costs;

        // drake::solvers::MathematicalProgram::indeterminate
        struct /* indeterminate */ {

          // drake/solvers/mathematical_program.h:2619
          const char* doc =
R"""(Getter for the indeterminate with index ``i`` in the program. */)""";

        } indeterminate;

        // drake::solvers::MathematicalProgram::indeterminates
        struct /* indeterminates */ {

          // drake/solvers/mathematical_program.h:2616
          const char* doc =
R"""(Getter for all indeterminates in the program. */)""";

        } indeterminates;

        // drake::solvers::MathematicalProgram::initial_guess
        struct /* initial_guess */ {

          // drake/solvers/mathematical_program.h:2437
          const char* doc = R"""(Getter for the initial guess */)""";

        } initial_guess;

        // drake::solvers::MathematicalProgram::linear_complementarity_constraints
        struct /* linear_complementarity_constraints */ {

          // drake/solvers/mathematical_program.h:2406
          const char* doc =
R"""(Getter for all linear complementarity constraints.*/)""";

        } linear_complementarity_constraints;

        // drake::solvers::MathematicalProgram::linear_constraints
        struct /* linear_constraints */ {

          // drake/solvers/mathematical_program.h:2346
          const char* doc = R"""(Getter for linear constraints. */)""";

        } linear_constraints;

        // drake::solvers::MathematicalProgram::linear_costs
        struct /* linear_costs */ {

          // drake/solvers/mathematical_program.h:2336
          const char* doc = R"""(Getter for linear costs. */)""";

        } linear_costs;

        // drake::solvers::MathematicalProgram::linear_equality_constraints
        struct /* linear_equality_constraints */ {

          // drake/solvers/mathematical_program.h:2331
          const char* doc = R"""(Getter for linear equality constraints.)""";

        } linear_equality_constraints;

        // drake::solvers::MathematicalProgram::linear_matrix_inequality_constraints
        struct /* linear_matrix_inequality_constraints */ {

          // drake/solvers/mathematical_program.h:2370
          const char* doc =
R"""(Getter for linear matrix inequality constraint */)""";

        } linear_matrix_inequality_constraints;

        // drake::solvers::MathematicalProgram::lorentz_cone_constraints
        struct /* lorentz_cone_constraints */ {

          // drake/solvers/mathematical_program.h:2351
          const char* doc = R"""(Getter for Lorentz cone constraint */)""";

        } lorentz_cone_constraints;

        // drake::solvers::MathematicalProgram::num_indeterminates
        struct /* num_indeterminates */ {

          // drake/solvers/mathematical_program.h:2461
          const char* doc =
R"""(Gets the number of indeterminates in the optimization program */)""";

        } num_indeterminates;

        // drake::solvers::MathematicalProgram::num_vars
        struct /* num_vars */ {

          // drake/solvers/mathematical_program.h:2434
          const char* doc =
R"""(Getter for number of variables in the optimization program */)""";

        } num_vars;

        // drake::solvers::MathematicalProgram::positive_semidefinite_constraints
        struct /* positive_semidefinite_constraints */ {

          // drake/solvers/mathematical_program.h:2364
          const char* doc =
R"""(Getter for positive semidefinite constraint */)""";

        } positive_semidefinite_constraints;

        // drake::solvers::MathematicalProgram::quadratic_costs
        struct /* quadratic_costs */ {

          // drake/solvers/mathematical_program.h:2341
          const char* doc = R"""(Getter for quadratic costs. */)""";

        } quadratic_costs;

        // drake::solvers::MathematicalProgram::rotated_lorentz_cone_constraints
        struct /* rotated_lorentz_cone_constraints */ {

          // drake/solvers/mathematical_program.h:2358
          const char* doc =
R"""(Getter for rotated Lorentz cone constraint */)""";

        } rotated_lorentz_cone_constraints;

        // drake::solvers::MathematicalProgram::visualization_callbacks
        struct /* visualization_callbacks */ {

          // drake/solvers/mathematical_program.h:2308
          const char* doc = R"""(Getter for all callbacks.)""";

        } visualization_callbacks;

      } MathematicalProgram;

      // drake::solvers::MathematicalProgramSolverInterface
      struct /* MathematicalProgramSolverInterface */ {

        // drake/solvers/mathematical_program_solver_interface.h:96
        const char* doc =
R"""(Interface used by implementations of individual solvers.)""";

        // drake::solvers::MathematicalProgramSolverInterface::MathematicalProgramSolverInterface
        struct /* ctor */ {

          // drake/solvers/mathematical_program_solver_interface.h:98
          const char* doc = R"""()""";

          // drake/solvers/mathematical_program_solver_interface.h:98
          const char* doc_2 = R"""()""";

          // drake/solvers/mathematical_program_solver_interface.h:100
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::MathematicalProgramSolverInterface::Solve
        struct /* Solve */ {

          // drake/solvers/mathematical_program_solver_interface.h:111
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::MathematicalProgramSolverInterface::available
        struct /* available */ {

          // drake/solvers/mathematical_program_solver_interface.h:104
          const char* doc =
R"""(Returns true iff this solver was enabled at compile-time.)""";

        } available;

        // drake::solvers::MathematicalProgramSolverInterface::solver_id
        struct /* solver_id */ {

          // drake/solvers/mathematical_program_solver_interface.h:114
          const char* doc = R"""(Returns the identifier of this solver.)""";

        } solver_id;

      } MathematicalProgramSolverInterface;

      // drake::solvers::MixedIntegerBranchAndBound
      struct /* MixedIntegerBranchAndBound */ {

        // drake/solvers/branch_and_bound.h:247
        const char* doc =
R"""(Given a mixed-integer optimization problem (MIP) (or more accurately,
mixed binary problem), solve this problem through branch-and-bound
process. We will first replace all the binary variables with
continuous variables, and relax the integral constraint on the binary
variables z ∈ {0, 1} with continuous constraints 0 ≤ z ≤ 1. In the
subsequent steps, at each node of the tree, we will fix some binary
variables to either 0 or 1, and solve the rest of the variables.
Notice that we will create a new set of variables in the branch-and-
bound process, since we need to replace the binary variables with
continuous variables.)""";

        // drake::solvers::MixedIntegerBranchAndBound::GetNewVariable
        struct /* GetNewVariable */ {

          // drake/solvers/branch_and_bound.h:365
          const char* doc =
R"""(Given an old variable in the original mixed-integer program, return
the corresponding new variable in the branch-and-bound process.

Parameter ``old_variable``:
    A variable in the original mixed-integer program.

Returns ``new_variable``:
    The corresponding variable in the branch-and-bound procedure. @pre
    old_variable is a variable in the mixed-integer program, passed in
    the constructor of this MixedIntegerBranchAndBound.

Throws:
    a runtime_error if the pre-condition fails.)""";

        } GetNewVariable;

        // drake::solvers::MixedIntegerBranchAndBound::GetNewVariables
        struct /* GetNewVariables */ {

          // drake/solvers/branch_and_bound.h:381
          const char* doc =
R"""(Given a matrix of old variables in the original mixed-integer program,
return a matrix of corresponding new variables in the branch-and-bound
process.

Parameter ``old_variables``:
    Variables in the original mixed-integer program.

Returns ``new_variables``:
    The corresponding variables in the branch-and-bound procedure.)""";

        } GetNewVariables;

        // drake::solvers::MixedIntegerBranchAndBound::GetOptimalCost
        struct /* GetOptimalCost */ {

          // drake/solvers/branch_and_bound.h:301
          const char* doc = R"""(Get the optimal cost. */)""";

        } GetOptimalCost;

        // drake::solvers::MixedIntegerBranchAndBound::GetSolution
        struct /* GetSolution */ {

          // drake/solvers/branch_and_bound.h:324
          const char* doc =
R"""(Get the n'th best integral solution for a variable. The best solutions
are sorted in the ascending order based on their costs. Each solution
is found in a separate node in the branch-and-bound tree, so the
values of the binary variables are different in each solution.

Parameter ``mip_var``:
    A variable in the original MIP.

Parameter ``nth_best_solution``:
    . The index of the best integral solution. @pre `mip_var` is a
    variable in the original MIP. @pre `nth_best_solution` is between
    0 and solutions().size().

Throws:
    runtime error if the preconditions are not satisfied.)""";

          // drake/solvers/branch_and_bound.h:342
          const char* doc_2 =
R"""(Get the n'th best integral solution for some variables. The best
solutions are sorted in the ascending order based on their costs. Each
solution is found in a separate node in the branch-and-bound tree, so

Parameter ``mip_vars``:
    Variables in the original MIP.

Parameter ``nth_best_solution``:
    . The index of the best integral solution. @pre `mip_vars` are
    variables in the original MIP. @pre `nth_best_solution` is between
    0 and solutions().size().

Throws:
    runtime error if the preconditions are not satisfied.)""";

        } GetSolution;

        // drake::solvers::MixedIntegerBranchAndBound::GetSubOptimalCost
        struct /* GetSubOptimalCost */ {

          // drake/solvers/branch_and_bound.h:311
          const char* doc =
R"""(Get the n'th sub-optimal cost. The costs are sorted in the ascending
order. The sub-optimal costs do not include the optimal cost.

Parameter ``nth_suboptimal_cost``:
    The n'th sub-optimal cost. @pre `nth_suboptimal_cost` is between 0
    and solutions().size() - 1.

Throws:
    s a runtime error if the precondition is not satisfied.)""";

        } GetSubOptimalCost;

        // drake::solvers::MixedIntegerBranchAndBound::IsLeafNodeFathomed
        struct /* IsLeafNodeFathomed */ {

          // drake/solvers/branch_and_bound.h:509
          const char* doc =
R"""(If a leaf node is fathomed, then there is no need to branch on this
node any more. A leaf node is fathomed is any of the following
conditions are satisfied: 1. The optimization problem in the node is
infeasible. 2. The optimal cost of the node is larger than the best
upper bound. 3. The optimal solution to the node satisfies all the
integral constraints. 4. All binary variables are fixed to either 0 or
1 in this node.

Parameter ``leaf_node``:
    A leaf node to check if it is fathomed. @pre The node should be a
    leaf node.

Throws:
    s runtime error if the precondition is not satisfied.)""";

        } IsLeafNodeFathomed;

        // drake::solvers::MixedIntegerBranchAndBound::MixedIntegerBranchAndBound
        struct /* ctor */ {

          // drake/solvers/branch_and_bound.h:285
          const char* doc =
R"""(Construct a branch-and-bound tree from a mixed-integer optimization
program.

Parameter ``prog``:
    A mixed-integer optimization program.

Parameter ``solver_id``:
    The ID of the solver for the optimization.)""";

        } ctor;

        // drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod
        struct /* NodeSelectionMethod */ {

          // drake/solvers/branch_and_bound.h:261
          const char* doc =
R"""(Different methods to pick a branching node.)""";

          // drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kDepthFirst
          struct /* kDepthFirst */ {

            // drake/solvers/branch_and_bound.h:263
            const char* doc =
R"""(< Pick the node with the most binary variables fixed.)""";

          } kDepthFirst;

          // drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kMinLowerBound
          struct /* kMinLowerBound */ {

            // drake/solvers/branch_and_bound.h:264
            const char* doc =
R"""(< Pick the node with the smallest optimal cost.)""";

          } kMinLowerBound;

          // drake::solvers::MixedIntegerBranchAndBound::NodeSelectionMethod::kUserDefined
          struct /* kUserDefined */ {

            // drake/solvers/branch_and_bound.h:262
            const char* doc = R"""(< User defined.)""";

          } kUserDefined;

        } NodeSelectionMethod;

        // drake::solvers::MixedIntegerBranchAndBound::SetNodeSelectionMethod
        struct /* SetNodeSelectionMethod */ {

          // drake/solvers/branch_and_bound.h:399
          const char* doc =
R"""(The user can choose the method to pick a node for branching. We
provide options such as "depth first" or "min lower bound".

Parameter ``node_selection_method``:
    The option to pick a node. If the option is
    NodeSelectionMethod::kUserDefined, then the user should also
    provide the method to pick a node through
    SetUserDefinedNodeSelectionFunction.)""";

        } SetNodeSelectionMethod;

        // drake::solvers::MixedIntegerBranchAndBound::SetSearchIntegralSolutionByRounding
        struct /* SetSearchIntegralSolutionByRounding */ {

          // drake/solvers/branch_and_bound.h:485
          const char* doc =
R"""(Set the flag to true if the user wants to search an integral solution
in each node, after the optimization problem in that node is solved.
The program can search for an integral solution based on the solution
to the optimization program in the node, by rounding the binary
variables to the nearest integer value, and solve for the continuous
variables. If a solution is obtained in this new program, then this
solution is an integral solution to the mixed-integer program.)""";

        } SetSearchIntegralSolutionByRounding;

        // drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedNodeCallbackFunction
        struct /* SetUserDefinedNodeCallbackFunction */ {

          // drake/solvers/branch_and_bound.h:493
          const char* doc =
R"""(The user can set a defined callback function in each node. This
function is called after the optimization is solved in each node.)""";

        } SetUserDefinedNodeCallbackFunction;

        // drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedNodeSelectionFunction
        struct /* SetUserDefinedNodeSelectionFunction */ {

          // drake/solvers/branch_and_bound.h:434
          const char* doc =
R"""(Set the user-defined method to pick the branching node. This method is
used if the user calls
SetNodeSelectionMethod(NodeSelectionMethod::kUserDefined).

For example, if the user has defined a function LeftMostNode that
would return the left-most unfathomed node in the tree, then the user
could do

```
{.cc}
MixedIntegerBranchAndBoundNode* LeftMostNodeInSubTree(
    const MixedIntegerBranchAndBound& branch_and_bound,
    const MixedIntegerBranchAndBoundNode& subtree_root) {
  // Starting from the subtree root, find the left most leaf node that is
not fathomed.
  blah
}

MixedIntegerBranchAndBound bnb(...);
bnb.SetNodeSelectionMethod(MixedIntegerBranchAndBound::NodeSelectionMethod::kUserDefined);
// Use a lambda function as the NodeSelectionFun
bnb->SetUserDefinedNodeSelectionFunction([](
    const MixedIntegerBranchAndBound& branch_and_bound) {
  return LeftMostNodeInSubTree(branch_and_bound,
*(branch_and_bound.root()));
```

A more detailed example can be found in
solvers/test/branch_and_bound_test.cc in
TestSetUserDefinedNodeSelectionFunction.

Note:
    The user defined function should pick an un-fathomed leaf node for
    branching.

Throws:
    a runtime error if the node is not a leaf node, or it is fathomed.)""";

        } SetUserDefinedNodeSelectionFunction;

        // drake::solvers::MixedIntegerBranchAndBound::SetUserDefinedVariableSelectionFunction
        struct /* SetUserDefinedVariableSelectionFunction */ {

          // drake/solvers/branch_and_bound.h:473
          const char* doc =
R"""(Set the user-defined method to pick the branching variable. This
method is used if the user calls
SetVariableSelectionMethod(VariableSelectionMethod::kUserDefined).

For example, if the user has defined a function FirstVariable, that
would return the first un-fixed binary variable in this branch as

```
{.cc}
SymbolicVariable* FirstVariable(const MixedIntegerBranchAndBoundNode& node)
{
  return node.remaining_binary_variables().begin();
}
```

The user can then set the branch-and-bound to use this function to
select the branching variable as

```
{.cc}
MixedIntegerBranchAndBound bnb(...);
bnb.SetVariableSelectionMethod(MixedIntegerBranchAndBound:VariableSelectionMethod::kUserDefined);
// Set VariableSelectFun by using a function pointer.
bnb.SetUserDefinedVariableSelectionFunction(FirstVariable);
```)""";

        } SetUserDefinedVariableSelectionFunction;

        // drake::solvers::MixedIntegerBranchAndBound::SetVariableSelectionMethod
        struct /* SetVariableSelectionMethod */ {

          // drake/solvers/branch_and_bound.h:446
          const char* doc =
R"""(The user can choose the method to pick a variable for branching in
each node. We provide options such as "most ambivalent" or "least
ambivalent".

Parameter ``variable_selection_method``:
    The option to pick a variable. If the option is
    VariableSelectionMethod::kUserDefined, then the user should also
    provide the method to pick a variable through
    SetUserDefinedVariableSelectionFunction(...).)""";

        } SetVariableSelectionMethod;

        // drake::solvers::MixedIntegerBranchAndBound::Solve
        struct /* Solve */ {

          // drake/solvers/branch_and_bound.h:298
          const char* doc =
R"""(Solve the mixed-integer problem (MIP) through a branch and bound
process.

Returns ``solution_result``:
    If solution_result=SolutionResult::kSolutionFound, then the best
    solutions are stored inside solutions(). The user can access the
    value of each variable(s) through GetSolution(...). If
    solution_result=SolutionResult::kInfeasibleConstraints, then the
    mixed-integer problem is primal infeasible. If
    solution_result=SolutionResult::kUnbounded, then the mixed-integer
    problem is primal unbounded.)""";

        } Solve;

        // drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod
        struct /* VariableSelectionMethod */ {

          // drake/solvers/branch_and_bound.h:252
          const char* doc =
R"""(Different methods to pick a branching variable.)""";

          // drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kLeastAmbivalent
          struct /* kLeastAmbivalent */ {

            // drake/solvers/branch_and_bound.h:254
            const char* doc =
R"""(< Pick the variable whose value is closest to 0 or 1.)""";

          } kLeastAmbivalent;

          // drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kMostAmbivalent
          struct /* kMostAmbivalent */ {

            // drake/solvers/branch_and_bound.h:255
            const char* doc =
R"""(< Pick the variable whose value is closest to 0.5)""";

          } kMostAmbivalent;

          // drake::solvers::MixedIntegerBranchAndBound::VariableSelectionMethod::kUserDefined
          struct /* kUserDefined */ {

            // drake/solvers/branch_and_bound.h:253
            const char* doc = R"""(< User defined.)""";

          } kUserDefined;

        } VariableSelectionMethod;

        // drake::solvers::MixedIntegerBranchAndBound::absolute_gap_tol
        struct /* absolute_gap_tol */ {

          // drake/solvers/branch_and_bound.h:541
          const char* doc =
R"""(Getter for the absolute gap tolerance. */)""";

        } absolute_gap_tol;

        // drake::solvers::MixedIntegerBranchAndBound::best_lower_bound
        struct /* best_lower_bound */ {

          // drake/solvers/branch_and_bound.h:522
          const char* doc = R"""(Getter for the best lower bound. */)""";

        } best_lower_bound;

        // drake::solvers::MixedIntegerBranchAndBound::best_upper_bound
        struct /* best_upper_bound */ {

          // drake/solvers/branch_and_bound.h:519
          const char* doc = R"""(Getter for the best upper bound. */)""";

        } best_upper_bound;

        // drake::solvers::MixedIntegerBranchAndBound::relative_gap_tol
        struct /* relative_gap_tol */ {

          // drake/solvers/branch_and_bound.h:551
          const char* doc =
R"""(Geeter for the relative gap tolerance. */)""";

        } relative_gap_tol;

        // drake::solvers::MixedIntegerBranchAndBound::root
        struct /* root */ {

          // drake/solvers/branch_and_bound.h:516
          const char* doc =
R"""(Getter for the root node. Note that this is aliased for the lifetime
of this object.)""";

        } root;

        // drake::solvers::MixedIntegerBranchAndBound::set_absolute_gap_tol
        struct /* set_absolute_gap_tol */ {

          // drake/solvers/branch_and_bound.h:538
          const char* doc =
R"""(Setter for the absolute gap tolerance. The branch-and-bound will
terminate if its difference between its best upper bound and best
lower bound is below this gap tolerance.)""";

        } set_absolute_gap_tol;

        // drake::solvers::MixedIntegerBranchAndBound::set_relative_gap_tol
        struct /* set_relative_gap_tol */ {

          // drake/solvers/branch_and_bound.h:548
          const char* doc =
R"""(Setter for the relative gap tolerance. The branch-and-bound will
terminate if (best_upper_bound() - best_lower_bound()) /
abs(best_lower_bound()) is smaller than this tolerance.)""";

        } set_relative_gap_tol;

        // drake::solvers::MixedIntegerBranchAndBound::solutions
        struct /* solutions */ {

          // drake/solvers/branch_and_bound.h:530
          const char* doc =
R"""(Getter for the solutions. Returns a list of solutions, together with
the costs evaluated at the solutions. The solutions are sorted in the
ascending order based on the cost.)""";

        } solutions;

      } MixedIntegerBranchAndBound;

      // drake::solvers::MixedIntegerBranchAndBoundNode
      struct /* MixedIntegerBranchAndBoundNode */ {

        // drake/solvers/branch_and_bound.h:36
        const char* doc =
R"""(A node in the branch-and-bound (bnb) tree. The whole branch-and-bound
tree solves the mixed-integer problem min f(x) (1) s.t g(x) ≤ 0 z ∈
{0, 1} where the binary variables z are a subset of the decision
variables x. In this node, we will fix some binary variables to either
0 and 1, and relax the rest of the binary variables to continuous
variables between 0 and 1. Namely we will solve the following problem
with all variables being continuous min f(x) (2) s.t g(x) ≤ 0 z_fixed
= b_fixed 0 ≤ z_relaxed ≤ 1 where z_fixed, z_relaxed is a partition of
the original binary variables z. z_fixed is the fixed binary
variables, z_relaxed is the relaxed binary variables. b_fixed is a
vector containing the assigned values of the fixed binary variables
z_fixed, b_fixed only contains value either 0 or 1.

Each node is created from its parent node, by fixing one binary
variable to either 0 or 1.)""";

        // drake::solvers::MixedIntegerBranchAndBoundNode::Branch
        struct /* Branch */ {

          // drake/solvers/branch_and_bound.h:81
          const char* doc =
R"""(Branches on ``binary_variable``, and creates two child nodes. In the
left child node, the binary variable is fixed to 0. In the right node,
the binary variable is fixed to 1. Solves the optimization program in
each child node.

Parameter ``binary_variable``:
    This binary variable is fixed to either 0 or 1 in the child node.
    @pre binary_variable is in remaining_binary_variables_;

Throws:
    std::runtime_error if the preconditions are not met.)""";

        } Branch;

        // drake::solvers::MixedIntegerBranchAndBoundNode::ConstructRootNode
        struct /* ConstructRootNode */ {

          // drake/solvers/branch_and_bound.h:69
          const char* doc =
R"""(Construct the root node from an optimization program. For the mixed-
integer optimization program min f(x) (1) s.t g(x) ≤ 0 z ∈ {0, 1} we
will construct a root node for this mixed-integer program. In the root
node, it enforces all the costs and constraints in the original
program, except the binary constraint z ∈ {0, 1}. Instead, it enforces
the relaxed constraint to 0 ≤ z ≤ 1. So the root node contains the
program min f(x) (2) s.t g(x) ≤ 0 0 ≤ z ≤ 1 This optimization program
is solved during the node construction.

Parameter ``prog``:
    The mixed-integer optimization program (1) in the documentation
    above.

Parameter ``solver_id``:
    The ID of the solver for the optimization program. @retval (node,
    map_old_vars_to_new_vars) node is the root node of the tree, that
    contains the optimization program (2) in the documentation above.
    This root node has no parent. We also need to recreate new
    decision variables in the root node, from the original
    optimization program (1), since the binary variables will be
    converted to continuous variables in (2). We thus return the map
    from the old variables to the new variables. @pre prog should
    contain binary variables. @pre solver_id can be either Gurobi or
    Scs.

Throws:
    std::runtime_error if the preconditions are not met.)""";

        } ConstructRootNode;

        // drake::solvers::MixedIntegerBranchAndBoundNode::IsLeaf
        struct /* IsLeaf */ {

          // drake/solvers/branch_and_bound.h:91
          const char* doc =
R"""(Determine if a node is a leaf or not. A leaf node has no child nodes.)""";

        } IsLeaf;

        // drake::solvers::MixedIntegerBranchAndBoundNode::IsRoot
        struct /* IsRoot */ {

          // drake/solvers/branch_and_bound.h:86
          const char* doc =
R"""(Returns true if a node is the root. A root node has no parent.)""";

        } IsRoot;

        // drake::solvers::MixedIntegerBranchAndBoundNode::MixedIntegerBranchAndBoundNode
        struct /* ctor */ {

          // drake/solvers/branch_and_bound.h:38
          const char* doc = R"""()""";

          // drake/solvers/branch_and_bound.h:38
          const char* doc_2 = R"""()""";

        } ctor;

        // drake::solvers::MixedIntegerBranchAndBoundNode::fixed_binary_value
        struct /* fixed_binary_value */ {

          // drake/solvers/branch_and_bound.h:136
          const char* doc =
R"""(Getter for the value of the binary variable, which was not fixed in
the parent node, but is fixed to either 0 or 1 in this node.)""";

        } fixed_binary_value;

        // drake::solvers::MixedIntegerBranchAndBoundNode::fixed_binary_variable
        struct /* fixed_binary_variable */ {

          // drake/solvers/branch_and_bound.h:128
          const char* doc =
R"""(Getter for the binary variable, whose value was not fixed in the
parent node, but is fixed to either 0 or 1 in this node.)""";

        } fixed_binary_variable;

        // drake::solvers::MixedIntegerBranchAndBoundNode::left_child
        struct /* left_child */ {

          // drake/solvers/branch_and_bound.h:99
          const char* doc = R"""(Getter for the left child. */)""";

        } left_child;

        // drake::solvers::MixedIntegerBranchAndBoundNode::mutable_left_child
        struct /* mutable_left_child */ {

          // drake/solvers/branch_and_bound.h:104
          const char* doc = R"""(Getter for the mutable left child. */)""";

        } mutable_left_child;

        // drake::solvers::MixedIntegerBranchAndBoundNode::mutable_parent
        struct /* mutable_parent */ {

          // drake/solvers/branch_and_bound.h:122
          const char* doc = R"""(Getter for the mutable parent node. */)""";

        } mutable_parent;

        // drake::solvers::MixedIntegerBranchAndBoundNode::mutable_right_child
        struct /* mutable_right_child */ {

          // drake/solvers/branch_and_bound.h:114
          const char* doc = R"""(Getter for the mutable right child. */)""";

        } mutable_right_child;

        // drake::solvers::MixedIntegerBranchAndBoundNode::optimal_solution_is_integral
        struct /* optimal_solution_is_integral */ {

          // drake/solvers/branch_and_bound.h:153
          const char* doc =
R"""(Getter for optimal_solution_is_integral. @pre The optimization problem
is solved successfully.

Throws:
    s a runtime error if the precondition is not satisfied.)""";

        } optimal_solution_is_integral;

        // drake::solvers::MixedIntegerBranchAndBoundNode::parent
        struct /* parent */ {

          // drake/solvers/branch_and_bound.h:119
          const char* doc = R"""(Getter for the parent node. */)""";

        } parent;

        // drake::solvers::MixedIntegerBranchAndBoundNode::prog
        struct /* prog */ {

          // drake/solvers/branch_and_bound.h:96
          const char* doc = R"""(Getter for the mathematical program.)""";

        } prog;

        // drake::solvers::MixedIntegerBranchAndBoundNode::remaining_binary_variables
        struct /* remaining_binary_variables */ {

          // drake/solvers/branch_and_bound.h:141
          const char* doc =
R"""(Getter for the remaining binary variables in this node.)""";

        } remaining_binary_variables;

        // drake::solvers::MixedIntegerBranchAndBoundNode::right_child
        struct /* right_child */ {

          // drake/solvers/branch_and_bound.h:109
          const char* doc = R"""(Getter for the right child. */)""";

        } right_child;

        // drake::solvers::MixedIntegerBranchAndBoundNode::solution_result
        struct /* solution_result */ {

          // drake/solvers/branch_and_bound.h:146
          const char* doc =
R"""(Getter for the solution result when solving the optimization program.
*/)""";

        } solution_result;

        // drake::solvers::MixedIntegerBranchAndBoundNode::solver_id
        struct /* solver_id */ {

          // drake/solvers/branch_and_bound.h:156
          const char* doc = R"""(Getter for solver id. */)""";

        } solver_id;

      } MixedIntegerBranchAndBoundNode;

      // drake::solvers::MixedIntegerRotationConstraintGenerator
      struct /* MixedIntegerRotationConstraintGenerator */ {

        // drake/solvers/mixed_integer_rotation_constraint.h:49
        const char* doc =
R"""(We relax the non-convex SO(3) constraint on rotation matrix R to
mixed-integer linear constraints. The formulation of these constraints
are described in Global Inverse Kinematics via Mixed-integer Convex
Optimization by Hongkai Dai, Gregory Izatt and Russ Tedrake, ISRR,
2017

The SO(3) constraint on a rotation matrix R = [r₁, r₂, r₃], rᵢ∈ℝ³ is

```
rᵢᵀrᵢ = 1    (1)
rᵢᵀrⱼ = 0    (2)
r₁ x r₂ = r₃ (3)
```

To relax SO(3) constraint on rotation matrix R, we divide the range
[-1, 1] (the range of each entry in R) into smaller intervals [φ(i),
φ(i+1)], and then relax the SO(3) constraint within each interval. We
provide 3 approaches for relaxation 1. By replacing each bilinear
product in constraint (1), (2) and (3) with a new variable, in the
McCormick envelope of the bilinear product w = x * y. 2. By
considering the intersection region between axis-aligned boxes, and
the surface of a unit sphere in 3D. 3. By combining the two approaches
above. This will result in a tighter relaxation.

These three approaches give different relaxation of SO(3) constraint
(the feasible sets for each relaxation are different), and different
computation speed. The users can switch between the approaches to find
the best fit for their problem.

Note:
    If you have several rotation matrices that all need to be relaxed
    through mixed-integer constraint, then you can create a single
    MixedIntegerRotationConstraintGenerator object, and add the mixed-
    integer constraint to each rotation matrix, by calling
    AddToProgram() function repeatedly.)""";

        // drake::solvers::MixedIntegerRotationConstraintGenerator::AddToProgram
        struct /* AddToProgram */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:119
          const char* doc =
R"""(Add the mixed-integer linear constraints to the optimization program,
as a relaxation of SO(3) constraint on the rotation matrix `R`.

Parameter ``R``:
    The rotation matrix on which the SO(3) constraint is imposed.

Parameter ``prog``:
    The optimization program to which the mixed-integer constraints
    (and additional variables) are added.)""";

        } AddToProgram;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::Approach
        struct /* Approach */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:54
          const char* doc = R"""()""";

          // drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBilinearMcCormick
          struct /* kBilinearMcCormick */ {

            // drake/solvers/mixed_integer_rotation_constraint.h:58
            const char* doc =
R"""(< Relax SO(3) constraint by considering the < McCormick envelope on
the bilinear product.)""";

          } kBilinearMcCormick;

          // drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBoth
          struct /* kBoth */ {

            // drake/solvers/mixed_integer_rotation_constraint.h:60
            const char* doc =
R"""(< Relax SO(3) constraint by considering both the < intersection
between boxes and the unit sphere < surface, and the McCormick
envelope on the < bilinear product.)""";

          } kBoth;

          // drake::solvers::MixedIntegerRotationConstraintGenerator::Approach::kBoxSphereIntersection
          struct /* kBoxSphereIntersection */ {

            // drake/solvers/mixed_integer_rotation_constraint.h:55
            const char* doc =
R"""(< Relax SO(3) constraint by considering the < intersection between
boxes and the unit sphere < surface.)""";

          } kBoxSphereIntersection;

        } Approach;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:51
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::MixedIntegerRotationConstraintGenerator
        struct /* ctor */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:51
          const char* doc = R"""()""";

          // drake/solvers/mixed_integer_rotation_constraint.h:51
          const char* doc_2 = R"""()""";

          // drake/solvers/mixed_integer_rotation_constraint.h:108
          const char* doc_3 =
R"""(Constructor

Parameter ``approach``:
    Refer to MixedIntegerRotationConstraintGenerator::Approach for the
    details.

Parameter ``num_intervals_per_half_axis``:
    We will cut the range [-1, 1] evenly to 2 *
    `num_intervals_per_half_axis` small intervals. The number of
    binary variables will depend on the number of intervals.

Parameter ``interval_binning``:
    The binning scheme we use to add SOS2 constraint with binary
    variables. If interval_binning = kLinear, then we will add 9 * 2 *
    `num_intervals_per_half_axis binary` variables; if
    interval_binning = kLogarithmic, then we will add 9 * (1 +
    log₂(num_intervals_per_half_axis)) binary variables. Refer to
    AddLogarithmicSos2Constraint and AddSos2Constraint for more
    details.)""";

        } ctor;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType
        struct /* ReturnType */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:66
          const char* doc = R"""()""";

          // drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType::B_
          struct /* B_ */ {

            // drake/solvers/mixed_integer_rotation_constraint.h:77
            const char* doc =
R"""(B_ contains the new binary variables added to the program. B_[i][j]
represents in which interval R(i, j) lies. If we use linear binning,
then B_[i][j] is of length 2 * num_intervals_per_half_axis_.
B_[i][j](k) = 1 => φ(k) ≤ R(i, j) ≤ φ(k + 1) B_[i][j](k) = 0 => R(i,
j) ≥ φ(k + 1) or R(i, j) ≤ φ(k) If we use logarithmic binning, then
B_[i][j] is of length 1 + log₂(num_intervals_per_half_axis_). If
B_[i][j] represents integer k in reflected Gray code, then R(i, j) is
in the interval [φ(k), φ(k+1)].)""";

          } B_;

          // drake::solvers::MixedIntegerRotationConstraintGenerator::ReturnType::lambda_
          struct /* lambda_ */ {

            // drake/solvers/mixed_integer_rotation_constraint.h:91
            const char* doc =
R"""(λ contains part of the new continuous variables added to the program.
λ_[i][j] is of length 2 * num_intervals_per_half_axis_ + 1, such that
R(i, j) = φᵀ * λ_[i][j]. Notice that λ_[i][j] satisfies the special
ordered set of type 2 (SOS2) constraint. Namely at most two entries in
λ_[i][j] can be strictly positive, and these two entries have to be
consecutive. Mathematically

```
∑ₖ λ_[i][j](k) = 1
λ_[i][j](k) ≥ 0 ∀ k
∃ m s.t λ_[i][j](n) = 0 if n ≠ m and n ≠ m+1
```)""";

          } lambda_;

        } ReturnType;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::approach
        struct /* approach */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:129
          const char* doc = R"""()""";

        } approach;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::interval_binning
        struct /* interval_binning */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:135
          const char* doc = R"""()""";

        } interval_binning;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::num_intervals_per_half_axis
        struct /* num_intervals_per_half_axis */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:131
          const char* doc = R"""()""";

        } num_intervals_per_half_axis;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::phi
        struct /* phi */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:124
          const char* doc = R"""(Getter for φ. */)""";

        } phi;

        // drake::solvers::MixedIntegerRotationConstraintGenerator::phi_nonnegative
        struct /* phi_nonnegative */ {

          // drake/solvers/mixed_integer_rotation_constraint.h:127
          const char* doc =
R"""(Getter for φ₊, the non-negative part of φ. */)""";

        } phi_nonnegative;

      } MixedIntegerRotationConstraintGenerator;

      // drake::solvers::MobyLCPSolver
      struct /* MobyLCPSolver */ {

        // drake/solvers/moby_lcp_solver.h:70
        const char* doc =
R"""(A class for solving Linear Complementarity Problems (LCPs). Solving a
LCP requires finding a solution to the problem:

```
Mz + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
```

(where M ∈ ℝⁿˣⁿ and q ∈ ℝⁿ are problem inputs and z ∈ ℝⁿ and w ∈ ℝⁿ
are unknown vectors) or correctly reporting that such a solution does
not exist. In spite of their linear structure, solving LCPs is NP-Hard
[Cottle 1992]. However, some LCPs are significantly easier to solve.
For instance, it can be seen that the LCP is solvable in worst-case
polynomial time for the case of symmetric positive-semi-definite M by
formulating it as the following convex quadratic program:

```
minimize:   f(z) = zᵀw = zᵀ(Mz + q)
subject to: z ≥ 0
            Mz + q ≥ 0
```

Note that this quadratic program's (QP) objective function at the
minimum z cannot be less than zero, and the LCP is only solved if the
objective function at the minimum is equal to zero. Since the seminal
result of Karmarkar, it has been known that convex QPs are solvable in
polynomial time [Karmarkar 1984].

The difficulty of solving an LCP is characterized by the properties of
its particular matrix, namely the class of matrices it belongs to.
Classes include, for example, Q, Q₀, P, P₀, copositive, and Z
matrices. [Cottle 1992] and [Murty 1998] (see pp. 224-230 in the
latter) describe relevant matrix classes in more detail.

* [Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992. * [Karmarkar 1984] N.
Karmarkar. A New Polynomial-Time Algorithm for Linear Programming.
Combinatorica, 4(4), pp. 373-395. * [Murty 1988] K. Murty. Linear
Complementarity, Linear and Nonlinear Programming. Heldermann Verlag,
1988.)""";

        // drake::solvers::MobyLCPSolver::ComputeZeroTolerance
        struct /* ComputeZeroTolerance */ {

          // drake/solvers/moby_lcp_solver.h:82
          const char* doc =
R"""(Calculates the zero tolerance that the solver would compute if the
user does not specify a tolerance.)""";

        } ComputeZeroTolerance;

        // drake::solvers::MobyLCPSolver::MobyLCPSolver<T>
        struct /* ctor */ {

          // drake/solvers/moby_lcp_solver.h:72
          const char* doc = R"""()""";

          // drake/solvers/moby_lcp_solver.h:72
          const char* doc_2 = R"""()""";

          // drake/solvers/moby_lcp_solver.h:74
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::MobyLCPSolver::SetLoggingEnabled
        struct /* SetLoggingEnabled */ {

          // drake/solvers/moby_lcp_solver.h:77
          const char* doc = R"""()""";

        } SetLoggingEnabled;

        // drake::solvers::MobyLCPSolver::Solve
        struct /* Solve */ {

          // drake/solvers/moby_lcp_solver.h:271
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::MobyLCPSolver::SolveLcpFast
        struct /* SolveLcpFast */ {

          // drake/solvers/moby_lcp_solver.h:125
          const char* doc =
R"""(Fast pivoting algorithm for LCPs of the form M = PAPᵀ, q = Pb, where b
∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A is positive definite).
Therefore, q is in the range of P and M is positive semi-definite. An
LCP of this form is also guaranteed to have a solution [Cottle 1992].

This particular implementation focuses on the case where the solution
requires few nonzero nonbasic variables, meaning that few z variables
need be nonzero to find a solution to Mz + q = w. This algorithm,
which is based off of Dantzig's Principle Pivoting Method I [Cottle
1992] is described in [Drumwright 2015]. This algorithm is able to use
"warm" starting- a solution to a "nearby" LCP can be used to find the
solution to a given LCP more quickly.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix class. For these reasons, the solver returns a flag
indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector. @param[in,out] z the solution to the LCP on return
    (if the solver succeeds). If the length of z is equal to the
    length of q, the solver will attempt to use z's value as a
    starting solution. If the solver fails (returns `false`), `z` will
    be set to the zero vector.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Throws:
    s std::logic_error if M is non-square or M's dimensions do not
    equal q's dimension.

Returns:
    `true` if the solver succeeded and `false` otherwise.

* [Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992. * [Drumwright 2015] E.
Drumwright. Rapidly computable viscous friction and no-slip rigid
contact models. arXiv: 1504.00719v1. 2015.)""";

        } SolveLcpFast;

        // drake::solvers::MobyLCPSolver::SolveLcpFastRegularized
        struct /* SolveLcpFastRegularized */ {

          // drake/solvers/moby_lcp_solver.h:179
          const char* doc =
R"""(Regularized version of the fast pivoting algorithm for LCPs of the
form M = PAPᵀ, q = Pb, where b ∈ ℝᵐ, P ∈ ℝⁿˣᵐ, and A ∈ ℝᵐˣᵐ (where A
is positive definite). Therefore, q is in the range of P and M is
positive semi-definite. Please see SolveLcpFast() for more
documentation about the particular algorithm.

This implementation wraps that algorithm with a Tikhonov-type
regularization approach. Specifically, this implementation repeatedly
attempts to solve the LCP:

```
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
```

where I is the identity matrix and α ≪ 1, using geometrically
increasing values of α, until the LCP is solved. Cottle et al.
describe how, for sufficiently large α, the LCP will always be
solvable [Cottle 1992], p. 493.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix class. For these reasons, the solver returns a flag
indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector. @param[in,out] z the solution to the LCP on return
    (if the solver succeeds). If the length of z is equal to the
    length of q, the solver will attempt to use z's value as a
    starting solution.

Parameter ``min_exp``:
    The minimum exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``step_exp``:
    The stepping exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``max_exp``:
    The maximum exponent for computing α over [10ᵝ, 10ᵞ] in steps of
    10ᵟ, where β is the minimum exponent, γ is the maximum exponent,
    and δ is the stepping exponent.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Throws:
    s std::logic_error if M is non-square or M's dimensions do not
    equal q's dimension.

Returns:
    `true` if the solver succeeded and `false` if the solver did not
    find a solution for α = 10ᵞ.

See also:
    SolveLcpFast()

* [Cottle, 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992.)""";

        } SolveLcpFastRegularized;

        // drake::solvers::MobyLCPSolver::SolveLcpLemke
        struct /* SolveLcpLemke */ {

          // drake/solvers/moby_lcp_solver.h:227
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. Lemke's Algorithm is described in
[Cottle 1992], Section 4.4. This implementation was adapted from the
LEMKE Library [LEMKE] for Matlab; this particular implementation fixes
a bug in LEMKE that could occur when multiple indices passed the
minimum ratio test.

Although this solver is theoretically guaranteed to give a solution to
the LCPs described above, accumulated floating point error from
pivoting operations could cause the solver to fail. Additionally, the
solver can be applied with some success to problems outside of its
guaranteed matrix classes. For these reasons, the solver returns a
flag indicating success/failure.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector. @param[in,out] z the solution to the LCP on return
    (if the solver succeeds). If the length of z is equal to the
    length of q, the solver will attempt to use z's value as a
    starting solution. **This warmstarting is generally not
    recommended**: it has a predisposition to lead to a failing
    pivoting sequence. If the solver fails (returns `false`), `z` will
    be set to the zero vector.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Parameter ``piv_tol``:
    The tolerance for testing against zero, specifically used for the
    purpose of finding variables for pivoting. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Returns:
    `true` if the solver **believes** it has computed a solution
    (which it determines by the ability to "pivot out" the
    "artificial" variable (see [Cottle 1992]) and `false` otherwise.
    @warning The caller should verify that the algorithm has solved
    the LCP to the desired tolerances on returns indicating success.

Throws:
    s std::logic_error if M is not square or the dimensions of M do
    not match the length of q.

* [Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992. * [LEMKE] P. Fackler
and M. Miranda. LEMKE.
http://people.sc.fsu.edu/~burkardt/m\_src/lemke/lemke.m)""";

        } SolveLcpLemke;

        // drake::solvers::MobyLCPSolver::SolveLcpLemkeRegularized
        struct /* SolveLcpLemkeRegularized */ {

          // drake/solvers/moby_lcp_solver.h:263
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. Lemke's Algorithm is described in
[Cottle 1992], Section 4.4.

This implementation wraps that algorithm with a Tikhonov-type
regularization approach. Specifically, this implementation repeatedly
attempts to solve the LCP:

```
(M + Iα)z + q = w
z ≥ 0
w ≥ 0
zᵀw = 0
```

where I is the identity matrix and α ≪ 1, using geometrically
increasing values of α, until the LCP is solved. See
SolveLcpFastRegularized() for description of the regularization
process and the function parameters, which are identical. See
SolveLcpLemke() for a description of Lemke's Algorithm. See
SolveLcpFastRegularized() for a description of all calling parameters
other than ``z``, which apply equally well to this function.
@param[in,out] z the solution to the LCP on return (if the solver
succeeds). If the length of z is equal to the length of q, the solver
will attempt to use z's value as a starting solution. **This
warmstarting is generally not recommended**: it has a predisposition
to lead to a failing pivoting sequence.

See also:
    SolveLcpFastRegularized()

See also:
    SolveLcpLemke()

* [Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992.)""";

        } SolveLcpLemkeRegularized;

        // drake::solvers::MobyLCPSolver::available
        struct /* available */ {

          // drake/solvers/moby_lcp_solver.h:269
          const char* doc = R"""()""";

        } available;

        // drake::solvers::MobyLCPSolver::get_num_pivots
        struct /* get_num_pivots */ {

          // drake/solvers/moby_lcp_solver.h:276
          const char* doc =
R"""(Returns the number of pivoting operations made by the last LCP solve.)""";

        } get_num_pivots;

        // drake::solvers::MobyLCPSolver::reset_num_pivots
        struct /* reset_num_pivots */ {

          // drake/solvers/moby_lcp_solver.h:280
          const char* doc =
R"""(Resets the number of pivoting operations made by the last LCP solver
to zero.)""";

        } reset_num_pivots;

        // drake::solvers::MobyLCPSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/moby_lcp_solver.h:273
          const char* doc = R"""()""";

        } solver_id;

      } MobyLCPSolver;

      // drake::solvers::MobyLcpSolverId
      struct /* MobyLcpSolverId */ {

        // drake/solvers/moby_lcp_solver.h:24
        const char* doc =
R"""(Non-template class for MobyLcpSolver<T> constants.)""";

        // drake::solvers::MobyLcpSolverId::MobyLcpSolverId
        struct /* ctor */ {

          // drake/solvers/moby_lcp_solver.h:26
          const char* doc = R"""()""";

          // drake/solvers/moby_lcp_solver.h:26
          const char* doc_2 = R"""()""";

          // drake/solvers/moby_lcp_solver.h:27
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::MobyLcpSolverId::id
        struct /* id */ {

          // drake/solvers/moby_lcp_solver.h:30
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

      } MobyLcpSolverId;

      // drake::solvers::MosekSolver
      struct /* MosekSolver */ {

        // drake/solvers/mosek_solver.h:14
        const char* doc = R"""()""";

        // drake::solvers::MosekSolver::AcquireLicense
        struct /* AcquireLicense */ {

          // drake/solvers/mosek_solver.h:65
          const char* doc =
R"""(This acquires a MOSEK license environment shared among all MosekSolver
instances; the environment will stay valid as long as at least one
shared_ptr returned by this function is alive. Call this ONLY if you
must use different MathematicalProgram instances at different
instances in time, and repeatedly acquiring the license is costly
(e.g., requires contacting a license server).

Returns:
    A shared pointer to a license environment that will stay valid as
    long as any shared_ptr returned by this function is alive. If
    MOSEK is not available in your build, this will return a null
    (empty) shared_ptr.

Throws:
    s std::runtime_error if MOSEK is available but a license cannot be
    obtained.)""";

        } AcquireLicense;

        // drake::solvers::MosekSolver::License
        struct /* License */ {

          // drake/solvers/mosek_solver.h:50
          const char* doc =
R"""(This type contains a valid MOSEK license environment, and is only to
be used from AcquireLicense().)""";

        } License;

        // drake::solvers::MosekSolver::MosekSolver
        struct /* ctor */ {

          // drake/solvers/mosek_solver.h:16
          const char* doc = R"""()""";

          // drake/solvers/mosek_solver.h:16
          const char* doc_2 = R"""()""";

          // drake/solvers/mosek_solver.h:18
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::MosekSolver::Solve
        struct /* Solve */ {

          // drake/solvers/mosek_solver.h:26
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::MosekSolver::available
        struct /* available */ {

          // drake/solvers/mosek_solver.h:24
          const char* doc =
R"""(Defined true if Mosek was included during compilation, false
otherwise.)""";

        } available;

        // drake::solvers::MosekSolver::id
        struct /* id */ {

          // drake/solvers/mosek_solver.h:31
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::MosekSolver::set_stream_logging
        struct /* set_stream_logging */ {

          // drake/solvers/mosek_solver.h:41
          const char* doc =
R"""(Control stream logging. Refer to
https://docs.mosek.com/8.1/capi/solver-io.html for more details.

Parameter ``flag``:
    Set to true if the user want to turn on stream logging.

Parameter ``log_file``:
    If the user wants to output the logging to a file, then set
    ``log_file`` to the name of that file. If the user wants to output
    the logging to the console, then set log_file to empty string.)""";

        } set_stream_logging;

        // drake::solvers::MosekSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/mosek_solver.h:28
          const char* doc = R"""()""";

        } solver_id;

      } MosekSolver;

      // drake::solvers::NewRotationMatrixVars
      struct /* NewRotationMatrixVars */ {

        // drake/solvers/rotation_constraint.h:44
        const char* doc =
R"""(Allocates a 3x3 matrix of decision variables with the trivial bounding
box constraint ensuring all elements are [-1,1], and the linear
constraint imposing -1 <= trace(R) <= 3.)""";

      } NewRotationMatrixVars;

      // drake::solvers::NewSymmetricVariableNames
      struct /* NewSymmetricVariableNames */ {

        // drake/solvers/mathematical_program.h:225
        const char* doc = R"""()""";

      } NewSymmetricVariableNames;

      // drake::solvers::NewVariableNames
      struct /* NewVariableNames */ {

        // drake/solvers/mathematical_program.h:203
        const char* doc = R"""()""";

        // drake/solvers/mathematical_program.h:216
        const char* doc_2 = R"""()""";

      } NewVariableNames;

      // drake::solvers::NloptSolver
      struct /* NloptSolver */ {

        // drake/solvers/nlopt_solver.h:11
        const char* doc = R"""()""";

        // drake::solvers::NloptSolver::NloptSolver
        struct /* ctor */ {

          // drake/solvers/nlopt_solver.h:13
          const char* doc = R"""()""";

          // drake/solvers/nlopt_solver.h:13
          const char* doc_2 = R"""()""";

          // drake/solvers/nlopt_solver.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::NloptSolver::Solve
        struct /* Solve */ {

          // drake/solvers/nlopt_solver.h:22
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::NloptSolver::available
        struct /* available */ {

          // drake/solvers/nlopt_solver.h:20
          const char* doc = R"""()""";

        } available;

        // drake::solvers::NloptSolver::id
        struct /* id */ {

          // drake/solvers/nlopt_solver.h:27
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::NloptSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/nlopt_solver.h:24
          const char* doc = R"""()""";

        } solver_id;

      } NloptSolver;

      // drake::solvers::OsqpSolver
      struct /* OsqpSolver */ {

        // drake/solvers/osqp_solver.h:9
        const char* doc = R"""()""";

        // drake::solvers::OsqpSolver::OsqpSolver
        struct /* ctor */ {

          // drake/solvers/osqp_solver.h:11
          const char* doc = R"""()""";

          // drake/solvers/osqp_solver.h:11
          const char* doc_2 = R"""()""";

          // drake/solvers/osqp_solver.h:13
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::OsqpSolver::Solve
        struct /* Solve */ {

          // drake/solvers/osqp_solver.h:20
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::OsqpSolver::available
        struct /* available */ {

          // drake/solvers/osqp_solver.h:18
          const char* doc = R"""()""";

        } available;

        // drake::solvers::OsqpSolver::id
        struct /* id */ {

          // drake/solvers/osqp_solver.h:25
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::OsqpSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/osqp_solver.h:22
          const char* doc = R"""()""";

        } solver_id;

      } OsqpSolver;

      // drake::solvers::PolynomialConstraint
      struct /* PolynomialConstraint */ {

        // drake/solvers/constraint.h:448
        const char* doc =
R"""(lb[i] <= P[i](x, y...) <= ub[i], where each P[i] is a multivariate
polynomial in x, y...

A constraint on the values of multivariate polynomials.

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the MathematicalProgram::Binding (the
individual scalar elements of the given VariableList).)""";

        // drake::solvers::PolynomialConstraint::PolynomialConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:450
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:450
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:459
          const char* doc_3 =
R"""(Constructs a polynomial constraint

Parameter ``polynomials``:
    Polynomial vector, a `num_constraints` x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a `num_vars` x 1 vector.

Parameter ``lb``:
    Lower bounds, a `num_constraints` x 1 vector.

Parameter ``ub``:
    Upper bounds, a `num_constraints` x 1 vector.)""";

        } ctor;

        // drake::solvers::PolynomialConstraint::poly_vars
        struct /* poly_vars */ {

          // drake/solvers/constraint.h:470
          const char* doc = R"""()""";

        } poly_vars;

        // drake::solvers::PolynomialConstraint::polynomials
        struct /* polynomials */ {

          // drake/solvers/constraint.h:468
          const char* doc = R"""()""";

        } polynomials;

      } PolynomialConstraint;

      // drake::solvers::PolynomialCost
      struct /* PolynomialCost */ {

        // drake/solvers/cost.h:228
        const char* doc =
R"""(Implements a cost of the form P(x, y...) where P is a multivariate
polynomial in x, y, ...

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the Binding<> (the individual scalar
elements of the given VariableList).)""";

        // drake::solvers::PolynomialCost::PolynomialCost
        struct /* ctor */ {

          // drake/solvers/cost.h:230
          const char* doc = R"""()""";

          // drake/solvers/cost.h:230
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:237
          const char* doc_3 =
R"""(Constructs a polynomial cost

Parameter ``polynomials``:
    Polynomial vector, a 1 x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a `num_vars` x 1 vector.)""";

        } ctor;

        // drake::solvers::PolynomialCost::poly_vars
        struct /* poly_vars */ {

          // drake/solvers/cost.h:244
          const char* doc = R"""()""";

        } poly_vars;

        // drake::solvers::PolynomialCost::polynomials
        struct /* polynomials */ {

          // drake/solvers/cost.h:242
          const char* doc = R"""()""";

        } polynomials;

      } PolynomialCost;

      // drake::solvers::PolynomialEvaluator
      struct /* PolynomialEvaluator */ {

        // drake/solvers/evaluator_base.h:164
        const char* doc =
R"""(Implements an evaluator of the form P(x, y...) where P is a
multivariate polynomial in x, y, ...

The Polynomial class uses a different variable naming scheme; thus the
caller must provide a list of Polynomial::VarType variables that
correspond to the members of the Binding<> (the individual scalar
elements of the given VariableList).)""";

        // drake::solvers::PolynomialEvaluator::PolynomialEvaluator
        struct /* ctor */ {

          // drake/solvers/evaluator_base.h:166
          const char* doc = R"""()""";

          // drake/solvers/evaluator_base.h:166
          const char* doc_2 = R"""()""";

          // drake/solvers/evaluator_base.h:174
          const char* doc_3 =
R"""(Constructs a polynomial evaluator given a set of polynomials and the
corresponding variables.

Parameter ``polynomials``:
    Polynomial vector, a `num_outputs` x 1 vector.

Parameter ``poly_vars``:
    Polynomial variables, a `num_vars` x 1 vector.)""";

        } ctor;

        // drake::solvers::PolynomialEvaluator::poly_vars
        struct /* poly_vars */ {

          // drake/solvers/evaluator_base.h:182
          const char* doc = R"""()""";

        } poly_vars;

        // drake::solvers::PolynomialEvaluator::polynomials
        struct /* polynomials */ {

          // drake/solvers/evaluator_base.h:180
          const char* doc = R"""()""";

        } polynomials;

      } PolynomialEvaluator;

      // drake::solvers::PositiveSemidefiniteConstraint
      struct /* PositiveSemidefiniteConstraint */ {

        // drake/solvers/constraint.h:702
        const char* doc =
R"""(Implements a positive semidefinite constraint on a symmetric matrix S
@f[\text{ S is p.s.d }@f] namely, all eigen values of S are non-
negative.)""";

        // drake::solvers::PositiveSemidefiniteConstraint::DoEval
        struct /* DoEval */ {

          // drake/solvers/constraint.h:773
          const char* doc =
R"""(Evaluate the eigen values of the symmetric matrix.

Parameter ``x``:
    The stacked columns of the symmetric matrix.)""";

          // drake/solvers/constraint.h:781
          const char* doc_2 =
R"""(Parameter ``x``:
    The stacked columns of the symmetric matrix. This function is not
    supported yet, since Eigen's eigen value solver does not accept
    AutoDiffScalar.)""";

          // drake/solvers/constraint.h:789
          const char* doc_3 =
R"""(Parameter ``x``:
    The stacked columns of the symmetric matrix. This function is not
    supported, since Eigen's eigen value solver does not accept
    symbolic::Expression.)""";

        } DoEval;

        // drake::solvers::PositiveSemidefiniteConstraint::PositiveSemidefiniteConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:704
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:704
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:758
          const char* doc_3 =
R"""(Impose the constraint that a symmetric matrix with size ``rows`` x
``rows`` is positive semidefinite.

See also:
    MathematicalProgram::AddPositiveSemidefiniteConstraint() for how
    to use this constraint on some decision variables. We currently
    use this constraint as a place holder in MathematicalProgram, to
    indicate the positive semidefiniteness of some decision variables.

Parameter ``rows``:
    The number of rows (and columns) of the symmetric matrix.

Example:

```
{.cc}
// Create a MathematicalProgram object.
auto prog = MathematicalProgram();

// Add a 2 x 2 symmetric matrix S to optimization program as new decision
// variables.
auto S = prog.NewSymmetricContinuousVariables<2>("S");

// Impose a positive semidefinite constraint on S.
std::shared_ptr<PositiveSemidefiniteConstraint> psd_constraint =
    prog.AddPositiveSemidefiniteConstraint(S);

/////////////////////////////////////////////////////////////
// Add more constraints to make the program more interesting,
// but this is not needed.

// Add the constraint that S(1, 0) = 1.
prog.AddBoundingBoxConstraint(1, 1, S(1, 0));

// Minimize S(0, 0) + S(1, 1).
prog.AddLinearCost(Eigen::RowVector2d(1, 1), {S.diagonal()});

/////////////////////////////////////////////////////////////

// Now solve the program.
prog.Solve();

// Retrieve the solution of matrix S.
auto S_value = GetSolution(S);

// Compute the eigen values of the solution, to see if they are
// all non-negative.
Eigen::Vector4d S_stacked;
S_stacked << S_value.col(0), S_value.col(1);

Eigen::VectorXd S_eigen_values;
psd_constraint->Eval(S_stacked, S_eigen_values);

std::cout<<"S solution is: " << S << std::endl;
std::cout<<"The eigen value of S is " << S_eigen_values << std::endl;
```)""";

        } ctor;

        // drake::solvers::PositiveSemidefiniteConstraint::matrix_rows
        struct /* matrix_rows */ {

          // drake/solvers/constraint.h:766
          const char* doc = R"""()""";

        } matrix_rows;

      } PositiveSemidefiniteConstraint;

      // drake::solvers::ProgramAttributes
      struct /* ProgramAttributes */ {

        // drake/solvers/mathematical_program.h:183
        const char* doc = R"""()""";

        // drake::solvers::ProgramAttributes::kBinaryVariable
        struct /* kBinaryVariable */ {

          // drake/solvers/mathematical_program.h:197
          const char* doc = R"""()""";

        } kBinaryVariable;

        // drake::solvers::ProgramAttributes::kCallback
        struct /* kCallback */ {

          // drake/solvers/mathematical_program.h:198
          const char* doc = R"""()""";

        } kCallback;

        // drake::solvers::ProgramAttributes::kError
        struct /* kError */ {

          // drake/solvers/mathematical_program.h:185
          const char* doc = R"""(< Do not use, to avoid & vs. && typos.)""";

        } kError;

        // drake::solvers::ProgramAttributes::kGenericConstraint
        struct /* kGenericConstraint */ {

          // drake/solvers/mathematical_program.h:187
          const char* doc = R"""()""";

        } kGenericConstraint;

        // drake::solvers::ProgramAttributes::kGenericCost
        struct /* kGenericCost */ {

          // drake/solvers/mathematical_program.h:186
          const char* doc = R"""()""";

        } kGenericCost;

        // drake::solvers::ProgramAttributes::kLinearComplementarityConstraint
        struct /* kLinearComplementarityConstraint */ {

          // drake/solvers/mathematical_program.h:193
          const char* doc = R"""()""";

        } kLinearComplementarityConstraint;

        // drake::solvers::ProgramAttributes::kLinearConstraint
        struct /* kLinearConstraint */ {

          // drake/solvers/mathematical_program.h:191
          const char* doc = R"""()""";

        } kLinearConstraint;

        // drake::solvers::ProgramAttributes::kLinearCost
        struct /* kLinearCost */ {

          // drake/solvers/mathematical_program.h:190
          const char* doc = R"""()""";

        } kLinearCost;

        // drake::solvers::ProgramAttributes::kLinearEqualityConstraint
        struct /* kLinearEqualityConstraint */ {

          // drake/solvers/mathematical_program.h:192
          const char* doc = R"""()""";

        } kLinearEqualityConstraint;

        // drake::solvers::ProgramAttributes::kLorentzConeConstraint
        struct /* kLorentzConeConstraint */ {

          // drake/solvers/mathematical_program.h:194
          const char* doc = R"""()""";

        } kLorentzConeConstraint;

        // drake::solvers::ProgramAttributes::kNoCapabilities
        struct /* kNoCapabilities */ {

          // drake/solvers/mathematical_program.h:184
          const char* doc = R"""()""";

        } kNoCapabilities;

        // drake::solvers::ProgramAttributes::kPositiveSemidefiniteConstraint
        struct /* kPositiveSemidefiniteConstraint */ {

          // drake/solvers/mathematical_program.h:196
          const char* doc = R"""()""";

        } kPositiveSemidefiniteConstraint;

        // drake::solvers::ProgramAttributes::kQuadraticConstraint
        struct /* kQuadraticConstraint */ {

          // drake/solvers/mathematical_program.h:189
          const char* doc = R"""()""";

        } kQuadraticConstraint;

        // drake::solvers::ProgramAttributes::kQuadraticCost
        struct /* kQuadraticCost */ {

          // drake/solvers/mathematical_program.h:188
          const char* doc = R"""()""";

        } kQuadraticCost;

        // drake::solvers::ProgramAttributes::kRotatedLorentzConeConstraint
        struct /* kRotatedLorentzConeConstraint */ {

          // drake/solvers/mathematical_program.h:195
          const char* doc = R"""()""";

        } kRotatedLorentzConeConstraint;

      } ProgramAttributes;

      // drake::solvers::QuadraticConstraint
      struct /* QuadraticConstraint */ {

        // drake/solvers/constraint.h:189
        const char* doc =
R"""(lb ≤ .5 xᵀQx + bᵀx ≤ ub Without loss of generality, the class stores a
symmetric matrix Q. For a non-symmetric matrix Q₀, we can define Q =
(Q₀ + Q₀ᵀ) / 2, since xᵀQ₀x = xᵀQ₀ᵀx = xᵀ*(Q₀+Q₀ᵀ)/2 *x. The first
equality holds because the transpose of a scalar is the scalar itself.
Hence we can always convert a non-symmetric matrix Q₀ to a symmetric
matrix Q.)""";

        // drake::solvers::QuadraticConstraint::Q
        struct /* Q */ {

          // drake/solvers/constraint.h:220
          const char* doc =
R"""(The symmetric matrix Q, being the Hessian of this constraint.)""";

        } Q;

        // drake::solvers::QuadraticConstraint::QuadraticConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:191
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:191
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:205
          const char* doc_3 =
R"""(Construct a quadratic constraint.

Template parameter ``DerivedQ``:
    The type for Q.

Template parameter ``Derivedb``:
    The type for b.

Parameter ``Q0``:
    The square matrix. Notice that Q₀ does not have to be symmetric.

Parameter ``b``:
    The linear coefficient.

Parameter ``lb``:
    The lower bound.

Parameter ``ub``:
    The upper bound.)""";

        } ctor;

        // drake::solvers::QuadraticConstraint::UpdateCoefficients
        struct /* UpdateCoefficients */ {

          // drake/solvers/constraint.h:231
          const char* doc =
R"""(Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.

Parameter ``new_Q``:
    new quadratic term

Parameter ``new_b``:
    new linear term)""";

        } UpdateCoefficients;

        // drake::solvers::QuadraticConstraint::b
        struct /* b */ {

          // drake/solvers/constraint.h:222
          const char* doc = R"""()""";

        } b;

      } QuadraticConstraint;

      // drake::solvers::QuadraticCost
      struct /* QuadraticCost */ {

        // drake/solvers/cost.h:100
        const char* doc =
R"""(Implements a cost of the form @f .5 x'Qx + b'x + c @f.)""";

        // drake::solvers::QuadraticCost::Q
        struct /* Q */ {

          // drake/solvers/cost.h:121
          const char* doc =
R"""(Returns the symmetric matrix Q, as the Hessian of the cost.)""";

        } Q;

        // drake::solvers::QuadraticCost::QuadraticCost
        struct /* ctor */ {

          // drake/solvers/cost.h:102
          const char* doc = R"""()""";

          // drake/solvers/cost.h:102
          const char* doc_2 = R"""()""";

          // drake/solvers/cost.h:111
          const char* doc_3 =
R"""(Constructs a cost of the form @f .5 x'Qx + b'x + c @f.

Parameter ``Q``:
    Quadratic term.

Parameter ``b``:
    Linear term.

Parameter ``c``:
    (optional) Constant term.)""";

        } ctor;

        // drake::solvers::QuadraticCost::UpdateCoefficients
        struct /* UpdateCoefficients */ {

          // drake/solvers/cost.h:135
          const char* doc =
R"""(Updates the quadratic and linear term of the constraint. The new
matrices need to have the same dimension as before.

Parameter ``new_Q``:
    New quadratic term.

Parameter ``new_b``:
    New linear term.

Parameter ``new_c``:
    (optional) New constant term.)""";

        } UpdateCoefficients;

        // drake::solvers::QuadraticCost::b
        struct /* b */ {

          // drake/solvers/cost.h:123
          const char* doc = R"""()""";

        } b;

        // drake::solvers::QuadraticCost::c
        struct /* c */ {

          // drake/solvers/cost.h:125
          const char* doc = R"""()""";

        } c;

      } QuadraticCost;

      // drake::solvers::ReplaceBilinearTerms
      struct /* ReplaceBilinearTerms */ {

        // drake/solvers/bilinear_product_util.h:32
        const char* doc =
R"""(Replaces all the bilinear product terms in the expression `e`, with
the corresponding terms in `W`, where `W` represents the matrix x *
yᵀ, such that after replacement, `e` does not have bilinear terms
involving `x` and `y`. For example, if e = x(0)*y(0) + 2 * x(0)*y(1) +
x(1) * y(1) + 3 * x(1), `e` has bilinear terms x(0)*y(0), x(0) * y(1)
and x(2) * y(1), if we call ReplaceBilinearTerms(e, x, y, W) where
W(i, j) represent the term x(i) * y(j), then this function returns
W(0, 0) + 2 * W(0, 1) + W(1, 1) + 3 * x(1).

Parameter ``e``:
    An expression potentially contains bilinear products between x and
    y.

Parameter ``x``:
    The bilinear product between `x` and `y` will be replaced by the
    corresponding term in `W`. Throws a runtime error if `x` contains
    duplicate entries.

Parameter ``y``:
    The bilinear product between `x` and `y` will be replaced by the
    corresponding term in `W.Throws a runtime error if `y` contains
    duplicate entries.

Parameter ``W``:
    Bilinear product term x(i) * y(j) will be replaced by W(i, j). If
    W(i,j) is not a single variable, but an expression, then this
    expression cannot contain a variable in either x or y. The program
    will throw a runtime error, if W(i, j) is not a single variable,
    and also contains a variable in x or y.

Returns:
    The symbolic expression after replacing x(i) * y(j) with W(i, j).)""";

      } ReplaceBilinearTerms;

      // drake::solvers::RollPitchYawLimitOptions
      struct /* RollPitchYawLimitOptions */ {

        // drake/solvers/rotation_constraint.h:47
        const char* doc = R"""()""";

        // drake::solvers::RollPitchYawLimitOptions::kNoLimits
        struct /* kNoLimits */ {

          // drake/solvers/rotation_constraint.h:48
          const char* doc = R"""()""";

        } kNoLimits;

        // drake::solvers::RollPitchYawLimitOptions::kPitch_0_to_PI
        struct /* kPitch_0_to_PI */ {

          // drake/solvers/rotation_constraint.h:53
          const char* doc = R"""()""";

        } kPitch_0_to_PI;

        // drake::solvers::RollPitchYawLimitOptions::kPitch_0_to_PI_2
        struct /* kPitch_0_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:57
          const char* doc = R"""()""";

        } kPitch_0_to_PI_2;

        // drake::solvers::RollPitchYawLimitOptions::kPitch_NegPI_2_to_PI_2
        struct /* kPitch_NegPI_2_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:52
          const char* doc = R"""()""";

        } kPitch_NegPI_2_to_PI_2;

        // drake::solvers::RollPitchYawLimitOptions::kRPYError
        struct /* kRPYError */ {

          // drake/solvers/rotation_constraint.h:49
          const char* doc = R"""(< Do not use, to avoid & vs. && typos.)""";

        } kRPYError;

        // drake::solvers::RollPitchYawLimitOptions::kRoll_0_to_PI
        struct /* kRoll_0_to_PI */ {

          // drake/solvers/rotation_constraint.h:51
          const char* doc = R"""()""";

        } kRoll_0_to_PI;

        // drake::solvers::RollPitchYawLimitOptions::kRoll_0_to_PI_2
        struct /* kRoll_0_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:56
          const char* doc = R"""()""";

        } kRoll_0_to_PI_2;

        // drake::solvers::RollPitchYawLimitOptions::kRoll_NegPI_2_to_PI_2
        struct /* kRoll_NegPI_2_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:50
          const char* doc = R"""()""";

        } kRoll_NegPI_2_to_PI_2;

        // drake::solvers::RollPitchYawLimitOptions::kYaw_0_to_PI
        struct /* kYaw_0_to_PI */ {

          // drake/solvers/rotation_constraint.h:55
          const char* doc = R"""()""";

        } kYaw_0_to_PI;

        // drake::solvers::RollPitchYawLimitOptions::kYaw_0_to_PI_2
        struct /* kYaw_0_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:58
          const char* doc = R"""()""";

        } kYaw_0_to_PI_2;

        // drake::solvers::RollPitchYawLimitOptions::kYaw_NegPI_2_to_PI_2
        struct /* kYaw_NegPI_2_to_PI_2 */ {

          // drake/solvers/rotation_constraint.h:54
          const char* doc = R"""()""";

        } kYaw_NegPI_2_to_PI_2;

      } RollPitchYawLimitOptions;

      // drake::solvers::RotatedLorentzConeConstraint
      struct /* RotatedLorentzConeConstraint */ {

        // drake/solvers/constraint.h:347
        const char* doc =
R"""(Constraining that the linear expression $ z=Ax+b $ lies within rotated
Lorentz cone. A vector z ∈ ℝ ⁿ lies within rotated Lorentz cone, if
@f[ z_0 \ge 0\\ z_1 \ge 0\\ z_0 z_1 \ge z_2^2 + z_3^2 + ... +
z_{n-1}^2 @f] where A ∈ ℝ ⁿˣᵐ, b ∈ ℝ ⁿ are given matrices. <!--> z₀ ≥
0 z₁ ≥ 0 z₀ * z₁ ≥ z₂² + z₃² + ... zₙ₋₁² <--> For more information and
visualization, please refer to
https://inst.eecs.berkeley.edu/~ee127a/book/login/l_socp_soc.html)""";

        // drake::solvers::RotatedLorentzConeConstraint::A
        struct /* A */ {

          // drake/solvers/constraint.h:363
          const char* doc = R"""(Getter for A. */)""";

        } A;

        // drake::solvers::RotatedLorentzConeConstraint::RotatedLorentzConeConstraint
        struct /* ctor */ {

          // drake/solvers/constraint.h:349
          const char* doc = R"""()""";

          // drake/solvers/constraint.h:349
          const char* doc_2 = R"""()""";

          // drake/solvers/constraint.h:351
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::RotatedLorentzConeConstraint::b
        struct /* b */ {

          // drake/solvers/constraint.h:366
          const char* doc = R"""(Getter for b. */)""";

        } b;

      } RotatedLorentzConeConstraint;

      // drake::solvers::ScsSolver
      struct /* ScsSolver */ {

        // drake/solvers/scs_solver.h:9
        const char* doc = R"""()""";

        // drake::solvers::ScsSolver::ScsSolver
        struct /* ctor */ {

          // drake/solvers/scs_solver.h:11
          const char* doc = R"""()""";

          // drake/solvers/scs_solver.h:11
          const char* doc_2 = R"""()""";

          // drake/solvers/scs_solver.h:13
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::ScsSolver::SetVerbose
        struct /* SetVerbose */ {

          // drake/solvers/scs_solver.h:31
          const char* doc = R"""()""";

        } SetVerbose;

        // drake::solvers::ScsSolver::Solve
        struct /* Solve */ {

          // drake/solvers/scs_solver.h:20
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::ScsSolver::available
        struct /* available */ {

          // drake/solvers/scs_solver.h:18
          const char* doc = R"""()""";

        } available;

        // drake::solvers::ScsSolver::id
        struct /* id */ {

          // drake/solvers/scs_solver.h:25
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::ScsSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/scs_solver.h:22
          const char* doc = R"""()""";

        } solver_id;

      } ScsSolver;

      // drake::solvers::SnoptSolver
      struct /* SnoptSolver */ {

        // drake/solvers/snopt_solver.h:11
        const char* doc = R"""()""";

        // drake::solvers::SnoptSolver::SnoptSolver
        struct /* ctor */ {

          // drake/solvers/snopt_solver.h:13
          const char* doc = R"""()""";

          // drake/solvers/snopt_solver.h:13
          const char* doc_2 = R"""()""";

          // drake/solvers/snopt_solver.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::SnoptSolver::Solve
        struct /* Solve */ {

          // drake/solvers/snopt_solver.h:22
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::SnoptSolver::available
        struct /* available */ {

          // drake/solvers/snopt_solver.h:20
          const char* doc = R"""()""";

        } available;

        // drake::solvers::SnoptSolver::id
        struct /* id */ {

          // drake/solvers/snopt_solver.h:27
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

        // drake::solvers::SnoptSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/snopt_solver.h:24
          const char* doc = R"""()""";

        } solver_id;

      } SnoptSolver;

      // drake::solvers::SolutionResult
      struct /* SolutionResult */ {

        // drake/solvers/mathematical_program_solver_interface.h:16
        const char* doc = R"""()""";

        // drake::solvers::SolutionResult::kDualInfeasible
        struct /* kDualInfeasible */ {

          // drake/solvers/mathematical_program_solver_interface.h:25
          const char* doc =
R"""(< Dual problem is infeasible. In this case we cannot)""";

        } kDualInfeasible;

        // drake::solvers::SolutionResult::kInfeasibleConstraints
        struct /* kInfeasibleConstraints */ {

          // drake/solvers/mathematical_program_solver_interface.h:19
          const char* doc = R"""(< The primal is infeasible.)""";

        } kInfeasibleConstraints;

        // drake::solvers::SolutionResult::kInfeasible_Or_Unbounded
        struct /* kInfeasible_Or_Unbounded */ {

          // drake/solvers/mathematical_program_solver_interface.h:22
          const char* doc = R"""()""";

        } kInfeasible_Or_Unbounded;

        // drake::solvers::SolutionResult::kInvalidInput
        struct /* kInvalidInput */ {

          // drake/solvers/mathematical_program_solver_interface.h:18
          const char* doc = R"""(< Invalid input.)""";

        } kInvalidInput;

        // drake::solvers::SolutionResult::kIterationLimit
        struct /* kIterationLimit */ {

          // drake/solvers/mathematical_program_solver_interface.h:24
          const char* doc = R"""(< Reaches the iteration limits.)""";

        } kIterationLimit;

        // drake::solvers::SolutionResult::kSolutionFound
        struct /* kSolutionFound */ {

          // drake/solvers/mathematical_program_solver_interface.h:17
          const char* doc = R"""(< Found the optimal solution.)""";

        } kSolutionFound;

        // drake::solvers::SolutionResult::kUnbounded
        struct /* kUnbounded */ {

          // drake/solvers/mathematical_program_solver_interface.h:20
          const char* doc = R"""(< The primal is unbounded.)""";

        } kUnbounded;

        // drake::solvers::SolutionResult::kUnknownError
        struct /* kUnknownError */ {

          // drake/solvers/mathematical_program_solver_interface.h:21
          const char* doc = R"""(< Unknown error.)""";

        } kUnknownError;

      } SolutionResult;

      // drake::solvers::SolverId
      struct /* SolverId */ {

        // drake/solvers/solver_id.h:17
        const char* doc =
R"""(Identifies a MathematicalProgramSolverInterface implementation.

A moved-from instance is guaranteed to be empty and will not compare
equal to any non-empty ID.)""";

        // drake::solvers::SolverId::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/solvers/solver_id.h:19
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::solvers::SolverId::SolverId
        struct /* ctor */ {

          // drake/solvers/solver_id.h:19
          const char* doc = R"""()""";

          // drake/solvers/solver_id.h:19
          const char* doc_2 = R"""()""";

          // drake/solvers/solver_id.h:27
          const char* doc_3 =
R"""(Constructs a specific, known solver type. Internally, a hidden
identifier is allocated and assigned to this instance; all instances
that share an identifier (including copies of this instance) are
considered equal. The solver names are not enforced to be unique,
though we recommend that they remain so in practice.)""";

        } ctor;

        // drake::solvers::SolverId::name
        struct /* name */ {

          // drake/solvers/solver_id.h:29
          const char* doc = R"""()""";

        } name;

      } SolverId;

      // drake::solvers::SolverResult
      struct /* SolverResult */ {

        // drake/solvers/mathematical_program_solver_interface.h:39
        const char* doc =
R"""(This class is used by implementations of the class
MathematicalProgramSolverInterface to report their results to the
mathematical program. It is guaranteed to have a defined solver id;
all other fields can be left undefined. Reading those values should be
guarded by a test on whether the field has been defined.)""";

        // drake::solvers::SolverResult::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/solvers/mathematical_program_solver_interface.h:41
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::solvers::SolverResult::SolverResult
        struct /* ctor */ {

          // drake/solvers/mathematical_program_solver_interface.h:41
          const char* doc = R"""()""";

          // drake/solvers/mathematical_program_solver_interface.h:41
          const char* doc_2 = R"""()""";

          // drake/solvers/mathematical_program_solver_interface.h:43
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::SolverResult::decision_variable_values
        struct /* decision_variable_values */ {

          // drake/solvers/mathematical_program_solver_interface.h:59
          const char* doc = R"""()""";

        } decision_variable_values;

        // drake::solvers::SolverResult::optimal_cost
        struct /* optimal_cost */ {

          // drake/solvers/mathematical_program_solver_interface.h:71
          const char* doc = R"""()""";

        } optimal_cost;

        // drake::solvers::SolverResult::optimal_cost_lower_bound
        struct /* optimal_cost_lower_bound */ {

          // drake/solvers/mathematical_program_solver_interface.h:84
          const char* doc = R"""()""";

        } optimal_cost_lower_bound;

        // drake::solvers::SolverResult::set_decision_variable_values
        struct /* set_decision_variable_values */ {

          // drake/solvers/mathematical_program_solver_interface.h:53
          const char* doc =
R"""(Sets the decision variable values. Eventually the decision variable
values in this class will be passed to MathematicalProgram, to set the
values for ALL variables in the mathematical program, such that
MathematicalProgram::decision_variables_(i) will have value
`values(i)`.)""";

        } set_decision_variable_values;

        // drake::solvers::SolverResult::set_optimal_cost
        struct /* set_optimal_cost */ {

          // drake/solvers/mathematical_program_solver_interface.h:69
          const char* doc =
R"""(Sets the optimal cost. Eventually this optimal cost will be passed to
MathematicalProgram, when calling
MathematicalProgram::SetSolverResult(...);)""";

        } set_optimal_cost;

        // drake::solvers::SolverResult::set_optimal_cost_lower_bound
        struct /* set_optimal_cost_lower_bound */ {

          // drake/solvers/mathematical_program_solver_interface.h:80
          const char* doc =
R"""(Sets the lower bound of the optimal cost. Eventually this lower bound
of the optimal cost will be passed to MathematicalProgram, when
calling MathematicalProgram::SetSolverResult(...); Some problems, such
as mixed-integer convex program, can find a lower bound of its optimal
cost, before finding the global optimal.)""";

        } set_optimal_cost_lower_bound;

        // drake::solvers::SolverResult::solver_id
        struct /* solver_id */ {

          // drake/solvers/mathematical_program_solver_interface.h:45
          const char* doc = R"""()""";

        } solver_id;

      } SolverResult;

      // drake::solvers::SolverType
      struct /* SolverType */ {

        // drake/solvers/solver_type.h:6
        const char* doc = R"""()""";

        // drake::solvers::SolverType::kDReal
        struct /* kDReal */ {

          // drake/solvers/solver_type.h:7
          const char* doc = R"""()""";

        } kDReal;

        // drake::solvers::SolverType::kEqualityConstrainedQP
        struct /* kEqualityConstrainedQP */ {

          // drake/solvers/solver_type.h:8
          const char* doc = R"""()""";

        } kEqualityConstrainedQP;

        // drake::solvers::SolverType::kGurobi
        struct /* kGurobi */ {

          // drake/solvers/solver_type.h:9
          const char* doc = R"""()""";

        } kGurobi;

        // drake::solvers::SolverType::kIpopt
        struct /* kIpopt */ {

          // drake/solvers/solver_type.h:10
          const char* doc = R"""()""";

        } kIpopt;

        // drake::solvers::SolverType::kLinearSystem
        struct /* kLinearSystem */ {

          // drake/solvers/solver_type.h:11
          const char* doc = R"""()""";

        } kLinearSystem;

        // drake::solvers::SolverType::kMobyLCP
        struct /* kMobyLCP */ {

          // drake/solvers/solver_type.h:12
          const char* doc = R"""()""";

        } kMobyLCP;

        // drake::solvers::SolverType::kMosek
        struct /* kMosek */ {

          // drake/solvers/solver_type.h:13
          const char* doc = R"""()""";

        } kMosek;

        // drake::solvers::SolverType::kNlopt
        struct /* kNlopt */ {

          // drake/solvers/solver_type.h:14
          const char* doc = R"""()""";

        } kNlopt;

        // drake::solvers::SolverType::kOsqp
        struct /* kOsqp */ {

          // drake/solvers/solver_type.h:15
          const char* doc = R"""()""";

        } kOsqp;

        // drake::solvers::SolverType::kScs
        struct /* kScs */ {

          // drake/solvers/solver_type.h:17
          const char* doc = R"""()""";

        } kScs;

        // drake::solvers::SolverType::kSnopt
        struct /* kSnopt */ {

          // drake/solvers/solver_type.h:16
          const char* doc = R"""()""";

        } kSnopt;

        // drake::solvers::SolverType::kUnrevisedLemke
        struct /* kUnrevisedLemke */ {

          // drake/solvers/solver_type.h:18
          const char* doc = R"""()""";

        } kUnrevisedLemke;

      } SolverType;

      // drake::solvers::SolverTypeConverter
      struct /* SolverTypeConverter */ {

        // drake/solvers/solver_type_converter.h:12
        const char* doc =
R"""(Converts between SolverType and SolverId.)""";

        // drake::solvers::SolverTypeConverter::IdToType
        struct /* IdToType */ {

          // drake/solvers/solver_type_converter.h:23
          const char* doc =
R"""(Converts the given ID to its matching type, iff the type matches one
of SolverType's known values.)""";

        } IdToType;

        // drake::solvers::SolverTypeConverter::SolverTypeConverter
        struct /* ctor */ {

          // drake/solvers/solver_type_converter.h:14
          const char* doc = R"""()""";

          // drake/solvers/solver_type_converter.h:14
          const char* doc_2 = R"""()""";

          // drake/solvers/solver_type_converter.h:15
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::SolverTypeConverter::TypeToId
        struct /* TypeToId */ {

          // drake/solvers/solver_type_converter.h:19
          const char* doc =
R"""(Converts the given type to its matching ID.)""";

        } TypeToId;

      } SolverTypeConverter;

      // drake::solvers::SystemIdentification
      struct /* SystemIdentification */ {

        // drake/solvers/system_identification.h:41
        const char* doc =
R"""(Utility functions for system identification.

This class is a holder for templated utility methods. It should not be
constructed. It must be template-instantiated (in its cpp file) for
each supported variant of Polynomial (currently only
Polynomial<double>).

For the purposes of system identification we require here that the set
of variables in a polynomial can be divided into two groups:

* "Parameter variables" are unchanged through many evaluations of the
Polynomial and so may be factored and renamed (lumped) at will. In
effect parameter variables are treated as constants.

* "Active variables" are those that may vary between evaluations of
the Polynomial, for instance because they are inputs or state
variables of the system.

Note: The term "system identification" used throughout here refers to
the process of simplifying the equations defining a physical system to
a minimum number of "lumped" parameters and then estimating the values
of those parameters based on empirical data.)""";

        // drake::solvers::SystemIdentification::EstimateParameters
        struct /* EstimateParameters */ {

          // drake/solvers/system_identification.h:109
          const char* doc =
R"""(Estimate some parameters of a polynomial based on empirical data.

Given one or more polynomial equations P[i](a, b, ... x, y, ...) = 0,
and measured values of some its arguments (x, y, ..., referred to as
the "active variables"), estimate values for the remaining arguments
(a, b, ..., referred to as the "parameters").

Measured x, y, ... is provided in a list of maps, active_var_values.

The return value is a pair, {estimates, error}, where: * estimates is
a map of polynomial VarTypes (a, b, ...) to their estimated values,
suitable as input for Polynomial::evaluatePartial. * error is the
root-mean-square error of the estimates.)""";

        } EstimateParameters;

        // drake::solvers::SystemIdentification::GetLumpedParametersFromPolynomial
        struct /* GetLumpedParametersFromPolynomial */ {

          // drake/solvers/system_identification.h:68
          const char* doc =
R"""(Extract lumped parameters from a given polynomial.

Given a Polynomial, poly, and a set of variables of poly that should
be treated as parameters (that is, variables eligible to be lumped),
obtain all of the unique expressions by which combinations of the
remaining active variables are multiplied to form the monomials of the
Polynomial.

For instance, if we have the polynomial: a*x + b*x + a*c*y + a*c*y**2
And our parameters are a, b, and c, then our lumped parameters are:
lump1 == a+b ; lump2 == a*c and we return: { (a + b) ->
VarType("lump", 1); (a * c) -> VarType("lump", 2) }

Note however that this function provides no guarantees of the lumped
parameter names generated except that they are unique -- "lump1" and
"lump2" here are examples.)""";

        } GetLumpedParametersFromPolynomial;

        // drake::solvers::SystemIdentification::GetLumpedParametersFromPolynomials
        struct /* GetLumpedParametersFromPolynomials */ {

          // drake/solvers/system_identification.h:78
          const char* doc =
R"""(Same as GetLumpedParametersFromPolynomial but for multiple
Polynomials.

It is preferable to use this if you have multiple Polynomials as it
saves you from having to union the resulting LumpingMapType results
together.)""";

        } GetLumpedParametersFromPolynomials;

        // drake::solvers::SystemIdentification::LumpedSystemIdentification
        struct /* LumpedSystemIdentification */ {

          // drake/solvers/system_identification.h:148
          const char* doc =
R"""(Performs full lumped-parameter identification of a system of
TrigPolys.

This is a convenience method meant to capture what is expected to be
the most common usage pattern of system ID.

Given one or more TrigPoly expressions to be set equal to zero, and a
list of observed values for a subset of the variables, lumps up the
remaining variables into lumped parameters and estimates a value for
each of those. This is broadly equivalent to calling the following
methods in sequence:

* GetLumpedParametersFromPolynomials *
RewritePolynomialWithLumpedParameters * EstimateParameters)""";

        } LumpedSystemIdentification;

        // drake::solvers::SystemIdentification::RewritePolynomialWithLumpedParameters
        struct /* RewritePolynomialWithLumpedParameters */ {

          // drake/solvers/system_identification.h:91
          const char* doc =
R"""(Rewrite a Polynomial in terms of lumped parameters.

For instance, if we have the polynomial: a*x + b*x + a*c*y + a*c*y**2
And our lumped parameters are: lump1 == a+b ; lump2 == a*c And our
polynomial is now: lump1*x + lump2*y + lump2*y**2)""";

        } RewritePolynomialWithLumpedParameters;

        // drake::solvers::SystemIdentification::SystemIdentificationResult
        struct /* SystemIdentificationResult */ {

          // drake/solvers/system_identification.h:114
          const char* doc =
R"""(A helper struct to hold System ID results */)""";

          // drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_parameter_values
          struct /* lumped_parameter_values */ {

            // drake/solvers/system_identification.h:123
            const char* doc =
R"""(The estimated value for each lumped parameter.)""";

          } lumped_parameter_values;

          // drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_parameters
          struct /* lumped_parameters */ {

            // drake/solvers/system_identification.h:116
            const char* doc =
R"""(The lumped parameters that were used in system ID.)""";

          } lumped_parameters;

          // drake::solvers::SystemIdentification::SystemIdentificationResult::lumped_polys
          struct /* lumped_polys */ {

            // drake/solvers/system_identification.h:120
            const char* doc =
R"""(The input polynomials, rewritten using the lumped parameters so that
only active variable and first-order lumped variable terms remain.)""";

          } lumped_polys;

          // drake::solvers::SystemIdentification::SystemIdentificationResult::partially_evaluated_polys
          struct /* partially_evaluated_polys */ {

            // drake/solvers/system_identification.h:127
            const char* doc =
R"""(The input polynomials, with all estimates substituted in so that only
active variables remain.)""";

          } partially_evaluated_polys;

          // drake::solvers::SystemIdentification::SystemIdentificationResult::rms_error
          struct /* rms_error */ {

            // drake/solvers/system_identification.h:130
            const char* doc =
R"""(The root-mean-square error of the estimation step.)""";

          } rms_error;

        } SystemIdentificationResult;

      } SystemIdentification;

      // drake::solvers::UnrevisedLemkeSolver
      struct /* UnrevisedLemkeSolver */ {

        // drake/solvers/unrevised_lemke_solver.h:37
        const char* doc =
R"""(A class for the Unrevised Implementation of Lemke Algorithm's for
solving Linear Complementarity Problems (LCPs). See MobyLcpSolver for
a description of LCPs. This code makes extensive use of the following
document: [Dai 2018] Dai, H. and Drumwright, E. Computing the
Principal Pivoting Transform for Solving Linear Complementarity
Problems with Lemke's Algorithm. (2018, located in
doc/pivot_column.pdf).)""";

        // drake::solvers::UnrevisedLemkeSolver::ComputeZeroTolerance
        struct /* ComputeZeroTolerance */ {

          // drake/solvers/unrevised_lemke_solver.h:47
          const char* doc =
R"""(Calculates the zero tolerance that the solver would compute if the
user does not specify a tolerance.)""";

        } ComputeZeroTolerance;

        // drake::solvers::UnrevisedLemkeSolver::IsSolution
        struct /* IsSolution */ {

          // drake/solvers/unrevised_lemke_solver.h:55
          const char* doc =
R"""(Checks whether a given candidate solution to the LCP Mz + q = w, z ≥
0, w ≥ 0, zᵀw = 0 is satisfied to a given tolerance. If the tolerance
is non-positive, this method computes a reasonable tolerance using M.)""";

        } IsSolution;

        // drake::solvers::UnrevisedLemkeSolver::Solve
        struct /* Solve */ {

          // drake/solvers/unrevised_lemke_solver.h:94
          const char* doc = R"""()""";

        } Solve;

        // drake::solvers::UnrevisedLemkeSolver::SolveLcpLemke
        struct /* SolveLcpLemke */ {

          // drake/solvers/unrevised_lemke_solver.h:88
          const char* doc =
R"""(Lemke's Algorithm for solving LCPs in the matrix class E, which
contains all strictly semimonotone matrices, all P-matrices, and all
strictly copositive matrices. The solver can be applied with
occasional success to problems outside of its guaranteed matrix
classes. Lemke's Algorithm is described in [Cottle 1992], Section 4.4.

The solver will denote failure on return if it exceeds a problem-size
dependent number of iterations.

Parameter ``M``:
    the LCP matrix.

Parameter ``q``:
    the LCP vector. @param[in,out] z the solution to the LCP on return
    (if the solver succeeds). If the length of z is equal to the
    length of q, the solver will attempt to use the basis from the
    last solution. This strategy can prove exceptionally fast if
    solutions differ little between successive calls. If the solver
    fails (returns `false`), `z` will be set to the zero vector on
    return.

Parameter ``num_pivots``:
    the number of pivots used, on return.

Parameter ``zero_tol``:
    The tolerance for testing against zero. If the tolerance is
    negative (default) the solver will determine a generally
    reasonable tolerance.

Returns:
    `true` if the solver computes a solution to floating point
    tolerances (i.e., if IsSolution() returns `true` on the problem)
    and `false` otherwise.

Throws:
    s std::logic_error if M is not square or the dimensions of M do
    not match the length of q.

* [Cottle 1992] R. Cottle, J.-S. Pang, and R. Stone. The Linear
Complementarity Problem. Academic Press, 1992.)""";

        } SolveLcpLemke;

        // drake::solvers::UnrevisedLemkeSolver::UnrevisedLemkeSolver<T>
        struct /* ctor */ {

          // drake/solvers/unrevised_lemke_solver.h:39
          const char* doc = R"""()""";

          // drake/solvers/unrevised_lemke_solver.h:39
          const char* doc_2 = R"""()""";

          // drake/solvers/unrevised_lemke_solver.h:41
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::UnrevisedLemkeSolver::available
        struct /* available */ {

          // drake/solvers/unrevised_lemke_solver.h:92
          const char* doc = R"""()""";

        } available;

        // drake::solvers::UnrevisedLemkeSolver::solver_id
        struct /* solver_id */ {

          // drake/solvers/unrevised_lemke_solver.h:96
          const char* doc = R"""()""";

        } solver_id;

      } UnrevisedLemkeSolver;

      // drake::solvers::UnrevisedLemkeSolverId
      struct /* UnrevisedLemkeSolverId */ {

        // drake/solvers/unrevised_lemke_solver.h:21
        const char* doc =
R"""(Non-template class for UnrevisedLemkeSolver<T> constants.)""";

        // drake::solvers::UnrevisedLemkeSolverId::UnrevisedLemkeSolverId
        struct /* ctor */ {

          // drake/solvers/unrevised_lemke_solver.h:23
          const char* doc = R"""()""";

          // drake/solvers/unrevised_lemke_solver.h:23
          const char* doc_2 = R"""()""";

          // drake/solvers/unrevised_lemke_solver.h:24
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::solvers::UnrevisedLemkeSolverId::id
        struct /* id */ {

          // drake/solvers/unrevised_lemke_solver.h:27
          const char* doc =
R"""(Returns:
    same as MathematicalProgramSolverInterface::solver_id())""";

        } id;

      } UnrevisedLemkeSolverId;

      // drake::solvers::VisualizationCallback
      struct /* VisualizationCallback */ {

        // drake/solvers/evaluator_base.h:284
        const char* doc =
R"""(Defines a simple evaluator with no outputs that takes a callback
function pointer. This is intended for debugging / visualization of
intermediate results during an optimization (for solvers that support
it).)""";

        // drake::solvers::VisualizationCallback::EvalCallback
        struct /* EvalCallback */ {

          // drake/solvers/evaluator_base.h:295
          const char* doc = R"""()""";

        } EvalCallback;

        // drake::solvers::VisualizationCallback::VisualizationCallback
        struct /* ctor */ {

          // drake/solvers/evaluator_base.h:286
          const char* doc = R"""()""";

          // drake/solvers/evaluator_base.h:286
          const char* doc_2 = R"""()""";

          // drake/solvers/evaluator_base.h:291
          const char* doc_3 = R"""()""";

        } ctor;

      } VisualizationCallback;

      // drake::solvers::operator!=
      struct /* operator_ne */ {

        // drake/solvers/solver_id.h:41
        const char* doc = R"""()""";

      } operator_ne;

      // drake::solvers::operator<<
      struct /* operator_lshift */ {

        // drake/solvers/mathematical_program_solver_interface.h:30
        const char* doc = R"""()""";

        // drake/solvers/mixed_integer_optimization_util.h:153
        const char* doc_2 = R"""()""";

        // drake/solvers/mixed_integer_rotation_constraint.h:163
        const char* doc_3 = R"""()""";

        // drake/solvers/solver_id.h:42
        const char* doc_4 = R"""()""";

      } operator_lshift;

      // drake::solvers::to_string
      struct /* to_string */ {

        // drake/solvers/mathematical_program_solver_interface.h:29
        const char* doc = R"""()""";

        // drake/solvers/mixed_integer_optimization_util.h:151
        const char* doc_2 = R"""()""";

        // drake/solvers/mixed_integer_rotation_constraint.h:161
        const char* doc_3 = R"""()""";

      } to_string;

    } solvers;

    // systems
    struct /* systems */ {

      // drake::systems::AbstractParameterTag
      struct /* AbstractParameterTag */ {

        // drake/systems/framework/framework_common.h:61
        const char* doc = R"""()""";

      } AbstractParameterTag;

      // drake::systems::AbstractStateTag
      struct /* AbstractStateTag */ {

        // drake/systems/framework/framework_common.h:53
        const char* doc = R"""()""";

      } AbstractStateTag;

      // drake::systems::AbstractValue
      struct /* AbstractValue */ {

        // drake/systems/framework/framework_common.h:76
        const char* doc =
R"""(A fully type-erased container class.

Only Value<T> should inherit directly from AbstractValue. User-defined
classes that define additional type-erased features should inherit
from Value<T>.

Most methods offer two variants, e.g., SetFrom and SetFromOrThrow. The
former variants are optimized to use static_casts in Release builds
but will not throw exceptions when concrete Value types are
mismatched; the latter variants are guaranteed to throw on mismatched
types, but may be slower at runtime. Prefer using the faster version
only in performance- sensitive code (e.g., inner loops), and the safer
version otherwise.)""";

        // drake/systems/framework/value.h:19
        const char* doc_2 =
R"""(A fully type-erased container class.

Only Value<T> should inherit directly from AbstractValue. User-defined
classes that define additional type-erased features should inherit
from Value<T>.

Most methods offer two variants, e.g., SetFrom and SetFromOrThrow. The
former variants are optimized to use static_casts in Release builds
but will not throw exceptions when concrete Value types are
mismatched; the latter variants are guaranteed to throw on mismatched
types, but may be slower at runtime. Prefer using the faster version
only in performance- sensitive code (e.g., inner loops), and the safer
version otherwise.)""";

        // drake/systems/framework/value.h:101
        const char* doc_3 =
R"""(A fully type-erased container class.

Only Value<T> should inherit directly from AbstractValue. User-defined
classes that define additional type-erased features should inherit
from Value<T>.

Most methods offer two variants, e.g., SetFrom and SetFromOrThrow. The
former variants are optimized to use static_casts in Release builds
but will not throw exceptions when concrete Value types are
mismatched; the latter variants are guaranteed to throw on mismatched
types, but may be slower at runtime. Prefer using the faster version
only in performance- sensitive code (e.g., inner loops), and the safer
version otherwise.)""";

        // drake::systems::AbstractValue::AbstractValue
        struct /* ctor */ {

          // drake/systems/framework/value.h:103
          const char* doc = R"""()""";

          // drake/systems/framework/value.h:103
          const char* doc_2 = R"""()""";

          // drake/systems/framework/value.h:105
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::AbstractValue::Clone
        struct /* Clone */ {

          // drake/systems/framework/value.h:109
          const char* doc = R"""(Returns a copy of this AbstractValue.)""";

        } Clone;

        // drake::systems::AbstractValue::GetMutableValue
        struct /* GetMutableValue */ {

          // drake/systems/framework/value.h:171
          const char* doc =
R"""(Returns the value wrapped in this AbstractValue, which must be of
exactly type T. T cannot be a superclass, abstract or otherwise. In
Debug builds, if the types don't match, an std::logic_error will be
thrown with a helpful error message. In Release builds, this is not
guaranteed. Intentionally not const: holders of const references to
the AbstractValue should not be able to mutate the value it contains.)""";

        } GetMutableValue;

        // drake::systems::AbstractValue::GetMutableValueOrThrow
        struct /* GetMutableValueOrThrow */ {

          // drake/systems/framework/value.h:178
          const char* doc =
R"""(Like GetMutableValue, but throws std::logic_error on mismatched types
even in Release builds.)""";

        } GetMutableValueOrThrow;

        // drake::systems::AbstractValue::GetNiceTypeName
        struct /* GetNiceTypeName */ {

          // drake/systems/framework/value.h:128
          const char* doc =
R"""(Returns a human-readable name for the underlying type T. This may be
slow but is useful for error messages. If T is polymorphic, this
returns the typeid of the most-derived type of the contained object.)""";

        } GetNiceTypeName;

        // drake::systems::AbstractValue::GetValue
        struct /* GetValue */ {

          // drake/systems/framework/value.h:142
          const char* doc =
R"""(Returns the value wrapped in this AbstractValue, which must be of
exactly type T. T cannot be a superclass, abstract or otherwise. In
Debug builds, if the types don't match, an std::logic_error will be
thrown with a helpful error message. In Release builds, this is not
guaranteed.

TODO(david-german-tri): Once this uses static_cast under the hood in
Release builds, lower-case it.)""";

        } GetValue;

        // drake::systems::AbstractValue::GetValueOrThrow
        struct /* GetValueOrThrow */ {

          // drake/systems/framework/value.h:149
          const char* doc =
R"""(Like GetValue, but throws std::logic_error on mismatched types even in
Release builds.)""";

        } GetValueOrThrow;

        // drake::systems::AbstractValue::Make
        struct /* Make */ {

          // drake/systems/framework/value.h:201
          const char* doc =
R"""(Returns an AbstractValue containing the given ``value``.)""";

        } Make;

        // drake::systems::AbstractValue::MaybeGetValue
        struct /* MaybeGetValue */ {

          // drake/systems/framework/value.h:158
          const char* doc =
R"""(Like GetValue, but quietly returns nullptr on mismatched types, even
in Release builds.

Returns:
    A pointer to the stored value if T is the right type, otherwise
    nullptr.)""";

        } MaybeGetValue;

        // drake::systems::AbstractValue::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/value.h:115
          const char* doc =
R"""(Copies or clones the value in ``other`` to this value. In Debug
builds, if the types don't match, an std::logic_error will be thrown
with a helpful error message. In Release builds, this is not
guaranteed.)""";

        } SetFrom;

        // drake::systems::AbstractValue::SetFromOrThrow
        struct /* SetFromOrThrow */ {

          // drake/systems/framework/value.h:119
          const char* doc =
R"""(Like SetFrom, but throws std::logic_error on mismatched types even in
Release builds.)""";

        } SetFromOrThrow;

        // drake::systems::AbstractValue::SetValue
        struct /* SetValue */ {

          // drake/systems/framework/value.h:189
          const char* doc =
R"""(Sets the value wrapped in this AbstractValue, which must be of exactly
type T. T cannot be a superclass, abstract or otherwise.

Parameter ``value_to_set``:
    The value to be copied or cloned into this AbstractValue. In Debug
    builds, if the types don't match, an std::logic_error will be
    thrown with a helpful error message. In Release builds, this is
    not guaranteed.)""";

        } SetValue;

        // drake::systems::AbstractValue::SetValueOrThrow
        struct /* SetValueOrThrow */ {

          // drake/systems/framework/value.h:195
          const char* doc =
R"""(Like SetValue, but throws on mismatched types even in Release builds.)""";

        } SetValueOrThrow;

        // drake::systems::AbstractValue::type_info
        struct /* type_info */ {

          // drake/systems/framework/value.h:123
          const char* doc =
R"""(Returns typeid of the contained object of type T. If T is polymorphic,
this returns the typeid of the most-derived type of the contained
object.)""";

        } type_info;

      } AbstractValue;

      // drake::systems::AbstractValues
      struct /* AbstractValues */ {

        // drake/systems/framework/abstract_values.h:18
        const char* doc =
R"""(AbstractValues is a container for non-numerical state and parameters.
It may or may not own the underlying data, and therefore is suitable
for both leaf Systems and diagrams.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::AbstractValues::AbstractValues
        struct /* ctor */ {

          // drake/systems/framework/abstract_values.h:21
          const char* doc = R"""()""";

          // drake/systems/framework/abstract_values.h:21
          const char* doc_2 = R"""()""";

          // drake/systems/framework/abstract_values.h:24
          const char* doc_3 = R"""()""";

          // drake/systems/framework/abstract_values.h:27
          const char* doc_4 =
R"""(Constructs an AbstractValues that owns the underlying data.)""";

          // drake/systems/framework/abstract_values.h:30
          const char* doc_5 =
R"""(Constructs an AbstractValues that does not own the underlying data.)""";

          // drake/systems/framework/abstract_values.h:33
          const char* doc_6 =
R"""(Constructs an AbstractValues that owns a single ``datum``.)""";

        } ctor;

        // drake::systems::AbstractValues::Clone
        struct /* Clone */ {

          // drake/systems/framework/abstract_values.h:56
          const char* doc =
R"""(Returns a deep copy of all the data in this AbstractValues. The clone
will own its own data. This is true regardless of whether the data
being cloned had ownership of its data or not.)""";

        } Clone;

        // drake::systems::AbstractValues::CopyFrom
        struct /* CopyFrom */ {

          // drake/systems/framework/abstract_values.h:51
          const char* doc =
R"""(Copies all of the AbstractValues in ``other`` into this. Asserts if
the two are not equal in size. Throws if any of the elements are of
incompatible type.)""";

        } CopyFrom;

        // drake::systems::AbstractValues::get_mutable_value
        struct /* get_mutable_value */ {

          // drake/systems/framework/abstract_values.h:46
          const char* doc =
R"""(Returns the element of AbstractValues at the given ``index``, or
aborts if the index is out-of-bounds.)""";

        } get_mutable_value;

        // drake::systems::AbstractValues::get_value
        struct /* get_value */ {

          // drake/systems/framework/abstract_values.h:42
          const char* doc =
R"""(Returns the element of AbstractValues at the given ``index``, or
aborts if the index is out-of-bounds.)""";

        } get_value;

        // drake::systems::AbstractValues::size
        struct /* size */ {

          // drake/systems/framework/abstract_values.h:38
          const char* doc =
R"""(Returns the number of elements of AbstractValues.)""";

        } size;

      } AbstractValues;

      // drake::systems::AddRandomInputs
      struct /* AddRandomInputs */ {

        // drake/systems/primitives/random_source.h:171
        const char* doc =
R"""(For each subsystem input port in ``builder`` that is (a) not yet
connected and (b) labeled as random in the InputPort, this method will
add a new RandomSource system of the appropriate type and connect it
to the subsystem input port.

Parameter ``sampling_interval_sec``:
    interval to be used for all new sources.

Returns:
    the total number of RandomSource systems added.

See also:
    stochastic_systems)""";

      } AddRandomInputs;

      // drake::systems::Adder
      struct /* Adder */ {

        // drake/systems/primitives/adder.h:29
        const char* doc =
R"""(An adder for arbitrarily many inputs of equal size.

@system{Adder, @input_port{Input1} @input_port{...}
@input_port{InputN}, @output_port{Sum} }

Template parameter ``T``:
    The type of mathematical object being added.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::Adder::Adder<T>
        struct /* ctor */ {

          // drake/systems/primitives/adder.h:31
          const char* doc = R"""()""";

          // drake/systems/primitives/adder.h:31
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/adder.h:36
          const char* doc_3 =
R"""(Construct an Adder System.

Parameter ``num_inputs``:
    is the number of input ports to be added.

Parameter ``size``:
    number of elements in each input and output signal.)""";

          // drake/systems/primitives/adder.h:40
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::Adder::get_output_port
        struct /* get_output_port */ {

          // drake/systems/primitives/adder.h:43
          const char* doc =
R"""(Returns the output port on which the sum is presented.)""";

        } get_output_port;

      } Adder;

      // drake::systems::AffineSystem
      struct /* AffineSystem */ {

        // drake/systems/primitives/affine_system.h:148
        const char* doc =
R"""(A discrete OR continuous affine system (with constant coefficients).

@system{AffineSystem, @input_port{u(t)}, @output_port{y(t)} }

Let `u` denote the input vector, `x` denote the state vector, and `y`
denote the output vector.

If `time_period > 0.0`, the affine system will have the following
discrete-time state update: @f[ x(t+h) = A x(t) + B u(t) + f_0, @f]
where `h` is the time_period. If `time_period == 0.0`, the affine
system will have the following continuous-time state update:
@f[\dot{x} = A x + B u + f_0. @f]

In both cases, the system will have the output: @f[y = C x + D u +
y_0, @f]

Template parameter ``T``:
    The scalar element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.

See also:
    LinearSystem

See also:
    MatrixGain)""";

        // drake::systems::AffineSystem::A
        struct /* A */ {

          // drake/systems/primitives/affine_system.h:193
          const char* doc = R"""(@name Helper getter methods. @{)""";

          // drake/systems/primitives/affine_system.h:204
          const char* doc_2 =
R"""(@name Implementations of TimeVaryingAffineSystem<T>'s pure virtual
methods. @{)""";

        } A;

        // drake::systems::AffineSystem::AffineSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/affine_system.h:150
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:150
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/affine_system.h:167
          const char* doc_3 =
R"""(Constructs an Affine system with a fixed set of coefficient matrices
`A`, `B`,`C`, and `D` as well as fixed initial velocity offset `xDot0`
and output offset `y0`. The coefficient matrices must obey the
following dimensions : | Matrix | Num Rows | Num Columns |
|:-------:|:-----------:|:-----------:| | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. @default 0.0

Subclasses must use the protected constructor, not this one.)""";

          // drake/systems/primitives/affine_system.h:177
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/affine_system.h:218
          const char* doc_5 =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.)""";

        } ctor;

        // drake::systems::AffineSystem::B
        struct /* B */ {

          // drake/systems/primitives/affine_system.h:194
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:205
          const char* doc_2 = R"""()""";

        } B;

        // drake::systems::AffineSystem::C
        struct /* C */ {

          // drake/systems/primitives/affine_system.h:196
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:207
          const char* doc_2 = R"""()""";

        } C;

        // drake::systems::AffineSystem::D
        struct /* D */ {

          // drake/systems/primitives/affine_system.h:197
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:208
          const char* doc_2 = R"""()""";

        } D;

        // drake::systems::AffineSystem::MakeAffineSystem
        struct /* MakeAffineSystem */ {

          // drake/systems/primitives/affine_system.h:184
          const char* doc =
R"""(Creates a unique pointer to AffineSystem<T> by decomposing
``dynamics`` and ``outputs`` using ``state_vars`` and ``input_vars``.

Throws:
    s runtime_error if either ``dynamics`` or ``outputs`` is not
    affine in ``state_vars`` and ``input_vars``.)""";

        } MakeAffineSystem;

        // drake::systems::AffineSystem::f0
        struct /* f0 */ {

          // drake/systems/primitives/affine_system.h:195
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:206
          const char* doc_2 = R"""()""";

        } f0;

        // drake::systems::AffineSystem::y0
        struct /* y0 */ {

          // drake/systems/primitives/affine_system.h:198
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:209
          const char* doc_2 = R"""()""";

        } y0;

      } AffineSystem;

      // drake::systems::AntiderivativeFunction
      struct /* AntiderivativeFunction */ {

        // drake/systems/analysis/antiderivative_function.h:54
        const char* doc =
R"""(A thin wrapper of the ScalarInitialValueProblem class that, in concert
with Drake's ODE initial value problem solvers ("integrators"),
provide the ability to perform quadrature on an arbitrary scalar
integrable function. That is, it allows the evaluation of an
antiderivative function F(u; 𝐤), such that F(u; 𝐤) = ∫ᵥᵘ f(x; 𝐤) dx
where f : ℝ → ℝ , u ∈ ℝ, v ∈ ℝ, 𝐤 ∈ ℝᵐ. The parameter vector 𝐤 allows
for generic function definitions, which can later be evaluated for any
instance of said vector. Also, note that 𝐤 can be understood as an
m-tuple or as an element of ℝᵐ, the vector space, depending on how it
is used by the integrable function.

See ScalarInitialValueProblem class documentation for information on
caching support and dense output usage for improved efficiency in
antiderivative function F evaluation.

For further insight into its use, consider the following examples.

- Solving the elliptic integral of the first kind E(φ; ξ) = ∫ᵠ √(1 -
ξ² sin² θ)⁻¹ dθ becomes straightforward by defining f(x; 𝐤) ≜ √(1 -
k₀² sin² x)⁻¹ with 𝐤 ≜ [ξ] and evaluating F(u; 𝐤) at u = φ.

- As the bearings in a rotating machine age over time, these are more
likely to fail. Let γ be a random variable describing the time to
first bearing failure, described by a family of probability density
functions gᵧ(y; l) parameterized by bearing load l. In this context,
the probability of a bearing under load to fail during the first N
months becomes P(0 < γ ≤ N mo.; l) = Gᵧ(N mo.; l) - Gᵧ(0; l), where
Gᵧ(y; l) is the family of cumulative density functions, parameterized
by bearing load l, and G'ᵧ(y; l) = gᵧ(y; l). Therefore, defining f(x;
𝐤) ≜ gᵧ(x; k₀) with 𝐤 ≜ [l] and evaluating F(u; 𝐤) at u = N yields the
result.

Template parameter ``T``:
    The ℝ domain scalar type, which must be a valid Eigen scalar.

Note:
    Instantiated templates for the following scalar types ``T`` are
    provided: - double)""";

        // drake::systems::AntiderivativeFunction::AntiderivativeFunction<T>
        struct /* ctor */ {

          // drake/systems/analysis/antiderivative_function.h:56
          const char* doc = R"""()""";

          // drake/systems/analysis/antiderivative_function.h:56
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/antiderivative_function.h:93
          const char* doc_3 =
R"""(Constructs the antiderivative function of the given
``integrable_function``, using ``default_values``.v as lower
integration bound if given (0 if not) and parameterized with
``default_values``.k if given (an empty vector if not) by default.

Parameter ``integrable_function``:
    The function f(x; 𝐤) to be integrated.

Parameter ``default_values``:
    The values specified by default for this function, i.e. default
    lower integration bound v ∈ ℝ and default parameter vector 𝐤 ∈ ℝᵐ.)""";

        } ctor;

        // drake::systems::AntiderivativeFunction::Evaluate
        struct /* Evaluate */ {

          // drake/systems/analysis/antiderivative_function.h:134
          const char* doc =
R"""(Evaluates the definite integral F(u; 𝐤) = ∫ᵥᵘ f(x; 𝐤) dx from the
lower integration bound v (see definition in class documentation) to
``u`` using the parameter vector 𝐤 (see definition in class
documentation) if present in ``values``, falling back to the ones
given on construction if missing.

Parameter ``u``:
    The upper integration bound.

Parameter ``values``:
    The specified values for the integration.

Returns:
    The value of the definite integral. @pre The given upper
    integration bound ``u`` must be larger than or equal to the lower
    integration bound v. @pre If given, the dimension of the parameter
    vector ``values``.k must match that of the parameter vector 𝐤 in
    the default specified values given on construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } Evaluate;

        // drake::systems::AntiderivativeFunction::MakeDenseEvalFunction
        struct /* MakeDenseEvalFunction */ {

          // drake/systems/analysis/antiderivative_function.h:168
          const char* doc =
R"""(Evaluates and yields an approximation of the definite integral F(u; 𝐤)
= ∫ᵥᵘ f(x; 𝐤) dx for v ≤ u ≤ w, i.e. the closed interval that goes
from the lower integration bound v (see definition in class
documentation) to the uppermost integration bound ``w``, using the
parameter vector 𝐤 (see definition in class documentation) if present
in ``values``, falling back to the ones given on construction if
missing.

To this end, the wrapped IntegratorBase instance solves the integral
from v to ``w`` (i.e. advances the state x of its differential form
x'(t) = f(x; 𝐤) from v to ``w``), creating a scalar dense output over
that [v, ``w``] interval along the way.

Parameter ``w``:
    The uppermost integration bound. Usually, v < ``w`` as an empty
    dense output would result if v = ``w``.

Parameter ``values``:
    The specified values for the integration.

Returns:
    A dense approximation to F(u; 𝐤) (that is, a function), defined
    for v ≤ u ≤ w.

Note:
    The larger the given ``w`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows. @pre The given uppermost integration bound ``w``
    must be larger than or equal to the lower integration bound v.
    @pre If given, the dimension of the parameter vector ``values``.k
    must match that of the parameter vector 𝐤 in the default specified
    values given on construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } MakeDenseEvalFunction;

        // drake::systems::AntiderivativeFunction::SpecifiedValues
        struct /* SpecifiedValues */ {

          // drake/systems/analysis/antiderivative_function.h:69
          const char* doc =
R"""(The set of values that, along with the function being integrated,
partially specify the definite integral i.e. providing the lower
integration bound v and the parameter vector 𝐤, leaving the upper
integration bound u to be specified on evaluation.)""";

          // drake::systems::AntiderivativeFunction::SpecifiedValues::SpecifiedValues
          struct /* ctor */ {

            // drake/systems/analysis/antiderivative_function.h:71
            const char* doc =
R"""(Default constructor that leaves all values unspecified.)""";

            // drake/systems/analysis/antiderivative_function.h:76
            const char* doc_2 =
R"""(Constructor that specifies all values.

Parameter ``v_in``:
    Specified lower integration bound v.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";

          } ctor;

          // drake::systems::AntiderivativeFunction::SpecifiedValues::k
          struct /* k */ {

            // drake/systems/analysis/antiderivative_function.h:81
            const char* doc = R"""(< The parameter vector 𝐤.)""";

          } k;

          // drake::systems::AntiderivativeFunction::SpecifiedValues::v
          struct /* v */ {

            // drake/systems/analysis/antiderivative_function.h:80
            const char* doc = R"""(< The lower integration bound v.)""";

          } v;

        } SpecifiedValues;

        // drake::systems::AntiderivativeFunction::get_integrator
        struct /* get_integrator */ {

          // drake/systems/analysis/antiderivative_function.h:199
          const char* doc =
R"""(Gets a pointer to the internal integrator instance.)""";

        } get_integrator;

        // drake::systems::AntiderivativeFunction::get_mutable_integrator
        struct /* get_mutable_integrator */ {

          // drake/systems/analysis/antiderivative_function.h:204
          const char* doc =
R"""(Gets a pointer to the internal mutable integrator instance.)""";

        } get_mutable_integrator;

        // drake::systems::AntiderivativeFunction::reset_integrator
        struct /* reset_integrator */ {

          // drake/systems/analysis/antiderivative_function.h:193
          const char* doc =
R"""(Resets the internal integrator instance.

A usage example is shown below.

```
{.cpp}
   antiderivative_f.reset_integrator<RungeKutta2Integrator<T>>(max_step);
```

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types. @warning This operation
    invalidates pointers returned by
    AntiderivativeFunction::get_integrator() and
    AntiderivativeFunction::get_mutable_integrator().)""";

        } reset_integrator;

      } AntiderivativeFunction;

      // drake::systems::BarycentricMeshSystem
      struct /* BarycentricMeshSystem */ {

        // drake/systems/primitives/barycentric_system.h:25
        const char* doc =
R"""(A (stateless) vector system implemented as a multi-linear
(barycentric) interpolation on a mesh over the inputs.

This has many potential uses, including representing the policies that
are generated by numerical control design methods like approximate
dynamic programming.

See also:
    math::BarycentricMesh)""";

        // drake::systems::BarycentricMeshSystem::BarycentricMeshSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/barycentric_system.h:28
          const char* doc = R"""()""";

          // drake/systems/primitives/barycentric_system.h:28
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/barycentric_system.h:36
          const char* doc_3 =
R"""(Constructs the system from a mesh and the associated mesh values.
``output_values`` is a matrix with each column representing the value
to output if the input is the associated mesh point. It must have the
same number of columns as mesh.get_num_mesh_points();
mesh.MeshValuesFrom(function) is one useful tool for creating it.)""";

        } ctor;

        // drake::systems::BarycentricMeshSystem::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/barycentric_system.h:53
          const char* doc =
R"""(Evaluates the BarycentricMesh at the input and writes it to the
output.)""";

        } DoCalcVectorOutput;

        // drake::systems::BarycentricMeshSystem::get_mesh
        struct /* get_mesh */ {

          // drake/systems/primitives/barycentric_system.h:46
          const char* doc = R"""(Returns a reference to the mesh.)""";

        } get_mesh;

        // drake::systems::BarycentricMeshSystem::get_output_values
        struct /* get_output_values */ {

          // drake/systems/primitives/barycentric_system.h:49
          const char* doc =
R"""(Returns a reference to the output values.)""";

        } get_output_values;

      } BarycentricMeshSystem;

      // drake::systems::BasicVector
      struct /* BasicVector */ {

        // drake/systems/framework/basic_vector.h:25
        const char* doc =
R"""(BasicVector is a semantics-free wrapper around an Eigen vector that
satisfies VectorBase. Once constructed, its size is fixed.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::BasicVector::BasicVector<T>
        struct /* ctor */ {

          // drake/systems/framework/basic_vector.h:30
          const char* doc = R"""()""";

          // drake/systems/framework/basic_vector.h:30
          const char* doc_2 = R"""()""";

          // drake/systems/framework/basic_vector.h:33
          const char* doc_3 = R"""(Constructs an empty BasicVector.)""";

          // drake/systems/framework/basic_vector.h:37
          const char* doc_4 =
R"""(Initializes with the given ``size`` using the drake::dummy_value<T>,
which is NaN when T = double.)""";

          // drake/systems/framework/basic_vector.h:41
          const char* doc_5 =
R"""(Constructs a BasicVector with the specified ``data``.)""";

          // drake/systems/framework/basic_vector.h:44
          const char* doc_6 =
R"""(Constructs a BasicVector whose elements are the elements of ``data``.)""";

        } ctor;

        // drake::systems::BasicVector::Clone
        struct /* Clone */ {

          // drake/systems/framework/basic_vector.h:130
          const char* doc =
R"""(Copies the entire vector to a new BasicVector, with the same concrete
implementation type.

Uses the Non-Virtual Interface idiom because smart pointers do not
have type covariance.)""";

        } Clone;

        // drake::systems::BasicVector::CopyToVector
        struct /* CopyToVector */ {

          // drake/systems/framework/basic_vector.h:108
          const char* doc = R"""()""";

        } CopyToVector;

        // drake::systems::BasicVector::DoClone
        struct /* DoClone */ {

          // drake/systems/framework/basic_vector.h:143
          const char* doc =
R"""(Returns a new BasicVector containing a copy of the entire vector.
Caller must take ownership, and may rely on the NVI wrapper to
initialize the clone elementwise.

Subclasses of BasicVector must override DoClone to return their
covariant type.)""";

        } DoClone;

        // drake::systems::BasicVector::GetAtIndex
        struct /* GetAtIndex */ {

          // drake/systems/framework/basic_vector.h:94
          const char* doc = R"""()""";

          // drake/systems/framework/basic_vector.h:99
          const char* doc_2 = R"""()""";

        } GetAtIndex;

        // drake::systems::BasicVector::Make
        struct /* Make */ {

          // drake/systems/framework/basic_vector.h:53
          const char* doc =
R"""(Constructs a BasicVector whose elements are the elements of ``data``.)""";

          // drake/systems/framework/basic_vector.h:63
          const char* doc_2 =
R"""(Constructs a BasicVector where each element is constructed using the
placewise-corresponding member of ``args`` as the sole constructor
argument. For instance: BasicVector<symbolic::Expression>::Make("x",
"y", "z");)""";

        } Make;

        // drake::systems::BasicVector::MakeRecursive
        struct /* MakeRecursive */ {

          // drake/systems/framework/basic_vector.h:152
          const char* doc =
R"""(Sets ``data`` at ``index`` to an object of type T, which must have a
single-argument constructor invoked via ``constructor_arg``, and then
recursively invokes itself on the next index with ``recursive`` args.
Helper for BasicVector<T>::Make.)""";

          // drake/systems/framework/basic_vector.h:160
          const char* doc_2 =
R"""(Base case for the MakeRecursive template recursion.)""";

        } MakeRecursive;

        // drake::systems::BasicVector::NormInf
        struct /* NormInf */ {

          // drake/systems/framework/basic_vector.h:121
          const char* doc =
R"""(Computes the infinity norm for this vector.)""";

        } NormInf;

        // drake::systems::BasicVector::ScaleAndAddToVector
        struct /* ScaleAndAddToVector */ {

          // drake/systems/framework/basic_vector.h:110
          const char* doc = R"""()""";

        } ScaleAndAddToVector;

        // drake::systems::BasicVector::SetFromVector
        struct /* SetFromVector */ {

          // drake/systems/framework/basic_vector.h:104
          const char* doc = R"""()""";

        } SetFromVector;

        // drake::systems::BasicVector::SetZero
        struct /* SetZero */ {

          // drake/systems/framework/basic_vector.h:118
          const char* doc = R"""()""";

        } SetZero;

        // drake::systems::BasicVector::get_mutable_value
        struct /* get_mutable_value */ {

          // drake/systems/framework/basic_vector.h:90
          const char* doc =
R"""(Returns the entire vector as a mutable Eigen::VectorBlock, which
allows mutation of the values, but does not allow resizing the vector
itself.)""";

        } get_mutable_value;

        // drake::systems::BasicVector::get_value
        struct /* get_value */ {

          // drake/systems/framework/basic_vector.h:84
          const char* doc =
R"""(Returns the entire vector as a const Eigen::VectorBlock.)""";

        } get_value;

        // drake::systems::BasicVector::set_value
        struct /* set_value */ {

          // drake/systems/framework/basic_vector.h:74
          const char* doc =
R"""(Sets the vector to the given value. After a.set_value(b.get_value()),
a must be identical to b. Throws ValueError if the new value has
different dimensions.)""";

        } set_value;

        // drake::systems::BasicVector::size
        struct /* size */ {

          // drake/systems/framework/basic_vector.h:69
          const char* doc = R"""()""";

        } size;

      } BasicVector;

      // drake::systems::Cache
      struct /* Cache */ {

        // drake/systems/framework/cache.h:592
        const char* doc =
R"""(Stores all the CacheEntryValue objects owned by a particular Context,
organized to allow fast access using a CacheIndex as an index. Memory
addresses of CacheEntryValue objects are stable once allocated, but
CacheIndex numbers are stable even after a Context has been copied so
should be preferred as a means for identifying particular cache
entries.)""";

        // drake::systems::Cache::Cache
        struct /* ctor */ {

          // drake/systems/framework/cache.h:596
          const char* doc = R"""()""";

          // drake/systems/framework/cache.h:603
          const char* doc_2 =
R"""(Constructor creates an empty cache referencing the system pathname
service of its owning subcontext. The supplied pointer must not be
null.)""";

        } ctor;

        // drake::systems::Cache::CreateNewCacheEntryValue
        struct /* CreateNewCacheEntryValue */ {

          // drake/systems/framework/cache.h:623
          const char* doc =
R"""(Allocates a new CacheEntryValue and provides it a DependencyTracker
using the given CacheIndex and DependencyTicket number. The
CacheEntryValue object is owned by this Cache and the returned
reference remains valid if other cache entry values are created. If
there is a pre-existing tracker with the given ticket number (allowed
only for well-known cached computations, such as time derivatives), it
is assigned the new cache entry value to manage. Otherwise a new
DependencyTracker is created. The created tracker object is owned by
the given DependencyGraph, which must be owned by the same Context
that owns this Cache. The graph must already contain trackers for the
indicated prerequisites. The tracker will retain a pointer to the
created CacheEntryValue for invalidation purposes.)""";

        } CreateNewCacheEntryValue;

        // drake::systems::Cache::DisableCaching
        struct /* DisableCaching */ {

          // drake/systems/framework/cache.h:666
          const char* doc =
R"""((Advanced) Disables caching for all the entries in this Cache. Note
that this is done by setting individual `is_disabled` flags in the
entries, so it can be changed on a per-entry basis later. This has no
effect on the `out_of_date` flags.)""";

        } DisableCaching;

        // drake::systems::Cache::EnableCaching
        struct /* EnableCaching */ {

          // drake/systems/framework/cache.h:674
          const char* doc =
R"""((Advanced) Re-enables caching for all entries in this Cache if any
were previously disabled. Note that this is done by clearing
individual `is_disabled` flags in the entries, so it overrides any
disabling that may have been done to individual entries. This has no
effect on the `out_of_date` flags so subsequent Eval() calls might not
initiate recomputation. Use SetAllEntriesOutOfDate() if you want to
force recomputation.)""";

        } EnableCaching;

        // drake::systems::Cache::SetAllEntriesOutOfDate
        struct /* SetAllEntriesOutOfDate */ {

          // drake/systems/framework/cache.h:679
          const char* doc =
R"""((Advanced) Mark every entry in this cache as "out of date". This
forces the next Eval() request for an entry to perform a
recalculation. After that normal caching behavior resumes.)""";

        } SetAllEntriesOutOfDate;

        // drake::systems::Cache::cache_size
        struct /* cache_size */ {

          // drake/systems/framework/cache.h:641
          const char* doc =
R"""(Returns the current size of the Cache container, providing for
CacheIndex values from `0..cache_size()-1`. Note that it is possible
to have empty slots in the cache. Use has_cache_entry_value() to
determine if there is a cache entry associated with a particular
index.)""";

        } cache_size;

        // drake::systems::Cache::get_cache_entry_value
        struct /* get_cache_entry_value */ {

          // drake/systems/framework/cache.h:647
          const char* doc =
R"""(Returns a const CacheEntryValue given an index. This is very fast.
Behavior is undefined if the index is out of range [0..cache_size()-1]
or if there is no CacheEntryValue with that index. Use
has_cache_entry_value() first if you aren't sure.)""";

        } get_cache_entry_value;

        // drake::systems::Cache::get_mutable_cache_entry_value
        struct /* get_mutable_cache_entry_value */ {

          // drake/systems/framework/cache.h:658
          const char* doc =
R"""(Returns a mutable CacheEntryValue given an index. This is very fast.
Behavior is undefined if the index is out of range [0..cache_size()-1]
or if there is no CacheEntryValue with that index. Use
has_cache_entry_value() first if you aren't sure.)""";

        } get_mutable_cache_entry_value;

        // drake::systems::Cache::has_cache_entry_value
        struct /* has_cache_entry_value */ {

          // drake/systems/framework/cache.h:631
          const char* doc =
R"""(Returns true if there is a CacheEntryValue in this cache that has the
given index.)""";

        } has_cache_entry_value;

      } Cache;

      // drake::systems::CacheEntry
      struct /* CacheEntry */ {

        // drake/systems/framework/cache_entry.h:42
        const char* doc =
R"""(A CacheEntry belongs to a System and represents the properties of one
of that System's cached computations. CacheEntry objects are assigned
CacheIndex values in the order they are declared; these are unique
within a single System and can be used for quick access to both the
CacheEntry and the corresponding CacheEntryValue in the System's
Context.

CacheEntry objects are allocated automatically for known System
computations like output ports and time derivatives, and may also be
allocated by user code for other cached computations.

A cache entry's value is always stored as an AbstractValue, which can
hold a concrete value of any copyable type. However, once a value has
been allocated using a particular concrete type, the type cannot be
changed.

CacheEntry objects support four important operations: - Allocate()
returns an object that can hold the cached value. - Calc()
unconditionally computes the cached value. - Eval() returns a
reference to the cached value, first updating with Calc() if it was
out of date. - GetKnownUpToDate() returns a reference to the current
value that you are certain must already be up to date.

The allocation and calculation functions must be provided at the time
a cache entry is declared. That is typically done in a System
constructor, in a manner very similar to the declaration of output
ports.)""";

        // drake::systems::CacheEntry::Allocate
        struct /* Allocate */ {

          // drake/systems/framework/cache_entry.h:104
          const char* doc =
R"""(Invokes this cache entry's allocator function to allocate a concrete
object suitable for holding the value to be held in this cache entry,
and returns that as an AbstractValue. The returned object will never
be null.

Throws:
    s std::logic_error if the allocator function returned null.)""";

        } Allocate;

        // drake::systems::CacheEntry::CacheEntry
        struct /* ctor */ {

          // drake/systems/framework/cache_entry.h:44
          const char* doc = R"""()""";

          // drake/systems/framework/cache_entry.h:44
          const char* doc_2 = R"""()""";

          // drake/systems/framework/cache_entry.h:88
          const char* doc_3 =
R"""((Advanced) Constructs a cache entry within a System and specifies the
resources it needs.

This method is intended only for use by the framework which provides
much nicer APIs for end users. See DeclareCacheEntry_documentation
"DeclareCacheEntry" for the user-facing API documentation.

The supplied allocator must return a suitable AbstractValue in which
to hold the result. The supplied calculator function must write to an
AbstractValue of the same underlying concrete type as is returned by
the allocator. The allocator function is not invoked here during
construction of the cache entry. Instead allocation is deferred until
the allocator can be provided with a complete Context, which cannot
occur until the full Diagram containing this subsystem has been
completed. That way the initial type, size, or value can Context-
dependent. The supplied prerequisite tickets are interpreted as
belonging to the same subsystem that owns this CacheEntry.

The list of prerequisites cannot be empty -- a cache entry that really
has no prerequisites must say so explicitly by providing a list
containing only `nothing_ticket()` as a prerequisite. The subsystem
pointer must not be null, and the cache index and ticket must be
valid. The description is an arbitrary string not interpreted in any
way by Drake.

Throws:
    s std::logic_error if the prerequisite list is empty.

See also:
    drake::systems::SystemBase::DeclareCacheEntry())""";

        } ctor;

        // drake::systems::CacheEntry::Calc
        struct /* Calc */ {

          // drake/systems/framework/cache_entry.h:112
          const char* doc =
R"""(Unconditionally computes the value this cache entry should have given
a particular context, into an already-allocated object. @pre `context`
is a subcontext that is compatible with the subsystem that owns this
cache entry. @pre `value` is non null and has exactly the same
concrete type as that of the object returned by this entry's
Allocate() method.)""";

        } Calc;

        // drake::systems::CacheEntry::Eval
        struct /* Eval */ {

          // drake/systems/framework/cache_entry.h:126
          const char* doc =
R"""(Returns a reference to the up-to-date value of this cache entry
contained in the given Context. This is the preferred way to obtain a
cached value. If the value is not already up to date with respect to
its prerequisites, or if caching is disabled for this entry, then this
entry's Calc() method is used first to update the value before the
reference is returned. The Calc() method may be arbitrarily expensive,
but this method is constant time and _very_ fast if the value is
already up to date. If you are certain the value should be up to date
already, you may use the GetKnownUpToDate() method instead. @pre
`context` is a subcontext that is compatible with the subsystem that
owns this cache entry.

Throws:
    s std::logic_error if the value doesn't actually have type V.)""";

        } Eval;

        // drake::systems::CacheEntry::EvalAbstract
        struct /* EvalAbstract */ {

          // drake/systems/framework/cache_entry.h:141
          const char* doc = R"""()""";

        } EvalAbstract;

        // drake::systems::CacheEntry::GetKnownUpToDate
        struct /* GetKnownUpToDate */ {

          // drake/systems/framework/cache_entry.h:162
          const char* doc = R"""()""";

        } GetKnownUpToDate;

        // drake::systems::CacheEntry::GetKnownUpToDateAbstract
        struct /* GetKnownUpToDateAbstract */ {

          // drake/systems/framework/cache_entry.h:177
          const char* doc = R"""()""";

        } GetKnownUpToDateAbstract;

        // drake::systems::CacheEntry::cache_index
        struct /* cache_index */ {

          // drake/systems/framework/cache_entry.h:245
          const char* doc =
R"""(Returns the CacheIndex used to locate this CacheEntry within the
containing System.)""";

        } cache_index;

        // drake::systems::CacheEntry::description
        struct /* description */ {

          // drake/systems/framework/cache_entry.h:219
          const char* doc =
R"""(Return the human-readable description for this CacheEntry. */)""";

        } description;

        // drake::systems::CacheEntry::disable_caching
        struct /* disable_caching */ {

          // drake/systems/framework/cache_entry.h:206
          const char* doc =
R"""((Debugging) Disables caching for this cache entry. Eval() will
recompute the cached value every time it is invoked, regardless of the
state of the out_of_date flag. That should have no effect on any
computed results, other than speed. See class documentation for ideas
as to what might be wrong if you see a change. Note that the `context`
is `const` here; cache entry values are mutable.)""";

        } disable_caching;

        // drake::systems::CacheEntry::enable_caching
        struct /* enable_caching */ {

          // drake/systems/framework/cache_entry.h:213
          const char* doc =
R"""((Debugging) Enables caching for this cache entry if it was previously
disabled.)""";

        } enable_caching;

        // drake::systems::CacheEntry::get_cache_entry_value
        struct /* get_cache_entry_value */ {

          // drake/systems/framework/cache_entry.h:227
          const char* doc =
R"""((Advanced) Returns a const reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. The
returned object contains the current value and tracks whether it is up
to date with respect to its prerequisites. If you just need the value,
use the Eval() method rather than this one. This method is constant
time and _very_ fast in all circumstances.)""";

        } get_cache_entry_value;

        // drake::systems::CacheEntry::get_mutable_cache_entry_value
        struct /* get_mutable_cache_entry_value */ {

          // drake/systems/framework/cache_entry.h:237
          const char* doc =
R"""((Advanced) Returns a mutable reference to the CacheEntryValue object
that corresponds to this CacheEntry, from the supplied Context. Note
that `context` is const; cache values are mutable. Don't call this
method unless you know what you're doing. This method is constant time
and _very_ fast in all circumstances.)""";

        } get_mutable_cache_entry_value;

        // drake::systems::CacheEntry::is_cache_entry_disabled
        struct /* is_cache_entry_disabled */ {

          // drake/systems/framework/cache_entry.h:196
          const char* doc =
R"""((Debugging) Returns `true` if caching has been disabled for this cache
entry. That means Eval() will recalculate even if the entry is marked
up to date.)""";

        } is_cache_entry_disabled;

        // drake::systems::CacheEntry::is_out_of_date
        struct /* is_out_of_date */ {

          // drake/systems/framework/cache_entry.h:189
          const char* doc =
R"""(Returns `true` if the current value of this cache entry is out of date
with respect to its prerequisites. If this returns `false` then the
Eval() method will not perform any computation when invoked, unless
caching has been disabled for this entry. If this returns `true` the
GetKnownUpToDate() methods will fail if invoked.)""";

        } is_out_of_date;

        // drake::systems::CacheEntry::prerequisites
        struct /* prerequisites */ {

          // drake/systems/framework/cache_entry.h:96
          const char* doc =
R"""(Returns a reference to the list of prerequisites needed by this cache
entry's Calc() function. These are all within the same subsystem that
owns this CacheEntry.)""";

        } prerequisites;

        // drake::systems::CacheEntry::ticket
        struct /* ticket */ {

          // drake/systems/framework/cache_entry.h:251
          const char* doc =
R"""(Returns the DependencyTicket used to register dependencies on the
value of this CacheEntry. This can also be used to locate the
DependencyTracker that manages dependencies at runtime for the
associated CacheEntryValue in a Context.)""";

        } ticket;

      } CacheEntry;

      // drake::systems::CacheEntryValue
      struct /* CacheEntryValue */ {

        // drake/systems/framework/cache.h:66
        const char* doc =
R"""(This is the representation in the Context for the value of one of a
System's CacheEntry objects. It consists of a single type-erased
value, a serial number, an `out_of_date` flag, and a DependencyTracker
ticket. Details: - "Out of date" means that some prerequisite of this
cache entry's computation has been changed in the current Context
since the stored value was last computed, and thus must be recomputed
prior to use. On the other hand, if the entry is _not_ out of date,
then it is "up to date" meaning that if you were to recompute it using
the current Context values you would get the identical result (so
don't bother!). - The "serial number" is an integer that is
incremented whenever the value is modified, or made available for
mutable access. You can use it to recognize that you are looking at
the same value as you saw at some earlier time. It is also useful for
performance studies since it is a count of how many times this value
was recomputed. Note that marking the value "out of date" is _not_ a
modification; that does not change the serial number. The serial
number is maintained internally and cannot be user-modified. - The
DependencyTicket ("ticket") stored here identifies the
DependencyTracker ("tracker") associated with this cache entry. The
tracker maintains lists of all upstream prerequisites and downstream
dependents of the value stored here, and also has a pointer to this
CacheEntryValue that it uses for invalidation. Upstream modifications
cause the tracker to set the `out_of_date` flag here, and mark all
downstream dependents out of date also. The tracker lives in the same
subcontext that owns the Cache that owns this CacheEntryValue.

We sometimes use the terms "invalid" and "invalidate" as synonyms for
"out of date" and "mark out of date".

For debugging purposes, caching may be disabled for an entire Context
or for particular cache entry values. This is independent of the
`out_of_date` flag described above, which is still expected to be
operational when caching is disabled. However, when caching is
disabled the Eval() methods will recompute the contained value even if
it is not marked out of date. That should have no effect other than to
slow computation; if results change, something is wrong. There could
be a problem with the specification of dependencies, a bug in user
code such as improper retention of a stale reference, or a bug in the
caching system.)""";

        // drake::systems::CacheEntryValue::CacheEntryValue
        struct /* ctor */ {

          // drake/systems/framework/cache.h:70
          const char* doc =
R"""(@name Does not allow move or assignment; copy constructor is private.
*/ @{ */)""";

        } ctor;

        // drake::systems::CacheEntryValue::GetAbstractValueOrThrow
        struct /* GetAbstractValueOrThrow */ {

          // drake/systems/framework/cache.h:118
          const char* doc =
R"""(Returns a const reference to the contained abstract value, which must
not be out of date with respect to any of its prerequisites. It is an
error to call this if there is no stored value object, or if the value
is out of date.

Throws:
    s std::logic_error if there is no value or it is out of date.

See also:
    get_abstract_value())""";

        } GetAbstractValueOrThrow;

        // drake::systems::CacheEntryValue::GetMutableAbstractValueOrThrow
        struct /* GetMutableAbstractValueOrThrow */ {

          // drake/systems/framework/cache.h:174
          const char* doc =
R"""((Advanced) Returns a mutable reference to the contained value after
incrementing the serial number. This is for the purpose of performing
an update or extended computation in place. If possible, use the safer
and more straightforward method SetValueOrThrow() rather than this
method. Mutable access is only permitted if the value is already
marked out of date (meaning that all downstream dependents have
already been notified). It is an error to call this if there is no
stored value, or it is already up to date. Since this is intended for
relatively expensive computations, these preconditions are checked
even in Release builds. If you have a small, fast computation to
perform, use set_value() instead. If your computation completes
successfully, you must mark the entry up to date yourself using
mark_up_to_date() if you want anyone to be able to use the new value.

Throws:
    s std::logic_error if there is no value, or if the value is
    already up to date.

See also:
    SetValueOrThrow(), set_value(), mark_up_to_date())""";

        } GetMutableAbstractValueOrThrow;

        // drake::systems::CacheEntryValue::GetMutableValueOrThrow
        struct /* GetMutableValueOrThrow */ {

          // drake/systems/framework/cache.h:188
          const char* doc =
R"""((Advanced) Convenience method that returns a mutable reference to the
contained value downcast to its known concrete type. Throws an
exception if the contained value does not have the indicated concrete
type. Note that you must call mark_up_to_date() after modifying the
value through the returned reference. See
GetMutableAbstractValueOrThrow() above for more information.

Throws:
    s std::logic_error if there is no value, or if the value is
    already up to date, of it doesn't actually have type V.

See also:
    SetValueOrThrow(), set_value(), mark_up_to_date()

Template parameter ``V``:
    The known actual value type.)""";

        } GetMutableValueOrThrow;

        // drake::systems::CacheEntryValue::GetPathDescription
        struct /* GetPathDescription */ {

          // drake/systems/framework/cache.h:357
          const char* doc =
R"""(Returns the description, preceded by the full pathname of the
subsystem associated with the owning subcontext.)""";

        } GetPathDescription;

        // drake::systems::CacheEntryValue::GetValueOrThrow
        struct /* GetValueOrThrow */ {

          // drake/systems/framework/cache.h:129
          const char* doc =
R"""(Returns a const reference to the contained value of known type V. It
is an error to call this if there is no stored value, or the value is
out of date, or the value doesn't actually have type V.

Throws:
    s std::logic_error if there is no stored value, or if it is out of
    date, or it doesn't actually have type V.

See also:
    get_value())""";

        } GetValueOrThrow;

        // drake::systems::CacheEntryValue::PeekAbstractValueOrThrow
        struct /* PeekAbstractValueOrThrow */ {

          // drake/systems/framework/cache.h:198
          const char* doc =
R"""((Advanced) Returns a reference to the contained value _without_
checking whether the value is out of date. This can be used to check
type and size information but should not be used to look at the value
unless you _really_ know what you're doing.

Throws:
    s std::logic_error if there is no contained value.)""";

        } PeekAbstractValueOrThrow;

        // drake::systems::CacheEntryValue::PeekValueOrThrow
        struct /* PeekValueOrThrow */ {

          // drake/systems/framework/cache.h:211
          const char* doc =
R"""((Advanced) Convenience method that provides access to the contained
value downcast to its known concrete type, _without_ checking whether
the value is out of date. This can be used to check type and size
information but should not be used to look at the value unless you
_really_ know what you're doing.

Throws:
    s std::logic_error if there is no contained value, or if the
    contained value does not actually have type V.

Template parameter ``V``:
    The known actual value type.)""";

        } PeekValueOrThrow;

        // drake::systems::CacheEntryValue::SetInitialValue
        struct /* SetInitialValue */ {

          // drake/systems/framework/cache.h:88
          const char* doc =
R"""(Defines the concrete value type by providing an initial AbstractValue
object containing an object of the appropriate concrete type. This
value is marked out of date. It is an error to call this if there is
already a value here; use has_value() if you want to check first.
Also, the given initial value may not be null. The serial number is
set to 1. No out-of-date notifications are sent to downstream
dependents.

Throws:
    s std::logic_error if the given value is null or if there is
    already a value, or if this CacheEntryValue is malformed in some
    detectable way.)""";

        } SetInitialValue;

        // drake::systems::CacheEntryValue::SetValueOrThrow
        struct /* SetValueOrThrow */ {

          // drake/systems/framework/cache.h:153
          const char* doc =
R"""(Assigns a new value to a cache entry and marks it up to date. The
cache entry must already contain a value object of type V to which the
new value is assigned, and that value must currently be marked out of
date. The supplied new value _must_ have been calculated using the
current values in the owning Context, and we assume that here although
this method cannot check that assumption. Consequently, this method
clears the `out_of_date` flag. No out-of-date notifications are issued
by this method; we assume downstream dependents were marked out of
date at the time this value went out of date. The serial number is
incremented.

This method is the safest and most convenient way to assign a new
value. However it requires that a new value be computed and then
copied into the cache entry, which is fine for small types V but may
be too expensive for large ones. You can alternatively obtain a
mutable reference to the value already contained in the cache entry
and update it in place via GetMutableValueOrThrow().

Throws:
    s std::logic_error if there is no value, or the value is already
    up to date, of it doesn't actually have type V.

See also:
    set_value(), GetMutableValueOrThrow())""";

        } SetValueOrThrow;

        // drake::systems::CacheEntryValue::ThrowIfBadCacheEntryValue
        struct /* ThrowIfBadCacheEntryValue */ {

          // drake/systems/framework/cache.h:389
          const char* doc =
R"""(Throws an std::logic_error if there is something clearly wrong with
this CacheEntryValue object. If the owning subcontext is known,
provide a pointer to it here and we'll check that this cache entry
agrees. In addition we check for other internal inconsistencies.

Throws:
    s std::logic_error for anything that goes wrong, with an
    appropriate explanatory message.)""";

        } ThrowIfBadCacheEntryValue;

        // drake::systems::CacheEntryValue::cache_index
        struct /* cache_index */ {

          // drake/systems/framework/cache.h:366
          const char* doc =
R"""(Returns the CacheIndex used to locate this CacheEntryValue within its
containing subcontext.)""";

        } cache_index;

        // drake::systems::CacheEntryValue::description
        struct /* description */ {

          // drake/systems/framework/cache.h:353
          const char* doc =
R"""(Returns the human-readable description for this CacheEntryValue. */)""";

        } description;

        // drake::systems::CacheEntryValue::disable_caching
        struct /* disable_caching */ {

          // drake/systems/framework/cache.h:397
          const char* doc =
R"""((Advanced) Disables caching for just this cache entry value. When
disabled, the corresponding entry's Eval() method will unconditionally
invoke Calc() to recompute the value, regardless of the setting of the
`out_of_date` flag. The `disabled` flag is independent of the
`out_of_date` flag, which will continue to be managed even if caching
is disabled.)""";

        } disable_caching;

        // drake::systems::CacheEntryValue::dummy
        struct /* dummy */ {

          // drake/systems/framework/cache.h:426
          const char* doc = R"""()""";

        } dummy;

        // drake::systems::CacheEntryValue::enable_caching
        struct /* enable_caching */ {

          // drake/systems/framework/cache.h:405
          const char* doc =
R"""((Advanced) Enables caching for this cache entry value if it was
previously disabled. When enabled (the default condition) the
corresponding entry's Eval() method will check the `out_of_date` flag
and invoke Calc() only if the entry is marked out of date.)""";

        } enable_caching;

        // drake::systems::CacheEntryValue::get_abstract_value
        struct /* get_abstract_value */ {

          // drake/systems/framework/cache.h:234
          const char* doc =
R"""(Returns a const reference to the contained abstract value, which must
not be out of date with respect to any of its prerequisites. It is an
error to call this if there is no stored value, or it is out of date.
Because this is used in performance-critical contexts, these
requirements will be checked only in Debug builds. If you are not in a
performance-critical situation (and you probably are not!), use
GetAbstractValueOrThrow() instead.)""";

        } get_abstract_value;

        // drake::systems::CacheEntryValue::get_value
        struct /* get_value */ {

          // drake/systems/framework/cache.h:250
          const char* doc =
R"""(Returns a const reference to the contained value of known type V. It
is an error to call this if there is no stored value, or the value is
out of date, or the value doesn't actually have type V. Because this
is expected to be used in performance-critical, inner-loop
circumstances, these requirements will be checked only in Debug
builds. If you are not in a performance-critical situation (and you
probably are not!), use `GetValueOrThrow<V>`() instead.

Template parameter ``V``:
    The known actual value type.)""";

        } get_value;

        // drake::systems::CacheEntryValue::has_value
        struct /* has_value */ {

          // drake/systems/framework/cache.h:362
          const char* doc =
R"""(Returns `true` if this CacheEntryValue currently contains a value
object at all, regardless of whether it is up to date. There will be
no value object after default construction, prior to
SetInitialValue().)""";

        } has_value;

        // drake::systems::CacheEntryValue::is_cache_entry_disabled
        struct /* is_cache_entry_disabled */ {

          // drake/systems/framework/cache.h:411
          const char* doc =
R"""((Advanced) Returns `true` if caching is disabled for this cache entry.
This is independent of the `out_of_date` flag.)""";

        } is_cache_entry_disabled;

        // drake::systems::CacheEntryValue::is_out_of_date
        struct /* is_out_of_date */ {

          // drake/systems/framework/cache.h:303
          const char* doc =
R"""(Returns `true` if the current value is out of date with respect to any
of its prerequisites. This refers only to the `out_of_date` flag and
is independent of whether caching is enabled or disabled. Don't call
this if there is no value here; use has_value() if you aren't sure.

See also:
    needs_recomputation())""";

        } is_out_of_date;

        // drake::systems::CacheEntryValue::mark_out_of_date
        struct /* mark_out_of_date */ {

          // drake/systems/framework/cache.h:339
          const char* doc =
R"""((Advanced) Marks the cache entry value as _out-of-date_ with respect
to its prerequisites, with no other effects. In particular, it does
not modify the value, does not change the serial number, and does not
notify downstream dependents. You should not call this method unless
you know that dependent notification has already been taken care of.
There are no error conditions; even an empty cache entry can be marked
out of date.)""";

        } mark_out_of_date;

        // drake::systems::CacheEntryValue::mark_up_to_date
        struct /* mark_up_to_date */ {

          // drake/systems/framework/cache.h:328
          const char* doc =
R"""((Advanced) Marks the cache entry value as up to date with respect to
its prerequisites, with no other effects. That is, this method clears
the `out_of_date` flag. In particular, this method does not modify the
value, does not change the serial number, and does not notify
downstream dependents of anything. This is a very dangerous method
since it enables access to the value but can't independently determine
whether it is really up to date. You should not call it unless you
really know what you're doing, or have a death wish. Do not call this
method if there is no stored value object; use has_value() if you
aren't sure. This is intended to be very fast so doesn't check for a
value object except in Debug builds.)""";

        } mark_up_to_date;

        // drake::systems::CacheEntryValue::needs_recomputation
        struct /* needs_recomputation */ {

          // drake/systems/framework/cache.h:313
          const char* doc =
R"""(Returns `true` if either (a) the value is out of date, or (b) caching
is disabled for this entry. This is a _very_ fast inline method
intended to be called every time a cache value is obtained with
Eval(). This is equivalent to `is_out_of_date() ||
is_entry_disabled()` but faster. Don't call this if there is no value
here; use has_value() if you aren't sure.)""";

        } needs_recomputation;

        // drake::systems::CacheEntryValue::serial_number
        struct /* serial_number */ {

          // drake/systems/framework/cache.h:345
          const char* doc =
R"""(Returns the serial number of the contained value. This counts up every
time the contained value changes, or whenever mutable access is
granted.)""";

        } serial_number;

        // drake::systems::CacheEntryValue::set_value
        struct /* set_value */ {

          // drake/systems/framework/cache.h:269
          const char* doc =
R"""(Assigns a new value to a cache entry and marks it up to date. The
cache value must already have a value object of type V to which the
new value is assigned, and that value must not already be up to date.
The new value is assumed to be up to date with its prerequisites, so
the `out_of_date` flag is cleared. No out-of-date notifications are
issued by this method; we assume downstream dependents were marked out
of date at the time this value went out of date. The serial number is
incremented. If you are not in a performance-critical situation (and
you probably are not!), use `SetValueOrThrow<V>()` instead.

Template parameter ``V``:
    The known actual value type.)""";

        } set_value;

        // drake::systems::CacheEntryValue::swap_value
        struct /* swap_value */ {

          // drake/systems/framework/cache.h:284
          const char* doc =
R"""((Advanced) Swaps ownership of the stored value object with the given
one. The value is marked out of date and the serial number is
incremented. This is useful for discrete updates of abstract state
variables that contain large objects. Both values must be non-null and
of the same concrete type but we won't check for errors except in
Debug builds.)""";

        } swap_value;

        // drake::systems::CacheEntryValue::ticket
        struct /* ticket */ {

          // drake/systems/framework/cache.h:372
          const char* doc =
R"""(Returns the DependencyTicket used to locate the DependencyTracker that
manages dependencies for this CacheEntryValue. The ticket refers to a
tracker that is owned by the same subcontext that owns this
CacheEntryValue.)""";

        } ticket;

      } CacheEntryValue;

      // drake::systems::CacheTag
      struct /* CacheTag */ {

        // drake/systems/framework/framework_common.h:31
        const char* doc = R"""()""";

      } CacheTag;

      // drake::systems::CompliantContactModel
      struct /* CompliantContactModel */ {

        // drake/multibody/rigid_body_plant/compliant_contact_model.h:36
        const char* doc =
R"""(This class encapsulates the compliant contact model force computations
as described in detail in drake_contacts.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

Note: The templated ScalarTypes are used in the KinematicsCache, but
all CompliantContactModels use RigidBodyTree<double>. This effectively
implies that we can e.g. AutoDiffXd with respect to the
configurations, but not the RigidBodyTree parameters. The collision
engine does not (yet) support AutoDiffXd, so calls to that logic will
throw errors at runtime.)""";

        // drake::systems::CompliantContactModel::CalcContactParameters
        struct /* CalcContactParameters */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:94
          const char* doc =
R"""(Given two collision elements (with their own defined compliant
material properties, computes the _derived_ parameters for the
_contact_. Returns the portion of the squish attributable to Element
`a` (sₐ). Element `b`'s squish factor is simply 1 - sₐ. See
contact_model_doxygen.h for details.

Parameter ``a``:
    The first element in the contact.

Parameter ``b``:
    The second element in the contact.

Parameter ``parameters``:
    The net _contact_ parameters.

Returns ``sₐ``:
    The "squish" factor of Element `a` -- the fraction of the full
    penetration deformation that `a` experiences.)""";

        } CalcContactParameters;

        // drake::systems::CompliantContactModel::CompliantContactModel<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:38
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:38
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:41
          const char* doc_3 = R"""(Instantiates a CompliantContactModel.)""";

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:45
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::CompliantContactModel::ComputeContactForce
        struct /* ComputeContactForce */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:63
          const char* doc =
R"""(Computes the generalized forces on all bodies due to contact.

Parameter ``tree``:
    A Multibody Dynamics (MBD) model of the world.

Parameter ``kinsol``:
    The kinematics of the rigid body system at the time of contact
    evaluation.

Parameter ``contacts``:
    The optional contact results. If non-null, stores the contact
    information for consuming on the output port.

Returns:
    The generalized forces across all the bodies due to contact
    response.

Throws:
    s std::runtime_error if T is non-double and potential gradient
    information would have been lost (currently this is happens
    precisely when penetration is detected).)""";

        } ComputeContactForce;

        // drake::systems::CompliantContactModel::default_material
        struct /* default_material */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:76
          const char* doc = R"""()""";

        } default_material;

        // drake::systems::CompliantContactModel::set_default_material
        struct /* set_default_material */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:74
          const char* doc =
R"""(Defines the default material property values for this model instance.
All elements with default-configured values will use the values in the
provided property set. This can be invoked before or after parsing
SDF/URDF files; all fields that were left unspecified will default to
these values. See drake_contact and CompliantMaterial for elaboration
on these values.)""";

        } set_default_material;

        // drake::systems::CompliantContactModel::set_model_parameters
        struct /* set_model_parameters */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:83
          const char* doc =
R"""(Configures the model parameters -- these are the global model values
that affect all contacts. If values are outside of valid ranges, the
program aborts. (See CompliantContactParameters for details on valid
ranges.))""";

        } set_model_parameters;

      } CompliantContactModel;

      // drake::systems::CompliantContactModelParameters
      struct /* CompliantContactModelParameters */ {

        // drake/multibody/rigid_body_plant/compliant_contact_model.h:14
        const char* doc =
R"""(The set of parameters for the compliant contact model. These values
affect all contacts in the simulation session. In some sense, they are
related to the scale of the simulation. The values must all be
_strictly_ positive. See drake_contacts for details.)""";

        // drake::systems::CompliantContactModelParameters::characteristic_radius
        struct /* characteristic_radius */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:20
          const char* doc = R"""()""";

        } characteristic_radius;

        // drake::systems::CompliantContactModelParameters::v_stiction_tolerance
        struct /* v_stiction_tolerance */ {

          // drake/multibody/rigid_body_plant/compliant_contact_model.h:17
          const char* doc = R"""()""";

        } v_stiction_tolerance;

      } CompliantContactModelParameters;

      // drake::systems::CompliantMaterial
      struct /* CompliantMaterial */ {

        // drake/multibody/rigid_body_plant/compliant_material.h:54
        const char* doc =
R"""(The set of per-object compliant material parameters with one material
applied to each collision object. The material parameters include: -
Young's modulus with units of pascals (i.e.,N/m²). This is a measure
of the tensile elasticity of the material and, as such, may also be
referred to as "elasticity" or, occasionally, "stiffness". The default
value is that of a hard rubber: 1e8 pascals. - dissipation with units
of s/m (i.e., 1/velocity). Its default value is 0.32, drawn from the
Hunt-Crossly 1975 paper representing the dissipation for ivory. -
coefficients of friction (static and dynamic). Unitless values with
default values of 0.9 for the static coefficient of friction and 0.5
for the dynamic coefficient.

Each collision geometry is associated with compliant contact material
properties. The value of properties can be _explicit_ or _default_.

Explicit values are those values that are explicitly set (via the API
or in a source specification file -- e.g., URDF or SDF). When queried,
the property set with explicit values will always report the explicit
value.

Default values are left "open". For default values the context in
which the property value is queried matters. Material properties set
to be "default" will return the hard-coded default value or a user-
provided default value. Thus, two different invocations on the _same_
instance can provide different values iff the property is configured
to be default, and the different invocations provide different default
values.

Using the dissipation property to provide a concrete example:

```
// Constructor sets all properties to be default configured.
CompliantMaterial material;

material.dissipation();        // Reports the hard-coded default value.
material.dissipation(1.2);     // Reports the provided default value, 1.2.

material.set_dissipation(10);  // dissipation is no longer default.

material.dissipation();        // Reports the explicit value, 10.
material.dissipation(1.2);     // Reports the explicit value, 10.
```

See drake_contacts for semantics of these properties for dynamics.)""";

        // drake::systems::CompliantMaterial::CompliantMaterial
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:56
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/compliant_material.h:56
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/compliant_material.h:57
          const char* doc_3 = R"""()""";

          // drake/multibody/rigid_body_plant/compliant_material.h:68
          const char* doc_4 =
R"""(Constructs fully specified material. Will throw an exception in any of
the following circumstances: - `youngs_modulus` <= 0 - `dissipation` <
0 - `static_friction` < 0 - `dynamic_friction` < 0 - `static_friction`
< `dynamic_friction`

No value will be configured to use default values.)""";

        } ctor;

        // drake::systems::CompliantMaterial::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:56
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::CompliantMaterial::dissipation
        struct /* dissipation */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:101
          const char* doc =
R"""(Extract the dissipation value with an optional default value. The
default value is checked in Debug build.

Parameter ``value``:
    The dissipation value with units of 1/velocity, i.e., s/m.)""";

        } dissipation;

        // drake::systems::CompliantMaterial::dissipation_is_default
        struct /* dissipation_is_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:110
          const char* doc =
R"""(Reports if the dissipation value is configured to use a default. A
newly constructed instance will report true. Furthermore, it must
return true if set_dissipation_to_default() has been called and false
if set_dissipation() has been called.)""";

        } dissipation_is_default;

        // drake::systems::CompliantMaterial::dynamic_friction
        struct /* dynamic_friction */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:147
          const char* doc =
R"""(Extract the dynamic friction coefficient with an optional default
value. The default value is checked for non-negativity in Debug build.

If the caller provides a default value for accessing static and
dynamic friction, it is the callers responsibility to confirm that the
dynamic friction default is less than or equal to the static friction
default.)""";

        } dynamic_friction;

        // drake::systems::CompliantMaterial::friction_is_default
        struct /* friction_is_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:157
          const char* doc =
R"""(Reports if the friction values are configured to use a default. A
newly constructed instance will report true. Furthermore, it must
return true if set_friction_to_default() has been called and false if
set_friction() has been called.)""";

        } friction_is_default;

        // drake::systems::CompliantMaterial::set_dissipation
        struct /* set_dissipation */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:96
          const char* doc =
R"""(Set the dissipation value. Attempting to set a negative value will
throw an exception. Returns a reference to `*this` so that multiple
invocations of `set` can be chained together.)""";

        } set_dissipation;

        // drake::systems::CompliantMaterial::set_dissipation_to_default
        struct /* set_dissipation_to_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:113
          const char* doc =
R"""(Reset the dissipation value to report the default value. */)""";

        } set_dissipation_to_default;

        // drake::systems::CompliantMaterial::set_friction
        struct /* set_friction */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:118
          const char* doc =
R"""(Sets *both* coefficients of friction to the same value. Throws an
exception if the value is negative. Returns a reference to `*this` so
that multiple invocations of `set` can be chained together.)""";

          // drake/multibody/rigid_body_plant/compliant_material.h:125
          const char* doc_2 =
R"""(Sets the two coefficients of friction. The `dynamic_friction` values
must be less than or equal to the `static_friction`. An exception will
be thrown if `dynamic_friction` > `static_friction` or if either value
is negative. Returns a reference to `*this` so that multiple
invocations of `set` can be chained together.)""";

        } set_friction;

        // drake::systems::CompliantMaterial::set_friction_to_default
        struct /* set_friction_to_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:164
          const char* doc =
R"""(Reset both friction coefficient values to report the default value. */)""";

        } set_friction_to_default;

        // drake::systems::CompliantMaterial::set_youngs_modulus
        struct /* set_youngs_modulus */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:75
          const char* doc =
R"""(Set the value for Young's modulus. Attempting to set a negative value
will throw an exception. Returns a reference to `*this` so that
multiple invocations of `set` can be chained together.

Parameter ``value``:
    The Young's modulus value with units of pascals.)""";

        } set_youngs_modulus;

        // drake::systems::CompliantMaterial::set_youngs_modulus_to_default
        struct /* set_youngs_modulus_to_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:91
          const char* doc =
R"""(Reset the elasticity value to report the default value. */)""";

        } set_youngs_modulus_to_default;

        // drake::systems::CompliantMaterial::static_friction
        struct /* static_friction */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:135
          const char* doc =
R"""(Extract the static friction coefficient with an optional default
value. The default value is checked for non-negativity in Debug build.

If the caller provides a default value for accessing static and
dynamic friction, it is the callers responsibility to confirm that the
dynamic friction default is less than or equal to the static friction
default.)""";

        } static_friction;

        // drake::systems::CompliantMaterial::youngs_modulus
        struct /* youngs_modulus */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:79
          const char* doc =
R"""(Extract the value for Young's modulus with an optional default value.
The default value is checked in Debug build.)""";

        } youngs_modulus;

        // drake::systems::CompliantMaterial::youngs_modulus_is_default
        struct /* youngs_modulus_is_default */ {

          // drake/multibody/rigid_body_plant/compliant_material.h:88
          const char* doc =
R"""(Reports if the elasticity value is configured to use a default. A
newly constructed instance will report true. Furthermore, it must
return true if set_youngs_modulus_to_default() has been called and
false if set_youngs_modulus() has been called.)""";

        } youngs_modulus_is_default;

      } CompliantMaterial;

      // drake::systems::CompositeEventCollection
      struct /* CompositeEventCollection */ {

        // drake/systems/framework/event.h:27
        const char* doc =
R"""(This class bundles an instance of each EventCollection<EventType> into
one object that stores the heterogeneous collection. This is intended
to hold heterogeneous events returned by methods like
System::CalcNextUpdateTime.

```
CompositeEventCollection<T> = {
  EventCollection<PublishEvent<T>>,
  EventCollection<DiscreteUpdateEvent<T>>,
  EventCollection<UnrestrictedUpdate<T>>}
```

There are two concrete derived classes: LeafCompositeEventCollection
and DiagramCompositeEventCollection. Adding new events to the
collection is only allowed for LeafCompositeEventCollection.

Template parameter ``T``:
    needs to be compatible with Eigen Scalar type.)""";

        // drake/systems/framework/event_collection.h:395
        const char* doc_2 =
R"""(This class bundles an instance of each EventCollection<EventType> into
one object that stores the heterogeneous collection. This is intended
to hold heterogeneous events returned by methods like
System::CalcNextUpdateTime.

```
CompositeEventCollection<T> = {
  EventCollection<PublishEvent<T>>,
  EventCollection<DiscreteUpdateEvent<T>>,
  EventCollection<UnrestrictedUpdate<T>>}
```

There are two concrete derived classes: LeafCompositeEventCollection
and DiagramCompositeEventCollection. Adding new events to the
collection is only allowed for LeafCompositeEventCollection.

Template parameter ``T``:
    needs to be compatible with Eigen Scalar type.)""";

        // drake::systems::CompositeEventCollection::Clear
        struct /* Clear */ {

          // drake/systems/framework/event_collection.h:404
          const char* doc = R"""(Clears all the events.)""";

        } Clear;

        // drake::systems::CompositeEventCollection::CompositeEventCollection<T>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:397
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:397
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:556
          const char* doc_3 =
R"""(Takes ownership of ``pub``, ``discrete`` and ``unrestricted``. Aborts
if any of these are null.)""";

        } ctor;

        // drake::systems::CompositeEventCollection::HasDiscreteUpdateEvents
        struct /* HasDiscreteUpdateEvents */ {

          // drake/systems/framework/event_collection.h:429
          const char* doc =
R"""(Returns `true` if and only if this collection contains one or more
discrete update events.)""";

        } HasDiscreteUpdateEvents;

        // drake::systems::CompositeEventCollection::HasEvents
        struct /* HasEvents */ {

          // drake/systems/framework/event_collection.h:413
          const char* doc =
R"""(Returns `true` if and only if this collection contains any events.)""";

        } HasEvents;

        // drake::systems::CompositeEventCollection::HasPublishEvents
        struct /* HasPublishEvents */ {

          // drake/systems/framework/event_collection.h:423
          const char* doc =
R"""(Returns `true` if and only if this collection contains one or more
publish events.)""";

        } HasPublishEvents;

        // drake::systems::CompositeEventCollection::HasUnrestrictedUpdateEvents
        struct /* HasUnrestrictedUpdateEvents */ {

          // drake/systems/framework/event_collection.h:437
          const char* doc =
R"""(Returns `true` if and only if this collection contains one or more
unrestricted update events.)""";

        } HasUnrestrictedUpdateEvents;

        // drake::systems::CompositeEventCollection::Merge
        struct /* Merge */ {

          // drake/systems/framework/event_collection.h:488
          const char* doc =
R"""(Merges the contained homogeneous event collections (e.g.,
EventCollection<PublishEvent<T>>,
EventCollection<DiscreteUpdateEvent<T>>, etc.) from `this` and
``other``, storing the results in `this`.)""";

        } Merge;

        // drake::systems::CompositeEventCollection::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/event_collection.h:497
          const char* doc =
R"""(Copies the collections of homogeneous events from ``other`` to `this`.)""";

        } SetFrom;

        // drake::systems::CompositeEventCollection::add_discrete_update_event
        struct /* add_discrete_update_event */ {

          // drake/systems/framework/event_collection.h:460
          const char* doc =
R"""(Assuming the internal discrete update event collection is an instance
of LeafEventCollection, adds the discrete update event ``event``
(ownership is also transferred) to it.

Throws:
    s std::bad_cast if the assumption is incorrect.)""";

        } add_discrete_update_event;

        // drake::systems::CompositeEventCollection::add_publish_event
        struct /* add_publish_event */ {

          // drake/systems/framework/event_collection.h:447
          const char* doc =
R"""(Assuming the internal publish event collection is an instance of
LeafEventCollection, adds the publish event ``event`` (ownership is
also transferred) to it.

Throws:
    s std::bad_cast if the assumption is incorrect.)""";

        } add_publish_event;

        // drake::systems::CompositeEventCollection::add_unrestricted_update_event
        struct /* add_unrestricted_update_event */ {

          // drake/systems/framework/event_collection.h:474
          const char* doc =
R"""(Assuming the internal unrestricted update event collection is an
instance of LeafEventCollection, adds the unrestricted update event
``event`` (ownership is also transferred) to it.

Throws:
    s std::bad_cast if the assumption is incorrect.)""";

        } add_unrestricted_update_event;

        // drake::systems::CompositeEventCollection::get_discrete_update_events
        struct /* get_discrete_update_events */ {

          // drake/systems/framework/event_collection.h:514
          const char* doc =
R"""(Returns a const reference to the collection of discrete update events.)""";

        } get_discrete_update_events;

        // drake::systems::CompositeEventCollection::get_mutable_discrete_update_events
        struct /* get_mutable_discrete_update_events */ {

          // drake/systems/framework/event_collection.h:537
          const char* doc =
R"""(Returns a mutable reference to the collection of discrete update
events.)""";

        } get_mutable_discrete_update_events;

        // drake::systems::CompositeEventCollection::get_mutable_publish_events
        struct /* get_mutable_publish_events */ {

          // drake/systems/framework/event_collection.h:530
          const char* doc =
R"""(Returns a mutable reference to the collection of publish events)""";

        } get_mutable_publish_events;

        // drake::systems::CompositeEventCollection::get_mutable_unrestricted_update_events
        struct /* get_mutable_unrestricted_update_events */ {

          // drake/systems/framework/event_collection.h:547
          const char* doc =
R"""(Returns a mutable reference to the collection of unrestricted update
events.)""";

        } get_mutable_unrestricted_update_events;

        // drake::systems::CompositeEventCollection::get_publish_events
        struct /* get_publish_events */ {

          // drake/systems/framework/event_collection.h:507
          const char* doc =
R"""(Returns a const reference to the collection of publish events.)""";

        } get_publish_events;

        // drake::systems::CompositeEventCollection::get_unrestricted_update_events
        struct /* get_unrestricted_update_events */ {

          // drake/systems/framework/event_collection.h:523
          const char* doc =
R"""(Returns a const reference to the collection of unrestricted update
events.)""";

        } get_unrestricted_update_events;

      } CompositeEventCollection;

      // drake::systems::ConstantValueSource
      struct /* ConstantValueSource */ {

        // drake/systems/primitives/constant_value_source.h:24
        const char* doc =
R"""(A source block that always outputs a constant value.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.)""";

        // drake::systems::ConstantValueSource::ConstantValueSource<T>
        struct /* ctor */ {

          // drake/systems/primitives/constant_value_source-inl.h:19
          const char* doc = R"""(``value`` The constant value to emit.)""";

          // drake/systems/primitives/constant_value_source-inl.h:36
          const char* doc_2 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/constant_value_source.h:26
          const char* doc_3 = R"""()""";

          // drake/systems/primitives/constant_value_source.h:26
          const char* doc_4 = R"""()""";

          // drake/systems/primitives/constant_value_source.h:29
          const char* doc_5 = R"""(``value`` The constant value to emit.)""";

          // drake/systems/primitives/constant_value_source.h:33
          const char* doc_6 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

      } ConstantValueSource;

      // drake::systems::ConstantVectorSource
      struct /* ConstantVectorSource */ {

        // drake/systems/primitives/constant_vector_source.h:26
        const char* doc =
R"""(A source block with a constant output port at all times. The value of
the output port is a parameter of the system (see Parameters).

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::ConstantVectorSource::ConstantVectorSource<T>
        struct /* ctor */ {

          // drake/systems/primitives/constant_vector_source.h:28
          const char* doc = R"""()""";

          // drake/systems/primitives/constant_vector_source.h:28
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/constant_vector_source.h:34
          const char* doc_3 =
R"""(Constructs a system with a vector output that is constant and equals
the supplied ``source_value`` at all times.

Parameter ``source_value``:
    the constant value of the output so that `y = source_value` at all
    times.)""";

          // drake/systems/primitives/constant_vector_source.h:41
          const char* doc_4 =
R"""(Constructs a system with a scalar-valued output of type T that is
constant and equals the supplied ``source_value`` at all times.

Parameter ``source_value``:
    the constant value of the output so that `y = source_value` at all
    times.)""";

          // drake/systems/primitives/constant_vector_source.h:48
          const char* doc_5 =
R"""(Constructs a system with a vector output that is constant, has the
type of the ``source_value``, and equals the ``source_value`` at all
times.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion.)""";

          // drake/systems/primitives/constant_vector_source.h:52
          const char* doc_6 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::ConstantVectorSource::get_mutable_source_value
        struct /* get_mutable_source_value */ {

          // drake/systems/primitives/constant_vector_source.h:62
          const char* doc =
R"""(Return a mutable reference to the source value of this block in the
given ``context``.)""";

        } get_mutable_source_value;

        // drake::systems::ConstantVectorSource::get_source_value
        struct /* get_source_value */ {

          // drake/systems/primitives/constant_vector_source.h:58
          const char* doc =
R"""(Return a read-only reference to the source value of this block in the
given ``context``.)""";

        } get_source_value;

      } ConstantVectorSource;

      // drake::systems::ContactDetail
      struct /* ContactDetail */ {

        // drake/multibody/rigid_body_plant/contact_detail.h:29
        const char* doc =
R"""(The base class for defining a contact detail. The contact can take
different forms (e.g., single ContactForce, a collection of
ContactForce instances, a patch with pressure defined over the patch
domain, etc.) The details of the contact detail are a function of the
contact response model that generates it.

All ContactDetail implementations provide a common interface; they
have the ability to produce a single equivalent resultant ContactForce
to the underlying data.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::ContactDetail::Clone
        struct /* Clone */ {

          // drake/multibody/rigid_body_plant/contact_detail.h:36
          const char* doc = R"""()""";

        } Clone;

        // drake::systems::ContactDetail::ComputeContactForce
        struct /* ComputeContactForce */ {

          // drake/multibody/rigid_body_plant/contact_detail.h:41
          const char* doc =
R"""(Computes a single equivalent contact force to the underlying contact
details.)""";

        } ComputeContactForce;

        // drake::systems::ContactDetail::ContactDetail<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/contact_detail.h:31
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_detail.h:31
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/contact_detail.h:33
          const char* doc_3 = R"""()""";

        } ctor;

      } ContactDetail;

      // drake::systems::ContactForce
      struct /* ContactForce */ {

        // drake/multibody/rigid_body_plant/contact_force.h:37
        const char* doc =
R"""(The data for a single contact force applied to one body of a
contacting pair.

Ultimately, a contact force consists of an application point, a
spatial force, and a unit vector. The spatial force includes: - a
translational force, that is a pure force applied at a point, - a
torque, the rotational force. This is not the same as the moment
induced by the translational force. This torque can arise from a
combination of different sources (e.g., torsional friction, the sum of
various moments, etc.)

The unit normal indicates the normal direction of the translational
force. Used to decompose the force into normal and tangential
components. The normal is typically defined by the contact normal.

A ContactForce makes no assumptions about the frame in which it is
defined except that the vectors representing application point
location, contact normal, force, and torque are all expressed in a
common frame, with the application point measured from the origin of
that frame. Every external instantiation of ContactForce must make it
clear which frame is being used.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::ContactForce::ContactForce<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/contact_force.h:39
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_force.h:39
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/contact_force.h:42
          const char* doc_3 =
R"""(Default constructor. All values are initialized to NaN. */)""";

          // drake/multibody/rigid_body_plant/contact_force.h:53
          const char* doc_4 =
R"""(Fully-specified constructor.

Parameter ``application_point``:
    The point at which the wrench is applied.

Parameter ``normal``:
    The translational force's unit-length normal direction.

Parameter ``force``:
    The translational force.

Parameter ``torque``:
    The torque component.)""";

          // drake/multibody/rigid_body_plant/contact_force.h:64
          const char* doc_5 =
R"""(Zero-torque constructor. This constructor sets the torque component to
be zero.

Parameter ``application_point``:
    The point at which the wrench is applied.

Parameter ``normal``:
    The translational force's unit-length normal direction.

Parameter ``force``:
    The translational force.)""";

        } ctor;

        // drake::systems::ContactForce::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/rigid_body_plant/contact_force.h:39
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::ContactForce::get_application_point
        struct /* get_application_point */ {

          // drake/multibody/rigid_body_plant/contact_force.h:75
          const char* doc = R"""()""";

        } get_application_point;

        // drake::systems::ContactForce::get_force
        struct /* get_force */ {

          // drake/multibody/rigid_body_plant/contact_force.h:77
          const char* doc = R"""()""";

        } get_force;

        // drake::systems::ContactForce::get_normal
        struct /* get_normal */ {

          // drake/multibody/rigid_body_plant/contact_force.h:87
          const char* doc = R"""()""";

        } get_normal;

        // drake::systems::ContactForce::get_normal_force
        struct /* get_normal_force */ {

          // drake/multibody/rigid_body_plant/contact_force.h:80
          const char* doc =
R"""(Computes the normal component of the translational force. */)""";

        } get_normal_force;

        // drake::systems::ContactForce::get_reaction_force
        struct /* get_reaction_force */ {

          // drake/multibody/rigid_body_plant/contact_force.h:71
          const char* doc =
R"""(Returns a spatial force applied at the same application point with
negative force and torque.)""";

        } get_reaction_force;

        // drake::systems::ContactForce::get_spatial_force
        struct /* get_spatial_force */ {

          // drake/multibody/rigid_body_plant/contact_force.h:102
          const char* doc =
R"""(This is a utility function for returning a compact representation of
the contact force's overall spatial force: a pair of vectors in R3
representing a rotational and translational force.

The rotational force does *not* necessarily include an `r X f` moment
term. It is simply the pure torque that was provided at initialization
time. Ultimately, the responsibility for computing this moment term
belongs to the portion of the code which knows the origin around which
the moment is generated.

Returns:
    the resultant spatial force.)""";

        } get_spatial_force;

        // drake::systems::ContactForce::get_tangent_force
        struct /* get_tangent_force */ {

          // drake/multibody/rigid_body_plant/contact_force.h:83
          const char* doc =
R"""(Computes the tangential component of the translational force. */)""";

        } get_tangent_force;

        // drake::systems::ContactForce::get_torque
        struct /* get_torque */ {

          // drake/multibody/rigid_body_plant/contact_force.h:85
          const char* doc = R"""()""";

        } get_torque;

      } ContactForce;

      // drake::systems::ContactInfo
      struct /* ContactInfo */ {

        // drake/multibody/rigid_body_plant/contact_info.h:48
        const char* doc =
R"""(A class containing information regarding contact response between two
bodies including: - The pair of collision elements that are contacting
(e1, e2), referenced by their unique identifiers. - A resultant
ContactForce -- a single ContactForce with the equivalent effect of
applying all individual ContactDetails to element e1. - An optional
list of ContactDetail instances.

Some forms of ContactDetail are more expensive than others. However,
ContactInfo instances will need to be copied. The contact model
defines a default behavior of whether the ContactDetails are stored in
the corresponding ContactInfo instance or not. If this happens, the
ContactInfo instance will contain a valid resultant force, but no
contact details.

Eventually, this beahvior will be subject to user configuration; the
user will specify whether they want the details to be included in the
ContactInfo, overriding the contact model's default behavior, and
paying the corresponding copying cost.

The resultant force and contact details, if they are included, are all
defined such that they act on the first element in the pair (e1).
Newton's third law requires that an equal and opposite force be
applied, at exactly the same point in space, to e2.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::ContactInfo::ContactInfo<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/contact_info.h:50
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_info.h:50
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/contact_info.h:57
          const char* doc_3 =
R"""(Initialize the contact response for two colliding collision elements.

Parameter ``element1``:
    The identifier for the first collision element.

Parameter ``element2``:
    The identifier for the second collision element.)""";

        } ctor;

        // drake::systems::ContactInfo::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/rigid_body_plant/contact_info.h:50
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::ContactInfo::get_contact_details
        struct /* get_contact_details */ {

          // drake/multibody/rigid_body_plant/contact_info.h:76
          const char* doc = R"""()""";

        } get_contact_details;

        // drake::systems::ContactInfo::get_element_id_1
        struct /* get_element_id_1 */ {

          // drake/multibody/rigid_body_plant/contact_info.h:60
          const char* doc = R"""()""";

        } get_element_id_1;

        // drake::systems::ContactInfo::get_element_id_2
        struct /* get_element_id_2 */ {

          // drake/multibody/rigid_body_plant/contact_info.h:63
          const char* doc = R"""()""";

        } get_element_id_2;

        // drake::systems::ContactInfo::get_resultant_force
        struct /* get_resultant_force */ {

          // drake/multibody/rigid_body_plant/contact_info.h:71
          const char* doc = R"""()""";

        } get_resultant_force;

        // drake::systems::ContactInfo::set_contact_details
        struct /* set_contact_details */ {

          // drake/multibody/rigid_body_plant/contact_info.h:80
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_info.h:85
          const char* doc_2 = R"""()""";

        } set_contact_details;

        // drake::systems::ContactInfo::set_resultant_force
        struct /* set_resultant_force */ {

          // drake/multibody/rigid_body_plant/contact_info.h:67
          const char* doc = R"""()""";

        } set_resultant_force;

      } ContactInfo;

      // drake::systems::ContactResultantForceCalculator
      struct /* ContactResultantForceCalculator */ {

        // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:141
        const char* doc =
R"""(This is a utility class for replacing a set of force/torques by an
equivalent force/torque (defined by the ContactForce class).

See also:
    ContactForce

The equivalent ContactForce consists of the set's resultant force
applied at a point `P`, together with a torque equal to the moment of
the set about `P` summed with any torques defined in the set members.
Point `P` is chosen to minimize the magnitude of the moment of the
*normal* forces (i.e., `P` lies along the "central axis" of the normal
forces). Note: only the *normal* components of the input contact
forces affect the location of point `P`. Tangential components of the
input contact forces affect the set's resultant, but not the
calculation of point `P`.

Center of Pressure (more precisely center of normal forces for planar
contact) =============================================================
================= For point `P` to be a center of pressure (as
returned by this class): - The normal components of all forces must
lie in the same direction, `n`. - The points, where each force is
applied, must lie on one plane, `F`. - Plane `F` must be perpendicular
to `n`. If these conditions are met, `P` will be the center of
pressure and lie on plane `F`, and the minimum moment due to the
normal forces will be zero. Note: this class does not rely on a center
of pressure *existing*.

Usage ===== The class is designed to be exercised by a contact
response model. As each pair of collision elements is evaluated, the
contact model should instantiate a ContactResultantForceCalculator. As
each contact point between the elements is processed and a contact
force is computed, the details of the contact force are provided to
the calculator (via calls to AddForce). Currently, the contact force
is defined by four values (see ContactForce): - position of the
force's point of application from a common origin O, - normal
component of the contact force (i.e., in the *normal* direction), -
tangential component of the contact force (e.g., friction force), and
- Optional torque term (e.g., torsional friction). All input vectors
must be expressed in a common frame and the position vector must be
measured from that frame's origin.

After all of the forces have been added to the calculator, an
equivalent ContactForce (force/torque) can be requested using the
appropriate method.

The *order* in which the forces are added has no impact on the final
result.

By default, the contact forces that are added to the calculator are
destroyed when the calculator is destroyed. There is an alternative
constructor which allows the caller to provide an STL vector which
will accumulate the contact information and allow the caller to
persist the data beyond the life span of the calculator.

A Single Force ============== If the set consists of a single contact
force, the minimum moment point and resultant force will be the
details of that force: i.e., its application point, response force,
and pure torque.

A Non-zero Minimum Moment ========================= For an arbitrary
set of forces, there may not be a well-defined center of pressure as
with the planar case outlined above. Generally, there is an infinite
set of minimum moment points for a set of contact forces; it is a line
called the "central axis". Any point on this line will lead to the
same minimum moment. The ContactResultantForceCalculator selects one
of those points.

We assume that the "ideal" point would be where the line intersects
the (deformed) contact surface. Generally, this can't be solved
because it depends on a geometric query that is outside the scope of
this calculator class. Furthermore, in many cases, it is unnecessary.
A point on the surface is good for visualization, but in contexts
where only a mathematically meaningful point is all that is needed,
then one point is as good as another. That said, the calculator
employs a method to cheaply approximate the intersection of the line
with the contact surface by doing the following.

The central axis can be thought of as a line defined by a point and
direction. The point can be any point on the line. The direction is
defined by the direction of the resultant normal force (i.e., the
vector sum of the normal components of all forces.) The direction
vector defines "positive" and "negative" directions on the line. The
force originated from the negative direction and accelerates the body
in the positive direction. If we had access to the geometry, the point
we would be interested in, would be the intersection of the line and
(deformed) geometry that is farthest in the "negative" direction
(i.e., closest to the originating source of the contact).

We will approximate this by finding the contact force application
point that similarly lies farthest in the negative direction (simply
by projecting the application points on the line.) This most-negative
projection point will serve as the reported minimum moment point.

This reported minimum moment point can be moved along the central axis
by the caller if additional information is available. Movement along
the axis preserves its "minimal-moment" property. For example, if the
caller had access to the (deformed) geometry, the ray defined by the
reported minimum moment point and the resultant ContactForce normal
direction can be intersected with the geometry to create an alternate,
but equally valid, minimum moment point.

A Zero-Resultant Force ====================== It is possible for all
of the contact forces to sum up to a zero resultant. But there may
still be a resultant moment, i.e., the forces are "coupled". In this
case, the minimum moment point can be literally any point in space. In
this case, the ContactResultantForceCalculator defines the minimum
moment point to be the centroid of all application points (the
"average" application point.) Similarly, the normal direction of this
resultant force is likewise meaningless but will be set to the +x
direction (i.e., <1, 0, 0>).

Computation considerations ========================== Even though the
resultant is reported as a ContactForce instance, it should not be
construed to mean that the results of the calculator can be
meaningfully composed. For example, given a set of contact forces: `S
= {f_0, ..., f_n-1}`, the result of computing the resultant for the
set `S` (i.e., `F = ComputeResultant(S)` will not necessarily provide
the same answer as would be produced by creating two disjoint subsets,
`S_a` and `S_b` and then performing:

```
F_a = ComputeResultant(S_a);
F_b = ComputeResultant(S_b);
F_ab = ComputeResultant({F_a, F_b});
```

Do not expect `F` to be equal to `F_ab`.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::ContactResultantForceCalculator::AddForce
        struct /* AddForce */ {

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:173
          const char* doc =
R"""(Adds a new contact force to the calculator.

If the calculator was initialized with a detail accumulator, an
instance of PointContactDetail, with this contact force, will be
appended to that accumulator.

Parameter ``force``:
    The contact force.)""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:185
          const char* doc_2 =
R"""(Adds a new force to the calculator from a contact detail. The result
of ContactDetail::ComputeContactForce will be used in the calculation.

If the calculator was initialized with a detail accumulator, the
detail will be appended to that accumulator. Otherwise, the detail
will be destroyed at the conclusion of this method invocation.

Parameter ``contact_detail``:
    The contact detail which will provide a ContactForce for
    computation.)""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:198
          const char* doc_3 =
R"""(Adds a new force to the calculator.

If the calculator was initialized with a detail accumulator, an
instance of PointContactDetail, with this contact information, will be
appended to that accumulator.

Parameter ``application_point``:
    The application point of the force.

Parameter ``normal``:
    The translational force's unit-length normal direction.

Parameter ``force``:
    The translational force.)""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:213
          const char* doc_4 =
R"""(Adds a new force with an arbitrary pure torque to the calculator.

If the calculator was initialized with a detail accumulator, an
instance of PointContactDetail, with this contact information, will be
appended to that accumulator.

Parameter ``application_point``:
    The application point of the force.

Parameter ``normal``:
    The translational force's unit-length normal direction.

Parameter ``force``:
    The translational force.

Parameter ``pure_torque``:
    The pure torque for the wrench.)""";

        } AddForce;

        // drake::systems::ContactResultantForceCalculator::ComputeResultant
        struct /* ComputeResultant */ {

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:233
          const char* doc =
R"""(Compute the resultant contact force -- it's translational force, pure
torque, and application point.

The rotational component of this ContactForce is pure torque only. It
does not include an `r X f` moment term. It will be non-zero due to
contributions from sources such as:

- the minimum moment (which may be non-zero in the general case), -
the moments induced by the tangential components of the forces shifted
to the minimum moment point, and - the sum of the pure torques of the
individual input contact forces.

The responsibility of computing the moment belongs to the code that
knows what frame the input contact forces are defined and what the
origin around which the moment would be induced.)""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:246
          const char* doc_2 =
R"""(Computes the resultant contact spatial force with respect to a given
reference point.

The force part is the summation of all f_i, where f_i is the
individual force. The torque part is the summation of all tau_i + (p_i
- r) X f_i, where tau_i is the ith pure torque, f_i is applied at p_i,
and r is the given reference point.

Parameter ``reference_point``:
    is in the same frame as all the individual forces.)""";

        } ComputeResultant;

        // drake::systems::ContactResultantForceCalculator::ContactResultantForceCalculator<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:143
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:143
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:149
          const char* doc_3 =
R"""(Default constructor -- no accumulation. As contact forces are added to
the calculator, the force will be added to the set of forces for
calculation, but they will be destroyed when the calculator is
destroyed.)""";

          // drake/multibody/rigid_body_plant/contact_resultant_force_calculator.h:161
          const char* doc_4 =
R"""(Accumulator constructor.

This allows the caller to provide a vector into which the contact
forces/details can be persisted beyond the life span of the
ContactResultantForceCalculator instance. See the various AddForce
methods for details on what is placed in the ``detail_accumulator``.

Parameter ``detail_accumulator``:
    If non-null, ContactDetail instances will be appended to the
    vector as they are assigned to the calculator.)""";

        } ctor;

      } ContactResultantForceCalculator;

      // drake::systems::ContactResults
      struct /* ContactResults */ {

        // drake/multibody/rigid_body_plant/contact_results.h:29
        const char* doc =
R"""(A class containing the contact results (contact points and response
spatial forces for each colliding pair of collision elements) as well
as the sum of all JᵀF for all contact, where J is the contact point
Jacobian, and F is the contact force.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::ContactResults::AddContact
        struct /* AddContact */ {

          // drake/multibody/rigid_body_plant/contact_results.h:50
          const char* doc = R"""()""";

        } AddContact;

        // drake::systems::ContactResults::Clear
        struct /* Clear */ {

          // drake/multibody/rigid_body_plant/contact_results.h:46
          const char* doc = R"""()""";

        } Clear;

        // drake::systems::ContactResults::ContactResults<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/contact_results.h:31
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/contact_results.h:31
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/contact_results.h:33
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::ContactResults::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/rigid_body_plant/contact_results.h:31
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::ContactResults::get_contact_info
        struct /* get_contact_info */ {

          // drake/multibody/rigid_body_plant/contact_results.h:42
          const char* doc =
R"""(Retrieves the ith ContactInfo instance. No bounds checking will be
done in a release build (but will be done in debug). It is assumed the
caller will only use values in the range [0, get_num_contacts() -1],
inclusive.)""";

        } get_contact_info;

        // drake::systems::ContactResults::get_generalized_contact_force
        struct /* get_generalized_contact_force */ {

          // drake/multibody/rigid_body_plant/contact_results.h:65
          const char* doc =
R"""(Returns the stored generalized force that represents the contact
forces.)""";

        } get_generalized_contact_force;

        // drake::systems::ContactResults::get_num_contacts
        struct /* get_num_contacts */ {

          // drake/multibody/rigid_body_plant/contact_results.h:36
          const char* doc =
R"""(Returns the number of unique collision element pairs in contact. */)""";

        } get_num_contacts;

        // drake::systems::ContactResults::set_generalized_contact_force
        struct /* set_generalized_contact_force */ {

          // drake/multibody/rigid_body_plant/contact_results.h:58
          const char* doc =
R"""(Stores the contact forces as a force in the generalized coordinate.

Parameter ``f``:
    = J^T * contact_force, where J is the stacked contact Jacobian,
    and contact_force is the stacked contact forces.)""";

        } set_generalized_contact_force;

      } ContactResults;

      // drake::systems::Context
      struct /* Context */ {

        // drake/systems/framework/context.h:40
        const char* doc =
R"""(Context is an abstract class template that represents all the typed
values that are used in a System's computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.)""";

        // drake/systems/framework/system_constraint.h:18
        const char* doc_2 =
R"""(Context is an abstract class template that represents all the typed
values that are used in a System's computations: time, numeric-valued
input ports, numerical state, and numerical parameters. There are also
type-erased abstract state variables, abstract-valued input ports,
abstract parameters, and a double accuracy setting. The framework
provides two concrete subclasses of Context: LeafContext (for leaf
Systems) and DiagramContext (for composite System Diagrams). Users are
forbidden to extend DiagramContext and are discouraged from
subclassing LeafContext.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.)""";

        // drake::systems::Context::Clone
        struct /* Clone */ {

          // drake/systems/framework/context.h:586
          const char* doc = R"""(Returns a deep copy of this Context.)""";

        } Clone;

        // drake::systems::Context::CloneState
        struct /* CloneState */ {

          // drake/systems/framework/context.h:591
          const char* doc =
R"""(Returns a deep copy of this Context's State.)""";

        } CloneState;

        // drake::systems::Context::CloneWithoutPointers
        struct /* CloneWithoutPointers */ {

          // drake/systems/framework/context.h:650
          const char* doc =
R"""((Internal use only) Clones a context but without any of its internal
pointers.)""";

        } CloneWithoutPointers;

        // drake::systems::Context::Context<T>
        struct /* ctor */ {

          // drake/systems/framework/context.h:45
          const char* doc = R"""()""";

          // drake/systems/framework/context.h:597
          const char* doc_2 = R"""()""";

          // drake/systems/framework/context.h:604
          const char* doc_3 =
R"""(Copy constructor takes care of base class and `Context<T>` data
members. Derived classes must implement copy constructors that
delegate to this one for use in their DoCloneWithoutPointers()
implementations.)""";

        } ctor;

        // drake::systems::Context::DoCloneState
        struct /* DoCloneState */ {

          // drake/systems/framework/context.h:666
          const char* doc =
R"""(Returns the appropriate concrete State object to be returned by
CloneState().)""";

        } DoCloneState;

        // drake::systems::Context::DoPropagateAccuracyChange
        struct /* DoPropagateAccuracyChange */ {

          // drake/systems/framework/context.h:678
          const char* doc =
R"""(Invokes PropagateAccuracyChange() on all subcontexts of this Context.
The default implementation does nothing, which is suitable for leaf
contexts. Diagram contexts must override.)""";

        } DoPropagateAccuracyChange;

        // drake::systems::Context::DoPropagateTimeChange
        struct /* DoPropagateTimeChange */ {

          // drake/systems/framework/context.h:671
          const char* doc =
R"""(Invokes PropagateTimeChange() on all subcontexts of this Context. The
default implementation does nothing, which is suitable for leaf
contexts. Diagram contexts must override.)""";

        } DoPropagateTimeChange;

        // drake::systems::Context::FixInputPort
        struct /* FixInputPort */ {

          // drake/systems/framework/context.h:511
          const char* doc =
R"""(Connects the input port at ``index`` to a FixedInputPortValue with the
given vector ``vec``. Aborts if ``index`` is out of range. Returns a
reference to the allocated FixedInputPortValue. The reference will
remain valid until this input port's value source is replaced or the
Context is destroyed. You may use that reference to modify the input
port's value using the appropriate FixedInputPortValue method, which
will ensure that invalidation notifications are delivered.)""";

          // drake/systems/framework/context.h:518
          const char* doc_2 =
R"""(Same as above method but starts with an Eigen vector whose contents
are used to initialize a BasicVector in the FixedInputPortValue.)""";

          // drake/systems/framework/context.h:531
          const char* doc_3 =
R"""(Same as the above method that takes a `const BasicVector<T>&`, but
here the vector is passed by unique_ptr instead of by const reference.
The caller must not retain any aliases to `vec`; within this method,
`vec` is cloned and then deleted.

Note:
    This overload will become deprecated in the future, because it can
    mislead users to believe that they can retain an alias of `vec` to
    mutate the fixed value during a simulation. Callers should prefer
    to use one of the other overloads instead.)""";

        } FixInputPort;

        // drake::systems::Context::PropagateAccuracyChange
        struct /* PropagateAccuracyChange */ {

          // drake/systems/framework/context.h:621
          const char* doc =
R"""((Internal use only) Sets a new accuracy and notifies accuracy-
dependent quantities that they are now invalid, as part of a given
change event.)""";

        } PropagateAccuracyChange;

        // drake::systems::Context::PropagateTimeChange
        struct /* PropagateTimeChange */ {

          // drake/systems/framework/context.h:611
          const char* doc =
R"""((Internal use only) Sets a new time and notifies time-dependent
quantities that they are now invalid, as part of a given change event.)""";

        } PropagateTimeChange;

        // drake::systems::Context::SetContinuousState
        struct /* SetContinuousState */ {

          // drake/systems/framework/context.h:359
          const char* doc =
R"""(Sets the continuous state to ``xc``, including q, v, and z partitions.
The supplied vector must be the same size as the existing continuous
state. Sends out of date notifications for all continuous-state-
dependent computations.)""";

        } SetContinuousState;

        // drake::systems::Context::SetTimeAndContinuousState
        struct /* SetTimeAndContinuousState */ {

          // drake/systems/framework/context.h:369
          const char* doc =
R"""(Sets time to ``time_sec`` and continuous state to ``xc``. Performs a
single notification sweep to avoid duplicate notifications for
computations that depend on both time and state.

Throws:
    s std::logic_error if this is not the root context.)""";

        } SetTimeAndContinuousState;

        // drake::systems::Context::SetTimeStateAndParametersFrom
        struct /* SetTimeStateAndParametersFrom */ {

          // drake/systems/framework/context.h:480
          const char* doc =
R"""(Sets this context's time, accuracy, state, and parameters from the
`double` values in ``source``, regardless of this context's scalar
type. Sends out of date notifications for all dependent computations
in this context.

Throws:
    s std::logic_error if this is not the root context.

Note:
    Currently does not copy fixed input port values from `source`. See
    System::FixInputPortsFrom() if you want to copy those.)""";

        } SetTimeStateAndParametersFrom;

        // drake::systems::Context::access_mutable_parameters
        struct /* access_mutable_parameters */ {

          // drake/systems/framework/context.h:633
          const char* doc =
R"""((Internal use only) Returns a reference to mutable parameters
_without_ invalidation notifications. Use get_mutable_parameters()
instead for normal access.)""";

        } access_mutable_parameters;

        // drake::systems::Context::access_mutable_state
        struct /* access_mutable_state */ {

          // drake/systems/framework/context.h:641
          const char* doc =
R"""((Internal use only) Returns a reference to a mutable state _without_
invalidation notifications. Use get_mutable_state() instead for normal
access.)""";

        } access_mutable_state;

        // drake::systems::Context::do_access_mutable_state
        struct /* do_access_mutable_state */ {

          // drake/systems/framework/context.h:662
          const char* doc =
R"""(Returns a mutable reference to its concrete State object _without_ any
invalidation. We promise not to allow user access to this object
without invalidation.)""";

        } do_access_mutable_state;

        // drake::systems::Context::do_access_state
        struct /* do_access_state */ {

          // drake/systems/framework/context.h:657
          const char* doc =
R"""(Returns a const reference to its concrete State object.)""";

        } do_access_state;

        // drake::systems::Context::get_abstract_parameter
        struct /* get_abstract_parameter */ {

          // drake/systems/framework/context.h:196
          const char* doc =
R"""(Returns a const reference to the abstract-valued parameter at
``index``. @pre ``index`` must identify an existing parameter.)""";

        } get_abstract_parameter;

        // drake::systems::Context::get_abstract_state
        struct /* get_abstract_state */ {

          // drake/systems/framework/context.h:156
          const char* doc =
R"""(Returns a const reference to the abstract component of the state,
which may be of size zero.)""";

          // drake/systems/framework/context.h:165
          const char* doc_2 =
R"""(Returns a const reference to the abstract component of the state at
``index``. @pre ``index`` must identify an existing element. @pre the
abstract state's type must match the template argument.)""";

        } get_abstract_state;

        // drake::systems::Context::get_accuracy
        struct /* get_accuracy */ {

          // drake/systems/framework/context.h:173
          const char* doc =
R"""(Returns the accuracy setting (if any). Note that the return type is
`optional<double>` rather than the double value itself.

See also:
    set_accuracy() for details.)""";

        } get_accuracy;

        // drake::systems::Context::get_continuous_state
        struct /* get_continuous_state */ {

          // drake/systems/framework/context.h:113
          const char* doc =
R"""(Returns a const reference to the continuous component of the state,
which may be of size zero.)""";

        } get_continuous_state;

        // drake::systems::Context::get_continuous_state_vector
        struct /* get_continuous_state_vector */ {

          // drake/systems/framework/context.h:119
          const char* doc =
R"""(Returns a reference to the continuous state vector, devoid of second-
order structure. The vector may be of size zero.)""";

        } get_continuous_state_vector;

        // drake::systems::Context::get_discrete_state
        struct /* get_discrete_state */ {

          // drake/systems/framework/context.h:130
          const char* doc =
R"""(Returns a reference to the entire discrete state, which may consist of
multiple discrete state vectors (groups).)""";

          // drake/systems/framework/context.h:144
          const char* doc_2 =
R"""(Returns a const reference to group (vector) ``index`` of the discrete
state. @pre ``index`` must identify an existing group.)""";

        } get_discrete_state;

        // drake::systems::Context::get_discrete_state_vector
        struct /* get_discrete_state_vector */ {

          // drake/systems/framework/context.h:137
          const char* doc =
R"""(Returns a reference to the _only_ discrete state vector. The vector
may be of size zero. @pre There is only one discrete state group.)""";

        } get_discrete_state_vector;

        // drake::systems::Context::get_mutable_abstract_parameter
        struct /* get_mutable_abstract_parameter */ {

          // drake/systems/framework/context.h:462
          const char* doc =
R"""(Returns a mutable reference to element ``index`` of the abstract-
valued parameters. Sends out of date notifications for all
computations dependent on this parameter. @pre ``index`` must identify
an existing abstract parameter.

Note:
    Currently notifies dependents of _all_ abstract parameters.)""";

        } get_mutable_abstract_parameter;

        // drake::systems::Context::get_mutable_abstract_state
        struct /* get_mutable_abstract_state */ {

          // drake/systems/framework/context.h:412
          const char* doc =
R"""(Returns a mutable reference to the abstract component of the state,
which may be of size zero. Sends out of date notifications for all
abstract-state-dependent computations.)""";

          // drake/systems/framework/context.h:427
          const char* doc_2 =
R"""(Returns a mutable reference to element ``index`` of the abstract
state. Sends out of date notifications for all computations that
depend on this abstract state variable. @pre ``index`` must identify
an existing element. @pre the abstract state's type must match the
template argument.

Note:
    Currently notifies dependents of _any_ abstract state variable.)""";

        } get_mutable_abstract_state;

        // drake::systems::Context::get_mutable_continuous_state
        struct /* get_mutable_continuous_state */ {

          // drake/systems/framework/context.h:338
          const char* doc =
R"""(Returns a mutable reference to the continuous component of the state,
which may be of size zero. Sends out of date notifications for all
continuous-state-dependent computations.)""";

        } get_mutable_continuous_state;

        // drake::systems::Context::get_mutable_continuous_state_vector
        struct /* get_mutable_continuous_state_vector */ {

          // drake/systems/framework/context.h:348
          const char* doc =
R"""(Returns a mutable reference to the continuous state vector, devoid of
second-order structure. The vector may be of size zero. Sends out of
date notifications for all continuous-state-dependent computations.)""";

        } get_mutable_continuous_state_vector;

        // drake::systems::Context::get_mutable_discrete_state
        struct /* get_mutable_discrete_state */ {

          // drake/systems/framework/context.h:382
          const char* doc =
R"""(Returns a mutable reference to the discrete component of the state,
which may be of size zero. Sends out of date notifications for all
discrete-state-dependent computations.)""";

          // drake/systems/framework/context.h:404
          const char* doc_2 =
R"""(Returns a mutable reference to group (vector) ``index`` of the
discrete state. Sends out of date notifications for all computations
that depend on this discrete state group. @pre ``index`` must identify
an existing group.

Note:
    Currently notifies dependents of _all_ groups.)""";

        } get_mutable_discrete_state;

        // drake::systems::Context::get_mutable_discrete_state_vector
        struct /* get_mutable_discrete_state_vector */ {

          // drake/systems/framework/context.h:394
          const char* doc =
R"""(Returns a mutable reference to the _only_ discrete state vector. Sends
out of date notifications for all discrete-state-dependent
computations.

See also:
    get_discrete_state_vector(). @pre There is only one discrete state
    group.)""";

        } get_mutable_discrete_state_vector;

        // drake::systems::Context::get_mutable_numeric_parameter
        struct /* get_mutable_numeric_parameter */ {

          // drake/systems/framework/context.h:449
          const char* doc =
R"""(Returns a mutable reference to element ``index`` of the vector-valued
(numeric) parameters. Sends out of date notifications for all
computations dependent on this parameter. @pre ``index`` must identify
an existing numeric parameter.

Note:
    Currently notifies dependents of _all_ numeric parameters.)""";

        } get_mutable_numeric_parameter;

        // drake::systems::Context::get_mutable_parameters
        struct /* get_mutable_parameters */ {

          // drake/systems/framework/context.h:437
          const char* doc =
R"""(Returns a mutable reference to this Context's parameters. Sends out of
date notifications for all parameter-dependent computations. If you
don't mean to change all the parameters, use the indexed methods to
modify only some of the parameters so that fewer computations are
invalidated and fewer notifications need be sent.)""";

        } get_mutable_parameters;

        // drake::systems::Context::get_mutable_state
        struct /* get_mutable_state */ {

          // drake/systems/framework/context.h:329
          const char* doc =
R"""(Returns a mutable reference to the whole State, potentially
invalidating _all_ state-dependent computations so requiring out of
date notifications to be made for all such computations. If you don't
mean to change the whole state, use more focused methods to modify
only a portion of the state. See class documentation for more
information.)""";

        } get_mutable_state;

        // drake::systems::Context::get_num_abstract_states
        struct /* get_num_abstract_states */ {

          // drake/systems/framework/context.h:150
          const char* doc =
R"""(Returns the number of elements in the abstract state.)""";

        } get_num_abstract_states;

        // drake::systems::Context::get_num_discrete_state_groups
        struct /* get_num_discrete_state_groups */ {

          // drake/systems/framework/context.h:124
          const char* doc =
R"""(Returns the number of vectors (groups) in the discrete state.)""";

        } get_num_discrete_state_groups;

        // drake::systems::Context::get_num_total_states
        struct /* get_num_total_states */ {

          // drake/systems/framework/context.h:103
          const char* doc =
R"""(Returns the total dimension of all of the basic vector states (as if
they were muxed).

Throws:
    s std::runtime_error if the system contains any abstract state.)""";

        } get_num_total_states;

        // drake::systems::Context::get_numeric_parameter
        struct /* get_numeric_parameter */ {

          // drake/systems/framework/context.h:185
          const char* doc =
R"""(Returns a const reference to the vector-valued parameter at ``index``.
@pre ``index`` must identify an existing parameter.)""";

        } get_numeric_parameter;

        // drake::systems::Context::get_parameters
        struct /* get_parameters */ {

          // drake/systems/framework/context.h:176
          const char* doc =
R"""(Returns a const reference to this Context's parameters.)""";

        } get_parameters;

        // drake::systems::Context::get_state
        struct /* get_state */ {

          // drake/systems/framework/context.h:70
          const char* doc =
R"""(Returns a const reference to the whole State.)""";

        } get_state;

        // drake::systems::Context::get_step_info
        struct /* get_step_info */ {

          // drake/systems/framework/context.h:684
          const char* doc =
R"""(Returns a const reference to current time and step information.)""";

        } get_step_info;

        // drake::systems::Context::get_time
        struct /* get_time */ {

          // drake/systems/framework/context.h:67
          const char* doc = R"""(Returns the current time in seconds.)""";

        } get_time;

        // drake::systems::Context::has_only_continuous_state
        struct /* has_only_continuous_state */ {

          // drake/systems/framework/context.h:84
          const char* doc =
R"""(Returns true if the Context has continuous state, but no discrete or
abstract state.)""";

        } has_only_continuous_state;

        // drake::systems::Context::has_only_discrete_state
        struct /* has_only_discrete_state */ {

          // drake/systems/framework/context.h:93
          const char* doc =
R"""(Returns true if the Context has discrete state, but no continuous or
abstract state.)""";

        } has_only_discrete_state;

        // drake::systems::Context::init_abstract_state
        struct /* init_abstract_state */ {

          // drake/systems/framework/context.h:703
          const char* doc =
R"""((Internal use only) Sets the abstract state to ``xa``, deleting
whatever was there before. @warning Does _not_ invalidate state-
dependent computations.)""";

        } init_abstract_state;

        // drake::systems::Context::init_continuous_state
        struct /* init_continuous_state */ {

          // drake/systems/framework/context.h:689
          const char* doc =
R"""((Internal use only) Sets the continuous state to ``xc``, deleting
whatever was there before. @warning Does _not_ invalidate state-
dependent computations.)""";

        } init_continuous_state;

        // drake::systems::Context::init_discrete_state
        struct /* init_discrete_state */ {

          // drake/systems/framework/context.h:696
          const char* doc =
R"""((Internal use only) Sets the discrete state to ``xd``, deleting
whatever was there before. @warning Does _not_ invalidate state-
dependent computations.)""";

        } init_discrete_state;

        // drake::systems::Context::init_parameters
        struct /* init_parameters */ {

          // drake/systems/framework/context.h:711
          const char* doc =
R"""((Internal use only) Sets the parameters to ``params``, deleting
whatever was there before. You must supply a Parameters object; null
is not acceptable. @warning Does _not_ invalidate parameter-dependent
computations.)""";

        } init_parameters;

        // drake::systems::Context::is_stateless
        struct /* is_stateless */ {

          // drake/systems/framework/context.h:75
          const char* doc =
R"""(Returns true if the Context has no state.)""";

        } is_stateless;

        // drake::systems::Context::num_abstract_parameters
        struct /* num_abstract_parameters */ {

          // drake/systems/framework/context.h:190
          const char* doc =
R"""(Returns the number of abstract-valued parameters.)""";

        } num_abstract_parameters;

        // drake::systems::Context::num_numeric_parameters
        struct /* num_numeric_parameters */ {

          // drake/systems/framework/context.h:179
          const char* doc =
R"""(Returns the number of vector-valued parameters.)""";

        } num_numeric_parameters;

        // drake::systems::Context::set_accuracy
        struct /* set_accuracy */ {

          // drake/systems/framework/context.h:573
          const char* doc =
R"""(Records the user's requested accuracy. If no accuracy is requested,
computations are free to choose suitable defaults, or to refuse to
proceed without an explicit accuracy setting. Any accuracy-dependent
computation in this Context and its subcontexts may be invalidated by
a change to the accuracy setting, so out of date notifications are
sent to all such computations (at least if the accuracy setting has
actually changed). Accuracy must have the same value in every
subcontext within the same context tree so may only be modified at the
root context of a tree.

Throws:
    s std::logic_error if this is not the root context.

Requested accuracy is stored in the Context for two reasons: - It
permits all computations performed over a System to see the _same_
accuracy request since accuracy is stored in one shared place, and -
it allows us to notify accuracy-dependent cached results that they are
out of date when the accuracy setting changes.

The accuracy of a complete simulation or other numerical study depends
on the accuracy of _all_ contributing computations, so it is important
that each computation is done in accordance with the overall requested
accuracy. Some examples of where this is needed: - Error-controlled
numerical integrators use the accuracy setting to decide what step
sizes to take. - The Simulator employs a numerical integrator, but
also uses accuracy to decide how precisely to isolate witness function
zero crossings. - Iterative calculations reported as results or cached
internally depend on accuracy to decide how strictly to converge the
results. Examples of these are: constraint projection, calculation of
distances between smooth shapes, and deformation calculations for soft
contact.

The common thread among these examples is that they all share the same
Context, so by keeping accuracy here it can be used effectively to
control all accuracy-dependent computations.)""";

        } set_accuracy;

        // drake::systems::Context::set_time
        struct /* set_time */ {

          // drake/systems/framework/context.h:318
          const char* doc =
R"""(Sets the current time in seconds. Sends out of date notifications for
all time-dependent computations (at least if the time has actually
changed). Time must have the same value in every subcontext within the
same Diagram context tree so may only be modified at the root context
of the tree.

Throws:
    s std::logic_error if this is not the root context.)""";

        } set_time;

      } Context;

      // drake::systems::ContextBase
      struct /* ContextBase */ {

        // drake/systems/framework/context_base.h:38
        const char* doc =
R"""(Provides non-templatized Context functionality shared by the
templatized derived classes. That includes caching, dependency
tracking, and management of local values for fixed input ports.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake/systems/framework/fixed_input_port_value.h:20
        const char* doc_2 =
R"""(Provides non-templatized Context functionality shared by the
templatized derived classes. That includes caching, dependency
tracking, and management of local values for fixed input ports.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake/systems/framework/framework_common.h:77
        const char* doc_3 =
R"""(Provides non-templatized Context functionality shared by the
templatized derived classes. That includes caching, dependency
tracking, and management of local values for fixed input ports.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake::systems::ContextBase::AddAbstractParameterTicket
        struct /* AddAbstractParameterTicket */ {

          // drake/systems/framework/context_base.h:275
          const char* doc =
R"""(Adds a ticket to the list of abstract parameter tickets. */)""";

        } AddAbstractParameterTicket;

        // drake::systems::ContextBase::AddAbstractStateTicket
        struct /* AddAbstractStateTicket */ {

          // drake/systems/framework/context_base.h:265
          const char* doc =
R"""(Adds a ticket to the list of abstract state tickets. */)""";

        } AddAbstractStateTicket;

        // drake::systems::ContextBase::AddDiscreteStateTicket
        struct /* AddDiscreteStateTicket */ {

          // drake/systems/framework/context_base.h:260
          const char* doc =
R"""(Adds a ticket to the list of discrete state tickets. */)""";

        } AddDiscreteStateTicket;

        // drake::systems::ContextBase::AddInputPort
        struct /* AddInputPort */ {

          // drake/systems/framework/context_base.h:251
          const char* doc =
R"""(Adds the next input port. Expected index is supplied along with the
assigned ticket. Subscribes the "all input ports" tracker to this one.)""";

        } AddInputPort;

        // drake::systems::ContextBase::AddNumericParameterTicket
        struct /* AddNumericParameterTicket */ {

          // drake/systems/framework/context_base.h:270
          const char* doc =
R"""(Adds a ticket to the list of numeric parameter tickets. */)""";

        } AddNumericParameterTicket;

        // drake::systems::ContextBase::AddOutputPort
        struct /* AddOutputPort */ {

          // drake/systems/framework/context_base.h:255
          const char* doc =
R"""(Adds the next output port. Expected index is supplied along with the
assigned ticket.)""";

        } AddOutputPort;

        // drake::systems::ContextBase::BuildTrackerPointerMap
        struct /* BuildTrackerPointerMap */ {

          // drake/systems/framework/context_base.h:416
          const char* doc =
R"""((Internal use only) Given a new context `clone` containing an
identically-structured dependency graph as the one in `source`,
creates a mapping of all tracker memory addresses from `source` to
`clone`. This must be done for the whole Context tree because pointers
can point outside of their containing subcontext.)""";

        } BuildTrackerPointerMap;

        // drake::systems::ContextBase::Clone
        struct /* Clone */ {

          // drake/systems/framework/context_base.h:50
          const char* doc =
R"""(Creates an identical copy of the concrete context object. */)""";

        } Clone;

        // drake::systems::ContextBase::CloneWithoutPointers
        struct /* CloneWithoutPointers */ {

          // drake/systems/framework/context_base.h:404
          const char* doc =
R"""((Internal use only) Clones a context but without copying any of its
internal pointers; the clone's pointers are set to null.)""";

        } CloneWithoutPointers;

        // drake::systems::ContextBase::ContextBase
        struct /* ctor */ {

          // drake/systems/framework/context_base.h:44
          const char* doc =
R"""(@name Does not allow copy, move, or assignment. */ @{ */)""";

          // drake/systems/framework/context_base.h:231
          const char* doc_2 =
R"""(Default constructor creates an empty ContextBase but initializes all
the built-in dependency trackers that are the same in every System
(like time, q, all states, all inputs, etc.). We can't allocate
trackers for individual discrete & abstract states, parameters, or
input ports since we don't yet know how many there are.)""";

          // drake/systems/framework/context_base.h:240
          const char* doc_3 =
R"""(Copy constructor takes care of base class data members, but _does not_
fix up base class pointers. Derived classes must implement copy
constructors that delegate to this one for use in their
DoCloneWithoutPointers() implementations. The cache and dependency
graph are copied, but any pointers contained in the source are left
null in the copy.)""";

        } ctor;

        // drake::systems::ContextBase::DisableCaching
        struct /* DisableCaching */ {

          // drake/systems/framework/context_base.h:63
          const char* doc =
R"""((Debugging) Disables caching recursively for this context and all its
subcontexts. Disabling forces every `Eval()` method to perform a full
calculation rather than returning the cached one. Results should be
identical with or without caching, except for performance. If they are
not, there is likely a problem with (a) the specified dependencies for
some calculation, or (b) a misuse of references into cached values
that hides modifications from the caching system, or (c) a bug in the
caching system. The `is_disabled` flags are independent of the
`out_of_date` flags, which continue to be maintained even when caching
is disabled (though they are ignored).)""";

        } DisableCaching;

        // drake::systems::ContextBase::DoCloneWithoutPointers
        struct /* DoCloneWithoutPointers */ {

          // drake/systems/framework/context_base.h:483
          const char* doc =
R"""(Derived classes must implement this so that it performs the complete
deep copy of the context, including all base class members but not
fixing up base class pointers. To do that, implement a protected copy
constructor that inherits from the base class copy constructor (which
doesn't repair the pointers), then implement DoCloneWithoutPointers()
as `return unique_ptr<ContextBase>(new DerivedType(*this));`.)""";

        } DoCloneWithoutPointers;

        // drake::systems::ContextBase::DoPropagateBuildTrackerPointerMap
        struct /* DoPropagateBuildTrackerPointerMap */ {

          // drake/systems/framework/context_base.h:488
          const char* doc =
R"""(DiagramContext must implement this to invoke BuildTrackerPointerMap()
on each of its subcontexts. The default implementation does nothing
which is fine for a LeafContext.)""";

        } DoPropagateBuildTrackerPointerMap;

        // drake::systems::ContextBase::DoPropagateBulkChange
        struct /* DoPropagateBulkChange */ {

          // drake/systems/framework/context_base.h:515
          const char* doc =
R"""(DiagramContext must implement this to invoke PropagateBulkChange() on
its subcontexts, passing along the indicated method that specifies the
particular bulk change (e.g. whole state, all parameters, all discrete
state variables, etc.). The default implementation does nothing which
is fine for a LeafContext.)""";

        } DoPropagateBulkChange;

        // drake::systems::ContextBase::DoPropagateCachingChange
        struct /* DoPropagateCachingChange */ {

          // drake/systems/framework/context_base.h:506
          const char* doc =
R"""(DiagramContext must implement this to invoke a caching behavior change
on each of its subcontexts. The default implementation does nothing
which is fine for a LeafContext.)""";

        } DoPropagateCachingChange;

        // drake::systems::ContextBase::DoPropagateFixContextPointers
        struct /* DoPropagateFixContextPointers */ {

          // drake/systems/framework/context_base.h:497
          const char* doc =
R"""(DiagramContext must implement this to invoke FixContextPointers() on
each of its subcontexts. The default implementation does nothing which
is fine for a LeafContext.)""";

        } DoPropagateFixContextPointers;

        // drake::systems::ContextBase::EnableCaching
        struct /* EnableCaching */ {

          // drake/systems/framework/context_base.h:76
          const char* doc =
R"""((Debugging) Re-enables caching recursively for this context and all
its subcontexts. The `is_disabled` flags are independent of the
`out_of_date` flags, which continue to be maintained even when caching
is disabled (though they are ignored). Hence re-enabling the cache
with this method may result in some entries being already considered
up to date. See SetAllCacheEntriesOutOfDate() if you want to ensure
that caching restarts with everything out of date. You might want to
do that, for example, for repeatability or because you modified
something in the debugger and want to make sure it gets used.)""";

        } EnableCaching;

        // drake::systems::ContextBase::FixContextPointers
        struct /* FixContextPointers */ {

          // drake/systems/framework/context_base.h:425
          const char* doc =
R"""((Internal use only) Assuming `clone` is a recently-cloned Context that
has yet to have its internal pointers updated, sets those pointers
now. The given map is used to update tracker pointers.)""";

        } FixContextPointers;

        // drake::systems::ContextBase::FixInputPort
        struct /* FixInputPort */ {

          // drake/systems/framework/context_base.h:183
          const char* doc =
R"""(Connects the input port at `index` to a FixedInputPortValue with the
given abstract `value`. Returns a reference to the allocated
FixedInputPortValue that will remain valid until this input port's
value source is replaced or the Context is destroyed. You may use that
reference to modify the input port's value using the appropriate
FixedInputPortValue method, which will ensure that invalidation
notifications are delivered.

This is the most general way to provide a value (type-erased) for an
unconnected input port. See `Context<T>` for more-convenient overloads
of FixInputPort() for vector values with elements of type T.

@pre `index` selects an existing input port of this Context.)""";

          // drake/systems/framework/context_base.h:189
          const char* doc_2 =
R"""(Same as above method but the value is passed by const reference
instead of by unique_ptr. The port will contain a copy of the `value`
(not retain a pointer to the `value`).)""";

        } FixInputPort;

        // drake::systems::ContextBase::GetSystemName
        struct /* GetSystemName */ {

          // drake/systems/framework/context_base.h:96
          const char* doc =
R"""(Returns the local name of the subsystem for which this is the Context.
This is intended primarily for error messages and logging.

See also:
    SystemBase::GetSystemName() for details.

See also:
    GetSystemPathname() if you want the full name.)""";

        } GetSystemName;

        // drake::systems::ContextBase::GetSystemPathname
        struct /* GetSystemPathname */ {

          // drake/systems/framework/context_base.h:104
          const char* doc =
R"""(Returns the full pathname of the subsystem for which this is the
Context. This is intended primarily for error messages and logging.

See also:
    SystemBase::GetSystemPathname() for details.)""";

        } GetSystemPathname;

        // drake::systems::ContextBase::MaybeGetFixedInputPortValue
        struct /* MaybeGetFixedInputPortValue */ {

          // drake/systems/framework/context_base.h:196
          const char* doc =
R"""(For input port `index`, returns a const FixedInputPortValue if the
port is fixed, otherwise nullptr. @pre `index` selects an existing
input port of this Context.)""";

        } MaybeGetFixedInputPortValue;

        // drake::systems::ContextBase::MaybeGetMutableFixedInputPortValue
        struct /* MaybeGetMutableFixedInputPortValue */ {

          // drake/systems/framework/context_base.h:204
          const char* doc =
R"""(For input port `index`, returns a mutable FixedInputPortValue if the
port is fixed, otherwise nullptr. @pre `index` selects an existing
input port of this Context.)""";

        } MaybeGetMutableFixedInputPortValue;

        // drake::systems::ContextBase::NoteAccuracyChanged
        struct /* NoteAccuracyChanged */ {

          // drake/systems/framework/context_base.h:300
          const char* doc =
R"""(Notifies the local accuracy tracker that the accuracy setting may have
changed.)""";

        } NoteAccuracyChanged;

        // drake::systems::ContextBase::NoteAllAbstractParametersChanged
        struct /* NoteAllAbstractParametersChanged */ {

          // drake/systems/framework/context_base.h:379
          const char* doc =
R"""(Notifies each local abstract parameter tracker that the value of the
parameter it manages may have changed. If there are no abstract
parameters owned by this context, nothing happens. A DiagramContext
does not own any parameters.)""";

        } NoteAllAbstractParametersChanged;

        // drake::systems::ContextBase::NoteAllAbstractStateChanged
        struct /* NoteAllAbstractStateChanged */ {

          // drake/systems/framework/context_base.h:353
          const char* doc =
R"""(Notifies each local abstract state variable tracker that the value of
the abstract state variable it manages may have changed. If there are
no abstract state variables owned by this context, nothing happens. A
DiagramContext does not own any abstract state variables.)""";

        } NoteAllAbstractStateChanged;

        // drake::systems::ContextBase::NoteAllContinuousStateChanged
        struct /* NoteAllContinuousStateChanged */ {

          // drake/systems/framework/context_base.h:316
          const char* doc =
R"""(Notifies the local q, v, and z trackers that each of them may have
changed, likely because someone has asked to modify continuous state
xc.)""";

        } NoteAllContinuousStateChanged;

        // drake::systems::ContextBase::NoteAllDiscreteStateChanged
        struct /* NoteAllDiscreteStateChanged */ {

          // drake/systems/framework/context_base.h:344
          const char* doc =
R"""(Notifies each local discrete state group tracker that the value of the
discrete state group it manages may have changed. If there are no
discrete state groups owned by this context, nothing happens. A
DiagramContext does not own any discrete state groups.)""";

        } NoteAllDiscreteStateChanged;

        // drake::systems::ContextBase::NoteAllNumericParametersChanged
        struct /* NoteAllNumericParametersChanged */ {

          // drake/systems/framework/context_base.h:370
          const char* doc =
R"""(Notifies each local numeric parameter tracker that the value of the
parameter it manages may have changed. If there are no numeric
parameters owned by this context, nothing happens. A DiagramContext
does not own any parameters.)""";

        } NoteAllNumericParametersChanged;

        // drake::systems::ContextBase::NoteAllParametersChanged
        struct /* NoteAllParametersChanged */ {

          // drake/systems/framework/context_base.h:361
          const char* doc =
R"""(Notifies the local numeric and abstract parameter trackers that each
of them may have changed, likely because someone asked to modify all
the parameters.)""";

        } NoteAllParametersChanged;

        // drake::systems::ContextBase::NoteAllQChanged
        struct /* NoteAllQChanged */ {

          // drake/systems/framework/context_base.h:323
          const char* doc =
R"""(Notifies the local q tracker that the q's may have changed. */)""";

        } NoteAllQChanged;

        // drake::systems::ContextBase::NoteAllStateChanged
        struct /* NoteAllStateChanged */ {

          // drake/systems/framework/context_base.h:308
          const char* doc =
R"""(Notifies the local continuous, discrete, and abstract state trackers
that each of them may have changed, likely because someone has asked
to modify the whole state x.)""";

        } NoteAllStateChanged;

        // drake::systems::ContextBase::NoteAllVChanged
        struct /* NoteAllVChanged */ {

          // drake/systems/framework/context_base.h:329
          const char* doc =
R"""(Notifies the local v tracker that the v's may have changed. */)""";

        } NoteAllVChanged;

        // drake::systems::ContextBase::NoteAllZChanged
        struct /* NoteAllZChanged */ {

          // drake/systems/framework/context_base.h:335
          const char* doc =
R"""(Notifies the local z tracker that the z's may have changed. */)""";

        } NoteAllZChanged;

        // drake::systems::ContextBase::NoteTimeChanged
        struct /* NoteTimeChanged */ {

          // drake/systems/framework/context_base.h:293
          const char* doc =
R"""(Notifies the local time tracker that time may have changed. */)""";

        } NoteTimeChanged;

        // drake::systems::ContextBase::PropagateBulkChange
        struct /* PropagateBulkChange */ {

          // drake/systems/framework/context_base.h:447
          const char* doc =
R"""((Internal use only) Applies the given bulk-change notification method
to the given `context`, and propagates the notification to subcontexts
if this is a DiagramContext.)""";

          // drake/systems/framework/context_base.h:456
          const char* doc_2 =
R"""((Internal use only) This is a convenience method for invoking the
eponymous static method on `this` context (which occurs frequently).)""";

        } PropagateBulkChange;

        // drake::systems::ContextBase::PropagateCachingChange
        struct /* PropagateCachingChange */ {

          // drake/systems/framework/context_base.h:436
          const char* doc =
R"""((Internal use only) Applies the given caching-change notification
method to `context`, and propagates the notification to subcontexts if
`context` is a DiagramContext. Used, for example, to enable and
disable the cache. The supplied `context` is const so depends on the
cache being mutable.)""";

        } PropagateCachingChange;

        // drake::systems::ContextBase::SetAllCacheEntriesOutOfDate
        struct /* SetAllCacheEntriesOutOfDate */ {

          // drake/systems/framework/context_base.h:88
          const char* doc =
R"""((Debugging) Marks all cache entries out of date, recursively for this
context and all its subcontexts. This forces the next `Eval()` request
for each cache entry to perform a full calculation rather than
returning the cached one. After that first recalculation, normal
caching behavior resumes (assuming the cache is not disabled). Results
should be identical whether this is called or not, since the caching
system should be maintaining this flag correctly. If they are not, see
the documentation for SetIsCacheDisabled() for suggestions.)""";

        } SetAllCacheEntriesOutOfDate;

        // drake::systems::ContextBase::get_cache
        struct /* get_cache */ {

          // drake/systems/framework/context_base.h:107
          const char* doc =
R"""(Returns a const reference to this subcontext's cache. */)""";

        } get_cache;

        // drake::systems::ContextBase::get_dependency_graph
        struct /* get_dependency_graph */ {

          // drake/systems/framework/context_base.h:139
          const char* doc =
R"""(Returns a const reference to the collection of value trackers within
this subcontext. Together these form the dependency subgraph for the
values in this subcontext, plus edges leading to neighboring trackers.)""";

        } get_dependency_graph;

        // drake::systems::ContextBase::get_mutable_cache
        struct /* get_mutable_cache */ {

          // drake/systems/framework/context_base.h:119
          const char* doc =
R"""((Advanced) Returns a mutable reference to this subcontext's cache.
Note that this method is const because the cache is always writable.
@warning Writing directly to the cache does not automatically
propagate invalidations to downstream dependents of a contained cache
entry, because invalidations would normally have been propagated when
the cache entry itself went out of date. Cache entries are updated
automatically when needed via their `Calc()` methods; most users
should not bypass that mechanism by using this method.)""";

        } get_mutable_cache;

        // drake::systems::ContextBase::get_mutable_dependency_graph
        struct /* get_mutable_dependency_graph */ {

          // drake/systems/framework/context_base.h:144
          const char* doc =
R"""(Returns a mutable reference to the dependency graph. */)""";

        } get_mutable_dependency_graph;

        // drake::systems::ContextBase::get_mutable_tracker
        struct /* get_mutable_tracker */ {

          // drake/systems/framework/context_base.h:132
          const char* doc =
R"""(Returns a mutable reference to a DependencyTracker in this subcontext.
(You do not need mutable access just to issue value change
notifications.))""";

        } get_mutable_tracker;

        // drake::systems::ContextBase::get_num_input_ports
        struct /* get_num_input_ports */ {

          // drake/systems/framework/context_base.h:149
          const char* doc =
R"""(Returns the number of input ports in this context. */)""";

        } get_num_input_ports;

        // drake::systems::ContextBase::get_num_output_ports
        struct /* get_num_output_ports */ {

          // drake/systems/framework/context_base.h:155
          const char* doc =
R"""(Returns the number of output ports represented in this context. */)""";

        } get_num_output_ports;

        // drake::systems::ContextBase::get_tracker
        struct /* get_tracker */ {

          // drake/systems/framework/context_base.h:126
          const char* doc =
R"""(Returns a const reference to a DependencyTracker in this subcontext.
Advanced users and internal code can use the returned reference to
issue value change notifications -- mutable access is not required for
that purpose.)""";

        } get_tracker;

        // drake::systems::ContextBase::input_port_ticket
        struct /* input_port_ticket */ {

          // drake/systems/framework/context_base.h:160
          const char* doc =
R"""(Returns the dependency ticket associated with a particular input port.
*/)""";

        } input_port_ticket;

        // drake::systems::ContextBase::is_root_context
        struct /* is_root_context */ {

          // drake/systems/framework/context_base.h:386
          const char* doc =
R"""(Returns true if this context has no parent. */)""";

        } is_root_context;

        // drake::systems::ContextBase::output_port_ticket
        struct /* output_port_ticket */ {

          // drake/systems/framework/context_base.h:166
          const char* doc =
R"""(Returns the dependency ticket associated with a particular output
port. */)""";

        } output_port_ticket;

        // drake::systems::ContextBase::owns_any_variables_or_parameters
        struct /* owns_any_variables_or_parameters */ {

          // drake/systems/framework/context_base.h:393
          const char* doc =
R"""((Internal use only) Returns true if this context provides resources
for its own individual state variables or parameters. That means those
variables or parameters were declared by this context's corresponding
System. Currently only leaf systems may declare variables and
parameters; diagram contexts can use this method to check that
invariant.)""";

        } owns_any_variables_or_parameters;

        // drake::systems::ContextBase::set_parent
        struct /* set_parent */ {

          // drake/systems/framework/context_base.h:467
          const char* doc =
R"""(Declares that `parent` is the context of the enclosing Diagram. Aborts
if the parent has already been set or is null.)""";

        } set_parent;

        // drake::systems::ContextBase::start_new_change_event
        struct /* start_new_change_event */ {

          // drake/systems/framework/context_base.h:212
          const char* doc =
R"""((Internal use only) Returns the next change event serial number that
is unique for this entire Context tree, not just this subcontext. This
number is not reset after a Context is copied but continues to count
up.)""";

        } start_new_change_event;

      } ContextBase;

      // drake::systems::ContinuousState
      struct /* ContinuousState */ {

        // drake/systems/framework/continuous_state.h:76
        const char* doc =
R"""(ContinuousState is a view of, and optionally a container for, all the
continuous state variables `xc` of a Drake System. Continuous state
variables are those whose values are defined by differential
equations, so we expect there to be a well-defined time derivative
`xcdot` ≜ `d/dt xc`.

The contents of `xc` are conceptually partitioned into three groups: -
`q` is generalized position - `v` is generalized velocity - `z` is
other continuous state

For a Drake LeafSystem these partitions are stored contiguously in
memory in this sequence: xc=[q v z]. But because a Drake System may be
a Diagram composed from subsystems, each with its own continuous state
variables ("substates"), the composite continuous state will not
generally be stored in contiguous memory. In that case the most we can
say is that xc={q,v,z}, that is, it consists of all the q's, v's, and
z's, in some order.

Nevertheless, this ContinuousState class provides a vector view of the
data that groups together all the q partitions, v partitions, and z
partitions. For example, if there are three subsystems (possibly
Diagrams) whose continuous state variables are respectively
xc₁={q₁,v₁,z₁}, xc₂={q₂,v₂,z₂}, and xc₃={q₃,v₃,z₃} the composite xc
includes all the partitions in an undefined order. However, composite
q, v, and z appear ordered as q=[q₁ q₂ q₃], v=[v₁ v₂ v₃], z=[z₁ z₂
z₃]. Note that the element ordering of the composite xc is _not_ a
concatenation of the composite subgroups. Do not index elements of the
full state xc unless you know it is the continuous state of a
LeafSystem (a LeafSystem looking at its own Context can depend on
that).

Any of the groups may be empty. However, groups q and v must be either
both present or both empty, because the time derivative `qdot` of the
second-order state variables `q` must be computable using a linear
mapping `qdot=N(q)*v`.

The time derivative `xcdot` has the identical substructure to `xc`,
with the partitions interpreted as `qdot`, `vdot`, and `zdot`. We use
identical ContinuousState objects for both.

<h4>Memory ownership</h4> When a ContinuousState represents the state
of a LeafSystem, it always owns the memory that is used for the state
variables and is responsible for destruction. For a Diagram,
ContinuousState can instead be a _view_ of the underlying LeafSystem
substates, so that modifying the Diagram's continuous state affects
the LeafSystems appropriately. In that case, the memory is owned by
the underlying LeafSystems. However, when a ContinuousState object of
any structure is cloned, the resulting object _always_ owns all its
underlying memory, which is initialized with a copy of the original
state variable values but is otherwise independent. The cloned object
retains the structure and ordering of the elements and does not
guarantee contiguous storage.

See also:
    DiagramContinuousState for more information.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::ContinuousState::Clone
        struct /* Clone */ {

          // drake/systems/framework/continuous_state.h:138
          const char* doc =
R"""(Creates a deep copy of this object with the same substructure but with
all data owned by the copy. That is, if the original was a Diagram
continuous state that merely referenced substates, the clone will not
include any references to the original substates and is thus decoupled
from the Context containing the original. The concrete type of the
BasicVector underlying each leaf ContinuousState is preserved. See the
class comments above for more information.)""";

        } Clone;

        // drake::systems::ContinuousState::ContinuousState<T>
        struct /* ctor */ {

          // drake/systems/framework/continuous_state.h:80
          const char* doc = R"""()""";

          // drake/systems/framework/continuous_state.h:80
          const char* doc_2 = R"""()""";

          // drake/systems/framework/continuous_state.h:85
          const char* doc_3 =
R"""(Constructs a ContinuousState for a system that does not have second-
order structure. The `q` and `v` partitions are empty; all of the
state `xc` is miscellaneous continuous state `z`.)""";

          // drake/systems/framework/continuous_state.h:103
          const char* doc_4 =
R"""(Constructs a ContinuousState that exposes second-order structure.

Parameter ``state``:
    The source xc of continuous state information.

Parameter ``num_q``:
    The number of position variables q.

Parameter ``num_v``:
    The number of velocity variables v.

Parameter ``num_z``:
    The number of other continuous variables z.

We require that `num_q ≥ num_v` and that the sum of the partition
sizes adds up to the size of `state`.)""";

          // drake/systems/framework/continuous_state.h:126
          const char* doc_5 =
R"""(Constructs a zero-length ContinuousState.)""";

          // drake/systems/framework/continuous_state.h:239
          const char* doc_6 =
R"""(Constructs a continuous state that exposes second-order structure,
with no particular constraints on the layout.

@pre The q, v, z are all views into the same storage as ``state``.

Parameter ``state``:
    The entire continuous state.

Parameter ``q``:
    The subset of state that is generalized position.

Parameter ``v``:
    The subset of state that is generalized velocity.

Parameter ``z``:
    The subset of state that is neither position nor velocity.)""";

        } ctor;

        // drake::systems::ContinuousState::CopyFrom
        struct /* CopyFrom */ {

          // drake/systems/framework/continuous_state.h:209
          const char* doc =
R"""(Copies the values from another ContinuousState of the same scalar type
into this State.)""";

        } CopyFrom;

        // drake::systems::ContinuousState::CopyToVector
        struct /* CopyToVector */ {

          // drake/systems/framework/continuous_state.h:227
          const char* doc =
R"""(Returns a copy of the entire continuous state vector into an Eigen
vector.)""";

        } CopyToVector;

        // drake::systems::ContinuousState::DoClone
        struct /* DoClone */ {

          // drake/systems/framework/continuous_state.h:256
          const char* doc =
R"""(DiagramContinuousState must override this to maintain the necessary
internal substructure, and to perform a deep copy so that the result
owns all its own data. The default implementation here requires that
the full state is a BasicVector (that is, this is a leaf continuous
state). The BasicVector is cloned to preserve its concrete type and
contents, then the q, v, z Subvectors are created referencing it.)""";

        } DoClone;

        // drake::systems::ContinuousState::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/continuous_state.h:216
          const char* doc =
R"""(Initializes this ContinuousState (regardless of scalar type) from a
State<double>. All scalar types in Drake must support initialization
from doubles.)""";

        } SetFrom;

        // drake::systems::ContinuousState::SetFromVector
        struct /* SetFromVector */ {

          // drake/systems/framework/continuous_state.h:221
          const char* doc =
R"""(Sets the entire continuous state vector from an Eigen expression.)""";

        } SetFromVector;

        // drake::systems::ContinuousState::get_generalized_position
        struct /* get_generalized_position */ {

          // drake/systems/framework/continuous_state.h:173
          const char* doc =
R"""(Returns a const reference to the subset of the state vector that is
generalized position `q`. May be zero length.)""";

        } get_generalized_position;

        // drake::systems::ContinuousState::get_generalized_velocity
        struct /* get_generalized_velocity */ {

          // drake/systems/framework/continuous_state.h:185
          const char* doc =
R"""(Returns a const reference to the subset of the continuous state vector
that is generalized velocity `v`. May be zero length.)""";

        } get_generalized_velocity;

        // drake::systems::ContinuousState::get_misc_continuous_state
        struct /* get_misc_continuous_state */ {

          // drake/systems/framework/continuous_state.h:197
          const char* doc =
R"""(Returns a const reference to the subset of the continuous state vector
that is other continuous state `z`. May be zero length.)""";

        } get_misc_continuous_state;

        // drake::systems::ContinuousState::get_mutable_generalized_position
        struct /* get_mutable_generalized_position */ {

          // drake/systems/framework/continuous_state.h:179
          const char* doc =
R"""(Returns a mutable reference to the subset of the state vector that is
generalized position `q`. May be zero length.)""";

        } get_mutable_generalized_position;

        // drake::systems::ContinuousState::get_mutable_generalized_velocity
        struct /* get_mutable_generalized_velocity */ {

          // drake/systems/framework/continuous_state.h:191
          const char* doc =
R"""(Returns a mutable reference to the subset of the continuous state
vector that is generalized velocity `v`. May be zero length.)""";

        } get_mutable_generalized_velocity;

        // drake::systems::ContinuousState::get_mutable_misc_continuous_state
        struct /* get_mutable_misc_continuous_state */ {

          // drake/systems/framework/continuous_state.h:203
          const char* doc =
R"""(Returns a mutable reference to the subset of the continuous state
vector that is other continuous state `z`. May be zero length.)""";

        } get_mutable_misc_continuous_state;

        // drake::systems::ContinuousState::get_mutable_vector
        struct /* get_mutable_vector */ {

          // drake/systems/framework/continuous_state.h:166
          const char* doc =
R"""(Returns a mutable reference to the entire continuous state vector.)""";

        } get_mutable_vector;

        // drake::systems::ContinuousState::get_vector
        struct /* get_vector */ {

          // drake/systems/framework/continuous_state.h:160
          const char* doc =
R"""(Returns a reference to the entire continuous state vector.)""";

        } get_vector;

        // drake::systems::ContinuousState::num_q
        struct /* num_q */ {

          // drake/systems/framework/continuous_state.h:147
          const char* doc =
R"""(Returns the number of generalized positions q in this state vector.)""";

        } num_q;

        // drake::systems::ContinuousState::num_v
        struct /* num_v */ {

          // drake/systems/framework/continuous_state.h:150
          const char* doc =
R"""(Returns the number of generalized velocities v in this state vector.)""";

        } num_v;

        // drake::systems::ContinuousState::num_z
        struct /* num_z */ {

          // drake/systems/framework/continuous_state.h:154
          const char* doc =
R"""(Returns the number of miscellaneous continuous state variables z in
this state vector.)""";

        } num_z;

        // drake::systems::ContinuousState::operator[]
        struct /* operator_array */ {

          // drake/systems/framework/continuous_state.h:156
          const char* doc = R"""()""";

          // drake/systems/framework/continuous_state.h:157
          const char* doc_2 = R"""()""";

        } operator_array;

        // drake::systems::ContinuousState::size
        struct /* size */ {

          // drake/systems/framework/continuous_state.h:144
          const char* doc =
R"""(Returns the size of the entire continuous state vector, which is
necessarily `num_q + num_v + num_z`.)""";

        } size;

      } ContinuousState;

      // drake::systems::ControllabilityMatrix
      struct /* ControllabilityMatrix */ {

        // drake/systems/primitives/linear_system.h:253
        const char* doc =
R"""(Returns the controllability matrix: R = [B, AB, ..., A^{n-1}B].)""";

      } ControllabilityMatrix;

      // drake::systems::Demultiplexer
      struct /* Demultiplexer */ {

        // drake/systems/primitives/demultiplexer.h:27
        const char* doc =
R"""(This system splits a vector valued signal on its input into multiple
outputs.

The input to this system directly feeds through to its output.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::Demultiplexer::Demultiplexer<T>
        struct /* ctor */ {

          // drake/systems/primitives/demultiplexer.h:29
          const char* doc = R"""()""";

          // drake/systems/primitives/demultiplexer.h:29
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/demultiplexer.h:42
          const char* doc_3 =
R"""(Constructs Demultiplexer with one vector valued input port of size
``size`` and vector valued output ports of size
``output_ports_sizes``.

``output_ports_sizes`` must exactly divide ``size``. Otherwise this
constructor throws an exception. The number of output ports is
therefore `size / output_ports_sizes`.

Parameter ``size``:
    is the size of the input signal to be demultiplexed into its
    individual components.

Parameter ``output_ports_sizes``:
    The size of the output ports. ``size`` must be a multiple of
    ``output_ports_sizes``.)""";

          // drake/systems/primitives/demultiplexer.h:46
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

      } Demultiplexer;

      // drake::systems::DenseOutput
      struct /* DenseOutput */ {

        // drake/systems/analysis/dense_output.h:45
        const char* doc =
R"""(An interface for dense output of ODE solutions, to efficiently
approximate them at arbitrarily many points when solving them
numerically (see IntegratorBase class documentation).

Multiple definitions of _dense output_ may be found in literature. For
some authors, it refers to the process of repeatedly adjusting the
integration step size so that all points to be approximated are
directly provided by the integrator (see [Engquist, 2015]). For
others, it stands for any numerical approximation technique used to
determine the solution in between steps (see [Hairer, 1993]). Despite
this caveat, it is common terminology in IVP literature and thus its
imparted functionality is immediately clear.

Herein, the concept in use may be formally stated as follows: given a
solution 𝐱(t) ∈ ℝⁿ to an ODE system that is approximated at a discrete
set of points 𝐲(tₖ) ∈ ℝⁿ where tₖ ∈ {t₁, ..., tᵢ} with tᵢ ∈ ℝ (e.g. as
a result of numerical integration), a dense output of 𝐱(t) is another
function 𝐳(t) ∈ ℝⁿ defined for t ∈ [t₁, tᵢ] such that 𝐳(tⱼ) = 𝐲(tⱼ)
for all tⱼ ∈ {t₁, ..., tᵢ} and that approximates 𝐱(t) for every value
in the closed interval [t₁, tᵢ].

@warning Dense outputs are, in general, not bound to attain the same
accuracy that error-controlled integration schemes do. Check each
subclass documentation for further specification. @warning Note that
dense outputs do not enforce any algebraic constraints on the solution
that integrators might enforce.

- [Engquist, 2105] B. Engquist. Encyclopedia of Applied and
Computational Mathematics, p. 339, Springer, 2015. - [Hairer, 1993] E.
Hairer, S. Nørsett and G. Wanner. Solving Ordinary Differential
Equations I (Nonstiff Problems), p.188, Springer, 1993.

Template parameter ``T``:
    A valid Eigen scalar type.)""";

        // drake::systems::DenseOutput::DenseOutput<T>
        struct /* ctor */ {

          // drake/systems/analysis/dense_output.h:47
          const char* doc = R"""()""";

          // drake/systems/analysis/dense_output.h:47
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/dense_output.h:118
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::DenseOutput::DoEvaluate
        struct /* DoEvaluate */ {

          // drake/systems/analysis/dense_output.h:121
          const char* doc = R"""()""";

        } DoEvaluate;

        // drake::systems::DenseOutput::DoEvaluateNth
        struct /* DoEvaluateNth */ {

          // drake/systems/analysis/dense_output.h:127
          const char* doc = R"""()""";

        } DoEvaluateNth;

        // drake::systems::DenseOutput::Evaluate
        struct /* Evaluate */ {

          // drake/systems/analysis/dense_output.h:58
          const char* doc =
R"""(Evaluates the output at the given time ``t``.

Parameter ``t``:
    Time at which to evaluate output.

Returns:
    Output vector value. @pre Output is not empty i.e. is_empty()
    equals false.

Throws:
    s std::logic_error if any of the preconditions are not met.

Throws:
    s std::runtime_error if given ``t`` is not within output's domain
    i.e. ``t`` ∉ [start_time(), end_time()].)""";

        } Evaluate;

        // drake::systems::DenseOutput::EvaluateNth
        struct /* EvaluateNth */ {

          // drake/systems/analysis/dense_output.h:80
          const char* doc =
R"""(Evaluates the output value's `n`th scalar element (0-indexed) at the
given time ``t``.

Note:
    On some implementations, the computational cost of this method may
    be lower than that of indexing an Evaluate(const T&) call return
    vector value, thus making it the preferred mechanism when
    targeting a single dimension.

Parameter ``t``:
    Time at which to evaluate output.

Parameter ``n``:
    The nth scalar element (0-indexed) of the output value to
    evaluate.

Returns:
    Output value's `n`th scalar element (0-indexed). @pre Output is
    not empty i.e. is_empty() equals false.

Throws:
    s std::logic_error if any of the preconditions are not met.

Throws:
    s std::runtime_error if given ``t`` is not within output's domain
    i.e. ``t`` ∉ [start_time(), end_time()].

Throws:
    s std::runtime_error if given ``n`` does not refer to a valid
    output dimension i.e. ``n`` ∉ [0, size()).)""";

        } EvaluateNth;

        // drake::systems::DenseOutput::ThrowIfNthElementIsInvalid
        struct /* ThrowIfNthElementIsInvalid */ {

          // drake/systems/analysis/dense_output.h:158
          const char* doc = R"""()""";

        } ThrowIfNthElementIsInvalid;

        // drake::systems::DenseOutput::ThrowIfOutputIsEmpty
        struct /* ThrowIfOutputIsEmpty */ {

          // drake/systems/analysis/dense_output.h:146
          const char* doc = R"""()""";

        } ThrowIfOutputIsEmpty;

        // drake::systems::DenseOutput::ThrowIfTimeIsInvalid
        struct /* ThrowIfTimeIsInvalid */ {

          // drake/systems/analysis/dense_output.h:171
          const char* doc = R"""()""";

        } ThrowIfTimeIsInvalid;

        // drake::systems::DenseOutput::do_end_time
        struct /* do_end_time */ {

          // drake/systems/analysis/dense_output.h:141
          const char* doc = R"""()""";

        } do_end_time;

        // drake::systems::DenseOutput::do_is_empty
        struct /* do_is_empty */ {

          // drake/systems/analysis/dense_output.h:132
          const char* doc = R"""()""";

        } do_is_empty;

        // drake::systems::DenseOutput::do_size
        struct /* do_size */ {

          // drake/systems/analysis/dense_output.h:135
          const char* doc = R"""()""";

        } do_size;

        // drake::systems::DenseOutput::do_start_time
        struct /* do_start_time */ {

          // drake/systems/analysis/dense_output.h:138
          const char* doc = R"""()""";

        } do_start_time;

        // drake::systems::DenseOutput::end_time
        struct /* end_time */ {

          // drake/systems/analysis/dense_output.h:112
          const char* doc =
R"""(Returns output's end time, or in other words, the newest time `t` that
it can be evaluated at e.g. via Evaluate(). @pre Output is not empty
i.e. is_empty() equals false.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } end_time;

        // drake::systems::DenseOutput::is_empty
        struct /* is_empty */ {

          // drake/systems/analysis/dense_output.h:97
          const char* doc =
R"""(Checks whether the output is empty or not.)""";

        } is_empty;

        // drake::systems::DenseOutput::size
        struct /* size */ {

          // drake/systems/analysis/dense_output.h:91
          const char* doc =
R"""(Returns the output size (i.e. the number of elements in an output
value). @pre Output is not empty i.e. is_empty() equals false.

Throws:
    std::logic_error if any of the preconditions is not met.)""";

        } size;

        // drake::systems::DenseOutput::start_time
        struct /* start_time */ {

          // drake/systems/analysis/dense_output.h:103
          const char* doc =
R"""(Returns output's start time, or in other words, the oldest time `t`
that it can be evaluated at e.g. via Evaluate(). @pre Output is not
empty i.e. is_empty() equals false.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } start_time;

      } DenseOutput;

      // drake::systems::DependencyGraph
      struct /* DependencyGraph */ {

        // drake/systems/framework/cache.h:25
        const char* doc =
R"""(Represents the portion of the complete dependency graph that is a
subgraph centered on the owning subcontext, plus some edges leading to
other subcontexts. DependencyTracker objects are the nodes of the
graph, and maintain prerequisite/subscriber edges that interconnect
these nodes, and may also connect to nodes contained in dependency
graphs belonging to other subcontexts within the same complete context
tree. Dependencies on the parent (containing DiagramContext) and
children (contained subcontexts) typically arise from exported input
and output ports, while sibling dependencies arise from output-to-
input port connections.

A DependencyGraph creates and owns all the DependencyTracker objects
for a particular subcontext, organized to allow fast access using a
DependencyTicket as an index. Memory addresses of DependencyTracker
objects are stable once allocated, but DependencyTicket numbers are
stable even after a Context has been copied so should be preferred.

Because DependencyTrackers contain pointers, copying a DependencyGraph
must always be done as part of copying an entire Context tree. There
is a copy constructor here but it must be followed by a pointer-fixup
step so is for internal use only.)""";

        // drake/systems/framework/dependency_tracker.h:23
        const char* doc_2 =
R"""(Represents the portion of the complete dependency graph that is a
subgraph centered on the owning subcontext, plus some edges leading to
other subcontexts. DependencyTracker objects are the nodes of the
graph, and maintain prerequisite/subscriber edges that interconnect
these nodes, and may also connect to nodes contained in dependency
graphs belonging to other subcontexts within the same complete context
tree. Dependencies on the parent (containing DiagramContext) and
children (contained subcontexts) typically arise from exported input
and output ports, while sibling dependencies arise from output-to-
input port connections.

A DependencyGraph creates and owns all the DependencyTracker objects
for a particular subcontext, organized to allow fast access using a
DependencyTicket as an index. Memory addresses of DependencyTracker
objects are stable once allocated, but DependencyTicket numbers are
stable even after a Context has been copied so should be preferred.

Because DependencyTrackers contain pointers, copying a DependencyGraph
must always be done as part of copying an entire Context tree. There
is a copy constructor here but it must be followed by a pointer-fixup
step so is for internal use only.)""";

        // drake/systems/framework/dependency_tracker.h:442
        const char* doc_3 =
R"""(Represents the portion of the complete dependency graph that is a
subgraph centered on the owning subcontext, plus some edges leading to
other subcontexts. DependencyTracker objects are the nodes of the
graph, and maintain prerequisite/subscriber edges that interconnect
these nodes, and may also connect to nodes contained in dependency
graphs belonging to other subcontexts within the same complete context
tree. Dependencies on the parent (containing DiagramContext) and
children (contained subcontexts) typically arise from exported input
and output ports, while sibling dependencies arise from output-to-
input port connections.

A DependencyGraph creates and owns all the DependencyTracker objects
for a particular subcontext, organized to allow fast access using a
DependencyTicket as an index. Memory addresses of DependencyTracker
objects are stable once allocated, but DependencyTicket numbers are
stable even after a Context has been copied so should be preferred.

Because DependencyTrackers contain pointers, copying a DependencyGraph
must always be done as part of copying an entire Context tree. There
is a copy constructor here but it must be followed by a pointer-fixup
step so is for internal use only.)""";

        // drake::systems::DependencyGraph::AppendToTrackerPointerMap
        struct /* AppendToTrackerPointerMap */ {

          // drake/systems/framework/dependency_tracker.h:549
          const char* doc =
R"""((Internal use only) Create a mapping from the memory addresses of the
trackers contained here to the corresponding ones in `clone`, which
must have exactly the same number of trackers. The mapping is appended
to the supplied map, which must not be null.)""";

        } AppendToTrackerPointerMap;

        // drake::systems::DependencyGraph::CreateNewDependencyTracker
        struct /* CreateNewDependencyTracker */ {

          // drake/systems/framework/dependency_tracker.h:475
          const char* doc =
R"""(Allocates a new DependencyTracker with an already-known ticket number,
the given description and an optional cache value to be invalidated.
The new tracker has no prerequisites or subscribers yet. This may
leave gaps in the node numbering. Use has_tracker() if you need to
know whether there is a tracker for a particular ticket. We promise
that the returned DependencyTracker's location in memory will remain
unchanged once created in a particular Context, even as more trackers
are added. The DependencyTicket retains its meaning even after cloning
the Context, although of course the tracker has a new address in the
clone. @pre The given ticket must be valid. @pre No DependencyTracker
is already using the given ticket.)""";

          // drake/systems/framework/dependency_tracker.h:489
          const char* doc_2 =
R"""(Assigns a new ticket number and then allocates a new DependencyTracker
that can be accessed with that ticket. You may obtain the assigned
ticket from the returned tracker. See the other signature for details.)""";

        } CreateNewDependencyTracker;

        // drake::systems::DependencyGraph::DependencyGraph
        struct /* ctor */ {

          // drake/systems/framework/dependency_tracker.h:448
          const char* doc =
R"""(@name Does not allow move or assignment; copy constructor limited. The
copy constructor does not copy internal pointers so requires special
handling. @{ */)""";

          // drake/systems/framework/dependency_tracker.h:455
          const char* doc_2 =
R"""(Constructor creates an empty graph referencing the system pathname
service of its owning subcontext. The supplied pointer must not be
null.)""";

          // drake/systems/framework/dependency_tracker.h:534
          const char* doc_3 =
R"""((Internal use only) Copy constructor partially duplicates the source
DependencyGraph object, with identical structure to the source but
with all internal pointers set to null, and all counters and
statistics set to their default-constructed values. Pointers must be
set properly using RepairTrackerPointers() once all the old-to-new
pointer mappings have been determined _for the whole Context_, not
just the containing subcontext. This should only be invoked by Context
code as part of copying an entire Context tree.

See also:
    AppendToTrackerPointerMap(), RepairTrackerPointers())""";

        } ctor;

        // drake::systems::DependencyGraph::RepairTrackerPointers
        struct /* RepairTrackerPointers */ {

          // drake/systems/framework/dependency_tracker.h:562
          const char* doc =
R"""((Internal use only) Assumes `this` DependencyGraph is a recent clone
whose trackers do not yet contain subscriber and prerequisite pointers
and sets the local pointers to point to the `source`-corresponding
trackers in the new owning context, the appropriate cache entry values
in the new cache, and to the system name providing service of the new
owning Context for logging and error reporting. The supplied map
should map source pointers to their corresponding trackers. It is a
fatal error if any old pointer we encounter is not present in the map;
that would indicate a bug in the Context cloning code.)""";

        } RepairTrackerPointers;

        // drake::systems::DependencyGraph::get_mutable_tracker
        struct /* get_mutable_tracker */ {

          // drake/systems/framework/dependency_tracker.h:521
          const char* doc =
R"""(Returns a mutable DependencyTracker given a ticket. This is very fast.
Behavior is undefined if the ticket is out of range
[0..num_trackers()-1].)""";

        } get_mutable_tracker;

        // drake::systems::DependencyGraph::get_tracker
        struct /* get_tracker */ {

          // drake/systems/framework/dependency_tracker.h:512
          const char* doc =
R"""(Returns a const DependencyTracker given a ticket. This is very fast.
Behavior is undefined if the ticket is out of range
[0..num_trackers()-1].)""";

        } get_tracker;

        // drake::systems::DependencyGraph::has_tracker
        struct /* has_tracker */ {

          // drake/systems/framework/dependency_tracker.h:498
          const char* doc =
R"""(Returns true if there is a DependencyTracker in this graph that has
the given ticket number.)""";

        } has_tracker;

        // drake::systems::DependencyGraph::trackers_size
        struct /* trackers_size */ {

          // drake/systems/framework/dependency_tracker.h:508
          const char* doc =
R"""(Returns the current size of the DependencyTracker container, providing
for DependencyTicket numbers from `0..trackers_size()-1`. Note that it
is possible to have empty slots in the container. Use has_tracker() to
determine if there is a tracker associated with a particular ticket.)""";

        } trackers_size;

      } DependencyGraph;

      // drake::systems::DependencyTag
      struct /* DependencyTag */ {

        // drake/systems/framework/framework_common.h:26
        const char* doc = R"""()""";

      } DependencyTag;

      // drake::systems::DependencyTracker
      struct /* DependencyTracker */ {

        // drake/systems/framework/dependency_tracker.h:134
        const char* doc = R"""()""";

        // drake::systems::DependencyTracker::AddDownstreamSubscriber
        struct /* AddDownstreamSubscriber */ {

          // drake/systems/framework/dependency_tracker.h:218
          const char* doc =
R"""(Adds a downstream subscriber to `this` DependencyTracker, which will
keep a pointer to the subscribing tracker. The subscriber will be
notified whenever this DependencyTracker is notified of a value or
prerequisite change. @pre The subscriber has already recorded its
dependency on this tracker in its prerequisite list.)""";

        } AddDownstreamSubscriber;

        // drake::systems::DependencyTracker::DependencyTracker
        struct /* ctor */ {

          // drake/systems/framework/dependency_tracker.h:136
          const char* doc = R"""()""";

          // drake/systems/framework/dependency_tracker.h:136
          const char* doc_2 = R"""()""";

        } ctor;

        // drake::systems::DependencyTracker::GetPathDescription
        struct /* GetPathDescription */ {

          // drake/systems/framework/dependency_tracker.h:147
          const char* doc =
R"""(Returns the description, preceded by the full pathname of the
subsystem associated with the owning subcontext.)""";

        } GetPathDescription;

        // drake::systems::DependencyTracker::HasPrerequisite
        struct /* HasPrerequisite */ {

          // drake/systems/framework/dependency_tracker.h:227
          const char* doc =
R"""(Returns `true` if this tracker has already subscribed to
`prerequisite`. This is slow and should not be used in performance-
sensitive code.)""";

        } HasPrerequisite;

        // drake::systems::DependencyTracker::HasSubscriber
        struct /* HasSubscriber */ {

          // drake/systems/framework/dependency_tracker.h:231
          const char* doc =
R"""(Returns `true` if `subscriber` is one of this tracker's subscribers.
This is slow and should not be used in performance-sensitive code.)""";

        } HasSubscriber;

        // drake::systems::DependencyTracker::NoteValueChange
        struct /* NoteValueChange */ {

          // drake/systems/framework/dependency_tracker.h:194
          const char* doc =
R"""(Notifies `this` DependencyTracker that its managed value was directly
modified or made available for mutable access. That is, this is the
_initiating_ event of a value modification. All of our downstream
subscribers are notified but the associated cache entry (if any) is
_not_ invalidated (see below for why). A unique, positive
`change_event` should have been obtained from the owning Context and
supplied here.

Why don't we invalidate the cache entry? Recall that this method is
for _initiating_ a change event, meaning that the quantity that this
tracker tracks is _initiating_ an invalidation sweep, as opposed to
just reacting to prerequisite changes. Normally cache entries become
invalid because their prerequisites change; they are not usually the
first step in an invalidation sweep. So it is unusual for
NoteValueChange() to be called on a cache entry's dependency tracker.
But if it is called, that is likely to mean the cache entry was just
given a new value, and is therefore _valid_; invalidating it now would
be an error.)""";

        } NoteValueChange;

        // drake::systems::DependencyTracker::RemoveDownstreamSubscriber
        struct /* RemoveDownstreamSubscriber */ {

          // drake/systems/framework/dependency_tracker.h:223
          const char* doc =
R"""(Removes a downstream subscriber from `this` DependencyTracker. @pre
The subscriber has already removed the dependency on this tracker from
its prerequisite list.)""";

        } RemoveDownstreamSubscriber;

        // drake::systems::DependencyTracker::SubscribeToPrerequisite
        struct /* SubscribeToPrerequisite */ {

          // drake/systems/framework/dependency_tracker.h:204
          const char* doc =
R"""(Subscribes `this` tracker to an upstream prerequisite's tracker. The
upstream tracker will keep a const pointer back to `this` tracker in
its subscriber list, and `this` tracker will keep a pointer to the
prerequisite tracker in its prerequisites list.)""";

        } SubscribeToPrerequisite;

        // drake::systems::DependencyTracker::ThrowIfBadDependencyTracker
        struct /* ThrowIfBadDependencyTracker */ {

          // drake/systems/framework/dependency_tracker.h:304
          const char* doc =
R"""(Throws an std::logic_error if there is something clearly wrong with
this DependencyTracker object. If the owning subcontext is known,
provide a pointer to it here and we'll check that this tracker agrees.
If you know which cache entry is supposed to be associated with this
tracker, supply a pointer to that and we'll check it (trackers that
are not associated with a real cache entry are still associated with
the CacheEntryValue::dummy()). In addition we check for other internal
inconsistencies.

Throws:
    s std::logic_error for anything that goes wrong, with an
    appropriate explanatory message.)""";

        } ThrowIfBadDependencyTracker;

        // drake::systems::DependencyTracker::UnsubscribeFromPrerequisite
        struct /* UnsubscribeFromPrerequisite */ {

          // drake/systems/framework/dependency_tracker.h:211
          const char* doc =
R"""(Unsubscribes `this` tracker from an upstream prerequisite tracker to
which we previously subscribed. Both the prerequisite list in `this`
tracker and the subscriber list in `prerequisite` are modified. @pre
The supplied pointer must not be null. @pre This tracker must already
be subscribed to the given `prerequisite`.)""";

        } UnsubscribeFromPrerequisite;

        // drake::systems::DependencyTracker::cache_entry_value
        struct /* cache_entry_value */ {

          // drake/systems/framework/dependency_tracker.h:171
          const char* doc =
R"""((Internal use only) Returns a pointer to the CacheEntryValue if this
tracker is a cache entry tracker, otherwise nullptr.)""";

        } cache_entry_value;

        // drake::systems::DependencyTracker::description
        struct /* description */ {

          // drake/systems/framework/dependency_tracker.h:143
          const char* doc =
R"""(Returns the human-readable description for this tracker. */)""";

        } description;

        // drake::systems::DependencyTracker::num_ignored_notifications
        struct /* num_ignored_notifications */ {

          // drake/systems/framework/dependency_tracker.h:268
          const char* doc =
R"""(How many times did we receive a repeat notification for the same
change event that we ignored?)""";

        } num_ignored_notifications;

        // drake::systems::DependencyTracker::num_notifications_received
        struct /* num_notifications_received */ {

          // drake/systems/framework/dependency_tracker.h:262
          const char* doc =
R"""(What is the total number of notifications received by this tracker?
This is the sum of managed-value change event notifications and
prerequisite change notifications received.)""";

        } num_notifications_received;

        // drake::systems::DependencyTracker::num_notifications_sent
        struct /* num_notifications_sent */ {

          // drake/systems/framework/dependency_tracker.h:274
          const char* doc =
R"""(What is the total number of notifications sent to downstream
subscribers by this trackers?)""";

        } num_notifications_sent;

        // drake::systems::DependencyTracker::num_prerequisite_change_events
        struct /* num_prerequisite_change_events */ {

          // drake/systems/framework/dependency_tracker.h:286
          const char* doc =
R"""(How many times was this tracker notified of a change to one of its
value's prerequisites?)""";

        } num_prerequisite_change_events;

        // drake::systems::DependencyTracker::num_prerequisites
        struct /* num_prerequisites */ {

          // drake/systems/framework/dependency_tracker.h:235
          const char* doc =
R"""(Returns the total number of "depends-on" edges emanating from `this`
tracker, pointing to its upstream prerequisites.)""";

        } num_prerequisites;

        // drake::systems::DependencyTracker::num_subscribers
        struct /* num_subscribers */ {

          // drake/systems/framework/dependency_tracker.h:246
          const char* doc =
R"""(Returns the total number of "is-prerequisite-of" edges emanating from
`this` tracker, pointing to its downstream subscribers.)""";

        } num_subscribers;

        // drake::systems::DependencyTracker::num_value_change_events
        struct /* num_value_change_events */ {

          // drake/systems/framework/dependency_tracker.h:280
          const char* doc =
R"""(How many times was this tracker notified of a change event for a
direct change to a value it tracks?)""";

        } num_value_change_events;

        // drake::systems::DependencyTracker::prerequisites
        struct /* prerequisites */ {

          // drake/systems/framework/dependency_tracker.h:240
          const char* doc =
R"""(Returns a reference to the prerequisite trackers. */)""";

        } prerequisites;

        // drake::systems::DependencyTracker::set_cache_entry_value
        struct /* set_cache_entry_value */ {

          // drake/systems/framework/dependency_tracker.h:160
          const char* doc =
R"""((Internal use only) Sets the cache entry value to be marked out-of-
date when this tracker's prerequisites change. @pre The supplied cache
entry value is non-null. @pre No cache entry value has previously been
assigned.)""";

        } set_cache_entry_value;

        // drake::systems::DependencyTracker::subscribers
        struct /* subscribers */ {

          // drake/systems/framework/dependency_tracker.h:249
          const char* doc =
R"""(Returns a reference to the subscribing trackers. */)""";

        } subscribers;

        // drake::systems::DependencyTracker::ticket
        struct /* ticket */ {

          // drake/systems/framework/dependency_tracker.h:151
          const char* doc =
R"""(Returns the DependencyTicket for this DependencyTracker in its
containing DependencyGraph. The ticket is unique within the containing
subcontext.)""";

        } ticket;

      } DependencyTracker;

      // drake::systems::Diagram
      struct /* Diagram */ {

        // drake/systems/framework/diagram.h:44
        const char* doc =
R"""(Diagram is a System composed of one or more constituent Systems,
arranged in a directed graph where the vertices are the constituent
Systems themselves, and the edges connect the output of one
constituent System to the input of another. To construct a Diagram,
use a DiagramBuilder.

Each System in the Diagram must have a unique, non-empty name.

Template parameter ``T``:
    The mathematical scalar type. Must be a valid Eigen scalar.)""";

        // drake::systems::Diagram::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:539
          const char* doc =
R"""(For the subsystem associated with `witness_func`, gets its mutable sub
composite event collection from `events`, and passes it to
`witness_func`'s AddEventToCollection method. This method also
modifies `event` by updating the pointers to "diagram" continuous
state to point to the ContinuousState pointers for the associated
subsystem instead. Aborts if the subsystem is not part of this
Diagram.)""";

        } AddTriggeredWitnessFunctionToCompositeEventCollection;

        // drake::systems::Diagram::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:84
          const char* doc =
R"""(Allocates a DiagramEventCollection for this Diagram.

See also:
    System::AllocateCompositeEventCollection().)""";

        } AllocateCompositeEventCollection;

        // drake::systems::Diagram::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {

          // drake/systems/framework/diagram.h:260
          const char* doc =
R"""(Aggregates the discrete update variables from each subsystem into a
DiagramDiscreteVariables.)""";

        } AllocateDiscreteVariables;

        // drake::systems::Diagram::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {

          // drake/systems/framework/diagram.h:235
          const char* doc = R"""()""";

        } AllocateForcedDiscreteUpdateEventCollection;

        // drake::systems::Diagram::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {

          // drake/systems/framework/diagram.h:229
          const char* doc = R"""(@cond)""";

        } AllocateForcedPublishEventCollection;

        // drake::systems::Diagram::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {

          // drake/systems/framework/diagram.h:241
          const char* doc = R"""()""";

        } AllocateForcedUnrestrictedUpdateEventCollection;

        // drake::systems::Diagram::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {

          // drake/systems/framework/diagram.h:249
          const char* doc =
R"""(Aggregates the time derivatives from each subsystem into a
DiagramContinuousState.)""";

        } AllocateTimeDerivatives;

        // drake::systems::Diagram::Diagram<type-parameter-0-0>
        struct /* ctor */ {

          // drake/systems/framework/diagram.h:47
          const char* doc = R"""()""";

          // drake/systems/framework/diagram.h:47
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram.h:54
          const char* doc_3 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/framework/diagram.h:505
          const char* doc_4 =
R"""(Constructs an uninitialized Diagram. Subclasses that use this
constructor are obligated to call DiagramBuilder::BuildInto(this).
Provides scalar- type conversion support only if every contained
subsystem provides the same support.)""";

          // drake/systems/framework/diagram.h:519
          const char* doc_5 =
R"""((Advanced) Constructs an uninitialized Diagram. Subclasses that use
this constructor are obligated to call
DiagramBuilder::BuildInto(this).

Declares scalar-type conversion support using ``converter``. Support
for a given pair of types `T, U` to convert from and to will be
enabled only if every contained subsystem supports that pair.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

        } ctor;

        // drake::systems::Diagram::DoAllocateInputAbstract
        struct /* DoAllocateInputAbstract */ {

          // drake/systems/framework/diagram.h:836
          const char* doc = R"""()""";

        } DoAllocateInputAbstract;

        // drake::systems::Diagram::DoAllocateInputVector
        struct /* DoAllocateInputVector */ {

          // drake/systems/framework/diagram.h:826
          const char* doc = R"""()""";

        } DoAllocateInputVector;

        // drake::systems::Diagram::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {

          // drake/systems/framework/diagram.h:793
          const char* doc =
R"""(Computes the next update time based on the configured actions, for
scalar types that are arithmetic, or aborts for scalar types that are
not arithmetic.)""";

        } DoCalcNextUpdateTime;

        // drake::systems::Diagram::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/systems/framework/diagram.h:269
          const char* doc = R"""()""";

        } DoCalcTimeDerivatives;

        // drake::systems::Diagram::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {

          // drake/systems/framework/diagram.h:526
          const char* doc =
R"""(For the subsystem associated with ``witness_func``, gets its
subcontext from ``context``, passes the subcontext to
``witness_func``' Evaulate method and returns the result. Aborts if
the subsystem is not part of this Diagram.)""";

        } DoCalcWitnessValue;

        // drake::systems::Diagram::DoGetMutableTargetSystemCompositeEventCollection
        struct /* DoGetMutableTargetSystemCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:667
          const char* doc =
R"""(Returns a pointer to mutable composite event collection if
``target_system`` is a subsystem of this, nullptr is returned
otherwise.)""";

        } DoGetMutableTargetSystemCompositeEventCollection;

        // drake::systems::Diagram::DoGetMutableTargetSystemContext
        struct /* DoGetMutableTargetSystemContext */ {

          // drake/systems/framework/diagram.h:600
          const char* doc =
R"""(Returns a pointer to mutable context if ``target_system`` is a sub
system of this, nullptr is returned otherwise.)""";

        } DoGetMutableTargetSystemContext;

        // drake::systems::Diagram::DoGetMutableTargetSystemState
        struct /* DoGetMutableTargetSystemState */ {

          // drake/systems/framework/diagram.h:626
          const char* doc =
R"""(Returns a pointer to mutable state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";

        } DoGetMutableTargetSystemState;

        // drake::systems::Diagram::DoGetTargetSystemCompositeEventCollection
        struct /* DoGetTargetSystemCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:682
          const char* doc =
R"""(Returns a pointer to const composite event collection if
``target_system`` is a subsystem of this, nullptr is returned
otherwise.)""";

        } DoGetTargetSystemCompositeEventCollection;

        // drake::systems::Diagram::DoGetTargetSystemContext
        struct /* DoGetTargetSystemContext */ {

          // drake/systems/framework/diagram.h:613
          const char* doc =
R"""(Returns a pointer to const context if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";

        } DoGetTargetSystemContext;

        // drake::systems::Diagram::DoGetTargetSystemContinuousState
        struct /* DoGetTargetSystemContinuousState */ {

          // drake/systems/framework/diagram.h:639
          const char* doc =
R"""(Returns a pointer to const state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";

        } DoGetTargetSystemContinuousState;

        // drake::systems::Diagram::DoGetTargetSystemState
        struct /* DoGetTargetSystemState */ {

          // drake/systems/framework/diagram.h:654
          const char* doc =
R"""(Returns a pointer to const state if ``target_system`` is a subsystem
of this, nullptr is returned otherwise.)""";

        } DoGetTargetSystemState;

        // drake::systems::Diagram::DoGetWitnessFunctions
        struct /* DoGetWitnessFunctions */ {

          // drake/systems/framework/diagram.h:576
          const char* doc =
R"""(Provides witness functions of subsystems that are active at the
beginning of a continuous time interval. The vector of witness
functions is not ordered in a particular manner.)""";

        } DoGetWitnessFunctions;

        // drake::systems::Diagram::DoMapQDotToVelocity
        struct /* DoMapQDotToVelocity */ {

          // drake/systems/framework/diagram.h:746
          const char* doc =
R"""(The ``generalized_velocity`` vector must have the same size and
ordering as the generalized velocity in the ContinuousState that this
Diagram reserves in its context.)""";

        } DoMapQDotToVelocity;

        // drake::systems::Diagram::DoMapVelocityToQDot
        struct /* DoMapVelocityToQDot */ {

          // drake/systems/framework/diagram.h:698
          const char* doc =
R"""(The ``generalized_velocity`` vector must have the same size and
ordering as the generalized velocity in the ContinuousState that this
Diagram reserves in its context.)""";

        } DoMapVelocityToQDot;

        // drake::systems::Diagram::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {

          // drake/systems/framework/diagram.h:69
          const char* doc = R"""()""";

        } GetDirectFeedthroughs;

        // drake::systems::Diagram::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {

          // drake/systems/framework/diagram.h:387
          const char* doc =
R"""(Returns a Graphviz fragment describing this Diagram. To obtain a
complete Graphviz graph, call System<T>::GetGraphvizString.)""";

        } GetGraphvizFragment;

        // drake::systems::Diagram::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {

          // drake/systems/framework/diagram.h:469
          const char* doc = R"""()""";

        } GetGraphvizInputPortToken;

        // drake::systems::Diagram::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {

          // drake/systems/framework/diagram.h:475
          const char* doc = R"""()""";

        } GetGraphvizOutputPortToken;

        // drake::systems::Diagram::GetMutableSubsystemCompositeEventCollection
        struct /* GetMutableSubsystemCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:340
          const char* doc =
R"""(Returns the mutable subsystem composite event collection that
corresponds to ``subsystem``. Aborts if ``subsystem`` is not a
subsystem of this diagram.)""";

        } GetMutableSubsystemCompositeEventCollection;

        // drake::systems::Diagram::GetMutableSubsystemContext
        struct /* GetMutableSubsystemContext */ {

          // drake/systems/framework/diagram.h:319
          const char* doc =
R"""(Returns the subcontext that corresponds to the system ``subsystem``.
Classes inheriting from Diagram need access to this method in order to
pass their constituent subsystems the appropriate subcontext. Aborts
if ``subsystem`` is not actually a subsystem of this diagram.)""";

        } GetMutableSubsystemContext;

        // drake::systems::Diagram::GetMutableSubsystemState
        struct /* GetMutableSubsystemState */ {

          // drake/systems/framework/diagram.h:355
          const char* doc =
R"""(Retrieves the state for a particular subsystem from the context for
the entire diagram. Invalidates all entries in that subsystem's cache
that depend on State. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.

TODO(david-german-tri): Provide finer-grained accessors for finer-
grained invalidation.)""";

          // drake/systems/framework/diagram.h:364
          const char* doc_2 =
R"""(Retrieves the state for a particular subsystem from the ``state`` for
the entire diagram. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";

        } GetMutableSubsystemState;

        // drake::systems::Diagram::GetSubsystemCompositeEventCollection
        struct /* GetSubsystemCompositeEventCollection */ {

          // drake/systems/framework/diagram.h:330
          const char* doc =
R"""(Returns the const subsystem composite event collection from ``events``
that corresponds to ``subsystem``. Aborts if ``subsystem`` is not a
subsystem of this diagram.)""";

        } GetSubsystemCompositeEventCollection;

        // drake::systems::Diagram::GetSubsystemContext
        struct /* GetSubsystemContext */ {

          // drake/systems/framework/diagram.h:308
          const char* doc =
R"""(Returns a constant reference to the subcontext that corresponds to the
system ``subsystem``. Classes inheriting from Diagram need access to
this method in order to pass their constituent subsystems the
appropriate subcontext. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";

        } GetSubsystemContext;

        // drake::systems::Diagram::GetSubsystemDerivatives
        struct /* GetSubsystemDerivatives */ {

          // drake/systems/framework/diagram.h:293
          const char* doc =
R"""(Retrieves the state derivatives for a particular subsystem from the
derivatives for the entire diagram. Aborts if ``subsystem`` is not
actually a subsystem of this diagram. Returns a 0-length
ContinuousState if ``subsystem`` has none.)""";

        } GetSubsystemDerivatives;

        // drake::systems::Diagram::GetSubsystemState
        struct /* GetSubsystemState */ {

          // drake/systems/framework/diagram.h:374
          const char* doc =
R"""(Retrieves the state for a particular subsystem from the ``state`` for
the entire diagram. Aborts if ``subsystem`` is not actually a
subsystem of this diagram.)""";

        } GetSubsystemState;

        // drake::systems::Diagram::GetSystemIndexOrAbort
        struct /* GetSystemIndexOrAbort */ {

          // drake/systems/framework/diagram.h:485
          const char* doc =
R"""(Returns the index of the given ``sys`` in this diagram, or aborts if
``sys`` is not a member of the diagram.)""";

        } GetSystemIndexOrAbort;

        // drake::systems::Diagram::GetSystems
        struct /* GetSystems */ {

          // drake/systems/framework/diagram.h:60
          const char* doc = R"""(Returns the list of contained Systems.)""";

        } GetSystems;

        // drake::systems::Diagram::SetDefaultParameters
        struct /* SetDefaultParameters */ {

          // drake/systems/framework/diagram.h:112
          const char* doc = R"""()""";

        } SetDefaultParameters;

        // drake::systems::Diagram::SetDefaultState
        struct /* SetDefaultState */ {

          // drake/systems/framework/diagram.h:96
          const char* doc = R"""()""";

        } SetDefaultState;

        // drake::systems::Diagram::SetRandomParameters
        struct /* SetRandomParameters */ {

          // drake/systems/framework/diagram.h:177
          const char* doc = R"""()""";

        } SetRandomParameters;

        // drake::systems::Diagram::SetRandomState
        struct /* SetRandomState */ {

          // drake/systems/framework/diagram.h:161
          const char* doc = R"""()""";

        } SetRandomState;

        // drake::systems::Diagram::get_num_continuous_states
        struct /* get_num_continuous_states */ {

          // drake/systems/framework/diagram.h:491
          const char* doc = R"""()""";

        } get_num_continuous_states;

      } Diagram;

      // drake::systems::DiagramBuilder
      struct /* DiagramBuilder */ {

        // drake/systems/framework/diagram.h:33
        const char* doc =
R"""(DiagramBuilder is a factory class for Diagram. It is single use: after
calling Build or BuildInto, DiagramBuilder gives up ownership of the
constituent systems, and should therefore be discarded.

A system must be added to the DiagramBuilder with AddSystem before it
can be wired up in any way. Every system must have a unique, non-empty
name.)""";

        // drake/systems/framework/diagram_builder.h:30
        const char* doc_2 =
R"""(DiagramBuilder is a factory class for Diagram. It is single use: after
calling Build or BuildInto, DiagramBuilder gives up ownership of the
constituent systems, and should therefore be discarded.

A system must be added to the DiagramBuilder with AddSystem before it
can be wired up in any way. Every system must have a unique, non-empty
name.)""";

        // drake::systems::DiagramBuilder::AddSystem
        struct /* AddSystem */ {

          // drake/systems/framework/diagram_builder.h:52
          const char* doc =
R"""(Takes ownership of ``system`` and adds it to the builder. Returns a
bare pointer to the System, which will remain valid for the lifetime
of the Diagram built by this builder.

If the system's name is unset, sets it to
System::GetMemoryObjectName() as a default in order to have unique
names within the diagram.

```
DiagramBuilder<T> builder;
  auto foo = builder.AddSystem(std::make_unique<Foo<T>>());
```

Template parameter ``S``:
    The type of system to add.)""";

          // drake/systems/framework/diagram_builder.h:84
          const char* doc_2 =
R"""(Constructs a new system with the given ``args``, and adds it to the
builder, which retains ownership. Returns a bare pointer to the
System, which will remain valid for the lifetime of the Diagram built
by this builder.

```
DiagramBuilder<double> builder;
  auto foo = builder.AddSystem<Foo<double>>("name", 3.14);
```

Note that for dependent names you must use the template keyword:

```
DiagramBuilder<T> builder;
  auto foo = builder.template AddSystem<Foo<T>>("name", 3.14);
```

You may prefer the `unique_ptr` variant instead.

Template parameter ``S``:
    The type of System to construct. Must subclass System<T>.)""";

          // drake/systems/framework/diagram_builder.h:111
          const char* doc_3 =
R"""(Constructs a new system with the given ``args``, and adds it to the
builder, which retains ownership. Returns a bare pointer to the
System, which will remain valid for the lifetime of the Diagram built
by this builder.

```
DiagramBuilder<double> builder;
  // Foo must be a template.
  auto foo = builder.AddSystem<Foo>("name", 3.14);
```

Note that for dependent names you must use the template keyword:

```
DiagramBuilder<T> builder;
  auto foo = builder.template AddSystem<Foo>("name", 3.14);
```

You may prefer the `unique_ptr` variant instead.

Template parameter ``S``:
    A template for the type of System to construct. The template will
    be specialized on the scalar type T of this builder.)""";

        } AddSystem;

        // drake::systems::DiagramBuilder::Build
        struct /* Build */ {

          // drake/systems/framework/diagram_builder.h:197
          const char* doc =
R"""(Builds the Diagram that has been described by the calls to Connect,
ExportInput, and ExportOutput. Throws std::logic_error if the graph is
not buildable.)""";

        } Build;

        // drake::systems::DiagramBuilder::BuildInto
        struct /* BuildInto */ {

          // drake/systems/framework/diagram_builder.h:208
          const char* doc =
R"""(Configures ``target`` to have the topology that has been described by
the calls to Connect, ExportInput, and ExportOutput. Throws
std::logic_error if the graph is not buildable.

Only Diagram subclasses should call this method. The target must not
already be initialized.)""";

        } BuildInto;

        // drake::systems::DiagramBuilder::Cascade
        struct /* Cascade */ {

          // drake/systems/framework/diagram_builder.h:156
          const char* doc =
R"""(Cascades ``src`` and ``dest``. The sole input port on the ``dest``
system is connected to sole output port on the ``src`` system. Throws
an exception if the sole-port precondition is not met (i.e., if
``dest`` has no input ports, or ``dest`` has more than one input port,
or ``src`` has no output ports, or ``src`` has more than one output
port).)""";

        } Cascade;

        // drake::systems::DiagramBuilder::Connect
        struct /* Connect */ {

          // drake/systems/framework/diagram_builder.h:129
          const char* doc =
R"""(Declares that input port ``dest`` is connected to output port ``src``.)""";

          // drake/systems/framework/diagram_builder.h:145
          const char* doc_2 =
R"""(Declares that sole input port on the ``dest`` system is connected to
sole output port on the ``src`` system. Throws an exception if the
sole-port precondition is not met (i.e., if ``dest`` has no input
ports, or ``dest`` has more than one input port, or ``src`` has no
output ports, or ``src`` has more than one output port).)""";

        } Connect;

        // drake::systems::DiagramBuilder::DiagramBuilder<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_builder.h:33
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_builder.h:33
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram_builder.h:35
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::DiagramBuilder::ExportInput
        struct /* ExportInput */ {

          // drake/systems/framework/diagram_builder.h:164
          const char* doc =
R"""(Declares that the given ``input`` port of a constituent system is an
input to the entire Diagram. ``name`` is an optional name for the
input port; if it is unspecified or empty, then a default name will be
provided.

Returns:
    The index of the exported input port of the entire diagram.)""";

        } ExportInput;

        // drake::systems::DiagramBuilder::ExportOutput
        struct /* ExportOutput */ {

          // drake/systems/framework/diagram_builder.h:186
          const char* doc =
R"""(Declares that the given ``output`` port of a constituent system is an
output of the entire diagram.

Returns:
    The index of the exported output port of the entire diagram.)""";

        } ExportOutput;

        // drake::systems::DiagramBuilder::GetMutableSystems
        struct /* GetMutableSystems */ {

          // drake/systems/framework/diagram_builder.h:119
          const char* doc = R"""(Returns the list of contained Systems.)""";

        } GetMutableSystems;

        // drake::systems::DiagramBuilder::empty
        struct /* empty */ {

          // drake/systems/framework/diagram_builder.h:116
          const char* doc =
R"""(Returns whether any Systems have been added yet.)""";

        } empty;

      } DiagramBuilder;

      // drake::systems::DiagramCompositeEventCollection
      struct /* DiagramCompositeEventCollection */ {

        // drake/systems/framework/event_collection.h:627
        const char* doc = R"""(CompositeEventCollection for a Diagram.)""";

        // drake::systems::DiagramCompositeEventCollection::DiagramCompositeEventCollection<T>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:630
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:630
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:636
          const char* doc_3 =
R"""(Allocated CompositeEventCollection for all constituent subsystems are
passed in ``subevents``, for which ownership is also transferred to
`this`.)""";

        } ctor;

        // drake::systems::DiagramCompositeEventCollection::get_mutable_subevent_collection
        struct /* get_mutable_subevent_collection */ {

          // drake/systems/framework/event_collection.h:688
          const char* doc = R"""()""";

        } get_mutable_subevent_collection;

        // drake::systems::DiagramCompositeEventCollection::get_subevent_collection
        struct /* get_subevent_collection */ {

          // drake/systems/framework/event_collection.h:696
          const char* doc = R"""()""";

        } get_subevent_collection;

        // drake::systems::DiagramCompositeEventCollection::num_subsystems
        struct /* num_subsystems */ {

          // drake/systems/framework/event_collection.h:681
          const char* doc =
R"""(Returns the number of subsystems for which this object contains event
collections.)""";

        } num_subsystems;

      } DiagramCompositeEventCollection;

      // drake::systems::DiagramContext
      struct /* DiagramContext */ {

        // drake/systems/framework/diagram_context.h:118
        const char* doc =
R"""(The DiagramContext is a container for all of the data necessary to
uniquely determine the computations performed by a Diagram.
Specifically, a DiagramContext contains Context objects for all its
constituent Systems.

See also:
    Context for more information.

In general, users should not need to interact with a DiagramContext
directly. Use the accessors on Diagram instead.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.)""";

        // drake::systems::DiagramContext::AddSystem
        struct /* AddSystem */ {

          // drake/systems/framework/diagram_context.h:146
          const char* doc =
R"""(Declares a new subsystem in the DiagramContext. Subsystems are
identified by number. If the subsystem has already been declared,
aborts.

User code should not call this method. It is for use during Diagram
context allocation only.)""";

        } AddSystem;

        // drake::systems::DiagramContext::DiagramContext<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_context.h:123
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_context.h:137
          const char* doc_2 =
R"""(Constructs a DiagramContext with the given ``num_subcontexts``, which
is final: you cannot resize a DiagramContext after construction. The
number and ordering of subcontexts is identical to the number and
ordering of subsystems in the corresponding Diagram.)""";

          // drake/systems/framework/diagram_context.h:358
          const char* doc_3 =
R"""(Protected copy constructor takes care of the local data members and
all base class members, but doesn't update base class pointers so is
not a complete copy.)""";

        } ctor;

        // drake::systems::DiagramContext::GetMutableSubsystemContext
        struct /* GetMutableSubsystemContext */ {

          // drake/systems/framework/diagram_context.h:348
          const char* doc =
R"""(Returns the context structure for a given subsystem ``index``. Aborts
if ``index`` is out of bounds, or if no system has been added to the
DiagramContext at that index. TODO(david-german-tri): Rename to
get_mutable_subsystem_context.)""";

        } GetMutableSubsystemContext;

        // drake::systems::DiagramContext::GetSubsystemContext
        struct /* GetSubsystemContext */ {

          // drake/systems/framework/diagram_context.h:338
          const char* doc =
R"""(Returns the context structure for a given constituent system
``index``. Aborts if ``index`` is out of bounds, or if no system has
been added to the DiagramContext at that index. TODO(david-german-
tri): Rename to get_subsystem_context.)""";

        } GetSubsystemContext;

        // drake::systems::DiagramContext::MakeParameters
        struct /* MakeParameters */ {

          // drake/systems/framework/diagram_context.h:312
          const char* doc =
R"""((Internal use only) Generates the parameters for the entire diagram by
wrapping the parameters of all the constituent Systems. The wrapper
simply holds pointers to the parameters in the subsystem Contexts. It
does not make a copy, or take ownership.)""";

        } MakeParameters;

        // drake::systems::DiagramContext::MakeState
        struct /* MakeState */ {

          // drake/systems/framework/diagram_context.h:297
          const char* doc =
R"""((Internal use only) Generates the state vector for the entire diagram
by wrapping the states of all the constituent diagrams.)""";

        } MakeState;

        // drake::systems::DiagramContext::SubscribeDiagramCompositeTrackersToChildrens
        struct /* SubscribeDiagramCompositeTrackersToChildrens */ {

          // drake/systems/framework/diagram_context.h:257
          const char* doc =
R"""((Internal use only) Makes the diagram state, parameter, and composite
cache entry trackers subscribe to the corresponding constituent
trackers in the child subcontexts.)""";

        } SubscribeDiagramCompositeTrackersToChildrens;

        // drake::systems::DiagramContext::SubscribeDiagramPortToExportedOutputPort
        struct /* SubscribeDiagramPortToExportedOutputPort */ {

          // drake/systems/framework/diagram_context.h:188
          const char* doc =
R"""((Internal use only) Declares that a particular output port of this
diagram is simply forwarded from an output port of one of its child
subsystems. Sets up tracking of the diagram port's dependency on the
child port. Aborts if the subsystem has not been added to the
DiagramContext.

User code should not call this method. It is for use during Diagram
context allocation only.)""";

        } SubscribeDiagramPortToExportedOutputPort;

        // drake::systems::DiagramContext::SubscribeExportedInputPortToDiagramPort
        struct /* SubscribeExportedInputPortToDiagramPort */ {

          // drake/systems/framework/diagram_context.h:160
          const char* doc =
R"""((Internal use only) Declares that a particular input port of a child
subsystem is an input to the entire Diagram that allocates this
Context. Sets up tracking of the child port's dependency on the parent
port. Aborts if the subsystem has not been added to the
DiagramContext.

User code should not call this method. It is for use during Diagram
context allocation only.)""";

        } SubscribeExportedInputPortToDiagramPort;

        // drake::systems::DiagramContext::SubscribeInputPortToOutputPort
        struct /* SubscribeInputPortToOutputPort */ {

          // drake/systems/framework/diagram_context.h:221
          const char* doc =
R"""((Internal use only) Declares that a connection exists between a peer
output port and input port in this Diagram, and registers the input
port's dependency tracker with the output port's dependency tracker.
By "peer" we mean that both ports belong to immediate child subsystems
of this Diagram (it is also possible for both ports to belong to the
same subsystem).

User code should not call this method. It is for use during Diagram
context allocation only.)""";

        } SubscribeInputPortToOutputPort;

      } DiagramContext;

      // drake::systems::DiagramContinuousState
      struct /* DiagramContinuousState */ {

        // drake/systems/framework/diagram_continuous_state.h:32
        const char* doc =
R"""(DiagramContinuousState is a ContinuousState consisting of Supervectors
xc, q, v, z over the corresponding entries in a set of referenced
ContinuousState objects, which may or may not be owned by this
DiagramContinuousState. This is done recursively since any of the
referenced ContinuousState objects could themselves be
DiagramContinuousState objects. The actual numerical data is always
contained in the leaf ContinuousState objects at the bottom of the
tree.

This object is used both for a Diagram's actual continuous state
variables xc (with partitions q, v, z) and for the time derivatives
xdot (qdot, vdot, zdot). Cloning a DiagramContinuousState results in
an object with identical structure, but which owns the referenced
ContinuousState objects, regardless of whether the original had
ownership.

Template parameter ``T``:
    The type of the output data. Must be a valid Eigen scalar.)""";

        // drake::systems::DiagramContinuousState::Clone
        struct /* Clone */ {

          // drake/systems/framework/diagram_continuous_state.h:66
          const char* doc =
R"""(Creates a deep copy of this DiagramContinuousState, with the same
substructure but with new, owned data. Intentionally shadows the
ContinuousState::Clone() method but with a more-specific return type
so you don't have to downcast.)""";

        } Clone;

        // drake::systems::DiagramContinuousState::DiagramContinuousState<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_continuous_state.h:34
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_continuous_state.h:34
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram_continuous_state.h:43
          const char* doc_3 =
R"""(Constructs a ContinuousState that is composed of other
ContinuousStates, which are not owned by this object and must outlive
it.

The DiagramContinuousState vector xc = [q v z] will have the same
ordering as the `substates` parameter, which should be the order of
the Diagram itself. That is, the substates should be indexed by ///
SubsystemIndex in the same order as the subsystems are.)""";

          // drake/systems/framework/diagram_continuous_state.h:53
          const char* doc_4 =
R"""(Constructs a ContinuousState that is composed (recursively) of other
ContinuousState objects, ownership of which is transferred here.)""";

        } ctor;

        // drake::systems::DiagramContinuousState::get_mutable_substate
        struct /* get_mutable_substate */ {

          // drake/systems/framework/diagram_continuous_state.h:84
          const char* doc =
R"""(Returns the continuous state at the given `index`. Aborts if `index`
is out-of-bounds.)""";

        } get_mutable_substate;

        // drake::systems::DiagramContinuousState::get_substate
        struct /* get_substate */ {

          // drake/systems/framework/diagram_continuous_state.h:76
          const char* doc =
R"""(Returns the continuous state at the given `index`. Aborts if `index`
is out-of-bounds.)""";

        } get_substate;

        // drake::systems::DiagramContinuousState::num_substates
        struct /* num_substates */ {

          // drake/systems/framework/diagram_continuous_state.h:72
          const char* doc = R"""()""";

        } num_substates;

      } DiagramContinuousState;

      // drake::systems::DiagramDiscreteValues
      struct /* DiagramDiscreteValues */ {

        // drake/systems/framework/diagram_discrete_values.h:27
        const char* doc =
R"""(DiagramDiscreteValues is a DiscreteValues container comprised
recursively of a sequence of child DiscreteValues objects. The API
allows this to be treated as though it were a single DiscreteValues
object whose groups are the concatenation of the groups in each child.

The child objects may be owned or not. When this is used to aggregate
LeafSystem discrete values in a Diagram, the child objects are not
owned. When this is cloned, deep copies are made that are owned here.)""";

        // drake::systems::DiagramDiscreteValues::Clone
        struct /* Clone */ {

          // drake/systems/framework/diagram_discrete_values.h:62
          const char* doc =
R"""(Creates a deep copy of this DiagramDiscreteValues object, with the
same substructure but with new, owned data. Intentionally shadows the
DiscreteValues::Clone() method but with a more-specific return type so
you don't have to downcast.)""";

        } Clone;

        // drake::systems::DiagramDiscreteValues::DiagramDiscreteValues<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_discrete_values.h:29
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_discrete_values.h:29
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram_discrete_values.h:39
          const char* doc_3 =
R"""(Constructs a DiagramDiscreteValues object that is composed of other
DiscreteValues, which are not owned by this object and must outlive
it.

The DiagramDiscreteValues vector xd = [xd₁ xd₂ ...] where each of the
xdᵢ is an array of BasicVector objects. These will have the same
ordering as the ``subdiscretes`` parameter, which should be the order
of the Diagram itself. That is, the substates should be indexed by
SubsystemIndex in the same order as the subsystems are.)""";

          // drake/systems/framework/diagram_discrete_values.h:47
          const char* doc_4 =
R"""(Constructs a DiagramDiscreteValues object that is composed
(recursively) of other DiscreteValues objects, ownership of which is
transferred here.)""";

        } ctor;

        // drake::systems::DiagramDiscreteValues::get_mutable_subdiscrete
        struct /* get_mutable_subdiscrete */ {

          // drake/systems/framework/diagram_discrete_values.h:85
          const char* doc =
R"""(Returns a mutable reference to one of the referenced DiscreteValues
objects which may or may not be owned locally.)""";

        } get_mutable_subdiscrete;

        // drake::systems::DiagramDiscreteValues::get_subdiscrete
        struct /* get_subdiscrete */ {

          // drake/systems/framework/diagram_discrete_values.h:77
          const char* doc =
R"""(Returns a const reference to one of the referenced DiscreteValues
objects which may or may not be owned locally.)""";

        } get_subdiscrete;

        // drake::systems::DiagramDiscreteValues::num_subdiscretes
        struct /* num_subdiscretes */ {

          // drake/systems/framework/diagram_discrete_values.h:71
          const char* doc =
R"""(Returns the number of DiscreteValues objects referenced by this
DiagramDiscreteValues object, necessarily the same as the number of
subcontexts in the containing DiagramContext.)""";

        } num_subdiscretes;

      } DiagramDiscreteValues;

      // drake::systems::DiagramEventCollection
      struct /* DiagramEventCollection */ {

        // drake/systems/framework/event_collection.h:158
        const char* doc =
R"""(A concrete class that holds all simultaneous homogeneous events for a
Diagram. For each subsystem in the corresponding Diagram, a derived
EventCollection instance is maintained internally, thus effectively
holding the same recursive tree structure as the corresponding
Diagram.)""";

        // drake::systems::DiagramEventCollection::Clear
        struct /* Clear */ {

          // drake/systems/framework/event_collection.h:237
          const char* doc = R"""(Clears all subevent collections.)""";

        } Clear;

        // drake::systems::DiagramEventCollection::DiagramEventCollection<EventType>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:160
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:160
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:168
          const char* doc_3 =
R"""(Note that this constructor only resizes the containers; it does not
allocate any derived EventCollection instances.

Parameter ``num_subsystems``:
    Number of subsystems in the corresponding Diagram.)""";

        } ctor;

        // drake::systems::DiagramEventCollection::DoMerge
        struct /* DoMerge */ {

          // drake/systems/framework/event_collection.h:264
          const char* doc =
R"""(Goes through each subevent collection and merges in the corresponding
one in ``other_collection``. Aborts if `this` does not have the same
number of subevent collections as ``other_collection``. In addition,
this method assumes that `this` and ``other_collection`` have the
exact same topology (i.e. both are created for the same Diagram.)

Throws:
    s std::bad_cast if ``other_collection`` is not an instance of
    DiagramEventCollection.)""";

        } DoMerge;

        // drake::systems::DiagramEventCollection::HasEvents
        struct /* HasEvents */ {

          // drake/systems/framework/event_collection.h:247
          const char* doc =
R"""(Returns `true` if and only if any of the subevent collections have any
events.)""";

        } HasEvents;

        // drake::systems::DiagramEventCollection::add_event
        struct /* add_event */ {

          // drake/systems/framework/event_collection.h:176
          const char* doc =
R"""(Aborts if called, because no events should be added at the Diagram
level.)""";

        } add_event;

        // drake::systems::DiagramEventCollection::get_mutable_subevent_collection
        struct /* get_mutable_subevent_collection */ {

          // drake/systems/framework/event_collection.h:229
          const char* doc =
R"""(Returns a mutable pointer to subsystem's EventCollection at ``index``.)""";

        } get_mutable_subevent_collection;

        // drake::systems::DiagramEventCollection::get_subevent_collection
        struct /* get_subevent_collection */ {

          // drake/systems/framework/event_collection.h:221
          const char* doc =
R"""(Returns a const pointer to subsystem's EventCollection at ``index``.
Aborts if the 0-indexed ``index`` is greater than or equal to the
number of subsystems specified in this object's construction (see
DiagramEventCollection(int)) or if ``index`` is not in the range [0,
num_subsystems() - 1].)""";

        } get_subevent_collection;

        // drake::systems::DiagramEventCollection::num_subsystems
        struct /* num_subsystems */ {

          // drake/systems/framework/event_collection.h:182
          const char* doc =
R"""(Returns the number of constituent EventCollection objects that
correspond to each subsystem in the Diagram.)""";

        } num_subsystems;

        // drake::systems::DiagramEventCollection::set_and_own_subevent_collection
        struct /* set_and_own_subevent_collection */ {

          // drake/systems/framework/event_collection.h:191
          const char* doc =
R"""(Transfers ``subevent_collection`` ownership to `this` and associates
it with the subsystem identified by ``index``. Aborts if ``index`` is
not in the range [0, num_subsystems() - 1] or if
``subevent_collection`` is null.)""";

        } set_and_own_subevent_collection;

        // drake::systems::DiagramEventCollection::set_subevent_collection
        struct /* set_subevent_collection */ {

          // drake/systems/framework/event_collection.h:207
          const char* doc =
R"""(Associate ``subevent_collection`` with subsystem identified by
``index``. Ownership of the object that ``subevent_collection`` is
maintained elsewhere, and its life span must be longer than this.
Aborts if ``index`` is not in the range [0, num_subsystems() - 1] or
if ``subevent_collection`` is null.)""";

        } set_subevent_collection;

      } DiagramEventCollection;

      // drake::systems::DiagramOutputPort
      struct /* DiagramOutputPort */ {

        // drake/systems/framework/diagram_output_port.h:31
        const char* doc =
R"""(Holds information about a subsystem output port that has been exported
to become one of this Diagram's output ports. The actual methods for
determining the port's value are supplied by the LeafOutputPort that
ultimately underlies the source port, although that may be any number
of levels down.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::systems::DiagramOutputPort::DiagramOutputPort<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_output_port.h:33
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_output_port.h:33
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram_output_port.h:60
          const char* doc_3 =
R"""((Internal use only) Constructs a DiagramOutputPort that exports an
output port of one of the diagram's child subsystems.

Parameter ``diagram``:
    The Diagram that will own this port.

Parameter ``system_base``:
    The same Diagram cast to its base class.

Parameter ``index``:
    The output port index to be assigned to the new port.

Parameter ``ticket``:
    The DependencyTicket to be assigned to the new port.

Parameter ``source_output_port``:
    An output port of one of this diagram's child subsystems that is
    to be forwarded to the new port.

Parameter ``source_subsystem_index``:
    The index of the child subsystem that owns `source_output_port`.

@pre The `diagram` System must actually be a Diagram. @pre `diagram`
lifetime must exceed the port's; we retain the pointer here. @pre
`diagram` and `system_base` must be the same object. @pre
`source_output_port` must be owned by a child of `diagram`. @pre
`source_subsystem_index` must be the index of that child in `diagram`.

This is intended only for use by Diagram and we depend on the caller
to meet the above preconditions, not all of which can be independently
verified here.)""";

        } ctor;

        // drake::systems::DiagramOutputPort::get_source_output_port
        struct /* get_source_output_port */ {

          // drake/systems/framework/diagram_output_port.h:81
          const char* doc =
R"""(Obtains a reference to the subsystem output port that was exported to
create this diagram port. Note that the source may itself be a diagram
output port.)""";

        } get_source_output_port;

      } DiagramOutputPort;

      // drake::systems::DiagramState
      struct /* DiagramState */ {

        // drake/systems/framework/diagram_context.h:27
        const char* doc =
R"""(DiagramState is a State, annotated with pointers to all the mutable
substates that it spans.)""";

        // drake::systems::DiagramState::DiagramState<T>
        struct /* ctor */ {

          // drake/systems/framework/diagram_context.h:29
          const char* doc = R"""()""";

          // drake/systems/framework/diagram_context.h:29
          const char* doc_2 = R"""()""";

          // drake/systems/framework/diagram_context.h:32
          const char* doc_3 =
R"""(Constructs a DiagramState consisting of ``size`` substates.)""";

        } ctor;

        // drake::systems::DiagramState::Finalize
        struct /* Finalize */ {

          // drake/systems/framework/diagram_context.h:65
          const char* doc =
R"""(Finalizes this state as a span of all the constituent substates.)""";

        } Finalize;

        // drake::systems::DiagramState::get_mutable_substate
        struct /* get_mutable_substate */ {

          // drake/systems/framework/diagram_context.h:59
          const char* doc = R"""(Returns the substate at ``index``.)""";

        } get_mutable_substate;

        // drake::systems::DiagramState::get_substate
        struct /* get_substate */ {

          // drake/systems/framework/diagram_context.h:53
          const char* doc = R"""(Returns the substate at ``index``.)""";

        } get_substate;

        // drake::systems::DiagramState::set_and_own_substate
        struct /* set_and_own_substate */ {

          // drake/systems/framework/diagram_context.h:47
          const char* doc =
R"""(Sets the substate at ``index`` to ``substate``, or aborts if ``index``
is out of bounds.)""";

        } set_and_own_substate;

        // drake::systems::DiagramState::set_substate
        struct /* set_substate */ {

          // drake/systems/framework/diagram_context.h:40
          const char* doc =
R"""(Sets the substate at ``index`` to ``substate``, or aborts if ``index``
is out of bounds. Does not take ownership of ``substate``, which must
live as long as this object.)""";

        } set_substate;

      } DiagramState;

      // drake::systems::DiscreteStateTag
      struct /* DiscreteStateTag */ {

        // drake/systems/framework/framework_common.h:49
        const char* doc = R"""()""";

      } DiscreteStateTag;

      // drake::systems::DiscreteUpdateEvent
      struct /* DiscreteUpdateEvent */ {

        // drake/systems/framework/event.h:404
        const char* doc =
R"""(This class represents a discrete update event. It has an optional
callback function to do custom handling of this event given const
Context and const DiscreteUpdateEvent references, and writes the
updates to a mutable, non-null DiscreteValues object.)""";

        // drake::systems::DiscreteUpdateEvent::DiscreteUpdateEvent<T>
        struct /* ctor */ {

          // drake/systems/framework/event.h:407
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:420
          const char* doc_2 =
R"""(Makes a DiscreteUpdateEvent with no trigger type, no event data, and
no specified callback function.)""";

          // drake/systems/framework/event.h:424
          const char* doc_3 =
R"""(Makes a DiscreteUpdateEvent with no trigger type, no event data, and
the specified callback function.)""";

          // drake/systems/framework/event.h:432
          const char* doc_4 = R"""()""";

          // drake/systems/framework/event.h:438
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::systems::DiscreteUpdateEvent::add_to_composite
        struct /* add_to_composite */ {

          // drake/systems/framework/event.h:448
          const char* doc =
R"""(Assuming that ``events`` is not null, this function makes a deep copy
of this event and adds the deep copy to ``events``'s collection of
discrete update events.)""";

        } add_to_composite;

        // drake::systems::DiscreteUpdateEvent::handle
        struct /* handle */ {

          // drake/systems/framework/event.h:458
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``,
'this' and ``discrete_state``.)""";

        } handle;

        // drake::systems::DiscreteUpdateEvent::is_discrete_update
        struct /* is_discrete_update */ {

          // drake/systems/framework/event.h:409
          const char* doc = R"""()""";

        } is_discrete_update;

      } DiscreteUpdateEvent;

      // drake::systems::DiscreteValues
      struct /* DiscreteValues */ {

        // drake/systems/framework/discrete_values.h:33
        const char* doc =
R"""(DiscreteValues is a container for numerical but non-continuous state
and parameters. It may own its underlying data, for use with leaf
Systems, or not, for use with Diagrams.

DiscreteValues is an ordered collection xd of BasicVector "groups" so
xd = [xd₀, xd₁...], where each group xdᵢ is a contiguous vector.
Requesting a specific group index from this collection is the most
granular way to retrieve discrete values from the Context, and thus is
the unit of cache invalidation. System authors are encouraged to
partition their DiscreteValues such that each cacheable computation
within the System may depend on only the elements of DiscreteValues
that it needs.

None of the contained vectors (groups) may be null, although any of
them may be zero-length.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::DiscreteValues::Clone
        struct /* Clone */ {

          // drake/systems/framework/discrete_values.h:149
          const char* doc =
R"""(Creates a deep copy of this object with the same substructure but with
all data owned by the copy. That is, if the original was a
DiagramDiscreteValues object that maintains a tree of substates, the
clone will not include any references to the original substates and is
thus decoupled from the Context containing the original. The concrete
type of the BasicVector underlying each leaf DiscreteValue is
preserved.)""";

        } Clone;

        // drake::systems::DiscreteValues::CopyFrom
        struct /* CopyFrom */ {

          // drake/systems/framework/discrete_values.h:136
          const char* doc =
R"""(Writes the values from ``other`` into this DiscreteValues, possibly
writing through to unowned data. Asserts if the dimensions don't
match.)""";

        } CopyFrom;

        // drake::systems::DiscreteValues::DiscreteValues<T>
        struct /* ctor */ {

          // drake/systems/framework/discrete_values.h:36
          const char* doc = R"""()""";

          // drake/systems/framework/discrete_values.h:36
          const char* doc_2 = R"""()""";

          // drake/systems/framework/discrete_values.h:39
          const char* doc_3 =
R"""(Constructs an empty DiscreteValues object containing no groups.)""";

          // drake/systems/framework/discrete_values.h:44
          const char* doc_4 =
R"""(Constructs a DiscreteValues that does not own the underlying ``data``.
The referenced data must outlive this DiscreteValues. Every entry must
be non-null.)""";

          // drake/systems/framework/discrete_values.h:54
          const char* doc_5 =
R"""(Constructs a DiscreteValues that owns the underlying ``data``. Every
entry must be non-null.)""";

          // drake/systems/framework/discrete_values.h:66
          const char* doc_6 =
R"""(Constructs a one-group DiscreteValues object that owns a single
``datum`` vector which may not be null.)""";

        } ctor;

        // drake::systems::DiscreteValues::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/discrete_values.h:141
          const char* doc =
R"""(Resets the values in this DiscreteValues from the values in ``other``,
possibly writing through to unowned data. Asserts if the dimensions
don't match.)""";

        } SetFrom;

        // drake::systems::DiscreteValues::get_data
        struct /* get_data */ {

          // drake/systems/framework/discrete_values.h:77
          const char* doc = R"""()""";

        } get_data;

        // drake::systems::DiscreteValues::get_mutable_vector
        struct /* get_mutable_vector */ {

          // drake/systems/framework/discrete_values.h:112
          const char* doc =
R"""(Returns a mutable reference to the BasicVector containing the values
for the _only_ group.)""";

          // drake/systems/framework/discrete_values.h:128
          const char* doc_2 =
R"""(Returns a mutable reference to the vector holding data for the
indicated group.)""";

        } get_mutable_vector;

        // drake::systems::DiscreteValues::get_vector
        struct /* get_vector */ {

          // drake/systems/framework/discrete_values.h:105
          const char* doc =
R"""(Returns a const reference to the BasicVector containing the values for
the _only_ group.)""";

          // drake/systems/framework/discrete_values.h:120
          const char* doc_2 =
R"""(Returns a const reference to the vector holding data for the indicated
group.)""";

        } get_vector;

        // drake::systems::DiscreteValues::num_groups
        struct /* num_groups */ {

          // drake/systems/framework/discrete_values.h:75
          const char* doc = R"""()""";

        } num_groups;

        // drake::systems::DiscreteValues::operator[]
        struct /* operator_array */ {

          // drake/systems/framework/discrete_values.h:92
          const char* doc =
R"""(Returns a mutable reference to an element in the _only_ group.)""";

          // drake/systems/framework/discrete_values.h:98
          const char* doc_2 =
R"""(Returns a const reference to an element in the _only_ group.)""";

        } operator_array;

        // drake::systems::DiscreteValues::size
        struct /* size */ {

          // drake/systems/framework/discrete_values.h:86
          const char* doc =
R"""(Returns the number of elements in the only DiscreteValues group.)""";

        } size;

      } DiscreteValues;

      // drake::systems::DrakeVisualizer
      struct /* DrakeVisualizer */ {

        // drake/multibody/rigid_body_plant/drake_visualizer.h:55
        const char* doc =
R"""(This is a Drake System block that takes a RigidBodyTree and publishes
LCM messages that are intended for drake-visualizer. It does this in
two phases: initialization and run-time. This system holds a
DiscreteState in its context that identifies whether the
initialization phase has been completed. It is initialized to false in
SetDefaultState(). The initialization phase is performed in
DoCalcDiscreteVariableUpdates(), which is scheduled by
DoCalcNextUpdateTime(). This class is intended to be used only in the
System framework with proper event handling. If this is not the use
case, users are encouraged to send the LCM messages directly through
LCM. ViewerDrawTranslator and multibody::CreateLoadRobotMessage() are
useful for generating the appropriate LCM messages.

During initialization, this system block analyzes the RigidBodyTree
and tells Drake Visualizer what it will be visualizing. For example,
these include the number of rigid bodies, their dimensions, and
colors. The LCM message used during this phase is called
`lcmt_viewer_load_robot` and the channel name is
"DRAKE_VIEWER_LOAD_ROBOT".

During run-time, this system block takes the current state of the
model and tells drake-visualizer how to visualize the model. For
example, this includes the position and orientation of each rigid
body. The LCM messages used during this phase is `lcmt_viewer_draw`
and the channel name is "DRAKE_VIEWER_DRAW".

The visualizer has an option that causes it to save the state it
dispatches for drawing and allows replay of that cached data at wall
clock time -- i.e., one second of simulation is played back for every
second in the real world. The playback *rate* is currently capped at
60 Hz. This is useful for immediate review of simulations which
evaluate at time rates radically out of scale with wall clock time,
enabling intuitive understanding of the simulation results. See
ReplayCachedSimulation().)""";

        // drake::systems::DrakeVisualizer::DrakeVisualizer
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/drake_visualizer.h:57
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/drake_visualizer.h:57
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/drake_visualizer.h:76
          const char* doc_3 =
R"""(A constructor that prepares for the transmission of `lcmt_viewer_draw`
and `lcmt_viewer_load_robot` messages, but does not actually publish
anything. LCM message publications occur each time
DrakeVisualizer::Publish() is called.

Parameter ``tree``:
    A reference to the rigid body tree that should be visualized by
    Drake Visualizer. This reference must remain valid for the
    duration of this object.

Parameter ``lcm``:
    A pointer to the object through which LCM messages can be
    published. This pointer must remain valid for the duration of this
    object.

Parameter ``enable_playback``:
    If true, the visualizer will cache the input data for playback and
    ReplayCachedSimulation() will replay that cache data.)""";

        } ctor;

        // drake::systems::DrakeVisualizer::PlaybackTrajectory
        struct /* PlaybackTrajectory */ {

          // drake/multibody/rigid_body_plant/drake_visualizer.h:108
          const char* doc =
R"""(Plays back (at real time) a trajectory representing the input signal.)""";

        } PlaybackTrajectory;

        // drake::systems::DrakeVisualizer::PublishLoadRobot
        struct /* PublishLoadRobot */ {

          // drake/multibody/rigid_body_plant/drake_visualizer.h:117
          const char* doc =
R"""(Publishes a lcmt_viewer_load_robot message containing a description of
what should be visualized. The message is intended to be received by
drake-visualizer. This method is automatically invoked when the
DrakeVisualizer instance is analyzed by a systems::Simulator.)""";

        } PublishLoadRobot;

        // drake::systems::DrakeVisualizer::ReplayCachedSimulation
        struct /* ReplayCachedSimulation */ {

          // drake/multibody/rigid_body_plant/drake_visualizer.h:103
          const char* doc =
R"""(Causes the visualizer to playback its cached data at real time. If it
has not been configured to record/playback, a warning message will be
written to the log, but otherwise, no work will be done.)""";

        } ReplayCachedSimulation;

        // drake::systems::DrakeVisualizer::set_publish_period
        struct /* set_publish_period */ {

          // drake/multibody/rigid_body_plant/drake_visualizer.h:85
          const char* doc =
R"""(Sets the publishing period of this system. See
LeafSystem::DeclarePublishPeriodSec() for details about the semantics
of parameter `period`.)""";

        } set_publish_period;

      } DrakeVisualizer;

      // drake::systems::Event
      struct /* Event */ {

        // drake/systems/framework/event.h:166
        const char* doc =
R"""(Abstract base class that represents an event. The base event contains
two main pieces of information: an enum trigger type and an optional
attribute of AbstractValue that can be used to explain why the event
is triggered. Derived classes should contain a function pointer to an
optional callback function that handles the event. No-op is the
default handling behavior. Currently, the System framework only
supports three concrete event types: PublishEvent,
DiscreteUpdateEvent, and UnrestrictedUpdateEvent distinguished by
their callback functions' access level to the context.)""";

        // drake::systems::Event::Clone
        struct /* Clone */ {

          // drake/systems/framework/event.h:245
          const char* doc = R"""(Clones this instance.)""";

        } Clone;

        // drake::systems::Event::DoClone
        struct /* DoClone */ {

          // drake/systems/framework/event.h:308
          const char* doc =
R"""(Derived classes must implement this method to clone themselves. Any
Event-specific data is cloned using the Clone() method. Data specific
to the class derived from Event must be cloned by the implementation.)""";

        } DoClone;

        // drake::systems::Event::Event<T>
        struct /* ctor */ {

          // drake/systems/framework/event.h:169
          const char* doc =
R"""(Constructs an Event with no trigger type and no event data.)""";

          // drake/systems/framework/event.h:171
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event.h:292
          const char* doc_3 = R"""()""";

          // drake/systems/framework/event.h:300
          const char* doc_4 =
R"""(Constructs an Event with the specified ``trigger``.)""";

        } ctor;

        // drake::systems::Event::TriggerType
        struct /* TriggerType */ {

          // drake/systems/framework/event.h:181
          const char* doc =
R"""(Predefined types of triggers. Used at run time to determine why the
associated event has occurred.)""";

          // drake::systems::Event::TriggerType::kForced
          struct /* kForced */ {

            // drake/systems/framework/event.h:195
            const char* doc =
R"""(This trigger indicates that an associated event is triggered by
directly calling the corresponding public system API for event
handling (e.g. Publish(context)).)""";

          } kForced;

          // drake::systems::Event::TriggerType::kInitialization
          struct /* kInitialization */ {

            // drake/systems/framework/event.h:188
            const char* doc =
R"""(This trigger indicates that an associated event is triggered at system
initialization.)""";

          } kInitialization;

          // drake::systems::Event::TriggerType::kPerStep
          struct /* kPerStep */ {

            // drake/systems/framework/event.h:227
            const char* doc =
R"""(This trigger indicates that an associated event is triggered whenever
a `solver` takes a `step`. A `solver` is an abstract construct that
controls the time and state evolution of a System. For example, a
simulator is a `solver`. Its `step` advances time a finite duration by
integrating a system, modifying its state accordingly. Per-step events
are most commonly created in System::GetPerStepEvents(). A very common
use of such per-step events is to update a discrete or abstract state
variable that changes whenever the continuous state advances; examples
are computing the "min" or "max" of some state variable, recording a
signal in a delay buffer, or publishing. Per-step events are also
useful to implement feedback controllers interfaced with physical
devices; the controller can be implemented in the event handler, and
the "step" would correspond to receiving sensory data from the
hardware.)""";

          } kPerStep;

          // drake::systems::Event::TriggerType::kPeriodic
          struct /* kPeriodic */ {

            // drake/systems/framework/event.h:210
            const char* doc =
R"""(This type indicates that an associated event is triggered by the
system proceeding to a time t ∈ {tᵢ = t₀ + p * i} for some period p,
time offset t₀, and i is a non-negative integer.

See also:
    PeriodicEventData. Periodic events are commonly created in
    System::CalcNextUpdateTime().)""";

          } kPeriodic;

          // drake::systems::Event::TriggerType::kTimed
          struct /* kTimed */ {

            // drake/systems/framework/event.h:202
            const char* doc =
R"""(This trigger indicates that an associated event is triggered by the
system proceeding to a single, arbitrary time. Timed events are
commonly created in System::CalcNextUpdateTime().)""";

          } kTimed;

          // drake::systems::Event::TriggerType::kUnknown
          struct /* kUnknown */ {

            // drake/systems/framework/event.h:182
            const char* doc = R"""()""";

          } kUnknown;

          // drake::systems::Event::TriggerType::kWitness
          struct /* kWitness */ {

            // drake/systems/framework/event.h:233
            const char* doc =
R"""(This trigger indicates that an associated event is triggered by the
zero crossing of a witness function.)""";

          } kWitness;

        } TriggerType;

        // drake::systems::Event::add_to_composite
        struct /* add_to_composite */ {

          // drake/systems/framework/event.h:289
          const char* doc =
R"""(Adds `this` event to the event collection ``events``. See derived
implementations for more details.)""";

        } add_to_composite;

        // drake::systems::Event::get_event_data
        struct /* get_event_data */ {

          // drake/systems/framework/event.h:264
          const char* doc =
R"""(Returns a const pointer to the event data. The returned value can be
nullptr, which means this event does not have any associated data.)""";

        } get_event_data;

        // drake::systems::Event::get_mutable_event_data
        struct /* get_mutable_event_data */ {

          // drake/systems/framework/event.h:271
          const char* doc =
R"""(Returns a mutable pointer to the event data. The returned value can be
nullptr, which means this event does not have any associated data.)""";

        } get_mutable_event_data;

        // drake::systems::Event::get_trigger_type
        struct /* get_trigger_type */ {

          // drake/systems/framework/event.h:252
          const char* doc = R"""(Returns the trigger type.)""";

        } get_trigger_type;

        // drake::systems::Event::has_event_data
        struct /* has_event_data */ {

          // drake/systems/framework/event.h:257
          const char* doc =
R"""(Returns true if this event has associated data.)""";

        } has_event_data;

        // drake::systems::Event::is_discrete_update
        struct /* is_discrete_update */ {

          // drake/systems/framework/event.h:175
          const char* doc =
R"""(Returns `true` if this is a DiscreteUpdateEvent.)""";

        } is_discrete_update;

        // drake::systems::Event::set_event_data
        struct /* set_event_data */ {

          // drake/systems/framework/event.h:280
          const char* doc = R"""()""";

        } set_event_data;

        // drake::systems::Event::set_trigger_type
        struct /* set_trigger_type */ {

          // drake/systems/framework/event.h:276
          const char* doc = R"""()""";

        } set_trigger_type;

      } Event;

      // drake::systems::EventCollection
      struct /* EventCollection */ {

        // drake/systems/framework/event.h:21
        const char* doc =
R"""(There are three concrete event types for any System: publish, discrete
state update, and unrestricted state update, listed in order of
increasing ability to change the state (i.e., zero to all).
EventCollection is an abstract base class that stores simultaneous
events *of the same type* that occur *at the same time* (i.e.,
simultaneous events).

For each concrete event type, the LeafSystem API provides a unique
customizable function for processing all simultaneous events of that
type, e.g. LeafSystem::DoPublish(const Context&, const vector<const
PublishEvent*>&) for publish events, where the second argument
represents all of the publish events that occur simultaneously for
that leaf system. The default implementation processes the events
(i.e., call their callback functions) in the order in which they are
stored in the second argument. The developer of new classes derived
from LeafSystem is responsible for overriding such functions if the
custom LeafSystem behavior depends on the order in which events are
processed. For example, suppose two publish events are being
processed, `events = {per-step publish, periodic publish}`. Depending
on the desired behavior, the developer has the freedom to ignore both
events, perform only one publish action, or perform both publish
actions in any arbitrary order. The System and Diagram API provide
only dispatch mechanisms that delegate actual event handling to the
constituent leaf systems. The Simulator promises that for each set of
simultaneous events of the same type, the public event handling method
(e.g. System::Publish(context, publish_events)) will be invoked
exactly once.

The System API provides several functions for customizable event
generation such as System::DoCalcNextUpdateTime() or
System::DoGetPerStepEvents(). These functions can return any number of
events of arbitrary types, and the resulting events are stored in
separate CompositeEventCollection instances. Before calling the event
handlers, all of these CompositeEventCollection objects must be merged
to generate a complete set of simultaneous events. Then, only events
of the appropriate type are passed to the event handlers. e.g.
sys.Publish(context, combined_event_collection.get_publish_events()).
For example, the Simulator executes this collation process when it is
applied to simulate a system.

Here is a complete example. For some LeafSystem `sys` at time `t`, its
System::DoCalcNextUpdateTime() generates the following
CompositeEventCollection (`events1`):

```
PublishEvent: {event1(kPeriodic, callback1)}
  DiscreteUpdateEvent: {event2(kPeriodic, callback2)}
  UnrestrictedUpdateEvent: {}
```

This LeafSystem also desires per-step event processing(`events2`),
generated by its implementation of System::DoGetPerStepEvents():

```
PublishEvent: {event3(kPerStep, callback3)}
  DiscreteUpdateEvent: {}
  UnrestrictedUpdateEvent: {event4(kPerStep,callback4)}
```

These collections of "simultaneous" events, `events1` and `events2`,
are then merged into the composite event collection `all_events`:

```
PublishEvent: {event1, event3}
  DiscreteUpdateEvent: {event2}
  UnrestrictedUpdateEvent: {event4}
```

This heterogeneous event collection can be processed by calling the
appropriate handler on the appropriate homogeneous subcollection:

```
sys.CalcUnrestrictedUpdate(context,
      all_events.get_unrestricted_update_events(), state);
  sys.CalcDiscreteVariableUpdates(context,
      all_events.get_discrete_update_events(), discrete_state);
  sys.Publish(context, all_events.get_publish_events())
```

For a LeafSystem, this is equivalent to (by expanding the dispatch
mechanisms in the System API):

```
sys.DoCalcUnrestrictedUpdate(context, {event4}, state);
  sys.DoCalcDiscreteVariableUpdates(context, {event2}, discrete_state);
  sys.DoPublish(context, {event1, event3})
```

Template parameter ``EventType``:
    a concrete derived type of Event (e.g., PublishEvent).)""";

        // drake/systems/framework/event_collection.h:97
        const char* doc_2 =
R"""(There are three concrete event types for any System: publish, discrete
state update, and unrestricted state update, listed in order of
increasing ability to change the state (i.e., zero to all).
EventCollection is an abstract base class that stores simultaneous
events *of the same type* that occur *at the same time* (i.e.,
simultaneous events).

For each concrete event type, the LeafSystem API provides a unique
customizable function for processing all simultaneous events of that
type, e.g. LeafSystem::DoPublish(const Context&, const vector<const
PublishEvent*>&) for publish events, where the second argument
represents all of the publish events that occur simultaneously for
that leaf system. The default implementation processes the events
(i.e., call their callback functions) in the order in which they are
stored in the second argument. The developer of new classes derived
from LeafSystem is responsible for overriding such functions if the
custom LeafSystem behavior depends on the order in which events are
processed. For example, suppose two publish events are being
processed, `events = {per-step publish, periodic publish}`. Depending
on the desired behavior, the developer has the freedom to ignore both
events, perform only one publish action, or perform both publish
actions in any arbitrary order. The System and Diagram API provide
only dispatch mechanisms that delegate actual event handling to the
constituent leaf systems. The Simulator promises that for each set of
simultaneous events of the same type, the public event handling method
(e.g. System::Publish(context, publish_events)) will be invoked
exactly once.

The System API provides several functions for customizable event
generation such as System::DoCalcNextUpdateTime() or
System::DoGetPerStepEvents(). These functions can return any number of
events of arbitrary types, and the resulting events are stored in
separate CompositeEventCollection instances. Before calling the event
handlers, all of these CompositeEventCollection objects must be merged
to generate a complete set of simultaneous events. Then, only events
of the appropriate type are passed to the event handlers. e.g.
sys.Publish(context, combined_event_collection.get_publish_events()).
For example, the Simulator executes this collation process when it is
applied to simulate a system.

Here is a complete example. For some LeafSystem `sys` at time `t`, its
System::DoCalcNextUpdateTime() generates the following
CompositeEventCollection (`events1`):

```
PublishEvent: {event1(kPeriodic, callback1)}
  DiscreteUpdateEvent: {event2(kPeriodic, callback2)}
  UnrestrictedUpdateEvent: {}
```

This LeafSystem also desires per-step event processing(`events2`),
generated by its implementation of System::DoGetPerStepEvents():

```
PublishEvent: {event3(kPerStep, callback3)}
  DiscreteUpdateEvent: {}
  UnrestrictedUpdateEvent: {event4(kPerStep,callback4)}
```

These collections of "simultaneous" events, `events1` and `events2`,
are then merged into the composite event collection `all_events`:

```
PublishEvent: {event1, event3}
  DiscreteUpdateEvent: {event2}
  UnrestrictedUpdateEvent: {event4}
```

This heterogeneous event collection can be processed by calling the
appropriate handler on the appropriate homogeneous subcollection:

```
sys.CalcUnrestrictedUpdate(context,
      all_events.get_unrestricted_update_events(), state);
  sys.CalcDiscreteVariableUpdates(context,
      all_events.get_discrete_update_events(), discrete_state);
  sys.Publish(context, all_events.get_publish_events())
```

For a LeafSystem, this is equivalent to (by expanding the dispatch
mechanisms in the System API):

```
sys.DoCalcUnrestrictedUpdate(context, {event4}, state);
  sys.DoCalcDiscreteVariableUpdates(context, {event2}, discrete_state);
  sys.DoPublish(context, {event1, event3})
```

Template parameter ``EventType``:
    a concrete derived type of Event (e.g., PublishEvent).)""";

        // drake::systems::EventCollection::Clear
        struct /* Clear */ {

          // drake/systems/framework/event_collection.h:124
          const char* doc =
R"""(Removes all events from this collection.)""";

        } Clear;

        // drake::systems::EventCollection::DoMerge
        struct /* DoMerge */ {

          // drake/systems/framework/event_collection.h:148
          const char* doc =
R"""(Derived implementation can assume that ``other`` is not null and that
`other != this`.)""";

        } DoMerge;

        // drake::systems::EventCollection::EventCollection<EventType>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:99
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:99
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:142
          const char* doc_3 =
R"""(Constructor only accessible by derived class.)""";

        } ctor;

        // drake::systems::EventCollection::HasEvents
        struct /* HasEvents */ {

          // drake/systems/framework/event_collection.h:129
          const char* doc =
R"""(Returns `false` if and only if this collection contains no events.)""";

        } HasEvents;

        // drake::systems::EventCollection::Merge
        struct /* Merge */ {

          // drake/systems/framework/event_collection.h:116
          const char* doc =
R"""(Merges all of ``other``'s events into `this`. If @p `other` == `this`,
does nothing. See derived DoMerge() for more details.)""";

        } Merge;

        // drake::systems::EventCollection::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/event_collection.h:107
          const char* doc =
R"""(Clears all the events maintained by `this` and adds all the events in
``other`` to this.)""";

        } SetFrom;

        // drake::systems::EventCollection::add_event
        struct /* add_event */ {

          // drake/systems/framework/event_collection.h:136
          const char* doc =
R"""(Adds an event to this collection, or throws if the concrete collection
does not permit adding new events. Derived classes must implement this
method to add the specified event to the homogeneous event collection.)""";

        } add_event;

      } EventCollection;

      // drake::systems::EventData
      struct /* EventData */ {

        // drake/systems/framework/event.h:34
        const char* doc =
R"""(Base class for storing trigger-specific data to be passed to event
handlers.)""";

        // drake::systems::EventData::Clone
        struct /* Clone */ {

          // drake/systems/framework/event.h:39
          const char* doc = R"""()""";

        } Clone;

        // drake::systems::EventData::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/framework/event.h:37
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::EventData::DoClone
        struct /* DoClone */ {

          // drake/systems/framework/event.h:44
          const char* doc = R"""()""";

        } DoClone;

        // drake::systems::EventData::EventData
        struct /* ctor */ {

          // drake/systems/framework/event.h:36
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:37
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event.h:37
          const char* doc_3 = R"""()""";

        } ctor;

      } EventData;

      // drake::systems::ExplicitEulerIntegrator
      struct /* ExplicitEulerIntegrator */ {

        // drake/systems/analysis/explicit_euler_integrator.h:19
        const char* doc =
R"""(A first-order, explicit Euler integrator. State is updated in the
following manner:

```
x(t+h) = x(t) + dx/dt * h
```)""";

        // drake::systems::ExplicitEulerIntegrator::ExplicitEulerIntegrator<T>
        struct /* ctor */ {

          // drake/systems/analysis/explicit_euler_integrator.h:21
          const char* doc = R"""()""";

          // drake/systems/analysis/explicit_euler_integrator.h:21
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/explicit_euler_integrator.h:36
          const char* doc_3 =
R"""(Constructs a fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``context``:
    Pointer to the context (nullptr is ok, but the caller must set a
    non-null context before Initialize()-ing the integrator).

See also:
    Initialize())""";

        } ctor;

        // drake::systems::ExplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/explicit_euler_integrator.h:50
          const char* doc =
R"""(Integrator does not provide an error estimate.)""";

        } get_error_estimate_order;

        // drake::systems::ExplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/explicit_euler_integrator.h:47
          const char* doc =
R"""(Explicit Euler integrator does not support error estimation.)""";

        } supports_error_estimation;

      } ExplicitEulerIntegrator;

      // drake::systems::FirstOrderLowPassFilter
      struct /* FirstOrderLowPassFilter */ {

        // drake/systems/primitives/first_order_low_pass_filter.h:43
        const char* doc =
R"""(An element-wise first order low pass filter system that filters the
i-th input uᵢ into the i-th output zᵢ. This system has one continuous
state per filtered input signal. Therefore, the i-th state of the
system zᵢ evolves according to:

```
żᵢ = -1/τᵢ (zᵢ - uᵢ)
```

where τᵢ is the time constant of the i-th filter. The i-th output of
the system is given by:

```
yᵢ = zᵢ
```

The transfer function for the i-th filter corresponds to:

```
H(s) = 1 / (1 + τᵢ s)
```

The Bode plot for the i-th filter exhibits a cutoff frequency (angular
frequency) at 1/τᵢ and a gain of one. For frequencies higher than the
cutoff frequency, the Bode plot approaches a 20 dB per decade negative
slope. The Bode plot in phase exhibits a -90 degrees shift (lag) for
frequencies much larger than the cutoff frequency and a zero shift for
low frequencies.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::FirstOrderLowPassFilter::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:89
          const char* doc = R"""()""";

        } DoCalcVectorOutput;

        // drake::systems::FirstOrderLowPassFilter::DoCalcVectorTimeDerivatives
        struct /* DoCalcVectorTimeDerivatives */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:83
          const char* doc = R"""()""";

        } DoCalcVectorTimeDerivatives;

        // drake::systems::FirstOrderLowPassFilter::FirstOrderLowPassFilter<T>
        struct /* ctor */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:45
          const char* doc = R"""()""";

          // drake/systems/primitives/first_order_low_pass_filter.h:45
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/first_order_low_pass_filter.h:53
          const char* doc_3 =
R"""(Constructs a FirstOrderLowPassFilter system that filters all input
signals with the same time constant, i.e. τᵢ = τ, ∀ i.

Parameter ``time_constant``:
    the time constant τ of the filter. It must be a positive number.

Parameter ``size``:
    number of elements in the signal to be processed.)""";

          // drake/systems/primitives/first_order_low_pass_filter.h:61
          const char* doc_4 =
R"""(Constructs a FirstOrderLowPassFilter so that the i-th component of the
input signal vector is low pass filtered with a time constant given in
the i-th component τᵢ of the input `time_constants` vector.

Parameter ``time_constants``:
    Vector of time constants. Each entry in this vector must be
    positive.)""";

          // drake/systems/primitives/first_order_low_pass_filter.h:65
          const char* doc_5 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::FirstOrderLowPassFilter::get_time_constant
        struct /* get_time_constant */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:71
          const char* doc =
R"""(Returns the time constant of the filter for filters that have the same
time constant τ for all signals. This method aborts if called on
filters if with different time constants per input signal.

See also:
    get_time_constants_vector().)""";

        } get_time_constant;

        // drake::systems::FirstOrderLowPassFilter::get_time_constants_vector
        struct /* get_time_constants_vector */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:74
          const char* doc =
R"""(Returns the vector of time constants for `this` filter.)""";

        } get_time_constants_vector;

        // drake::systems::FirstOrderLowPassFilter::set_initial_output_value
        struct /* set_initial_output_value */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:79
          const char* doc =
R"""(Sets the initial conditions on the output value of the filtered
signal.

Parameter ``context``:
    The current system context.

Parameter ``z0``:
    The vector on initial conditions on the output value.)""";

        } set_initial_output_value;

        // drake::systems::FirstOrderLowPassFilter::time_constants_
        struct /* time_constants_ */ {

          // drake/systems/primitives/first_order_low_pass_filter.h:95
          const char* doc = R"""()""";

        } time_constants_;

      } FirstOrderLowPassFilter;

      // drake::systems::FirstOrderTaylorApproximation
      struct /* FirstOrderTaylorApproximation */ {

        // drake/systems/primitives/linear_system.h:246
        const char* doc =
R"""(A first-order Taylor series approximation to a ``system`` in the
neighborhood of an arbitrary point. When Taylor-expanding a system at
a non-equilibrium point, it may be represented either of the form: @f[
\dot{x} - \dot{x0} = A (x - x0) + B (u - u0), @f] for continuous time,
or @f[ x[n+1] - x0[n+1] = A (x[n] - x0[n]) + B (u[n] - u0[n]), @f] for
discrete time. As above, we denote x0, u0 to be the nominal state and
input at the provided ``context``. The system description is affine
when the terms $ \dot{x0} - A x0 - B u0 $ and $ x0[n+1] - A x0[n] - B
u0[n] $ are nonzero.

More precisely, let x be a state and u be an input. This function
returns an AffineSystem of the form: @f[ \dot{x} = A x + B u + f0, @f]
(CT) @f[ x[n+1] = A x[n] + B u[n] + f0, @f] (DT) where $ f0 = \dot{x0}
- A x0 - B u0 $ (CT) and $ f0 = x0[n+1] - A x[n] - B u[n] $ (DT).

This method currently supports approximating around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use ``input_port_index`` and ``output_port_index`` to
select the input for the newly constructed system. Any additional
input ports will be treated as constants (fixed at the value specified
in ``context``).

Parameter ``system``:
    The system or subsystem to linearize.

Parameter ``context``:
    Defines the nominal operating point about which the system should
    be linearized.

Parameter ``input_port_index``:
    A valid input port index for ``system`` or kNoInput or (default)
    kUseFirstInputIfItExists.

Parameter ``output_port_index``:
    A valid output port index for ``system`` or kNoOutput or (default)
    kUseFirstOutputIfItExists.

Returns:
    An AffineSystem at this linearization point.

Throws:
    s std::runtime_error if the system if the system is not (only)
    continuous or (only) discrete time with a single periodic update.

Note that x, u and y are in the same coordinate system as the original
``system``, since the terms involving x0, u0 reside in f0.)""";

      } FirstOrderTaylorApproximation;

      // drake::systems::FixedInputPortValue
      struct /* FixedInputPortValue */ {

        // drake/systems/framework/fixed_input_port_value.h:35
        const char* doc =
R"""(A FixedInputPortValue encapsulates a vector or abstract value for use
as an internal value source for one of a System's input ports. The
semantics are identical to a Parameter. We assign a DependencyTracker
to this object and subscribe the InputPort to it when that port is
fixed. Any modification to the value here issues a notification to its
dependent, and increments a serial number kept here.)""";

        // drake::systems::FixedInputPortValue::FixedInputPortValue
        struct /* ctor */ {

          // drake/systems/framework/fixed_input_port_value.h:39
          const char* doc =
R"""(@name Does not allow move or assignment; copy is private. */ @{ */)""";

        } ctor;

        // drake::systems::FixedInputPortValue::GetMutableData
        struct /* GetMutableData */ {

          // drake/systems/framework/fixed_input_port_value.h:71
          const char* doc =
R"""(Returns a pointer to the data inside this FixedInputPortValue, and
notifies the dependent input port that the value has changed.

To ensure invalidation notifications are delivered, callers should
call this method every time they wish to update the stored value. In
particular, callers MUST NOT write through the returned pointer if
there is any possibility this FixedInputPortValue has been accessed
since the last time this method was called.)""";

        } GetMutableData;

        // drake::systems::FixedInputPortValue::GetMutableVectorData
        struct /* GetMutableVectorData */ {

          // drake/systems/framework/fixed_input_port_value.h:86
          const char* doc =
R"""(Returns a pointer to the data inside this FixedInputPortValue, and
notifies the dependent input port that the value has changed,
invalidating downstream computations. Throws std::bad_cast if the data
is not vector data.

To ensure invalidation notifications are delivered, callers should
call this method every time they wish to update the stored value. In
particular, callers MUST NOT write through the returned pointer if
there is any possibility this FixedInputPortValue has been accessed
since the last time this method was called.

Template parameter ``T``:
    Element type of the input port's vector value. Must be a valid
    Eigen scalar.)""";

        } GetMutableVectorData;

        // drake::systems::FixedInputPortValue::get_owning_context
        struct /* get_owning_context */ {

          // drake/systems/framework/fixed_input_port_value.h:101
          const char* doc =
R"""(Returns a const reference to the context that owns this object. */)""";

        } get_owning_context;

        // drake::systems::FixedInputPortValue::get_value
        struct /* get_value */ {

          // drake/systems/framework/fixed_input_port_value.h:50
          const char* doc =
R"""(Returns a reference to the contained abstract value. */)""";

        } get_value;

        // drake::systems::FixedInputPortValue::get_vector_value
        struct /* get_vector_value */ {

          // drake/systems/framework/fixed_input_port_value.h:58
          const char* doc =
R"""(Returns a reference to the contained `BasicVector<T>` or throws an
exception if this doesn't contain an object of that type.)""";

        } get_vector_value;

        // drake::systems::FixedInputPortValue::serial_number
        struct /* serial_number */ {

          // drake/systems/framework/fixed_input_port_value.h:92
          const char* doc =
R"""(Returns the serial number of the contained value. This counts up every
time the contained value changes, or when mutable access is granted.)""";

        } serial_number;

        // drake::systems::FixedInputPortValue::ticket
        struct /* ticket */ {

          // drake/systems/framework/fixed_input_port_value.h:95
          const char* doc =
R"""(Returns the ticket used to find the associated DependencyTracker. */)""";

        } ticket;

      } FixedInputPortValue;

      // drake::systems::Gain
      struct /* Gain */ {

        // drake/systems/primitives/gain.h:29
        const char* doc =
R"""(An element-wise gain block with input `u` and output `y = k * u` with
`k` a constant vector. The input to this system directly feeds through
to its output.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.

To use other specific scalar types see gain-inl.h.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::Gain::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/gain-inl.h:51
          const char* doc = R"""()""";

          // drake/systems/primitives/gain.h:61
          const char* doc_2 = R"""()""";

        } DoCalcVectorOutput;

        // drake::systems::Gain::Gain<T>
        struct /* ctor */ {

          // drake/systems/primitives/gain-inl.h:22
          const char* doc =
R"""(Constructs a Gain system where the same gain is applied to every input
value.

Parameter ``k``:
    the gain constant so that `y = k * u`.

Parameter ``size``:
    number of elements in the signal to be processed.)""";

          // drake/systems/primitives/gain-inl.h:25
          const char* doc_2 =
R"""(Constructs a Gain system where different gains can be applied to each
input value.

Parameter ``k``:
    the gain vector constants so that `y_i = k_i * u_i` where
    subscript `i` indicates the i-th element of the vector.)""";

          // drake/systems/primitives/gain-inl.h:31
          const char* doc_3 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/gain.h:31
          const char* doc_4 = R"""()""";

          // drake/systems/primitives/gain.h:31
          const char* doc_5 = R"""()""";

          // drake/systems/primitives/gain.h:38
          const char* doc_6 =
R"""(Constructs a Gain system where the same gain is applied to every input
value.

Parameter ``k``:
    the gain constant so that `y = k * u`.

Parameter ``size``:
    number of elements in the signal to be processed.)""";

          // drake/systems/primitives/gain.h:45
          const char* doc_7 =
R"""(Constructs a Gain system where different gains can be applied to each
input value.

Parameter ``k``:
    the gain vector constants so that `y_i = k_i * u_i` where
    subscript `i` indicates the i-th element of the vector.)""";

          // drake/systems/primitives/gain.h:49
          const char* doc_8 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::Gain::get_gain
        struct /* get_gain */ {

          // drake/systems/primitives/gain-inl.h:35
          const char* doc =
R"""(Returns the gain constant. This method should only be called if the
gain can be represented as a scalar value, i.e., every element in the
gain vector is the same. It will abort if the gain cannot be
represented as a single scalar value.)""";

          // drake/systems/primitives/gain.h:55
          const char* doc_2 =
R"""(Returns the gain constant. This method should only be called if the
gain can be represented as a scalar value, i.e., every element in the
gain vector is the same. It will abort if the gain cannot be
represented as a single scalar value.)""";

        } get_gain;

        // drake::systems::Gain::get_gain_vector
        struct /* get_gain_vector */ {

          // drake/systems/primitives/gain-inl.h:46
          const char* doc = R"""(Returns the gain vector constant.)""";

          // drake/systems/primitives/gain.h:58
          const char* doc_2 = R"""(Returns the gain vector constant.)""";

        } get_gain_vector;

        // drake::systems::Gain::k_
        struct /* k_ */ {

          // drake/systems/primitives/gain.h:67
          const char* doc = R"""()""";

        } k_;

      } Gain;

      // drake::systems::HermitianDenseOutput
      struct /* HermitianDenseOutput */ {

        // drake/systems/analysis/hermitian_dense_output.h:98
        const char* doc =
R"""(A StepwiseDenseOutput class implementation using Hermitian
interpolators, and therefore a _continuous extension_ of the solution
𝐱(t) (see [Engquist, 2105]). This concept can be recast as a type of
dense output that is continuous.

Updates take the form of integration steps, for which state 𝐱 and
state time derivative d𝐱/dt are known at least at both ends of the
step. Hermite cubic polynomials are then constructed upon
StepwiseDenseOutput::Consolidate "consolidation", yielding a C1
extension of the solution 𝐱(t).

Hermitian continuous extensions exhibit the same truncation error as
that of the integration scheme being used for up to 3rd order schemes
(see [Hairer, 1993]).

From a performance standpoint, memory footprint and evaluation
overhead (i.e. the computational cost of an evaluation) increase
linearly and logarithmically with the amount of steps taken,
respectively.

- [Engquist, 2105] B. Engquist. Encyclopedia of Applied and
Computational Mathematics, p. 339, Springer, 2015. - [Hairer, 1993] E.
Hairer, S. Nørsett and G. Wanner. Solving Ordinary Differential
Equations I (Nonstiff Problems), p.190, Springer, 1993.

Template parameter ``T``:
    A valid Eigen scalar type.)""";

        // drake::systems::HermitianDenseOutput::Consolidate
        struct /* Consolidate */ {

          // drake/systems/analysis/hermitian_dense_output.h:270
          const char* doc = R"""()""";

        } Consolidate;

        // drake::systems::HermitianDenseOutput::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/analysis/hermitian_dense_output.h:100
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::HermitianDenseOutput::DoEvaluate
        struct /* DoEvaluate */ {

          // drake/systems/analysis/hermitian_dense_output.h:288
          const char* doc = R"""()""";

        } DoEvaluate;

        // drake::systems::HermitianDenseOutput::DoEvaluateNth
        struct /* DoEvaluateNth */ {

          // drake/systems/analysis/hermitian_dense_output.h:294
          const char* doc = R"""()""";

        } DoEvaluateNth;

        // drake::systems::HermitianDenseOutput::HermitianDenseOutput<T>
        struct /* ctor */ {

          // drake/systems/analysis/hermitian_dense_output.h:100
          const char* doc = R"""()""";

          // drake/systems/analysis/hermitian_dense_output.h:100
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/hermitian_dense_output.h:243
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::HermitianDenseOutput::IntegrationStep
        struct /* IntegrationStep */ {

          // drake/systems/analysis/hermitian_dense_output.h:115
          const char* doc =
R"""(An integration step representation class, holding just enough for
Hermitian interpolation: three (3) related sets containing step times
{t₀, ..., tᵢ₋₁, tᵢ} where tᵢ ∈ ℝ, step states {𝐱₀, ..., 𝐱ᵢ₋₁, 𝐱ᵢ}
where 𝐱ᵢ ∈ ℝⁿ, and state derivatives {d𝐱/dt₀, ..., d𝐱/dtᵢ₋₁, d𝐱/dtᵢ}
where d𝐱/dtᵢ ∈ ℝⁿ.

This step definition allows for intermediate time, state and state
derivative triplets (e.g. the integrator internal stages) to improve
interpolation.

Note:
    The use of column matrices instead of plain vectors helps reduce
    HermitianDenseOutput construction overhead, as this type of dense
    output leverages a PiecewisePolynomial instance that takes
    matrices.)""";

          // drake::systems::HermitianDenseOutput::IntegrationStep::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/analysis/hermitian_dense_output.h:117
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::HermitianDenseOutput::IntegrationStep::Extend
          struct /* Extend */ {

            // drake/systems/analysis/hermitian_dense_output.h:163
            const char* doc =
R"""(Extends the step forward in time from column matrices.

Provided ``time``, ``state`` and ``state_derivative`` are appended to
the current step, effectively increasing its time length.

Parameter ``time``:
    Time tᵢ to extend the step to.

Parameter ``state``:
    State vector 𝐱ᵢ at ``time`` tᵢ as a column matrix.

Parameter ``state_derivative``:
    State derivative vector d𝐱/dtᵢ at ``time`` tᵢ as a column matrix.

Throws:
    s std::runtime_error if given ``state`` 𝐱ᵢ is not a column
    matrix.<br> if given ``state_derivative`` d𝐱/dtᵢ is not a column
    matrix.<br> if given ``time`` tᵢ is not greater than the previous
    time tᵢ₋₁ in the step.<br> if given ``state`` 𝐱ᵢ dimension does
    not match the dimension of the previous state 𝐱ᵢ₋₁.<br> if given
    ``state`` 𝐱ᵢ and ``state_derivative`` d𝐱/dtᵢ do not match each
    other's dimension.)""";

          } Extend;

          // drake::systems::HermitianDenseOutput::IntegrationStep::IntegrationStep
          struct /* ctor */ {

            // drake/systems/analysis/hermitian_dense_output.h:117
            const char* doc = R"""()""";

            // drake/systems/analysis/hermitian_dense_output.h:117
            const char* doc_2 = R"""()""";

            // drake/systems/analysis/hermitian_dense_output.h:119
            const char* doc_3 = R"""(Constructs an empty step.)""";

            // drake/systems/analysis/hermitian_dense_output.h:136
            const char* doc_4 =
R"""(Constructs a zero length step (i.e. a step containing a single time,
state and state derivative triplet) from column matrices.

Parameter ``initial_time``:
    Initial time t₀ where the step starts.

Parameter ``initial_state``:
    Initial state vector 𝐱₀ at ``initial_time`` as a column matrix.

Parameter ``initial_state_derivative``:
    Initial state derivative vector d𝐱/dt₀ at ``initial_time`` as a
    column matrix.

Throws:
    s std::runtime_error if given ``initial_state`` 𝐱₀ is not a column
    matrix.<br> if given ``initial_state_derivative`` d𝐱/t₀ is not a
    column matrix.<br> if given ``initial_state`` 𝐱₀ and
    ``initial_state_derivative`` d𝐱/dt₀ do not match each other's
    dimension.)""";

          } ctor;

          // drake::systems::HermitianDenseOutput::IntegrationStep::end_time
          struct /* end_time */ {

            // drake/systems/analysis/hermitian_dense_output.h:180
            const char* doc =
R"""(Returns step end time tᵢ (that of the first time, state and state
derivative triplet), which may coincide with its start time t₀ (that
of the last time, state and state derivative triplet) if the step has
zero length (that is, it contains a single triplet).)""";

          } end_time;

          // drake::systems::HermitianDenseOutput::IntegrationStep::get_state_derivatives
          struct /* get_state_derivatives */ {

            // drake/systems/analysis/hermitian_dense_output.h:195
            const char* doc =
R"""(Gets step state derivatives {d𝐱/dt₀, ..., d𝐱/dtᵢ₋₁, d𝐱/dtᵢ} as column
matrices.)""";

          } get_state_derivatives;

          // drake::systems::HermitianDenseOutput::IntegrationStep::get_states
          struct /* get_states */ {

            // drake/systems/analysis/hermitian_dense_output.h:191
            const char* doc =
R"""(Returns step states {𝐱₀, ..., 𝐱ᵢ₋₁, 𝐱ᵢ} as column matrices.)""";

          } get_states;

          // drake::systems::HermitianDenseOutput::IntegrationStep::get_times
          struct /* get_times */ {

            // drake/systems/analysis/hermitian_dense_output.h:188
            const char* doc = R"""(Returns step times {t₀, ..., tᵢ₋₁, tᵢ}.)""";

          } get_times;

          // drake::systems::HermitianDenseOutput::IntegrationStep::size
          struct /* size */ {

            // drake/systems/analysis/hermitian_dense_output.h:183
            const char* doc =
R"""(Returns the step state 𝐱 size (i.e. dimension).)""";

          } size;

          // drake::systems::HermitianDenseOutput::IntegrationStep::start_time
          struct /* start_time */ {

            // drake/systems/analysis/hermitian_dense_output.h:174
            const char* doc =
R"""(Returns step start time t₀ (that of the first time, state and state
derivative triplet), which may coincide with its end time tᵢ (that of
the last time, state and state derivative triplet) if the step has
zero length (that is, it contains a single triplet).)""";

          } start_time;

        } IntegrationStep;

        // drake::systems::HermitianDenseOutput::Rollback
        struct /* Rollback */ {

          // drake/systems/analysis/hermitian_dense_output.h:263
          const char* doc = R"""()""";

        } Rollback;

        // drake::systems::HermitianDenseOutput::Update
        struct /* Update */ {

          // drake/systems/analysis/hermitian_dense_output.h:258
          const char* doc =
R"""(Update output with the given ``step``.

Provided ``step`` is queued for later consolidation. Note that the
time the ``step`` extends cannot be readily evaluated (see
StepwiseDenseOutput class documentation).

Parameter ``step``:
    Integration step to update this output with.

Throws:
    s std::runtime_error if given ``step`` has zero length.<br> if
    given ``step`` does not ensure C1 continuity at the end of this
    dense output.<br> if given ``step`` dimensions does not match this
    dense output dimensions.)""";

        } Update;

        // drake::systems::HermitianDenseOutput::do_end_time
        struct /* do_end_time */ {

          // drake/systems/analysis/hermitian_dense_output.h:307
          const char* doc = R"""()""";

        } do_end_time;

        // drake::systems::HermitianDenseOutput::do_is_empty
        struct /* do_is_empty */ {

          // drake/systems/analysis/hermitian_dense_output.h:299
          const char* doc = R"""()""";

        } do_is_empty;

        // drake::systems::HermitianDenseOutput::do_size
        struct /* do_size */ {

          // drake/systems/analysis/hermitian_dense_output.h:303
          const char* doc = R"""()""";

        } do_size;

        // drake::systems::HermitianDenseOutput::do_start_time
        struct /* do_start_time */ {

          // drake/systems/analysis/hermitian_dense_output.h:309
          const char* doc = R"""()""";

        } do_start_time;

      } HermitianDenseOutput;

      // drake::systems::ImplicitEulerIntegrator
      struct /* ImplicitEulerIntegrator */ {

        // drake/systems/analysis/implicit_euler_integrator.h:85
        const char* doc =
R"""(A first-order, fully implicit integrator with second order error
estimation.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

This integrator uses the following update rule:

```
x(t+h) = x(t) + h f(t+h,x(t+h))
```

where x are the state variables, h is the integration step size, and
f() returns the time derivatives of the state variables. Contrast this
update rule to that of an explicit first-order integrator:

```
x(t+h) = x(t) + h f(t, x(t))
```

Thus implicit first-order integration must solve a nonlinear system of
equations to determine *both* the state at t+h and the time
derivatives of that state at that time. Cast as a nonlinear system of
equations, we seek the solution to:

```
x(t+h) - x(t) - h f(t+h,x(t+h)) = 0
```

given unknowns x(t+h).

This "implicit Euler" method is known to be L-Stable, meaning both
that applying it at a fixed integration step to the "test" equation
`y(t) = eᵏᵗ` yields zero (for `k < 0` and `t → ∞`) *and* that it is
also A-Stable. A-Stability, in turn, means that the method can
integrate the linear constant coefficient system `dx/dt = Ax` at any
step size without the solution becoming unstable (growing without
bound). The practical effect of L-Stability is that the integrator
tends to be stable for any given step size on an arbitrary system of
ordinary differential equations. See [Lambert, 1991], Ch. 6 for an
approachable discussion on stiff differential equations and L- and
A-Stability.

The time complexity of this method is often dominated by the time to
form the Jacobian matrix consisting of the partial derivatives of the
nonlinear system (of `n` dimensions, where `n` is the number of state
variables) taken with respect to the partial derivatives of the state
variables at `x(t+h)`. For typical numerical differentiation, `f` will
be evaluated `n` times during the Jacobian formation; if we liberally
assume that the derivative function evaluation code runs in `O(n)`
time (e.g., as it would for multi-rigid body dynamics without
kinematic loops), the asymptotic complexity to form the Jacobian will
be `O(n²)`. This Jacobian matrix needs to be formed repeatedly- as
often as every time the state variables are updated- during the
solution process. Using automatic differentiation replaces the `n`
derivative evaluations with what is hopefully a much less expensive
process, though the complexity to form the Jacobian matrix is still
`O(n²)`. For large `n`, the time complexity may be dominated by the
`O(n³)` time required to (repeatedly) solve linear systems problems as
part of the nonlinear system solution process.

This implementation uses Newton-Raphson (NR) and relies upon the
obvious convergence to a solution for `g = 0` where `g(x(t+h)) ≡
x(t+h) - x(t) - h f(t+h,x(t+h))` as `h` becomes sufficiently small. It
also uses the implicit trapezoid method- fed the result from implicit
Euler for (hopefully) faster convergence- to compute the error
estimate. General implementational details were gleaned from [Hairer,
1996].

- [Hairer, 1996] E. Hairer and G. Wanner. Solving Ordinary
Differential Equations II (Stiff and Differential-Algebraic Problems).
Springer, 1996. - [Lambert, 1991] J. D. Lambert. Numerical Methods for
Ordinary Differential Equations. John Wiley & Sons, 1991.)""";

        // drake::systems::ImplicitEulerIntegrator::ImplicitEulerIntegrator<T>
        struct /* ctor */ {

          // drake/systems/analysis/implicit_euler_integrator.h:87
          const char* doc = R"""()""";

          // drake/systems/analysis/implicit_euler_integrator.h:87
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/implicit_euler_integrator.h:91
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::ImplicitEulerIntegrator::JacobianComputationScheme
        struct /* JacobianComputationScheme */ {

          // drake/systems/analysis/implicit_euler_integrator.h:111
          const char* doc =
R"""(Selecting the wrong such Jacobian determination scheme will slow
(possibly critically) the implicit integration process. Automatic
differentiation is recommended if the System supports it for reasons
of both higher accuracy and increased speed. Forward differencing
(i.e., numerical differentiation) exhibits error in the approximation
close to √ε, where ε is machine epsilon, from n forward dynamics calls
(where n is the number of state variables). Central differencing
yields the most accurate numerically differentiated Jacobian matrix,
but expends double the computational effort for approximately three
digits greater accuracy: the total error in the central-difference
approximation is close to ε^(2/3), from 2n forward dynamics calls. See
[Nocedal 2004, pp. 167-169].

- [Nocedal 2004] J. Nocedal and S. Wright. Numerical Optimization.
Springer, 2004.)""";

          // drake::systems::ImplicitEulerIntegrator::JacobianComputationScheme::kAutomatic
          struct /* kAutomatic */ {

            // drake/systems/analysis/implicit_euler_integrator.h:119
            const char* doc = R"""(Automatic differentiation.)""";

          } kAutomatic;

          // drake::systems::ImplicitEulerIntegrator::JacobianComputationScheme::kCentralDifference
          struct /* kCentralDifference */ {

            // drake/systems/analysis/implicit_euler_integrator.h:116
            const char* doc = R"""(O(h²) Central differencing.)""";

          } kCentralDifference;

          // drake::systems::ImplicitEulerIntegrator::JacobianComputationScheme::kForwardDifference
          struct /* kForwardDifference */ {

            // drake/systems/analysis/implicit_euler_integrator.h:113
            const char* doc = R"""(O(h) Forward differencing.)""";

          } kForwardDifference;

        } JacobianComputationScheme;

        // drake::systems::ImplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/implicit_euler_integrator.h:165
          const char* doc =
R"""(This integrator provides second order error estimates.)""";

        } get_error_estimate_order;

        // drake::systems::ImplicitEulerIntegrator::get_jacobian_computation_scheme
        struct /* get_jacobian_computation_scheme */ {

          // drake/systems/analysis/implicit_euler_integrator.h:156
          const char* doc = R"""()""";

        } get_jacobian_computation_scheme;

        // drake::systems::ImplicitEulerIntegrator::get_num_derivative_evaluations_for_jacobian
        struct /* get_num_derivative_evaluations_for_jacobian */ {

          // drake/systems/analysis/implicit_euler_integrator.h:187
          const char* doc =
R"""(Gets the number of ODE function evaluations (calls to
CalcTimeDerivatives()) *used only for computing the Jacobian matrices*
since the last call to ResetStatistics(). This count includes those
derivative calculations necessary for computing Jacobian matrices
during the error estimation process.)""";

        } get_num_derivative_evaluations_for_jacobian;

        // drake::systems::ImplicitEulerIntegrator::get_num_error_estimator_derivative_evaluations
        struct /* get_num_error_estimator_derivative_evaluations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:178
          const char* doc =
R"""(Gets the number of ODE function evaluations (calls to
CalcTimeDerivatives()) *used only for the error estimation process*
since the last call to ResetStatistics(). This count includes *all*
such calls including (1) those necessary to compute Jacobian matrices;
and (2) calls that exhibit little cost (due to results being cached).)""";

        } get_num_error_estimator_derivative_evaluations;

        // drake::systems::ImplicitEulerIntegrator::get_num_error_estimator_derivative_evaluations_for_jacobian
        struct /* get_num_error_estimator_derivative_evaluations_for_jacobian */ {

          // drake/systems/analysis/implicit_euler_integrator.h:224
          const char* doc =
R"""(@name Error-estimation statistics functions. The functions return
statistics specific to the error estimation process. @{ Gets the
number of ODE function evaluations (calls to CalcTimeDerivatives())
*used only for computing the Jacobian matrices needed by the error
estimation process* since the last call to ResetStatistics().)""";

        } get_num_error_estimator_derivative_evaluations_for_jacobian;

        // drake::systems::ImplicitEulerIntegrator::get_num_error_estimator_iteration_matrix_factorizations
        struct /* get_num_error_estimator_iteration_matrix_factorizations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:244
          const char* doc =
R"""(Gets the number of factorizations of the iteration matrix *used only
during the error estimation process* since the last call to
ResetStatistics().)""";

        } get_num_error_estimator_iteration_matrix_factorizations;

        // drake::systems::ImplicitEulerIntegrator::get_num_error_estimator_jacobian_evaluations
        struct /* get_num_error_estimator_jacobian_evaluations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:237
          const char* doc =
R"""(Gets the number of Jacobian matrix evaluations *used only during the
error estimation process* since the last call to ResetStatistics().)""";

        } get_num_error_estimator_jacobian_evaluations;

        // drake::systems::ImplicitEulerIntegrator::get_num_error_estimator_newton_raphson_iterations
        struct /* get_num_error_estimator_newton_raphson_iterations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:231
          const char* doc =
R"""(Gets the number of iterations *used in the Newton-Raphson nonlinear
systems of equation solving process for the error estimation process*
since the last call to ResetStatistics().)""";

        } get_num_error_estimator_newton_raphson_iterations;

        // drake::systems::ImplicitEulerIntegrator::get_num_iteration_matrix_factorizations
        struct /* get_num_iteration_matrix_factorizations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:210
          const char* doc =
R"""(Gets the number of factorizations of the iteration matrix since the
last call to ResetStatistics(). This count includes those
refactorizations necessary during the error estimation process.)""";

        } get_num_iteration_matrix_factorizations;

        // drake::systems::ImplicitEulerIntegrator::get_num_jacobian_evaluations
        struct /* get_num_jacobian_evaluations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:203
          const char* doc =
R"""(Gets the number of Jacobian evaluations (i.e., the number of times
that the Jacobian matrix was reformed) since the last call to
ResetStatistics(). This count includes those evaluations necessary
during the error estimation process.)""";

        } get_num_jacobian_evaluations;

        // drake::systems::ImplicitEulerIntegrator::get_num_newton_raphson_iterations
        struct /* get_num_newton_raphson_iterations */ {

          // drake/systems/analysis/implicit_euler_integrator.h:195
          const char* doc =
R"""(Gets the number of iterations used in the Newton-Raphson nonlinear
systems of equation solving process since the last call to
ResetStatistics(). This count includes those Newton-Raphson iterations
used during the error estimation process.)""";

        } get_num_newton_raphson_iterations;

        // drake::systems::ImplicitEulerIntegrator::get_reuse
        struct /* get_reuse */ {

          // drake/systems/analysis/implicit_euler_integrator.h:144
          const char* doc =
R"""(Gets whether the integrator attempts to reuse Jacobian matrices and
iteration matrix factorizations.

See also:
    set_reuse())""";

        } get_reuse;

        // drake::systems::ImplicitEulerIntegrator::set_jacobian_computation_scheme
        struct /* set_jacobian_computation_scheme */ {

          // drake/systems/analysis/implicit_euler_integrator.h:150
          const char* doc =
R"""(Sets the Jacobian computation scheme. This function can be safely
called at any time (i.e., the integrator need not be re-initialized
afterward).

Note:
    Discards any already-computed Jacobian matrices if the scheme
    changes.)""";

        } set_jacobian_computation_scheme;

        // drake::systems::ImplicitEulerIntegrator::set_reuse
        struct /* set_reuse */ {

          // drake/systems/analysis/implicit_euler_integrator.h:139
          const char* doc =
R"""(Sets whether the integrator attempts to reuse Jacobian matrices and
iteration matrix factorizations (default is `true`). Forming Jacobian
matrices and factorizing iteration matrices are generally the two most
expensive operations performed by this integrator. For small systems
(those with on the order of ten state variables), the additional
accuracy that using fresh Jacobians and factorizations buys- which can
permit increased step sizes but should have no effect on solution
accuracy- can outweigh the small factorization cost.

See also:
    get_reuse)""";

        } set_reuse;

        // drake::systems::ImplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/implicit_euler_integrator.h:162
          const char* doc =
R"""(The integrator supports error estimation.)""";

        } supports_error_estimation;

      } ImplicitEulerIntegrator;

      // drake::systems::InitialValueProblem
      struct /* InitialValueProblem */ {

        // drake/systems/analysis/initial_value_problem.h:64
        const char* doc =
R"""(A general initial value problem (or IVP) representation class, that
allows evaluating the 𝐱(t; 𝐤) solution function to the given ODE d𝐱/dt
= f(t, 𝐱; 𝐤), where f : t ⨯ 𝐱 → ℝⁿ, t ∈ ℝ, 𝐱 ∈ ℝⁿ, 𝐤 ∈ ℝᵐ, provided an
initial condition 𝐱(t₀; 𝐤) = 𝐱₀. The parameter vector 𝐤 allows for
generic IVP definitions, which can later be solved for any instance of
said vector.

By default, an explicit 3rd order RungeKutta integration scheme is
used.

The implementation of this class performs basic computation caching,
optimizing away repeated integration whenever the IVP is solved for
increasing values of time t while both initial conditions and
parameters are kept constant, e.g. if solved for t₁ > t₀ first,
solving for t₂ > t₁ will only require integrating from t₁ onward.

Additionally, IntegratorBase's dense output support can be leveraged
to efficiently approximate the IVP solution within closed intervals of
t. This is convenient when there's a need for a more dense sampling of
the IVP solution than what would be available through either fixed or
error-controlled step integration (for a given accuracy), or when the
IVP is to be solved repeatedly for arbitrarily many t values within a
given interval. See documentation of the internally held
IntegratorBase subclass instance (either the default or a user-defined
one, set via reset_integrator()) for further reference on the specific
dense output technique in use.

For further insight into its use, consider the following examples:

- The momentum 𝐩 of a particle of mass m that is traveling through a
volume of a gas with dynamic viscosity μ can be described by d𝐩/dt =
-μ * 𝐩/m. At time t₀, the particle carries an initial momentum 𝐩₀. In
this context, t is unused (the ODE is autonomous), 𝐱 ≜ 𝐩, 𝐤 ≜ [m, μ],
t₀ = 0, 𝐱₀ ≜ 𝐩₀, d𝐱/dt = f(t, 𝐱; 𝐤) = -k₂ * 𝐱 / k₁.

- The velocity 𝐯 of the same particle in the same exact conditions as
before, but when a time varying force 𝐅(t) is applied to it, can be be
described by d𝐯/dt = (𝐅(t) - μ * 𝐯) / m. In this context, 𝐱 ≜ 𝐯, 𝐤 ≜
[m, μ], 𝐱₀ ≜ 𝐯₀, d𝐱/dt = f(t, 𝐱; 𝐤) = (𝐅(t) - k₂ * 𝐱) / k₁.

Template parameter ``T``:
    The ℝ domain scalar type, which must be a valid Eigen scalar.

Note:
    Instantiated templates for the following scalar types ``T`` are
    provided: - double)""";

        // drake::systems::InitialValueProblem::DenseSolve
        struct /* DenseSolve */ {

          // drake/systems/analysis/initial_value_problem-inl.h:252
          const char* doc =
R"""(Solves and yields an approximation of the IVP solution x(t; 𝐤) for the
closed time interval between the initial time t₀ and the given final
time ``tf``, using initial state 𝐱₀ and parameter vector 𝐤 present in
``values`` (falling back to the ones given on construction if not
given).

To this end, the wrapped IntegratorBase instance solves this IVP,
advancing time and state from t₀ and 𝐱₀ = 𝐱(t₀) to ``tf`` and
𝐱(``tf``), creating a dense output over that [t₀, ``tf``] interval
along the way.

Parameter ``tf``:
    The IVP will be solved up to this time. Usually, t₀ < ``tf`` as an
    empty dense output would result if t₀ = ``tf``.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    A dense approximation to 𝐱(t; 𝐤) with 𝐱(t₀; 𝐤) = 𝐱₀, defined for
    t₀ ≤ t ≤ tf.

Note:
    The larger the given ``tf`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows. @pre Given ``tf`` must be larger than or equal to
    the specified initial time t₀ (either given or default). @pre If
    given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction. @pre If given, the
    dimension of the parameter vector ``values``.k must match that of
    the parameter vector in the default specified values given on
    construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

          // drake/systems/analysis/initial_value_problem.h:175
          const char* doc_2 =
R"""(Solves and yields an approximation of the IVP solution x(t; 𝐤) for the
closed time interval between the initial time t₀ and the given final
time ``tf``, using initial state 𝐱₀ and parameter vector 𝐤 present in
``values`` (falling back to the ones given on construction if not
given).

To this end, the wrapped IntegratorBase instance solves this IVP,
advancing time and state from t₀ and 𝐱₀ = 𝐱(t₀) to ``tf`` and
𝐱(``tf``), creating a dense output over that [t₀, ``tf``] interval
along the way.

Parameter ``tf``:
    The IVP will be solved up to this time. Usually, t₀ < ``tf`` as an
    empty dense output would result if t₀ = ``tf``.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    A dense approximation to 𝐱(t; 𝐤) with 𝐱(t₀; 𝐤) = 𝐱₀, defined for
    t₀ ≤ t ≤ tf.

Note:
    The larger the given ``tf`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows. @pre Given ``tf`` must be larger than or equal to
    the specified initial time t₀ (either given or default). @pre If
    given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction. @pre If given, the
    dimension of the parameter vector ``values``.k must match that of
    the parameter vector in the default specified values given on
    construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } DenseSolve;

        // drake::systems::InitialValueProblem::InitialValueProblem<T>
        struct /* ctor */ {

          // drake/systems/analysis/initial_value_problem-inl.h:111
          const char* doc =
R"""(Constructs an IVP described by the given ``ode_function``, using given
``default_values``.t0 and ``default_values``.x0 as initial conditions,
and parameterized with ``default_values``.k by default.

Parameter ``ode_function``:
    The ODE function f(t, 𝐱; 𝐤) that describes the state evolution
    over time.

Parameter ``default_values``:
    The values specified by default for this IVP, i.e. default initial
    time t₀ ∈ ℝ and state vector 𝐱₀ ∈ ℝⁿ, and default parameter vector
    𝐤 ∈ ℝᵐ. @pre An initial time ``default_values``.t0 is given. @pre
    An initial state vector ``default_values``.x0 is given. @pre A
    parameter vector ``default_values``.k is given.

Throws:
    s std::logic_error if preconditions are not met.)""";

          // drake/systems/analysis/initial_value_problem.h:66
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/initial_value_problem.h:66
          const char* doc_3 = R"""()""";

          // drake/systems/analysis/initial_value_problem.h:127
          const char* doc_4 =
R"""(Constructs an IVP described by the given ``ode_function``, using given
``default_values``.t0 and ``default_values``.x0 as initial conditions,
and parameterized with ``default_values``.k by default.

Parameter ``ode_function``:
    The ODE function f(t, 𝐱; 𝐤) that describes the state evolution
    over time.

Parameter ``default_values``:
    The values specified by default for this IVP, i.e. default initial
    time t₀ ∈ ℝ and state vector 𝐱₀ ∈ ℝⁿ, and default parameter vector
    𝐤 ∈ ℝᵐ. @pre An initial time ``default_values``.t0 is given. @pre
    An initial state vector ``default_values``.x0 is given. @pre A
    parameter vector ``default_values``.k is given.

Throws:
    s std::logic_error if preconditions are not met.)""";

        } ctor;

        // drake::systems::InitialValueProblem::Solve
        struct /* Solve */ {

          // drake/systems/analysis/initial_value_problem-inl.h:149
          const char* doc =
R"""(Solves the IVP for time ``tf``, using the initial time t₀, initial
state vector 𝐱₀ and parameter vector 𝐤 present in ``values``, falling
back to the ones given on construction if not given.

Parameter ``tf``:
    The IVP will be solved for this time.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    The IVP solution 𝐱(``tf``; 𝐤) for 𝐱(t₀; 𝐤) = 𝐱₀. @pre Given ``tf``
    must be larger than or equal to the specified initial time t₀
    (either given or default). @pre If given, the dimension of the
    initial state vector ``values``.x0 must match that of the default
    initial state vector in the default specified values given on
    construction. @pre If given, the dimension of the parameter vector
    ``values``.k must match that of the parameter vector in the
    default specified values given on construction.

Throws:
    s std::logic_error if preconditions are not met.)""";

          // drake/systems/analysis/initial_value_problem.h:146
          const char* doc_2 =
R"""(Solves the IVP for time ``tf``, using the initial time t₀, initial
state vector 𝐱₀ and parameter vector 𝐤 present in ``values``, falling
back to the ones given on construction if not given.

Parameter ``tf``:
    The IVP will be solved for this time.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    The IVP solution 𝐱(``tf``; 𝐤) for 𝐱(t₀; 𝐤) = 𝐱₀. @pre Given ``tf``
    must be larger than or equal to the specified initial time t₀
    (either given or default). @pre If given, the dimension of the
    initial state vector ``values``.x0 must match that of the default
    initial state vector in the default specified values given on
    construction. @pre If given, the dimension of the parameter vector
    ``values``.k must match that of the parameter vector in the
    default specified values given on construction.

Throws:
    s std::logic_error if preconditions are not met.)""";

        } Solve;

        // drake::systems::InitialValueProblem::SpecifiedValues
        struct /* SpecifiedValues */ {

          // drake/systems/analysis/initial_value_problem.h:87
          const char* doc =
R"""(A collection of values i.e. initial time t₀, initial state vector 𝐱₀
and parameters vector 𝐤.to further specify the ODE system (in order to
become an initial value problem).)""";

          // drake::systems::InitialValueProblem::SpecifiedValues::SpecifiedValues
          struct /* ctor */ {

            // drake/systems/analysis/initial_value_problem.h:89
            const char* doc =
R"""(Default constructor, leaving all values unspecified.)""";

            // drake/systems/analysis/initial_value_problem.h:96
            const char* doc_2 =
R"""(Constructor specifying all values.

Parameter ``t0_in``:
    Specified initial time t₀.

Parameter ``x0_in``:
    Specified initial state vector 𝐱₀.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";

          } ctor;

          // drake::systems::InitialValueProblem::SpecifiedValues::k
          struct /* k */ {

            // drake/systems/analysis/initial_value_problem.h:111
            const char* doc = R"""(< The parameter vector 𝐤 for the IVP.)""";

          } k;

          // drake::systems::InitialValueProblem::SpecifiedValues::operator!=
          struct /* operator_ne */ {

            // drake/systems/analysis/initial_value_problem.h:105
            const char* doc = R"""()""";

          } operator_ne;

          // drake::systems::InitialValueProblem::SpecifiedValues::t0
          struct /* t0 */ {

            // drake/systems/analysis/initial_value_problem.h:109
            const char* doc = R"""(< The initial time t₀ for the IVP.)""";

          } t0;

          // drake::systems::InitialValueProblem::SpecifiedValues::x0
          struct /* x0 */ {

            // drake/systems/analysis/initial_value_problem.h:110
            const char* doc =
R"""(< The initial state vector 𝐱₀ for the IVP.)""";

          } x0;

        } SpecifiedValues;

        // drake::systems::InitialValueProblem::get_integrator
        struct /* get_integrator */ {

          // drake/systems/analysis/initial_value_problem.h:203
          const char* doc =
R"""(Gets a pointer to the internal integrator instance.)""";

        } get_integrator;

        // drake::systems::InitialValueProblem::get_mutable_integrator
        struct /* get_mutable_integrator */ {

          // drake/systems/analysis/initial_value_problem.h:208
          const char* doc =
R"""(Gets a pointer to the internal mutable integrator instance.)""";

        } get_mutable_integrator;

        // drake::systems::InitialValueProblem::reset_integrator
        struct /* reset_integrator */ {

          // drake/systems/analysis/initial_value_problem.h:195
          const char* doc =
R"""(Resets the internal integrator instance by in-place construction of
the given integrator type.

A usage example is shown below.

```
{.cpp}
   ivp.reset_integrator<RungeKutta2Integrator<T>>(max_step);
```

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types. @warning This operation
    invalidates pointers returned by
    InitialValueProblem::get_integrator() and
    InitialValueProblem::get_mutable_integrator().)""";

        } reset_integrator;

      } InitialValueProblem;

      // drake::systems::InputPort
      struct /* InputPort */ {

        // drake/systems/framework/input_port.h:22
        const char* doc =
R"""(This extends InputPortBase with some scalar type-dependent methods.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.)""";

        // drake::systems::InputPort::InputPort<T>
        struct /* ctor */ {

          // drake/systems/framework/input_port.h:24
          const char* doc = R"""()""";

          // drake/systems/framework/input_port.h:24
          const char* doc_2 = R"""()""";

          // drake/systems/framework/input_port.h:32
          const char* doc_3 =
R"""((Internal use only) Constructs a type-specific input port. See
InputPortBase::InputPortBase() for the meaning of these parameters.
The additional `system` parameter here must be the same object as the
`system_base` parameter.)""";

        } ctor;

        // drake::systems::InputPort::get_system
        struct /* get_system */ {

          // drake/systems/framework/input_port.h:47
          const char* doc =
R"""(Returns a reference to the System that owns this input port. Note that
for a Diagram input port this will be the Diagram, not the LeafSystem
whose input port was exported.)""";

        } get_system;

      } InputPort;

      // drake::systems::InputPortBase
      struct /* InputPortBase */ {

        // drake/systems/framework/framework_common.h:78
        const char* doc =
R"""(An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.

InputPortBase is the scalar type-independent part of an InputPort.)""";

        // drake/systems/framework/input_port_base.h:22
        const char* doc_2 =
R"""(An InputPort is a System resource that describes the kind of input a
System accepts, on a given port. It does not directly contain any
runtime input port data; that is always contained in a Context. The
actual value will be either the value of an OutputPort to which this
is connected, or a fixed value set in a Context.

InputPortBase is the scalar type-independent part of an InputPort.)""";

        // drake::systems::InputPortBase::InputPortBase
        struct /* ctor */ {

          // drake/systems/framework/input_port_base.h:24
          const char* doc = R"""()""";

          // drake/systems/framework/input_port_base.h:24
          const char* doc_2 = R"""()""";

          // drake/systems/framework/input_port_base.h:81
          const char* doc_3 =
R"""(Provides derived classes the ability to set the base class members at
construction.

Parameter ``index``:
    The index to be assigned to this InputPort.

Parameter ``ticket``:
    The DependencyTicket to be assigned to this InputPort.

Parameter ``data_type``:
    Whether the port described is vector- or abstract-valued.

Parameter ``size``:
    If the port described is vector-valued, the number of elements, or
    kAutoSize if determined by connections. Ignored for abstract-
    valued ports.

Parameter ``name``:
    A name for the port. Input port names should be non-empty and
    unique within a single System.

Parameter ``random_type``:
    Input ports may optionally be labeled as random, if the port is
    intended to model a random-source "noise" or "disturbance" input.

Parameter ``system_base``:
    The System that will own this new input port.)""";

        } ctor;

        // drake::systems::InputPortBase::get_data_type
        struct /* get_data_type */ {

          // drake/systems/framework/input_port_base.h:45
          const char* doc = R"""(Returns the port data type. */)""";

        } get_data_type;

        // drake::systems::InputPortBase::get_index
        struct /* get_index */ {

          // drake/systems/framework/input_port_base.h:31
          const char* doc =
R"""(Returns the index of this input port within the owning System. For a
Diagram, this will be the index within the Diagram, _not_ the index
within a LeafSystem whose input port was exported.)""";

        } get_index;

        // drake::systems::InputPortBase::get_name
        struct /* get_name */ {

          // drake/systems/framework/input_port_base.h:58
          const char* doc = R"""(Get port name. */)""";

        } get_name;

        // drake::systems::InputPortBase::get_random_type
        struct /* get_random_type */ {

          // drake/systems/framework/input_port_base.h:55
          const char* doc =
R"""(Returns the RandomDistribution if this is a random port. */)""";

        } get_random_type;

        // drake::systems::InputPortBase::get_system_base
        struct /* get_system_base */ {

          // drake/systems/framework/input_port_base.h:42
          const char* doc =
R"""(Returns a reference to the SystemBase that owns this input port. Note
that for a diagram input port this will be the diagram, not the leaf
system whose input port was exported.)""";

        } get_system_base;

        // drake::systems::InputPortBase::is_random
        struct /* is_random */ {

          // drake/systems/framework/input_port_base.h:52
          const char* doc =
R"""(Returns true if this is a random port. */)""";

        } is_random;

        // drake::systems::InputPortBase::size
        struct /* size */ {

          // drake/systems/framework/input_port_base.h:49
          const char* doc =
R"""(Returns the fixed size expected for a vector-valued input port. Not
meaningful for abstract-valued input ports.)""";

        } size;

        // drake::systems::InputPortBase::ticket
        struct /* ticket */ {

          // drake/systems/framework/input_port_base.h:35
          const char* doc =
R"""(Returns the DependencyTicket for this input port within the owning
System.)""";

        } ticket;

      } InputPortBase;

      // drake::systems::InputPortTag
      struct /* InputPortTag */ {

        // drake/systems/framework/framework_common.h:41
        const char* doc = R"""()""";

      } InputPortTag;

      // drake::systems::Integrator
      struct /* Integrator */ {

        // drake/systems/primitives/integrator.h:22
        const char* doc =
R"""(An integrator for a continuous vector input.

Template parameter ``T``:
    The type being integrated. Must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::Integrator::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/integrator.h:43
          const char* doc = R"""()""";

        } DoCalcVectorOutput;

        // drake::systems::Integrator::DoCalcVectorTimeDerivatives
        struct /* DoCalcVectorTimeDerivatives */ {

          // drake/systems/primitives/integrator.h:50
          const char* doc = R"""()""";

        } DoCalcVectorTimeDerivatives;

        // drake::systems::Integrator::Integrator<T>
        struct /* ctor */ {

          // drake/systems/primitives/integrator.h:24
          const char* doc = R"""()""";

          // drake/systems/primitives/integrator.h:24
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/integrator.h:28
          const char* doc_3 =
R"""(Constructs an Integrator system.

Parameter ``size``:
    number of elements in the signal to be processed.)""";

          // drake/systems/primitives/integrator.h:32
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::Integrator::set_integral_value
        struct /* set_integral_value */ {

          // drake/systems/primitives/integrator.h:38
          const char* doc =
R"""(Sets the value of the integral modifying the state in the context.
``value`` must be a column vector of the appropriate size.)""";

        } set_integral_value;

      } Integrator;

      // drake::systems::IntegratorBase
      struct /* IntegratorBase */ {

        // drake/systems/analysis/integrator_base.h:119
        const char* doc =
R"""(An abstract class for an integrator for ODEs and DAEs as represented
by a Drake System. Integrators solve initial value problems of the
form:

```
ẋ(t) = f(t, x(t)) with f : ℝ × ℝⁿ → ℝⁿ
```

(i.e., `f()` is an ordinary differential equation) given initial
conditions (t₀, x₀). Thus, integrators advance the continuous state of
a dynamical system forward in time.

Apart from solving initial value problems, for which the integrator is
a key component of a simulator, integrators can also be used to solve
boundary value problems (via numerical methods like the Multiple
Shooting Method) and trajectory optimization problems (via numerical
methods like direct transcription). This class and its derivatives
were developed primarily toward the former application (through
IntegrateAtMost() and the Simulator class). However, the
IntegratorBase architecture was developed to support these ancillary
applications as well using the IntegrateWithMultipleSteps() and
IntegrateWithSingleFixedStep() methods; the latter permits the caller
to advance time using fixed steps in applications where variable
stepping would be deleterious (e.g., direct transcription).

For applications that require a more dense sampling of the system
continuous state than what would be available through either fixed or
error-controlled step integration (for a given accuracy), dense output
support is available (through StartDenseIntegration() and
StopDenseIntegration() methods). The accuracy and performance of these
outputs may vary with each integration scheme implementation. Unless
specified otherwise, an HermitianDenseOutput is provided by default.

A natural question for a user to ask of an integrator is: Which scheme
(method) should be applied to a particular problem? The answer is
whichever one most quickly computes the solution to the desired
accuracy! Selecting an integration scheme for a particular problem is
presently an artform. As examples of some selection criteria:
multistep methods (none of which are currently implemented in Drake)
generally work poorly when events (that require state
reinitializations) are common, symplectic methods generally work well
at maintaining stability for large integration steps, and stiff
integrators are often best for computationally stiff systems. If
ignorant as to the characteristics of a particular problem, it is
often best to start with an explicit, Runge-Kutta type method.
Statistics collected by the integrator can help diagnose performance
issues and possibly point to the use of a different integration
scheme.

Some systems are known to exhibit "computational stiffness", by which
it is meant that (excessively) small integration steps are necessary
for purposes of stability: in other words, steps must be taken smaller
than that required to achieve a desired accuracy *over a particular
interval*. Thus, the nature of computationally stiff problems is that
the solution to the ODE is *smooth* in the interval of stiffness (in
contrast, some problems possess such high frequency dynamics that very
small steps are simply necessary to capture the solution accurately).
Implicit integrators are the go-to approach for solving
computationally stiff problems, but careful consideration is
warranted. Implicit integrators typically require much more
computation than non-implicit (explicit) integrators, stiffness might
be an issue on only a very small time interval, and some problems
might be only "moderately stiff". Put another way, applying an
implicit integrator to a potentially stiff problem might not yield
faster computation. The first chapter of [Hairer, 1996] illustrates
the issues broached in this paragraph using various examples.

Established methods for integrating ordinary differential equations
invariably make provisions for estimating the "local error" (i.e., the
error over a small time interval) of a solution. Although the
relationship between local error and global error (i.e., the
accumulated error over multiple time steps) can be tenuous, such error
estimates can allow integrators to work adaptively, subdividing time
intervals as necessary (if, e.g., the system is particularly dynamic
or stationary in an interval). Even for applications that do not
recommend such adaptive integration- like direct transcription methods
for trajectory optimization- error estimation allows the user to
assess the accuracy of the solution.

IntegratorBase provides numerous settings and flags that can leverage
problem-specific information to speed integration and/or improve
integration accuracy. As an example, set_maximum_step_size() allows
the user to prevent overly large integration steps (that integration
error control alone might be insufficient to detect). As noted
previously, IntegratorBase also collects a plethora of statistics that
can be used to diagnose poor integration performance. For example, a
large number of shrinkages due to error control could indicate that a
system is computationally stiff.

- [Hairer, 1996] E. Hairer and G. Wanner. Solving Ordinary
Differential Equations II (Stiff and Differential-Algebraic Problems).
Springer, 1996.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::IntegratorBase::CalcAdjustedStepSize
        struct /* CalcAdjustedStepSize */ {

          // drake/systems/analysis/integrator_base.h:1299
          const char* doc =
R"""(Calculates adjusted integrator step sizes toward keeping state
variables within error bounds on the next integration step. Note that
it is not guaranteed that the (possibly) reduced step size will keep
state variables within error bounds; however, the process of (1)
taking a trial integration step, (2) calculating the error, and (3)
adjusting the step size can be repeated until convergence.

Parameter ``err``:
    The norm of the integrator error that was computed using
    ``attempted_step_size``.

Parameter ``attempted_step_size``:
    The step size that was attempted. @param[in,out]
    at_minimum_step_size If `true` on entry, the error control
    mechanism is not allowed to shrink the step because the integrator
    is stepping at the minimum step size (note that this condition
    will only occur if `get_throw_on_minimum_step_size_violation() ==
    false`- an exception would be thrown otherwise). If `true` on
    entry and `false` on exit, the error control mechanism has managed
    to increase the step size above the working minimum; if `true` on
    entry and `true` on exit, error control would like to shrink the
    step size but cannot. If `false` on entry and `true` on exit,
    error control shrank the step to the working minimum step size.

Returns:
    a pair of types bool and T; the bool will be set to `true` if the
    integration step was to be considered successful and `false`
    otherwise. The value of the T type will be set to the recommended
    next step size.)""";

          // drake/systems/analysis/integrator_base.h:1763
          const char* doc_2 =
R"""(Calculates adjusted integrator step sizes toward keeping state
variables within error bounds on the next integration step. Note that
it is not guaranteed that the (possibly) reduced step size will keep
state variables within error bounds; however, the process of (1)
taking a trial integration step, (2) calculating the error, and (3)
adjusting the step size can be repeated until convergence.

Parameter ``err``:
    The norm of the integrator error that was computed using
    ``attempted_step_size``.

Parameter ``attempted_step_size``:
    The step size that was attempted. @param[in,out]
    at_minimum_step_size If `true` on entry, the error control
    mechanism is not allowed to shrink the step because the integrator
    is stepping at the minimum step size (note that this condition
    will only occur if `get_throw_on_minimum_step_size_violation() ==
    false`- an exception would be thrown otherwise). If `true` on
    entry and `false` on exit, the error control mechanism has managed
    to increase the step size above the working minimum; if `true` on
    entry and `true` on exit, error control would like to shrink the
    step size but cannot. If `false` on entry and `true` on exit,
    error control shrank the step to the working minimum step size.

Returns:
    a pair of types bool and T; the bool will be set to `true` if the
    integration step was to be considered successful and `false`
    otherwise. The value of the T type will be set to the recommended
    next step size.)""";

        } CalcAdjustedStepSize;

        // drake::systems::IntegratorBase::CalcStateChangeNorm
        struct /* CalcStateChangeNorm */ {

          // drake/systems/analysis/integrator_base.h:1269
          const char* doc =
R"""(Computes the infinity norm of a change in continuous state. We use the
infinity norm to capture the idea that, by providing accuracy
requirements, the user can indirectly specify error tolerances that
act to limit the largest error in any state vector component.

Returns:
    the norm (a non-negative value))""";

          // drake/systems/analysis/integrator_base.h:1703
          const char* doc_2 =
R"""(Computes the infinity norm of a change in continuous state. We use the
infinity norm to capture the idea that, by providing accuracy
requirements, the user can indirectly specify error tolerances that
act to limit the largest error in any state vector component.

Returns:
    the norm (a non-negative value))""";

        } CalcStateChangeNorm;

        // drake::systems::IntegratorBase::CalcTimeDerivatives
        struct /* CalcTimeDerivatives */ {

          // drake/systems/analysis/integrator_base.h:1170
          const char* doc =
R"""(Evaluates the derivative function (and updates call statistics).
Subclasses should call this function rather than calling
system.CalcTimeDerivatives() directly.)""";

          // drake/systems/analysis/integrator_base.h:1182
          const char* doc_2 =
R"""(Evaluates the derivative function (and updates call statistics).
Subclasses should call this function rather than calling
system.CalcTimeDerivatives() directly. This version of this function
exists to allow integrators to count AutoDiff'd systems in derivative
function evaluations.)""";

        } CalcTimeDerivatives;

        // drake::systems::IntegratorBase::DoDenseStep
        struct /* DoDenseStep */ {

          // drake/systems/analysis/integrator_base.h:1377
          const char* doc =
R"""(Derived classes may implement this method to (1) integrate the
continuous portion of this system forward by a single step of size
``dt``, (2) set the error estimate (via get_mutable_error_estimate())
and (3) update their own dense output implementation (via
get_mutable_dense_output()). This method is called during the default
Step() method.

Parameter ``dt``:
    The integration step to take.

Returns:
    `true` if successful, `false` if either the integrator was unable
    to take a single step of size ``dt`` or to advance its dense
    output an equal step.

See also:
    DoStep()

TODO(hidmic): Make pure virtual and override on each subclass, as the
'optimal' dense output scheme is only known by the specific
integration scheme being implemented.)""";

        } DoDenseStep;

        // drake::systems::IntegratorBase::DoInitialize
        struct /* DoInitialize */ {

          // drake/systems/analysis/integrator_base.h:1309
          const char* doc =
R"""(Derived classes can override this method to perform special
initialization. This method is called during the Initialize() method.
This default method does nothing.)""";

        } DoInitialize;

        // drake::systems::IntegratorBase::DoReset
        struct /* DoReset */ {

          // drake/systems/analysis/integrator_base.h:1315
          const char* doc =
R"""(Derived classes can override this method to perform routines when
Reset() is called. This default method does nothing.)""";

        } DoReset;

        // drake::systems::IntegratorBase::DoResetStatistics
        struct /* DoResetStatistics */ {

          // drake/systems/analysis/integrator_base.h:1165
          const char* doc =
R"""(Resets any statistics particular to a specific integrator. The default
implementation of this function does nothing. If your integrator
collects its own statistics, you should re-implement this method and
reset them there.)""";

        } DoResetStatistics;

        // drake::systems::IntegratorBase::DoStartDenseIntegration
        struct /* DoStartDenseIntegration */ {

          // drake/systems/analysis/integrator_base.h:1326
          const char* doc =
R"""(Derived classes can override this method to provide a continuous
extension of their own when StartDenseIntegration() is called.

TODO(hidmic): Make pure virtual and override on each subclass, as the
'optimal' dense output scheme is only known by the specific
integration scheme being implemented.)""";

        } DoStartDenseIntegration;

        // drake::systems::IntegratorBase::DoStep
        struct /* DoStep */ {

          // drake/systems/analysis/integrator_base.h:1359
          const char* doc =
R"""(Derived classes must implement this method to (1) integrate the
continuous portion of this system forward by a single step of size
``dt`` and (2) set the error estimate (via
get_mutable_error_estimate()). This method is called during the
default Step() method.

Parameter ``dt``:
    The integration step to take.

Returns:
    `true` if successful, `false` if the integrator was unable to take
    a single step of size ``dt`` (due to, e.g., an integrator
    convergence failure). @post If the time on entry is denoted `t`,
    the time and state will be advanced to `t+dt` if the method
    returns `true`; otherwise, the time and state should be reset to
    those at `t`. @warning It is expected that DoStep() will return
    `true` for some, albeit possibly very small, positive value of
    ``dt``. The derived integrator's stepping algorithm can make this
    guarantee, for example, by switching to an algorithm not subject
    to convergence failures (e.g., explicit Euler) for very small step
    sizes.)""";

        } DoStep;

        // drake::systems::IntegratorBase::Initialize
        struct /* Initialize */ {

          // drake/systems/analysis/integrator_base.h:462
          const char* doc =
R"""(An integrator must be initialized before being used. The pointer to
the context must be set before Initialize() is called (or an
std::logic_error will be thrown). If Initialize() is not called, an
exception will be thrown when attempting to call StepOnceAtMost(). To
reinitialize the integrator, Reset() should be called followed by
Initialize().

Throws:
    s std::logic_error If the context has not been set or a user-set
    parameter has been set illogically (i.e., one of the weighting
    matrix coefficients is set to a negative value- this check is only
    performed for integrators that support error estimation; the
    maximum step size is smaller than the minimum step size; the
    requested initial step size is outside of the interval [minimum
    step size, maximum step size]).

See also:
    Reset())""";

        } Initialize;

        // drake::systems::IntegratorBase::InitializeAccuracy
        struct /* InitializeAccuracy */ {

          // drake/systems/analysis/integrator_base.h:1210
          const char* doc =
R"""(Generic code for validating (and resetting, if need be) the integrator
working accuracy for error controlled integrators. This method is
intended to be called from an integrator's DoInitialize() method.

Parameter ``default_accuracy``:
    a reasonable default accuracy setting for this integrator.

Parameter ``loosest_accuracy``:
    the loosest accuracy that this integrator should support.

Parameter ``max_step_fraction``:
    a fraction of the maximum step size to use when setting the
    integrator accuracy and the user has not specified accuracy
    directly.

Throws:
    s std::logic_error if neither the initial step size target nor the
    maximum step size has been set.)""";

        } InitializeAccuracy;

        // drake::systems::IntegratorBase::IntegrateAtMost
        struct /* IntegrateAtMost */ {

          // drake/systems/analysis/integrator_base.h:568
          const char* doc =
R"""(Integrates the system forward in time by a single step with step size
subject to integration error tolerances (assuming that the integrator
supports error estimation). The integrator must already have been
initialized or an exception will be thrown. The context will be
integrated forward by an amount that will never exceed the minimum of
`publish_dt`, `update_dt`, and `1.01 * get_maximum_step_size()`.

Parameter ``publish_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) at which the next publish will occur.

Parameter ``update_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) at which the next update will occur.

Parameter ``boundary_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) marking the end of the user-designated simulated interval.

Throws:
    s std::logic_error If the integrator has not been initialized or
    one of publish_dt, update_dt, or boundary_dt is negative.

Returns:
    The reason for the integration step ending. @warning Users should
    generally not call this function directly; within simulation
    circumstances, users will typically call `Simulator::StepTo()`. In
    other circumstances, users will typically call
    `IntegratorBase::IntegrateWithMultipleSteps()`.

This method at a glance: - For integrating ODEs/DAEs via Simulator -
Supports fixed step and variable step integration schemes - Takes only
a single step forward.)""";

          // drake/systems/analysis/integrator_base.h:1865
          const char* doc_2 =
R"""(Integrates the system forward in time by a single step with step size
subject to integration error tolerances (assuming that the integrator
supports error estimation). The integrator must already have been
initialized or an exception will be thrown. The context will be
integrated forward by an amount that will never exceed the minimum of
`publish_dt`, `update_dt`, and `1.01 * get_maximum_step_size()`.

Parameter ``publish_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) at which the next publish will occur.

Parameter ``update_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) at which the next update will occur.

Parameter ``boundary_dt``:
    The step size, >= 0.0 (exception will be thrown if this is not the
    case) marking the end of the user-designated simulated interval.

Throws:
    s std::logic_error If the integrator has not been initialized or
    one of publish_dt, update_dt, or boundary_dt is negative.

Returns:
    The reason for the integration step ending. @warning Users should
    generally not call this function directly; within simulation
    circumstances, users will typically call `Simulator::StepTo()`. In
    other circumstances, users will typically call
    `IntegratorBase::IntegrateWithMultipleSteps()`.

This method at a glance: - For integrating ODEs/DAEs via Simulator -
Supports fixed step and variable step integration schemes - Takes only
a single step forward.)""";

        } IntegrateAtMost;

        // drake::systems::IntegratorBase::IntegrateWithMultipleSteps
        struct /* IntegrateWithMultipleSteps */ {

          // drake/systems/analysis/integrator_base.h:600
          const char* doc =
R"""(Stepping function for integrators operating outside of Simulator that
advances the continuous state exactly by ``dt``. This method is
designed for integrator users that do not wish to consider publishing
or discontinuous, mid-interval updates. This method will step the
integrator multiple times, as necessary, to attain requested error
tolerances and to ensure the integrator converges. @warning Users
should simulate systems using `Simulator::StepTo()` in place of this
function (which was created for off-simulation purposes), generally.

Parameter ``dt``:
    The non-negative integration step to take.

Throws:
    s std::logic_error If the integrator has not been initialized or
    dt is negative.

See also:
    IntegrateAtMost(), which is designed to be operated by Simulator
    and accounts for publishing and state reinitialization.

See also:
    IntegrateWithSingleStep(), which is also designed to be operated
    *outside of* Simulator, but throws an exception if the integrator
    cannot advance time by ``dt`` in a single step.

This method at a glance: - For integrating ODEs/DAEs not using
Simulator - Supports fixed step and variable step integration schemes
- Takes as many steps as necessary until time has advanced by ``dt``)""";

        } IntegrateWithMultipleSteps;

        // drake::systems::IntegratorBase::IntegrateWithSingleFixedStep
        struct /* IntegrateWithSingleFixedStep */ {

          // drake/systems/analysis/integrator_base.h:653
          const char* doc =
R"""(Stepping function for integrators operating outside of Simulator that
advances the continuous state exactly by ``dt`` *and using a single
fixed step*. This method is designed for integrator users that do not
wish to consider publishing or discontinuous, mid-interval updates.
One such example application is that of direct transcription for
trajectory optimization, for which the integration process should be
_consistent_: it should execute the same sequence of arithmetic
operations for all values of the nonlinear programming variables. In
keeping with the naming semantics of this function, error controlled
integration is not supported (though error estimates will be computed
for integrators that support that feature), which is a minimal
requirement for "consistency". @warning Users should simulate systems
using `Simulator::StepTo()` in place of this function (which was
created for off-simulation purposes), generally.

Parameter ``dt``:
    The non-negative integration step to take.

Throws:
    s std::logic_error If the integrator has not been initialized or
    dt is negative **or** if the integrator is not operating in fixed
    step mode.

Throws:
    s std::runtime_error If the integrator was unable to take a step
    of the requested size.

See also:
    IntegrateAtMost(), which is designed to be operated by Simulator
    and accounts for publishing and state reinitialization.

See also:
    IntegrateWithMultipleSteps(), which is also designed to be
    operated *outside of* Simulator, but will take as many integration
    steps as necessary until time has been stepped forward by ``dt``.

This method at a glance: - For integrating ODEs/DAEs not using
Simulator - Fixed step integration (no step size reductions for error
control or integrator convergence) - Takes only a single step forward.)""";

        } IntegrateWithSingleFixedStep;

        // drake::systems::IntegratorBase::IntegratorBase<T>
        struct /* ctor */ {

          // drake/systems/analysis/integrator_base.h:121
          const char* doc = R"""()""";

          // drake/systems/analysis/integrator_base.h:121
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/integrator_base.h:174
          const char* doc_3 =
R"""(Maintains references to the system being integrated and the context
used to specify the initial conditions for that system (if any).

Parameter ``system``:
    A reference to the system to be integrated; the integrator will
    maintain a reference to the system in perpetuity, so the
    integrator must not outlive the system.

Parameter ``context``:
    A pointer to a writeable context (nullptr is ok, but a non-null
    pointer must be set before Initialize() is called). The integrator
    will advance the system state using the pointer to this context.
    The pointer to the context will be maintained internally. The
    integrator must not outlive the context.)""";

        } ctor;

        // drake::systems::IntegratorBase::Reset
        struct /* Reset */ {

          // drake/systems/analysis/integrator_base.h:413
          const char* doc =
R"""(Resets the integrator to initial values, i.e., default construction
values.)""";

        } Reset;

        // drake::systems::IntegratorBase::ResetStatistics
        struct /* ResetStatistics */ {

          // drake/systems/analysis/integrator_base.h:683
          const char* doc =
R"""(@name Integrator statistics methods.

@{ These methods allow the caller to manipulate and query integrator
statistics. Generally speaking, the larger the integration step taken,
the faster a simulation will run. These methods allow querying (and
resetting) the integrator statistics as one means of determining how
to make a simulation run faster.

Forget accumulated statistics. These are reset to the values they have
post construction or immediately after `Initialize()`.)""";

        } ResetStatistics;

        // drake::systems::IntegratorBase::StartDenseIntegration
        struct /* StartDenseIntegration */ {

          // drake/systems/analysis/integrator_base.h:824
          const char* doc =
R"""(Starts dense integration, allocating a new dense output for this
integrator to use.

@pre The integrator has been initialized. @pre The system being
integrated has continuous state. @pre No dense integration is in
progress (no dense output is held by the integrator)

Throws:
    s std::logic_error if any of the preconditions is not met.
    @warning Dense integration may incur significant overhead.)""";

        } StartDenseIntegration;

        // drake::systems::IntegratorBase::StepOnceErrorControlledAtMost
        struct /* StepOnceErrorControlledAtMost */ {

          // drake/systems/analysis/integrator_base.h:1260
          const char* doc =
R"""(Default code for advancing the continuous state of the system by a
single step of ``dt_max`` (or smaller, depending on error control).
This particular function is designed to be called directly by an error
estimating integrator's DoStep() method to effect error-controlled
integration. The integrator can effect error controlled integration
without calling this method, if the implementer so chooses, but this
default method is expected to function well in most circumstances.

Parameter ``dt_max``:
    The maximum step size to be taken. The integrator may take a
    smaller step than specified to satisfy accuracy requirements, to
    resolve integrator convergence problems, or to respect the
    integrator's maximum step size.

Throws:
    s std::logic_error if integrator does not support error
    estimation.

Note:
    This function will shrink the integration step as necessary
    whenever the integrator's DoStep() fails to take the requested
    step e.g., due to integrator convergence failure.

Returns:
    `true` if the full step of size ``dt_max`` is taken and `false`
    otherwise (i.e., a smaller step than ``dt_max`` was taken).)""";

          // drake/systems/analysis/integrator_base.h:1574
          const char* doc_2 =
R"""(Default code for advancing the continuous state of the system by a
single step of ``dt_max`` (or smaller, depending on error control).
This particular function is designed to be called directly by an error
estimating integrator's DoStep() method to effect error-controlled
integration. The integrator can effect error controlled integration
without calling this method, if the implementer so chooses, but this
default method is expected to function well in most circumstances.

Parameter ``dt_max``:
    The maximum step size to be taken. The integrator may take a
    smaller step than specified to satisfy accuracy requirements, to
    resolve integrator convergence problems, or to respect the
    integrator's maximum step size.

Throws:
    s std::logic_error if integrator does not support error
    estimation.

Note:
    This function will shrink the integration step as necessary
    whenever the integrator's DoStep() fails to take the requested
    step e.g., due to integrator convergence failure.

Returns:
    `true` if the full step of size ``dt_max`` is taken and `false`
    otherwise (i.e., a smaller step than ``dt_max`` was taken).)""";

        } StepOnceErrorControlledAtMost;

        // drake::systems::IntegratorBase::StepResult
        struct /* StepResult */ {

          // drake/systems/analysis/integrator_base.h:135
          const char* doc =
R"""(Status returned by StepOnceAtMost(). When a step is successful, it
will return an indication of what caused it to stop where it did. When
unsuccessful it will throw an exception so you won't see any return
value. When return of control is due ONLY to reaching a publish time,
(status is kReachedPublishTime) the context may return an interpolated
value at an earlier time.

Note: the simulation step must always end at an update time but can
end after a publish time.)""";

          // drake::systems::IntegratorBase::StepResult::kReachedBoundaryTime
          struct /* kReachedBoundaryTime */ {

            // drake/systems/analysis/integrator_base.h:155
            const char* doc =
R"""(Reached the desired integration time without reaching an update time.)""";

          } kReachedBoundaryTime;

          // drake::systems::IntegratorBase::StepResult::kReachedPublishTime
          struct /* kReachedPublishTime */ {

            // drake/systems/analysis/integrator_base.h:139
            const char* doc =
R"""(Indicates a publish time has been reached but not an update time.)""";

          } kReachedPublishTime;

          // drake::systems::IntegratorBase::StepResult::kReachedStepLimit
          struct /* kReachedStepLimit */ {

            // drake/systems/analysis/integrator_base.h:158
            const char* doc =
R"""(Took maximum number of steps without finishing integrating over the
interval.)""";

          } kReachedStepLimit;

          // drake::systems::IntegratorBase::StepResult::kReachedUpdateTime
          struct /* kReachedUpdateTime */ {

            // drake/systems/analysis/integrator_base.h:147
            const char* doc =
R"""(Indicates that integration terminated at an update time.)""";

          } kReachedUpdateTime;

          // drake::systems::IntegratorBase::StepResult::kReachedZeroCrossing
          struct /* kReachedZeroCrossing */ {

            // drake/systems/analysis/integrator_base.h:143
            const char* doc =
R"""(Localized an event; this is the *before* state (interpolated).)""";

          } kReachedZeroCrossing;

          // drake::systems::IntegratorBase::StepResult::kTimeHasAdvanced
          struct /* kTimeHasAdvanced */ {

            // drake/systems/analysis/integrator_base.h:151
            const char* doc =
R"""(User requested control whenever an internal step is successful.)""";

          } kTimeHasAdvanced;

        } StepResult;

        // drake::systems::IntegratorBase::StopDenseIntegration
        struct /* StopDenseIntegration */ {

          // drake/systems/analysis/integrator_base.h:865
          const char* doc =
R"""(Stops dense integration, yielding ownership of the current dense
output to the caller.

Remark:
    s This process is irreversible.

Returns:
    A DenseOutput instance, i.e. a representation of the continuous
    state trajectory of the system being integrated that can be
    evaluated at any time within its extension. This representation is
    defined starting at the context time of the last
    StartDenseIntegration() call and finishing at the current context
    time. @pre Dense integration is in progress (a dense output is
    held by this integrator, after a call to StartDenseIntegration()).
    @post Previously held dense output is not updated nor referenced
    by the integrator anymore.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } StopDenseIntegration;

        // drake::systems::IntegratorBase::get_accuracy_in_use
        struct /* get_accuracy_in_use */ {

          // drake/systems/analysis/integrator_base.h:262
          const char* doc =
R"""(Gets the accuracy in use by the integrator. This number may differ
from the target accuracy if, for example, the user has requested an
accuracy not attainable or not recommended for the particular
integrator.)""";

        } get_accuracy_in_use;

        // drake::systems::IntegratorBase::get_actual_initial_step_size_taken
        struct /* get_actual_initial_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:729
          const char* doc =
R"""(The actual size of the successful first step.)""";

        } get_actual_initial_step_size_taken;

        // drake::systems::IntegratorBase::get_context
        struct /* get_context */ {

          // drake/systems/analysis/integrator_base.h:774
          const char* doc =
R"""(Returns a const reference to the internally-maintained Context holding
the most recent state in the trajectory. This is suitable for
publishing or extracting information about this trajectory step.)""";

        } get_context;

        // drake::systems::IntegratorBase::get_dense_output
        struct /* get_dense_output */ {

          // drake/systems/analysis/integrator_base.h:844
          const char* doc =
R"""(Returns a const pointer to the integrator's current DenseOutput
instance, holding a representation of the continuous state trajectory
since the last StartDenseIntegration() call. This is suitable to query
the integrator's current dense output, if any (may be nullptr).)""";

        } get_dense_output;

        // drake::systems::IntegratorBase::get_error_estimate
        struct /* get_error_estimate */ {

          // drake/systems/analysis/integrator_base.h:905
          const char* doc =
R"""(Gets the error estimate (used only for integrators that support error
estimation). If the integrator does not support error estimation,
nullptr is returned.)""";

        } get_error_estimate;

        // drake::systems::IntegratorBase::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/integrator_base.h:890
          const char* doc =
R"""(Derived classes must override this function to return the order of the
integrator's error estimate. If the integrator does not provide an
error estimate, the derived class implementation should return 0.)""";

        } get_error_estimate_order;

        // drake::systems::IntegratorBase::get_fixed_step_mode
        struct /* get_fixed_step_mode */ {

          // drake/systems/analysis/integrator_base.h:213
          const char* doc =
R"""(Gets whether an integrator is running in fixed step mode. If the
integrator does not support error estimation, this function will
always return `true`. If the integrator runs in fixed step mode, it
will always take the maximum step size directed (which may be that
determined by get_maximum_step_size() or may be smaller, as directed
by, e.g., Simulator for event handling purposes).

See also:
    set_fixed_step_mode())""";

        } get_fixed_step_mode;

        // drake::systems::IntegratorBase::get_generalized_state_weight_vector
        struct /* get_generalized_state_weight_vector */ {

          // drake/systems/analysis/integrator_base.h:1109
          const char* doc =
R"""(@name Methods for weighting state variable errors @{ This group of
methods describes how errors for state variables with heterogeneous
units are weighted in the context of error-controlled integration.
This is an advanced topic and most users can simply specify desired
accuracy and accept the default state variable weights.

A collection of state variables is generally defined in heterogeneous
units (e.g. length, angles, velocities, energy). Some of the state
variables cannot even be expressed in meaningful units, like
quaternions. Certain integrators provide an estimate of the absolute
error made in each state variable during an integration step. These
errors must be properly weighted to obtain an "accuracy" _with respect
to each particular variable_. These per-variable accuracy
determinations can be compared against the user's requirements and
used to select an appropriate size for the next step [Sherman 2011].
The weights are normally determined automatically using the system's
characteristic dimensions, so *most users can stop reading now!*
Custom weighting is primarily useful for performance improvement; an
optimal weighting would allow an error-controlled integrator to
provide the desired level of accuracy across all state variables
without wasting computation achieving superfluous accuracy for some of
those variables.

Users interested in more precise control over state variable weighting
may use the methods in this group to access and modify weighting
factors for individual state variables. Changes to these weights can
only be made prior to integrator initialization or as a result of an
event being triggered and then followed by re-initialization.

<h4>Relative versus absolute accuracy</h4>

State variable integration error, as estimated by an integrator, is an
absolute quantity with the same units as the variable. At each time
step we therefore need to determine an absolute error that would be
deemed "good enough", i.e. satisfies the user's accuracy requirement.
If a variable is maintained to a *relative* accuracy then that "good
enough" value is defined to be the required accuracy `a` (a fraction
like 0.001) times the current value of the variable, as long as that
value is far from zero. For variables maintained to an *absolute*
accuracy, or relative variables that are at or near zero (where
relative accuracy would be undefined or too strict, respectively), we
need a different way to determine the "good enough" absolute error.
The methods in this section control how that absolute error value is
calculated.

<h4>How to choose weights</h4>

The weight `wᵢ` for a state variable `xᵢ` should be chosen so that the
product `wᵢ * dxᵢ` is unitless, and in particular is 1 when `dxᵢ`
represents a "unit effect" of state variable `xᵢ`; that is, the change
in `xᵢ` that produces a unit change in some quantity of interest in
the system being simulated. Why unity (1)? Aside from normalizing the
values, unity "grounds" the weighted error to the user-specified
accuracy. A weighting can be applied individually to each state
variable, but typically it is done approximately by combining the
known type of the variable (e.g. length, angle) with a "characteristic
scale" for that quantity. For example, if a "characteristic length"
for the system being simulated is 0.1 meters, and `x₀` is a length
variable measured in meters, then `w₀` should be 10 so that `w₀*dx₀=1`
when `dx₀=0.1`. For angles representing pointing accuracy (say a
camera direction) we typically assume a "characteristic angle" is one
radian (about 60 degrees), so if x₁ is a pointing direction then w₁=1
is an appropriate weight. We can now scale an error vector `e=[dx₀
dx₁]` to a unitless fractional error vector `f=[w₀*dx₀ w₁*dx₁]`. Now
to achieve a given accuracy `a`, say `a=.0001`, we need only check
that `|fᵢ|<=a` for each element `i` of `f`. Further, this gives us a
quantitative measure of "worst accuracy" that we can use to increase
or reduce size of the next attempted step, so that we will just
achieve the required accuracy but not much more. We'll be more precise
about this below.

@anchor quasi_coordinates <h4>Some subtleties for second-order dynamic
systems</h4>

Systems governed by 2nd-order differential equations are typically
split into second order (configuration) variables q, and rate
(velocity) variables v, where the time derivatives qdot of q are
linearly related to v by the kinematic differential equation `qdot =
dq/dt = N(q)*v`. Velocity variables are chosen to be physically
significant, but configuration variables may be chosen for convenience
and do not necessarily have direct physical interpretation. For
examples, quaternions are chosen as a numerically stable orientation
representation. This is problematic for choosing weights which must be
done by physical reasoning as sketched above. We resolve this by
introducing the notion of "quasi-coordinates" ꝗ (pronounced "qbar")
which are defined by the equation `ꝗdot = dꝗ/dt = v`. Other than time
scaling, quasi-coordinates have the same units as their corresponding
velocity variables. That is, for weighting we need to think of the
configuration coordinates in the same physical space as the velocity
variables; weight those by their physical significance; and then map
back to an instantaneous weighting on the actual configuration
variables q. This mapping is performed automatically; you need only to
be concerned about physical weightings.

Note that generalized quasi-coordinates `ꝗ` can only be defined
locally for a particular configuration `q`. There is in general no
meaningful set of `n` generalized coordinates which can be
differentiated with respect to time to yield `v`. For example, the
Hairy Ball Theorem implies that it is not possible for three
orientation variables to represent all 3D rotations without
singularities, yet three velocity variables can represent angular
velocity in 3D without singularities.

To summarize, separate weights can be provided for each of - `n`
generalized quasi-coordinates `ꝗ` (configuration variables in the
velocity variable space), and - `nz` miscellaneous continuous state
variables `z`.

Weights on the generalized velocity variables `v (= dꝗ/dt)` are
derived directly from the weights on `ꝗ`, weighted by a characteristic
time. Weights on the actual `nq` generalized coordinates can be
calculated efficiently from weights on the quasi-coordinates (details
below).

<h4>How the weights are used</h4>

The errors in the `ꝗ` and `z` variables are weighted by the diagonal
elements of diagonal weighting matrices Wꝗ and Wz, respectively. (The
block-diagonal weighting matrix `Wq` on the original generalized
coordinates `q` is calculated from `N` and `Wꝗ`; see below.) In the
absence of other information, the default for all weighting values is
one, so `Wꝗ` and `Wz` are `n × n` and `nz × nz` identity matrices. The
weighting matrix `Wv` for the velocity variables is just `Wv = τ*Wꝗ`
where `τ` is a "characteristic time" for the system, that is, a
quantity in time units that represents a significant evolution of the
trajectory. This serves to control the accuracy with which velocity is
determined relative to configuration. Note that larger values of `τ`
are more conservative since they increase the velocity weights.
Typically we use `τ=1.0` or `0.1` seconds for human-scale mechanical
systems. <!-- TODO(sherm1): provide more guidance for velocity
weighting. -->

The weighting matrices `Wq`, `Wv`, and `Wz` are used to compute a
weighted infinity norm as follows. Although `Wv` and `Wz` are
constant, the actual weightings may be state dependent for relative-
error calculations. Define block diagonal error weighting matrix
`E=diag(Eq,Ev,Ez)` as follows:

```
Eq = Wq
  Ev: Ev(i,i) = { min(Wv(i,i), 1/|vᵢ|)     if vᵢ is relative
                { Wv(i,i)                  if vᵢ is absolute
  Ez: Ez(i,i) = { min(Wz(i,i), 1/|zᵢ|)     if zᵢ is relative
                { Wz(i,i)                  if zᵢ is absolute
```

(`Ev` and `Ez` are diagonal.) A `v` or `z` will be maintained to
relative accuracy unless (a) it is "close" to zero (less than 1), or
(b) the variable has been defined as requiring absolute accuracy.
Position variables `q` are always maintained to absolute accuracy (see
[Sherman 2011] for rationale).

Now given an error estimate vector `e=[eq ev ez]`, the vector `f=E*e`
can be considered to provide a unitless fractional error for each of
the state variables. To achieve a given user-specified accuracy `a`,
we require that norm_inf(`f`) <= `a`. That is, no element of `f` can
have absolute value larger than `a`. We also use `f` to determine an
ideal next step size using an appropriate integrator-specific
computation.

<h4>Determining weights for q</h4>

The kinematic differential equations `qdot=N(q)*v` employ an `nq × n`
matrix `N`. By construction, this relationship is invertible using
`N`'s left pseudo-inverse `N⁺` so that `v=N⁺ qdot` and `N⁺ N = I` (the
identity matrix); however, `N N⁺ != I`, as `N` has more rows than
columns generally. [Nikravesh 1988] shows how such a matrix `N` can be
determined and provides more information. Given this relationship
between `N` and `N⁺`, we can relate weighted errors in configuration
coordinates `q` to weighted errors in generalized quasi-coordinates
`ꝗ`, as the following derivation shows:

```
v = N⁺ qdot         Inverse kinematic differential equation
       dꝗ/dt = N⁺ dq/dt        Use synonyms for v and qdot
          dꝗ = N⁺ dq           Change time derivatives to differentials
       Wꝗ dꝗ = Wꝗ N⁺ dq        Pre-multiply both sides by Wꝗ
     N Wꝗ dꝗ = N Wꝗ N⁺ dq      Pre-multiply both sides by N
     N Wꝗ dꝗ = Wq dq           Define Wq := N Wꝗ N⁺
      N Wꝗ v = Wq qdot         Back to time derivatives.
```

The last two equations show that `Wq` as defined above provides the
expected relationship between the weighted `ꝗ` or `v` variables in
velocity space and the weighted `q` or `qdot` (resp.) variables in
configuration space.

Finally, note that a diagonal entry of one of the weighting matrices
can be set to zero to disable error estimation for that state variable
(i.e., auxiliary variable or configuration/velocity variable pair),
but that setting an entry to a negative value will cause an exception
to be thrown when the integrator is initialized.

- [Nikravesh 1988] P. Nikravesh. Computer-Aided Analysis of Mechanical
Systems. Prentice Hall, 1988. Sec. 6.3. - [Sherman 2011] M. Sherman,
et al. Procedia IUTAM 2:241-261 (2011), Section 3.3.
http://dx.doi.org/10.1016/j.piutam.2011.04.023

See also:
    CalcStateChangeNorm()

Gets the weighting vector (equivalent to a diagonal matrix) applied to
weighting both generalized coordinate and velocity state variable
errors, as described in the group documentation. Only used for
integrators that support error estimation.)""";

        } get_generalized_state_weight_vector;

        // drake::systems::IntegratorBase::get_ideal_next_step_size
        struct /* get_ideal_next_step_size */ {

          // drake/systems/analysis/integrator_base.h:767
          const char* doc =
R"""(Return the step size the integrator would like to take next, based
primarily on the integrator's accuracy prediction. This value will not
be computed for integrators that do not support error estimation and
NaN will be returned.)""";

        } get_ideal_next_step_size;

        // drake::systems::IntegratorBase::get_initial_step_size_target
        struct /* get_initial_step_size_target */ {

          // drake/systems/analysis/integrator_base.h:534
          const char* doc =
R"""(Gets the target size of the first integration step. You can find out
what step size was *actually* used for the first integration step with
`get_actual_initial_step_size_taken()`.

See also:
    request_initial_step_size_target())""";

        } get_initial_step_size_target;

        // drake::systems::IntegratorBase::get_largest_step_size_taken
        struct /* get_largest_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:747
          const char* doc =
R"""(The size of the largest step taken since the last Initialize() or
ResetStatistics() call.)""";

        } get_largest_step_size_taken;

        // drake::systems::IntegratorBase::get_maximum_step_size
        struct /* get_maximum_step_size */ {

          // drake/systems/analysis/integrator_base.h:283
          const char* doc =
R"""(Gets the maximum step size that may be taken by this integrator. This
is a soft maximum: the integrator may stretch it by as much as 1% to
hit a discrete event.

See also:
    set_requested_minimum_step_size())""";

        } get_maximum_step_size;

        // drake::systems::IntegratorBase::get_misc_state_weight_vector
        struct /* get_misc_state_weight_vector */ {

          // drake/systems/analysis/integrator_base.h:1136
          const char* doc =
R"""(Gets the weighting vector (equivalent to a diagonal matrix) for
weighting errors in miscellaneous continuous state variables `z`. Only
used for integrators that support error estimation.)""";

        } get_misc_state_weight_vector;

        // drake::systems::IntegratorBase::get_mutable_context
        struct /* get_mutable_context */ {

          // drake/systems/analysis/integrator_base.h:780
          const char* doc =
R"""(Returns a mutable pointer to the internally-maintained Context holding
the most recent state in the trajectory.)""";

        } get_mutable_context;

        // drake::systems::IntegratorBase::get_mutable_dense_output
        struct /* get_mutable_dense_output */ {

          // drake/systems/analysis/integrator_base.h:1337
          const char* doc =
R"""(Returns a mutable pointer to the internally-maintained
StepwiseDenseOutput instance, holding a representation of the
continuous state trajectory since the last time
StartDenseIntegration() was called. This is useful for derived classes
to update the integrator's current dense output, if any (may be
nullptr).)""";

        } get_mutable_dense_output;

        // drake::systems::IntegratorBase::get_mutable_error_estimate
        struct /* get_mutable_error_estimate */ {

          // drake/systems/analysis/integrator_base.h:1412
          const char* doc =
R"""(Gets an error estimate of the state variables recorded by the last
call to StepOnceFixedSize(). If the integrator does not support error
estimation, this function will return nullptr.)""";

        } get_mutable_error_estimate;

        // drake::systems::IntegratorBase::get_mutable_generalized_state_weight_vector
        struct /* get_mutable_generalized_state_weight_vector */ {

          // drake/systems/analysis/integrator_base.h:1126
          const char* doc =
R"""(Gets a mutable weighting vector (equivalent to a diagonal matrix)
applied to weighting both generalized coordinate and velocity state
variable errors, as described in the group documentation. Only used
for integrators that support error estimation. Returns a VectorBlock
to make the values mutable without permitting changing the size of the
vector. Requires re-initializing the integrator after calling this
method; if Initialize() is not called afterward, an exception will be
thrown when attempting to call StepOnceAtMost(). If the caller sets
one of the entries to a negative value, an exception will be thrown
when the integrator is initialized.)""";

        } get_mutable_generalized_state_weight_vector;

        // drake::systems::IntegratorBase::get_mutable_misc_state_weight_vector
        struct /* get_mutable_misc_state_weight_vector */ {

          // drake/systems/analysis/integrator_base.h:1151
          const char* doc =
R"""(Gets a mutable weighting vector (equivalent to a diagonal matrix) for
weighting errors in miscellaneous continuous state variables `z`. Only
used for integrators that support error estimation. Returns a
VectorBlock to make the values mutable without permitting changing the
size of the vector. Requires re-initializing the integrator after
calling this method. If Initialize() is not called afterward, an
exception will be thrown when attempting to call StepOnceAtMost(). If
the caller sets one of the entries to a negative value, an exception
will be thrown when the integrator is initialized.)""";

        } get_mutable_misc_state_weight_vector;

        // drake::systems::IntegratorBase::get_num_derivative_evaluations
        struct /* get_num_derivative_evaluations */ {

          // drake/systems/analysis/integrator_base.h:724
          const char* doc =
R"""(Returns the number of ODE function evaluations (calls to
CalcTimeDerivatives()) since the last call to ResetStatistics() or
Initialize(). This count includes *all* such calls including (1) those
necessary to compute Jacobian matrices; (2) those used in rejected
integrated steps (for, e.g., purposes of error control); (3) those
used strictly for integrator error estimation; and (4) calls that
exhibit little cost (due to results being cached).)""";

        } get_num_derivative_evaluations;

        // drake::systems::IntegratorBase::get_num_step_shrinkages_from_error_control
        struct /* get_num_step_shrinkages_from_error_control */ {

          // drake/systems/analysis/integrator_base.h:711
          const char* doc =
R"""(Gets the number of step size shrinkages due to failure to meet
targeted error tolerances, since the last call to ResetStatistics or
Initialize().)""";

        } get_num_step_shrinkages_from_error_control;

        // drake::systems::IntegratorBase::get_num_step_shrinkages_from_substep_failures
        struct /* get_num_step_shrinkages_from_substep_failures */ {

          // drake/systems/analysis/integrator_base.h:705
          const char* doc =
R"""(Gets the number of step size shrinkages due to sub-step failures
(e.g., integrator convergence failures) since the last call to
ResetStatistics() or Initialize().)""";

        } get_num_step_shrinkages_from_substep_failures;

        // drake::systems::IntegratorBase::get_num_steps_taken
        struct /* get_num_steps_taken */ {

          // drake/systems/analysis/integrator_base.h:755
          const char* doc =
R"""(The number of integration steps taken since the last Initialize() or
ResetStatistics() call.)""";

        } get_num_steps_taken;

        // drake::systems::IntegratorBase::get_num_substep_failures
        struct /* get_num_substep_failures */ {

          // drake/systems/analysis/integrator_base.h:698
          const char* doc =
R"""(Gets the number of failed sub-steps (implying one or more step size
reductions was required to permit solving the necessary nonlinear
system of equations).)""";

        } get_num_substep_failures;

        // drake::systems::IntegratorBase::get_previous_integration_step_size
        struct /* get_previous_integration_step_size */ {

          // drake/systems/analysis/integrator_base.h:896
          const char* doc =
R"""(Gets the size of the last (previous) integration step. If no
integration steps have been taken, value will be NaN.)""";

        } get_previous_integration_step_size;

        // drake::systems::IntegratorBase::get_requested_minimum_step_size
        struct /* get_requested_minimum_step_size */ {

          // drake/systems/analysis/integrator_base.h:370
          const char* doc =
R"""(Gets the requested minimum step size `h_min` for this integrator.

See also:
    set_requested_minimum_step_size()

See also:
    get_working_minimum_step_size(T))""";

        } get_requested_minimum_step_size;

        // drake::systems::IntegratorBase::get_smallest_adapted_step_size_taken
        struct /* get_smallest_adapted_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:739
          const char* doc =
R"""(The size of the smallest step taken *as the result of a controlled
integration step adjustment* since the last Initialize() or
ResetStatistics() call. This value will be NaN for integrators without
error estimation.)""";

        } get_smallest_adapted_step_size_taken;

        // drake::systems::IntegratorBase::get_stretch_factor
        struct /* get_stretch_factor */ {

          // drake/systems/analysis/integrator_base.h:576
          const char* doc =
R"""(Gets the stretch factor (> 1), which is multiplied by the maximum
(typically user-designated) integration step size to obtain the amount
that the integrator is able to stretch the maximum time step toward
hitting an upcoming publish or update event in IntegrateAtMost().

See also:
    IntegrateAtMost())""";

        } get_stretch_factor;

        // drake::systems::IntegratorBase::get_system
        struct /* get_system */ {

          // drake/systems/analysis/integrator_base.h:880
          const char* doc =
R"""(Gets a constant reference to the system that is being integrated (and
was provided to the constructor of the integrator).)""";

        } get_system;

        // drake::systems::IntegratorBase::get_target_accuracy
        struct /* get_target_accuracy */ {

          // drake/systems/analysis/integrator_base.h:255
          const char* doc =
R"""(Gets the target accuracy.

See also:
    get_accuracy_in_use())""";

        } get_target_accuracy;

        // drake::systems::IntegratorBase::get_throw_on_minimum_step_size_violation
        struct /* get_throw_on_minimum_step_size_violation */ {

          // drake/systems/analysis/integrator_base.h:390
          const char* doc =
R"""(Reports the current setting of the
throw_on_minimum_step_size_violation flag.

See also:
    set_throw_on_minimum_step_size_violation().)""";

        } get_throw_on_minimum_step_size_violation;

        // drake::systems::IntegratorBase::get_working_minimum_step_size
        struct /* get_working_minimum_step_size */ {

          // drake/systems/analysis/integrator_base.h:400
          const char* doc =
R"""(Gets the current value of the working minimum step size `h_work(t)`
for this integrator, which may vary with the current time t as stored
in the integrator's context. See @link Minstep this section @endlink
for more detail.)""";

        } get_working_minimum_step_size;

        // drake::systems::IntegratorBase::is_initialized
        struct /* is_initialized */ {

          // drake/systems/analysis/integrator_base.h:883
          const char* doc =
R"""(Indicates whether the integrator has been initialized.)""";

        } is_initialized;

        // drake::systems::IntegratorBase::request_initial_step_size_target
        struct /* request_initial_step_size_target */ {

          // drake/systems/analysis/integrator_base.h:519
          const char* doc =
R"""(Request that the first attempted integration step have a particular
size. If no request is made, the integrator will estimate a suitable
size for the initial step attempt. *If the integrator does not support
error control*, this method will throw a std::logic_error (call
supports_error_estimation() to verify before calling this method). For
variable-step integration, the initial target will be treated as a
maximum step size subject to accuracy requirements and event
occurrences. You can find out what size *actually* worked with
`get_actual_initial_step_size_taken()`.

Throws:
    s std::logic_error If the integrator does not support error
    estimation.)""";

        } request_initial_step_size_target;

        // drake::systems::IntegratorBase::reset_context
        struct /* reset_context */ {

          // drake/systems/analysis/integrator_base.h:791
          const char* doc =
R"""(Replace the pointer to the internally-maintained Context with a
different one. This is useful for supplying a new set of initial
conditions or wiping out the current context (by passing in a null
pointer). You should invoke Initialize() after replacing the Context
unless the context is null.

Parameter ``context``:
    The pointer to the new context or nullptr to wipe out the current
    context without replacing it with another.)""";

        } reset_context;

        // drake::systems::IntegratorBase::set_accuracy_in_use
        struct /* set_accuracy_in_use */ {

          // drake/systems/analysis/integrator_base.h:1196
          const char* doc =
R"""(Sets the working ("in use") accuracy for this integrator. The working
accuracy may not be equivalent to the target accuracy when the latter
is too loose or tight for an integrator's capabilities.

See also:
    get_accuracy_in_use()

See also:
    get_target_accuracy())""";

        } set_accuracy_in_use;

        // drake::systems::IntegratorBase::set_actual_initial_step_size_taken
        struct /* set_actual_initial_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:1415
          const char* doc = R"""()""";

        } set_actual_initial_step_size_taken;

        // drake::systems::IntegratorBase::set_fixed_step_mode
        struct /* set_fixed_step_mode */ {

          // drake/systems/analysis/integrator_base.h:198
          const char* doc =
R"""(Sets an integrator with error control to fixed step mode. If the
integrator runs in fixed step mode, it will always take the maximum
step size directed (which may be that determined by
get_maximum_step_size(), or may be smaller, as directed by, e.g.,
Simulator for event handling purposes).

Throws:
    s std::logic_error if integrator does not support error estimation
    and ``flag`` is set to `false`.)""";

        } set_fixed_step_mode;

        // drake::systems::IntegratorBase::set_ideal_next_step_size
        struct /* set_ideal_next_step_size */ {

          // drake/systems/analysis/integrator_base.h:1433
          const char* doc = R"""()""";

        } set_ideal_next_step_size;

        // drake::systems::IntegratorBase::set_largest_step_size_taken
        struct /* set_largest_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:1428
          const char* doc = R"""()""";

        } set_largest_step_size_taken;

        // drake::systems::IntegratorBase::set_maximum_step_size
        struct /* set_maximum_step_size */ {

          // drake/systems/analysis/integrator_base.h:271
          const char* doc =
R"""(Sets the maximum step size that may be taken by this integrator. The
integrator may stretch the maximum step size by as much as 1% to reach
a discrete event. For fixed step integrators, all steps will be taken
at the maximum step size *unless* an event would be missed.)""";

        } set_maximum_step_size;

        // drake::systems::IntegratorBase::set_requested_minimum_step_size
        struct /* set_requested_minimum_step_size */ {

          // drake/systems/analysis/integrator_base.h:360
          const char* doc =
R"""(Sets the requested minimum step size `h_min` that may be taken by this
integrator. No step smaller than this will be taken except under
circumstances as described @link Minstep above. @endlink This setting
will be ignored if it is smaller than the absolute minimum `h_floor`
also described above. Default value is zero.

Parameter ``min_step_size``:
    a non-negative value. Setting this value to zero will cause the
    integrator to use a reasonable value instead (see
    get_working_minimum_step_size()).

See also:
    get_requested_minimum_step_size()

See also:
    get_working_minimum_step_size())""";

        } set_requested_minimum_step_size;

        // drake::systems::IntegratorBase::set_smallest_adapted_step_size_taken
        struct /* set_smallest_adapted_step_size_taken */ {

          // drake/systems/analysis/integrator_base.h:1423
          const char* doc =
R"""(Sets the size of the smallest-step-taken statistic as the result of a
controlled integration step adjustment.)""";

        } set_smallest_adapted_step_size_taken;

        // drake::systems::IntegratorBase::set_target_accuracy
        struct /* set_target_accuracy */ {

          // drake/systems/analysis/integrator_base.h:242
          const char* doc =
R"""(Request that the integrator attempt to achieve a particular accuracy
for the continuous portions of the simulation. Otherwise a default
accuracy is chosen for you. This may be ignored for fixed-step
integration since accuracy control requires variable step sizes. You
should call supports_error_estimation() to ensure that the integrator
supports this capability before calling this function; if the
integrator does not support it, this method will throw an exception.

Integrators vary in the range of accuracy (loosest to tightest) that
they can support. If you request accuracy outside the supported range
for the chosen integrator it will be quietly adjusted to be in range.
You can find out the accuracy setting actually being used using
`get_accuracy_in_use()`.

The precise meaning of *accuracy* is a complicated discussion, but
translates roughly to the number of significant digits you want in the
results. By convention it is supplied as `10^-digits`, meaning that an
accuracy of 1e-3 provides about three significant digits. For more
information, see [Sherman 2011]. - M. Sherman, et al. Procedia IUTAM
2:241-261 (2011), Section 3.3.
http://dx.doi.org/10.1016/j.piutam.2011.04.023

Throws:
    s std::logic_error if integrator does not support error
    estimation.)""";

        } set_target_accuracy;

        // drake::systems::IntegratorBase::set_throw_on_minimum_step_size_violation
        struct /* set_throw_on_minimum_step_size_violation */ {

          // drake/systems/analysis/integrator_base.h:381
          const char* doc =
R"""(Sets whether the integrator should throw a std::runtime_error
exception when the integrator's step size selection algorithm
determines that it must take a step smaller than the minimum step size
(for, e.g., purposes of error control). Default is `true`. If `false`,
the integrator will advance time and state using the minimum specified
step size in such situations. See @link Minstep this section @endlink
for more detail.)""";

        } set_throw_on_minimum_step_size_violation;

        // drake::systems::IntegratorBase::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/integrator_base.h:188
          const char* doc =
R"""(Indicates whether an integrator supports error estimation. Without
error estimation, target accuracy will be unused.)""";

        } supports_error_estimation;

      } IntegratorBase;

      // drake::systems::IsControllable
      struct /* IsControllable */ {

        // drake/systems/primitives/linear_system.h:257
        const char* doc =
R"""(Returns true iff the controllability matrix is full row rank.)""";

      } IsControllable;

      // drake::systems::IsObservable
      struct /* IsObservable */ {

        // drake/systems/primitives/linear_system.h:266
        const char* doc =
R"""(Returns true iff the observability matrix is full column rank.)""";

      } IsObservable;

      // drake::systems::KinematicsResults
      struct /* KinematicsResults */ {

        // drake/multibody/rigid_body_plant/kinematics_results.h:28
        const char* doc =
R"""(A class containing the kinematics results from a RigidBodyPlant
system.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd

Note: The templated ScalarTypes are used in the KinematicsCache, but
all KinematicsResults use RigidBodyTree<double>. This effectively
implies that we can e.g. AutoDiffXd with respect to the
configurations, but not the RigidBodyTree parameters.)""";

        // drake::systems::KinematicsResults::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:30
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::KinematicsResults::KinematicsResults<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:30
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/kinematics_results.h:30
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/kinematics_results.h:35
          const char* doc_3 =
R"""(Constructs a KinematicsResults object associated with

Parameter ``tree``:
    . An alias to

Parameter ``tree``:
    is maintained so that the tree's lifetime must exceed this
    object's lifetime.)""";

        } ctor;

        // drake::systems::KinematicsResults::Update
        struct /* Update */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:39
          const char* doc =
R"""(Updates the KinematicsResults object given the configuration vector

Parameter ``q``:
    and velocity vector

Parameter ``v``:
    .)""";

        } Update;

        // drake::systems::KinematicsResults::get_body_orientation
        struct /* get_body_orientation */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:53
          const char* doc =
R"""(Returns the quaternion representation of the three dimensional
orientation of body ``body_index`` in the world's frame.)""";

        } get_body_orientation;

        // drake::systems::KinematicsResults::get_body_position
        struct /* get_body_position */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:57
          const char* doc =
R"""(Returns the three dimensional position of body ``body_index`` in
world's frame.)""";

        } get_body_position;

        // drake::systems::KinematicsResults::get_cache
        struct /* get_cache */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:85
          const char* doc = R"""()""";

        } get_cache;

        // drake::systems::KinematicsResults::get_joint_position
        struct /* get_joint_position */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:75
          const char* doc =
R"""(Returns the joint position vector associated with the joint between
``body`` and ``body``'s parent. TODO(tkoolen) should pass in joint
instead of body, but that's currently not convenient.)""";

        } get_joint_position;

        // drake::systems::KinematicsResults::get_joint_velocity
        struct /* get_joint_velocity */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:82
          const char* doc =
R"""(Returns the joint velocity vector associated with the joint between
``body`` and ``body``'s parent. TODO(tkoolen) should pass in joint
instead of body, but that's currently not convenient.)""";

        } get_joint_velocity;

        // drake::systems::KinematicsResults::get_num_bodies
        struct /* get_num_bodies */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:43
          const char* doc =
R"""(Returns the number of bodies in the kinematics results.)""";

        } get_num_bodies;

        // drake::systems::KinematicsResults::get_num_positions
        struct /* get_num_positions */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:46
          const char* doc =
R"""(Returns the number of generalized positions.)""";

        } get_num_positions;

        // drake::systems::KinematicsResults::get_num_velocities
        struct /* get_num_velocities */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:49
          const char* doc =
R"""(Returns the number of generalized velocities.)""";

        } get_num_velocities;

        // drake::systems::KinematicsResults::get_pose_in_world
        struct /* get_pose_in_world */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:60
          const char* doc =
R"""(Returns the pose of body ``body`` with respect to the world.)""";

        } get_pose_in_world;

        // drake::systems::KinematicsResults::get_twist_in_world_aligned_body_frame
        struct /* get_twist_in_world_aligned_body_frame */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:68
          const char* doc =
R"""(Returns the twist of ``body`` with respect to the world, expressed in
world frame.)""";

        } get_twist_in_world_aligned_body_frame;

        // drake::systems::KinematicsResults::get_twist_in_world_frame
        struct /* get_twist_in_world_frame */ {

          // drake/multibody/rigid_body_plant/kinematics_results.h:64
          const char* doc =
R"""(Returns the twist of ``body`` with respect to the world, expressed in
world frame.)""";

        } get_twist_in_world_frame;

      } KinematicsResults;

      // drake::systems::LeafCompositeEventCollection
      struct /* LeafCompositeEventCollection */ {

        // drake/systems/framework/event.h:29
        const char* doc =
R"""(A CompositeEventCollection for a LeafSystem. i.e.

```
PublishEvent<T>: {event1i, ...}
  DiscreteUpdateEvent<T>: {event2i, ...}
  UnrestrictedUpdateEvent<T>: {event3i, ...}
```)""";

        // drake/systems/framework/event_collection.h:585
        const char* doc_2 =
R"""(A CompositeEventCollection for a LeafSystem. i.e.

```
PublishEvent<T>: {event1i, ...}
  DiscreteUpdateEvent<T>: {event2i, ...}
  UnrestrictedUpdateEvent<T>: {event3i, ...}
```)""";

        // drake::systems::LeafCompositeEventCollection::LeafCompositeEventCollection<T>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:587
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:587
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:589
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::LeafCompositeEventCollection::get_discrete_update_events
        struct /* get_discrete_update_events */ {

          // drake/systems/framework/event_collection.h:608
          const char* doc =
R"""(Returns a const reference to the collection of discrete update events.)""";

        } get_discrete_update_events;

        // drake::systems::LeafCompositeEventCollection::get_publish_events
        struct /* get_publish_events */ {

          // drake/systems/framework/event_collection.h:599
          const char* doc =
R"""(Returns a const reference to the collection of publish events.)""";

        } get_publish_events;

        // drake::systems::LeafCompositeEventCollection::get_unrestricted_update_events
        struct /* get_unrestricted_update_events */ {

          // drake/systems/framework/event_collection.h:617
          const char* doc =
R"""(Returns a const reference to the collection of unrestricted update
events.)""";

        } get_unrestricted_update_events;

      } LeafCompositeEventCollection;

      // drake::systems::LeafContext
      struct /* LeafContext */ {

        // drake/systems/framework/leaf_context.h:26
        const char* doc =
R"""(LeafContext contains all prerequisite data necessary to uniquely
determine the results of computations performed by the associated
LeafSystem.

See also:
    Context for more information.

Template parameter ``T``:
    The mathematical type of the context, which must be a valid Eigen
    scalar.)""";

        // drake::systems::LeafContext::DoCloneState
        struct /* DoCloneState */ {

          // drake/systems/framework/leaf_context.h:70
          const char* doc = R"""()""";

        } DoCloneState;

        // drake::systems::LeafContext::DoCloneWithoutPointers
        struct /* DoCloneWithoutPointers */ {

          // drake/systems/framework/leaf_context.h:66
          const char* doc =
R"""(Derived classes should reimplement and replace this; don't recursively
invoke it.)""";

        } DoCloneWithoutPointers;

        // drake::systems::LeafContext::LeafContext<T>
        struct /* ctor */ {

          // drake/systems/framework/leaf_context.h:31
          const char* doc = R"""()""";

          // drake/systems/framework/leaf_context.h:36
          const char* doc_2 = R"""()""";

          // drake/systems/framework/leaf_context.h:57
          const char* doc_3 =
R"""(Protected copy constructor takes care of the local data members and
all base class members, but doesn't update base class pointers so is
not a complete copy.)""";

        } ctor;

      } LeafContext;

      // drake::systems::LeafEventCollection
      struct /* LeafEventCollection */ {

        // drake/systems/framework/event.h:23
        const char* doc =
R"""(A concrete class that holds all simultaneous homogeneous events for a
LeafSystem.)""";

        // drake/systems/framework/event_collection.h:286
        const char* doc_2 =
R"""(A concrete class that holds all simultaneous homogeneous events for a
LeafSystem.)""";

        // drake::systems::LeafEventCollection::Clear
        struct /* Clear */ {

          // drake/systems/framework/event_collection.h:333
          const char* doc =
R"""(Removes all events from this collection.)""";

        } Clear;

        // drake::systems::LeafEventCollection::DoMerge
        struct /* DoMerge */ {

          // drake/systems/framework/event_collection.h:359
          const char* doc =
R"""(All events in ``other_collection`` are concatanated to this. Aborts if
``other_collection`` is null.

Here is an example. Suppose this collection stores the following
events:

```
EventType: {event1, event2, event3}
```

``other_collection`` has:

```
EventType: {event4}
```

After calling DoMerge(other_collection), `this` stores:

```
EventType: {event1, event2, event3, event4}
```

Throws:
    s std::bad_cast if ``other_collection`` is not an instance of
    LeafEventCollection.)""";

        } DoMerge;

        // drake::systems::LeafEventCollection::HasEvents
        struct /* HasEvents */ {

          // drake/systems/framework/event_collection.h:328
          const char* doc =
R"""(Returns `true` if and only if this collection is nonempty.)""";

        } HasEvents;

        // drake::systems::LeafEventCollection::LeafEventCollection<EventType>
        struct /* ctor */ {

          // drake/systems/framework/event_collection.h:288
          const char* doc = R"""()""";

          // drake/systems/framework/event_collection.h:288
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event_collection.h:293
          const char* doc_3 = R"""(Constructor.)""";

        } ctor;

        // drake::systems::LeafEventCollection::MakeForcedEventCollection
        struct /* MakeForcedEventCollection */ {

          // drake/systems/framework/event_collection.h:301
          const char* doc =
R"""(Static method that generates a LeafEventCollection with exactly one
event with no optional attribute, data or callback, and trigger type
kForced.)""";

        } MakeForcedEventCollection;

        // drake::systems::LeafEventCollection::add_event
        struct /* add_event */ {

          // drake/systems/framework/event_collection.h:319
          const char* doc =
R"""(Add ``event`` to the existing collection. Ownership of ``event`` is
transferred. Aborts if event is null.)""";

        } add_event;

        // drake::systems::LeafEventCollection::get_events
        struct /* get_events */ {

          // drake/systems/framework/event_collection.h:313
          const char* doc =
R"""(Returns a const reference to the vector of const pointers to all of
the events.)""";

        } get_events;

      } LeafEventCollection;

      // drake::systems::LeafOutputPort
      struct /* LeafOutputPort */ {

        // drake/systems/framework/leaf_output_port.h:34
        const char* doc =
R"""(Implements an output port whose value is managed by a cache entry in
the same LeafSystem as the port. This is intended for internal use in
implementing the DeclareOutputPort() variants in LeafSystem.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::LeafOutputPort::LeafOutputPort<T>
        struct /* ctor */ {

          // drake/systems/framework/leaf_output_port.h:36
          const char* doc = R"""()""";

          // drake/systems/framework/leaf_output_port.h:36
          const char* doc_2 = R"""()""";

          // drake/systems/framework/leaf_output_port.h:60
          const char* doc_3 =
R"""(Constructs a cached output port. The `system` parameter must be the
same object as the `system_base` parameter.)""";

        } ctor;

        // drake::systems::LeafOutputPort::cache_entry
        struct /* cache_entry */ {

          // drake/systems/framework/leaf_output_port.h:70
          const char* doc =
R"""(Returns the cache entry associated with this output port. */)""";

        } cache_entry;

      } LeafOutputPort;

      // drake::systems::LeafSystem
      struct /* LeafSystem */ {

        // drake/systems/framework/leaf_system.h:81
        const char* doc =
R"""(A superclass template that extends System with some convenience
utilities that are not applicable to Diagrams.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::LeafSystem::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {

          // drake/systems/framework/leaf_system.h:346
          const char* doc = R"""()""";

        } AddTriggeredWitnessFunctionToCompositeEventCollection;

        // drake::systems::LeafSystem::AllocateAbstractState
        struct /* AllocateAbstractState */ {

          // drake/systems/framework/leaf_system.h:526
          const char* doc =
R"""(Reserves the abstract state as required by CreateDefaultContext. By
default, it clones the abstract states declared through
DeclareAbstractState() calls. Derived systems should override for
different behaviors.)""";

        } AllocateAbstractState;

        // drake::systems::LeafSystem::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {

          // drake/systems/framework/leaf_system.h:91
          const char* doc =
R"""(Allocates a CompositeEventCollection object for this system.

See also:
    System::AllocateCompositeEventCollection().)""";

        } AllocateCompositeEventCollection;

        // drake::systems::LeafSystem::AllocateContext
        struct /* AllocateContext */ {

          // drake/systems/framework/leaf_system.h:97
          const char* doc =
R"""(Shadows System<T>::AllocateContext to provide a more concrete return
type LeafContext<T>.)""";

        } AllocateContext;

        // drake::systems::LeafSystem::AllocateContinuousState
        struct /* AllocateContinuousState */ {

          // drake/systems/framework/leaf_system.h:503
          const char* doc =
R"""(Returns a ContinuousState used to implement both CreateDefaultContext
and AllocateTimeDerivatives. Allocates the state configured with
DeclareContinuousState, or none by default. Systems with continuous
state variables may override, but must ensure the ContinuousState
vector is a subclass of BasicVector.)""";

        } AllocateContinuousState;

        // drake::systems::LeafSystem::AllocateDiscreteState
        struct /* AllocateDiscreteState */ {

          // drake/systems/framework/leaf_system.h:514
          const char* doc =
R"""(Reserves the discrete state as required by CreateDefaultContext. By
default, reserves no state. Systems with discrete state should
override.)""";

        } AllocateDiscreteState;

        // drake::systems::LeafSystem::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {

          // drake/systems/framework/leaf_system.h:231
          const char* doc =
R"""(Returns the AllocateDiscreteState value, which must not be nullptr.)""";

        } AllocateDiscreteVariables;

        // drake::systems::LeafSystem::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {

          // drake/systems/framework/leaf_system.h:114
          const char* doc = R"""()""";

        } AllocateForcedDiscreteUpdateEventCollection;

        // drake::systems::LeafSystem::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {

          // drake/systems/framework/leaf_system.h:109
          const char* doc = R"""(@cond)""";

        } AllocateForcedPublishEventCollection;

        // drake::systems::LeafSystem::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {

          // drake/systems/framework/leaf_system.h:120
          const char* doc = R"""()""";

        } AllocateForcedUnrestrictedUpdateEventCollection;

        // drake::systems::LeafSystem::AllocateParameters
        struct /* AllocateParameters */ {

          // drake/systems/framework/leaf_system.h:536
          const char* doc =
R"""(Reserves the parameters as required by CreateDefaultContext. The
default implementation in this class clones the model_vector for all
parameters declared via DeclareNumericParameter(), as well as the
model value for all parameters declared via
DeclareAbstractParameter(). Subclasses can override this method if the
default behavior is not sufficient.)""";

        } AllocateParameters;

        // drake::systems::LeafSystem::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {

          // drake/systems/framework/leaf_system.h:226
          const char* doc =
R"""(Returns the AllocateContinuousState value, which must not be nullptr.)""";

        } AllocateTimeDerivatives;

        // drake::systems::LeafSystem::DeclareAbstractInputPort
        struct /* DeclareAbstractInputPort */ {

          // drake/systems/framework/leaf_system.h:874
          const char* doc =
R"""(Declares an abstract-valued input port using the given
``model_value``. This is the best way to declare LeafSystem abstract
input ports. LeafSystem's default implementation of
DoAllocateInputAbstract will be model_value.Clone().)""";

        } DeclareAbstractInputPort;

        // drake::systems::LeafSystem::DeclareAbstractOutputPort
        struct /* DeclareAbstractOutputPort */ {

          // drake/systems/framework/leaf_system.h:1189
          const char* doc =
R"""(Declares an abstract-valued output port by specifying a model value of
concrete type `OutputType` and a calculator function that is a class
member function (method) with signature:

```
void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;
```

where `MySystem` must be a class derived from `LeafSystem<T>`.
`OutputType` must be such that `Value<OutputType>` is permitted.
Template arguments will be deduced and do not need to be specified.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/leaf_system.h:1225
          const char* doc_2 =
R"""(Declares an abstract-valued output port by specifying only a
calculator function that is a class member function (method) with
signature:

```
void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;
```

where `MySystem` is a class derived from `LeafSystem<T>`. `OutputType`
is a concrete type such that `Value<OutputType>` is permitted, and
must be default constructible, so that we can create a model value
using `Value<OutputType>{}` (value initialized so numerical types will
be zeroed in the model). Template arguments will be deduced and do not
need to be specified.

Note:
    The default constructor will be called once immediately, and
    subsequent allocations will just copy the model value without
    invoking the constructor again. If you want the constructor
    invoked again at each allocation (not common), use one of the
    other signatures to explicitly provide a method for the allocator
    to call; that method can then invoke the `OutputType` default
    constructor.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/leaf_system.h:1250
          const char* doc_3 =
R"""(Declares an abstract-valued output port by specifying member functions
to use both for the allocator and calculator. The signatures are:

```
OutputType MySystem::MakeOutputValue() const;
void MySystem::CalcOutputValue(const Context<T>&, OutputType*) const;
```

where `MySystem` is a class derived from `LeafSystem<T>` and
`OutputType` may be any concrete type such that `Value<OutputType>` is
permitted. See alternate signature if your allocator method needs a
Context. Template arguments will be deduced and do not need to be
specified.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/leaf_system.h:1272
          const char* doc_4 =
R"""((Advanced) Declares an abstract-valued output port using the given
allocator and calculator functions provided in their most generic
forms. If you have a member function available use one of the other
signatures.

See also:
    LeafOutputPort::AllocCallback, LeafOutputPort::CalcCallback)""";

        } DeclareAbstractOutputPort;

        // drake::systems::LeafSystem::DeclareAbstractParameter
        struct /* DeclareAbstractParameter */ {

          // drake/systems/framework/leaf_system.h:647
          const char* doc =
R"""(Declares an abstract parameter using the given ``model_value``. This
is the best way to declare LeafSystem abstract parameters.
LeafSystem's default implementation of AllocateParameters uses
model_value.Clone(), and the default implementation of
SetDefaultParameters() will reset parameters to their model values.
Returns the index of the new parameter.)""";

        } DeclareAbstractParameter;

        // drake::systems::LeafSystem::DeclareAbstractState
        struct /* DeclareAbstractState */ {

          // drake/systems/framework/leaf_system.h:827
          const char* doc =
R"""(Declares an abstract state.

Parameter ``abstract_state``:
    The abstract state, its ownership is transferred.

Returns:
    index of the declared abstract state.)""";

        } DeclareAbstractState;

        // drake::systems::LeafSystem::DeclareContinuousState
        struct /* DeclareContinuousState */ {

          // drake/systems/framework/leaf_system.h:752
          const char* doc =
R"""(Declares that this System should reserve continuous state with
``num_state_variables`` state variables, which have no second-order
structure. Has no effect if AllocateContinuousState is overridden.)""";

          // drake/systems/framework/leaf_system.h:761
          const char* doc_2 =
R"""(Declares that this System should reserve continuous state with
``num_q`` generalized positions, ``num_v`` generalized velocities, and
``num_z`` miscellaneous state variables. Has no effect if
AllocateContinuousState is overridden.)""";

          // drake/systems/framework/leaf_system.h:771
          const char* doc_3 =
R"""(Declares that this System should reserve continuous state with
``model_vector``.size() miscellaneous state variables, stored in a
vector Cloned from ``model_vector``. Has no effect if
AllocateContinuousState is overridden.)""";

          // drake/systems/framework/leaf_system.h:785
          const char* doc_4 =
R"""(Declares that this System should reserve continuous state with
``num_q`` generalized positions, ``num_v`` generalized velocities, and
``num_z`` miscellaneous state variables, stored in a vector Cloned
from ``model_vector``. Aborts if ``model_vector`` has the wrong size.
Has no effect if AllocateContinuousState is overridden. If the
``model_vector`` declares any VectorBase::CalcInequalityConstraint()
constraints, they will be re-declared as inequality constraints on
this system (see DeclareInequalityConstraint()).)""";

          // drake/systems/framework/leaf_system.h:806
          const char* doc_5 =
R"""(Declares that this System should reserve continuous state with
``num_q`` generalized positions, ``num_v`` generalized velocities, and
``num_z`` miscellaneous state variables, stored in the a vector Cloned
from ``model_vector``. Aborts if ``model_vector`` is nullptr or has
the wrong size. Has no effect if AllocateContinuousState is
overridden.)""";

        } DeclareContinuousState;

        // drake::systems::LeafSystem::DeclareDiscreteState
        struct /* DeclareDiscreteState */ {

          // drake/systems/framework/leaf_system.h:817
          const char* doc =
R"""(Declares that this System should reserve discrete state with
``num_state_variables`` state variables. Has no effect if
AllocateDiscreteState is overridden.)""";

        } DeclareDiscreteState;

        // drake::systems::LeafSystem::DeclareEqualityConstraint
        struct /* DeclareEqualityConstraint */ {

          // drake/systems/framework/leaf_system.h:1299
          const char* doc =
R"""(Declares a system constraint of the form f(context) = 0 by specifying
a member function to use to calculate the (VectorX) constraint value
with a signature:

```
void MySystem::CalcConstraint(const Context<T>&, VectorX<T>*) const;
```

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint. Template arguments will be deduced
    and do not need to be specified.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";

          // drake/systems/framework/leaf_system.h:1326
          const char* doc_2 =
R"""(Declares a system constraint of the form f(context) = 0 by specifying
a std::function to use to calculate the (Vector) constraint value with
a signature:

```
void CalcConstraint(const Context<T>&, VectorX<T>*);
```

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";

        } DeclareEqualityConstraint;

        // drake::systems::LeafSystem::DeclareInequalityConstraint
        struct /* DeclareInequalityConstraint */ {

          // drake/systems/framework/leaf_system.h:1349
          const char* doc =
R"""(Declares a system constraint of the form f(context) ≥ 0 by specifying
a member function to use to calculate the (VectorX) constraint value
with a signature:

```
void MySystem::CalcConstraint(const Context<T>&, VectorX<T>*) const;
```

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint. Template arguments will be deduced
    and do not need to be specified.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";

          // drake/systems/framework/leaf_system.h:1376
          const char* doc_2 =
R"""(Declares a system constraint of the form f(context) ≥ 0 by specifying
a std::function to use to calculate the (Vector) constraint value with
a signature:

```
void CalcConstraint(const Context<T>&, VectorX<T>*);
```

Parameter ``count``:
    is the dimension of the VectorX output.

Parameter ``description``:
    should be a human-readable phrase.

Returns:
    The index of the constraint.

See also:
    SystemConstraint<T> for more information about the meaning of
    these constraints.)""";

        } DeclareInequalityConstraint;

        // drake::systems::LeafSystem::DeclareInitializationEvent
        struct /* DeclareInitializationEvent */ {

          // drake/systems/framework/leaf_system.h:743
          const char* doc =
R"""(Declares an initialization event by deep copying ``event`` and storing
it internally. ``event``'s associated trigger type must be
Event::TriggerType::kInitialization. Aborts otherwise.)""";

        } DeclareInitializationEvent;

        // drake::systems::LeafSystem::DeclareNumericParameter
        struct /* DeclareNumericParameter */ {

          // drake/systems/framework/leaf_system.h:599
          const char* doc =
R"""(Declares a numeric parameter using the given ``model_vector``. This is
the best way to declare LeafSystem numeric parameters. LeafSystem's
default implementation of AllocateParameters uses
model_vector.Clone(), and the default implementation of
SetDefaultParameters() will reset parameters to their model vectors.
If the ``model_vector`` declares any
VectorBase::CalcInequalityConstraint() constraints, they will be re-
declared as inequality constraints on this system (see
DeclareInequalityConstraint()). Returns the index of the new
parameter.)""";

        } DeclareNumericParameter;

        // drake::systems::LeafSystem::DeclarePerStepEvent
        struct /* DeclarePerStepEvent */ {

          // drake/systems/framework/leaf_system.h:734
          const char* doc =
R"""(Declares a per-step event using ``event``, which is deep copied (the
copy is maintained by `this`). ``event``'s associated trigger type
must be set to Event::TriggerType::kPerStep. Aborts otherwise.)""";

        } DeclarePerStepEvent;

        // drake::systems::LeafSystem::DeclarePeriodicDiscreteUpdate
        struct /* DeclarePeriodicDiscreteUpdate */ {

          // drake/systems/framework/leaf_system.h:707
          const char* doc =
R"""(Declares a periodic discrete update event with period = ``period_sec``
and offset = ``offset_sec``. The event does not have a custom callback
function, and its trigger will be set to
Event::TriggerType::kPeriodic. Its attribute will be an
Event<T>::PeriodicAttribute of ``offset_sec`` and ``period_sec``.)""";

        } DeclarePeriodicDiscreteUpdate;

        // drake::systems::LeafSystem::DeclarePeriodicEvent
        struct /* DeclarePeriodicEvent */ {

          // drake/systems/framework/leaf_system.h:667
          const char* doc =
R"""(Declares that this System has a simple, fixed-period event specified
with no custom callback function, and its attribute field contains an
Event<T>::PeriodicAttribute constructed from the specified
``period_sec`` and ``offset_sec``. The first tick will occur at t =
``offset_sec``, and it will recur at every ``period_sec`` thereafter.
Note that the periodic events returned by system::CalcNextUpdateTime()
will happen at a time strictly after the querying time. E.g. if there
is a periodic event with offset = 0 and period = 5, when calling
CalcNextUpdateTime() at t = 0, the returned event will happen at t = 5
not t = 0.

Template parameter ``EventType``:
    A class derived from Event (e.g., PublishEvent,
    DiscreteUpdateEvent, UnrestrictedUpdateEvent, etc.))""";

          // drake/systems/framework/leaf_system.h:693
          const char* doc_2 =
R"""(Declares that this System has a simple, fixed-period event specified
by ``event``. A deep copy of ``event`` will be made and maintained by
`this`. ``event``'s trigger type must be Event::TriggerType::kPeriodic
or this method aborts. The first tick will occur at t =
``offset_sec``, and it will recur at every ``period_sec`` thereafter.
Note that the periodic events returned by system::CalcNextUpdateTime()
will happen at a time strictly after the querying time. E.g. if there
is a periodic event with offset = 0 and period = 5, when calling
CalcNextUpdateTime() at t = 0, the returned event will happen at t = 5
not t = 0.

Note that ``event``'s attribute field is preserved.

Template parameter ``EventType``:
    A class derived from Event (e.g., PublishEvent,
    DiscreteUpdateEvent, UnrestrictedUpdateEvent, etc.))""";

        } DeclarePeriodicEvent;

        // drake::systems::LeafSystem::DeclarePeriodicPublish
        struct /* DeclarePeriodicPublish */ {

          // drake/systems/framework/leaf_system.h:726
          const char* doc =
R"""(Declares a periodic publish event with period = ``period_sec`` and
offset = ``offset_sec``. The event does not have a custom callback
function, and its trigger will be set to
Event::TriggerType::kPeriodic. Its attribute will be an
Event<T>::PeriodicAttribute of ``offset_sec`` and ``period_sec``.)""";

        } DeclarePeriodicPublish;

        // drake::systems::LeafSystem::DeclarePeriodicUnrestrictedUpdate
        struct /* DeclarePeriodicUnrestrictedUpdate */ {

          // drake/systems/framework/leaf_system.h:716
          const char* doc =
R"""(Declares a periodic unrestricted update event with period =
``period_sec`` and offset = ``offset_sec``. The event does not have a
custom callback function, and its trigger will be set to
Event::TriggerType::kPeriodic. Its attribute will be an
Event<T>::PeriodicAttribute of ``offset_sec`` and ``period_sec``.)""";

        } DeclarePeriodicUnrestrictedUpdate;

        // drake::systems::LeafSystem::DeclareVectorInputPort
        struct /* DeclareVectorInputPort */ {

          // drake/systems/framework/leaf_system.h:850
          const char* doc =
R"""(Declares a vector-valued input port using the given ``model_vector``.
This is the best way to declare LeafSystem input ports that require
subclasses of BasicVector. The port's size will be
model_vector.size(), and LeafSystem's default implementation of
DoAllocateInputVector will be model_vector.Clone(). If the port is
intended to model a random noise or disturbance input, ``random_type``
can (optionally) be used to label it as such. If the ``model_vector``
declares any VectorBase::CalcInequalityConstraint() constraints, they
will be re-declared as inequality constraints on this system (see
DeclareInequalityConstraint()).)""";

        } DeclareVectorInputPort;

        // drake::systems::LeafSystem::DeclareVectorOutputPort
        struct /* DeclareVectorOutputPort */ {

          // drake/systems/framework/leaf_system.h:1084
          const char* doc =
R"""(Declares a vector-valued output port by specifying (1) a model vector
of type BasicVectorSubtype derived from BasicVector and initialized to
the correct size and desired initial value, and (2) a calculator
function that is a class member function (method) with signature:

```
void MySystem::CalcOutputVector(const Context<T>&,
                                BasicVectorSubtype*) const;
```

where `MySystem` is a class derived from `LeafSystem<T>`. Template
arguments will be deduced and do not need to be specified.)""";

          // drake/systems/framework/leaf_system.h:1147
          const char* doc_2 =
R"""(Declares a vector-valued output port by specifying _only_ a calculator
function that is a class member function (method) with signature:

```
void MySystem::CalcOutputVector(const Context<T>&,
                                BasicVectorSubtype*) const;
```

where `MySystem` is a class derived from `LeafSystem<T>` and
`BasicVectorSubtype` is derived from `BasicVector<T>` and has a
suitable default constructor that allocates a vector of the expected
size. This will use `BasicVectorSubtype{}` (that is, the default
constructor) to produce a model vector for the output port's value.
Template arguments will be deduced and do not need to be specified.

Note:
    The default constructor will be called once immediately, and
    subsequent allocations will just copy the model value without
    invoking the constructor again. If you want the constructor
    invoked again at each allocation (not common), use one of the
    other signatures to explicitly provide a method for the allocator
    to call; that method can then invoke the `BasicVectorSubtype`
    default constructor.)""";

          // drake/systems/framework/leaf_system.h:1167
          const char* doc_3 =
R"""((Advanced) Declares a vector-valued output port using the given
`model_vector` and a function for calculating the port's value at
runtime. The port's size will be model_vector.size(), and the default
allocator for the port will be model_vector.Clone(). Note that this
takes the calculator function in its most generic form; if you have a
member function available use one of the other signatures.

See also:
    LeafOutputPort::CalcVectorCallback)""";

        } DeclareVectorOutputPort;

        // drake::systems::LeafSystem::DeclareWitnessFunction
        struct /* DeclareWitnessFunction */ {

          // drake/systems/framework/leaf_system.h:906
          const char* doc =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.

Note:
    Constructing a witness function with no corresponding event forces
    Simulator's integration of an ODE to end a step at the witness
    isolation time. For example, isolating a function's minimum or
    maximum values can be realized with a witness that triggers on a
    sign change of the function's time derivative, ensuring that the
    actual extreme value is present in the discretized trajectory.)""";

          // drake/systems/framework/leaf_system.h:917
          const char* doc_2 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function; and with no event object.)""";

          // drake/systems/framework/leaf_system.h:929
          const char* doc_3 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, calculator
function, and publish event callback function for when this triggers.)""";

          // drake/systems/framework/leaf_system.h:953
          const char* doc_4 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, calculator
function, and discrete update event callback function for when this
triggers.)""";

          // drake/systems/framework/leaf_system.h:977
          const char* doc_5 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, calculator
function, and unrestricted update event callback function for when
this triggers.)""";

          // drake/systems/framework/leaf_system.h:1005
          const char* doc_6 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.)""";

          // drake/systems/framework/leaf_system.h:1023
          const char* doc_7 =
R"""(Constructs the witness function with the given description (used
primarily for debugging and logging), direction type, and calculator
function, and with an object corresponding to the event that is to be
dispatched when this witness function triggers. Example types of event
objects are publish, discrete variable update, unrestricted update
events. A clone of the event will be owned by the newly constructed
WitnessFunction.)""";

        } DeclareWitnessFunction;

        // drake::systems::LeafSystem::DoAllocateContext
        struct /* DoAllocateContext */ {

          // drake/systems/framework/leaf_system.h:126
          const char* doc = R"""(@endcond)""";

        } DoAllocateContext;

        // drake::systems::LeafSystem::DoAllocateInputAbstract
        struct /* DoAllocateInputAbstract */ {

          // drake/systems/framework/leaf_system.h:424
          const char* doc =
R"""(Allocates an AbstractValue suitable as an input value for
``input_port``. The default implementation in this class either clones
the model_value (if the port was declared via
DeclareAbstractInputPort) or else aborts.

Subclasses with abstract input ports must either provide a model_value
when declaring the port, or else override this method.)""";

        } DoAllocateInputAbstract;

        // drake::systems::LeafSystem::DoAllocateInputVector
        struct /* DoAllocateInputVector */ {

          // drake/systems/framework/leaf_system.h:408
          const char* doc =
R"""(Allocates a vector that is suitable as an input value for
``input_port``. The default implementation in this class either clones
the model_vector (if the port was declared via DeclareVectorInputPort)
or else allocates a BasicVector (if the port was declared via
DeclareInputPort(kVectorValued, size). Subclasses can override this
method if the default behavior is not sufficient.)""";

        } DoAllocateInputVector;

        // drake::systems::LeafSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {

          // drake/systems/framework/leaf_system.h:1427
          const char* doc =
R"""(Derived-class event handler for all simultaneous discrete update
events. This method updates the ``discrete_state`` on discrete update
events. The default implementation traverses events in the arbitrary
order they appear in ``events``, and for each event that has a
callback function, it will invoke it with ``context``, that event, and
``discrete_state``. Note that the same ``discrete_state`` is passed to
subsequent callbacks. Override this in your derived LeafSystem if your
derived LeafSystem requires a behavior other than the default.

This method is called only from the virtual
DispatchDiscreteVariableUpdateHandler(), which is only called from the
public non-virtual CalcDiscreteVariableUpdates(), which will already
have error-checked the parameters so you don't have to. In particular,
implementations may assume that ``context`` is valid; that
``discrete_state`` is non-null, and that the referenced object has the
same constituent structure as was produced by
AllocateDiscreteVariables().

Parameter ``context``:
    The "before" state.

Parameter ``events``:
    All the discrete update events that need handling. @param[in,out]
    discrete_state The current state of the system on input; the
    desired state of the system on return.)""";

        } DoCalcDiscreteVariableUpdates;

        // drake::systems::LeafSystem::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {

          // drake/systems/framework/leaf_system.h:367
          const char* doc =
R"""(Computes the next update time based on the configured periodic events,
for scalar types that are arithmetic, or aborts for scalar types that
are not arithmetic. Subclasses that require aperiodic events should
override. @post `time` is set to a value greater than or equal to
`context.get_time()` on return. @warning If you override this method,
think carefully before setting `time` to `context.get_time()` on
return, which can inadvertently cause simulations of systems derived
from LeafSystem to loop interminably. Such a loop will occur if, for
example, the event(s) does not modify the state.)""";

        } DoCalcNextUpdateTime;

        // drake::systems::LeafSystem::DoCalcUnrestrictedUpdate
        struct /* DoCalcUnrestrictedUpdate */ {

          // drake/systems/framework/leaf_system.h:1466
          const char* doc = R"""()""";

        } DoCalcUnrestrictedUpdate;

        // drake::systems::LeafSystem::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {

          // drake/systems/framework/leaf_system.h:340
          const char* doc = R"""()""";

        } DoCalcWitnessValue;

        // drake::systems::LeafSystem::DoHasDirectFeedthrough
        struct /* DoHasDirectFeedthrough */ {

          // drake/systems/framework/leaf_system.h:582
          const char* doc =
R"""(Returns true if there is direct-feedthrough from the given
``input_port`` to the given ``output_port``, false if there is not
direct-feedthrough, or nullopt if unknown (in which case
SystemSymbolicInspector will attempt to measure the feedthrough using
symbolic form).

By default, LeafSystem assumes there is direct feedthrough of values
from every input to every output. This is a conservative assumption
that ensures we detect and can prevent the formation of algebraic
loops (implicit computations) in system Diagrams. Systems which do not
have direct feedthrough may override that assumption in two ways:

- Override DoToSymbolic, allowing LeafSystem to infer the sparsity
from the symbolic equations. This method is typically preferred for
systems that have a symbolic form, but should be avoided in certain
corner cases where fully descriptive symbolic analysis is impossible,
e.g., when the symbolic form depends on C++ native conditionals. For
additional discussion, consult the documentation for
SystemSymbolicInspector.

- Override this function directly, reporting manual sparsity. This
method is recommended when DoToSymbolic has not been implemented, or
when creating the symbolic form is too computationally expensive, or
when its output is not fully descriptive, as discussed above. Manually
configured sparsity must be conservative: if there is any Context for
which an input port is direct-feedthrough to an output port, this
function must return either true or nullopt for those two ports.)""";

        } DoHasDirectFeedthrough;

        // drake::systems::LeafSystem::DoMakeLeafContext
        struct /* DoMakeLeafContext */ {

          // drake/systems/framework/leaf_system.h:321
          const char* doc =
R"""(Provides a new instance of the leaf context for this system. Derived
leaf systems with custom derived leaf system contexts should override
this to provide a context of the appropriate type. The returned
context should be "empty"; invoked by AllocateContext(), the caller
will take the responsibility to initialize the core LeafContext data.
The default implementation provides a default-constructed
`LeafContext<T>`.)""";

        } DoMakeLeafContext;

        // drake::systems::LeafSystem::DoPublish
        struct /* DoPublish */ {

          // drake/systems/framework/leaf_system.h:1398
          const char* doc =
R"""(Derived-class event handler for all simultaneous publish events in
``events``. Override this in your derived LeafSystem if your derived
LeafSystem requires a behavior other than the default behavior, which
traverses events in the arbitrary order they appear in ``events``, and
for each event that has a callback function, it will invoke the
callback with ``context`` and that event. This can be used for tasks
that need read-only access to the context, such as sending messages,
producing console output, debugging, logging, saving the trajectory to
a file, etc.

This method is called only from the virtual DispatchPublishHandler,
which is only called from the public non-virtual Publish(), which will
have already error-checked ``context`` so you may assume that it is
valid.

Parameter ``context``:
    Const current context.

Parameter ``events``:
    All the publish events that need handling.)""";

        } DoPublish;

        // drake::systems::LeafSystem::DoValidateAllocatedLeafContext
        struct /* DoValidateAllocatedLeafContext */ {

          // drake/systems/framework/leaf_system.h:332
          const char* doc =
R"""(Derived classes that impose restrictions on what resources are
permitted should check those restrictions by implementing this. For
example, a derived class might require a single input and single
output. Note that the supplied Context will be complete except that
input and output dependencies on peer and parent subcontexts will not
yet have been set up, so you may not consider them for validation. The
default implementation does nothing.)""";

        } DoValidateAllocatedLeafContext;

        // drake::systems::LeafSystem::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {

          // drake/systems/framework/leaf_system.h:236
          const char* doc = R"""()""";

        } GetDirectFeedthroughs;

        // drake::systems::LeafSystem::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {

          // drake/systems/framework/leaf_system.h:452
          const char* doc =
R"""(Emits a graphviz fragment for this System. Leaf systems are visualized
as records. For instance, a leaf system with 2 inputs and 1 output is:

@verbatim 123456 [shape= record, label="name | {<u0> 0 |<y0> 0} |
{<u1> 1 | }"]; @endverbatim

which looks like:

@verbatim +------------+----+ | name | u0 | u1 | | | y0 | |
+-------+----+----+ @endverbatim)""";

        } GetGraphvizFragment;

        // drake::systems::LeafSystem::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {

          // drake/systems/framework/leaf_system.h:483
          const char* doc = R"""()""";

        } GetGraphvizInputPortToken;

        // drake::systems::LeafSystem::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {

          // drake/systems/framework/leaf_system.h:489
          const char* doc = R"""()""";

        } GetGraphvizOutputPortToken;

        // drake::systems::LeafSystem::GetMutableNumericParameter
        struct /* GetMutableNumericParameter */ {

          // drake/systems/framework/leaf_system.h:631
          const char* doc =
R"""(Extracts the numeric parameters of type U from the ``context`` at
``index``. Asserts if the context is not a LeafContext, or if it does
not have a vector-valued parameter of type U at ``index``.)""";

        } GetMutableNumericParameter;

        // drake::systems::LeafSystem::GetNumericParameter
        struct /* GetNumericParameter */ {

          // drake/systems/framework/leaf_system.h:616
          const char* doc =
R"""(Extracts the numeric parameters of type U from the ``context`` at
``index``. Asserts if the context is not a LeafContext, or if it does
not have a vector-valued parameter of type U at ``index``.)""";

        } GetNumericParameter;

        // drake::systems::LeafSystem::LeafSystem<T>
        struct /* ctor */ {

          // drake/systems/framework/leaf_system.h:84
          const char* doc = R"""()""";

          // drake/systems/framework/leaf_system.h:84
          const char* doc_2 = R"""()""";

          // drake/systems/framework/leaf_system.h:291
          const char* doc_3 =
R"""(Default constructor that declares no inputs, outputs, state,
parameters, events, nor scalar-type conversion support (AutoDiff,
etc.). To enable AutoDiff support, use the SystemScalarConverter-based
constructor.)""";

          // drake/systems/framework/leaf_system.h:303
          const char* doc_4 =
R"""(Constructor that declares no inputs, outputs, state, parameters, or
events, but allows subclasses to declare scalar-type conversion
support (AutoDiff, etc.).

The scalar-type conversion support will use ``converter``. To enable
scalar-type conversion support, pass a `SystemTypeTag<S>{}` where `S`
must be the exact class of `this` being constructed.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

        } ctor;

        // drake::systems::LeafSystem::SetDefaultParameters
        struct /* SetDefaultParameters */ {

          // drake/systems/framework/leaf_system.h:206
          const char* doc =
R"""(Default implementation: sets all numeric parameters to the model
vector given to DeclareNumericParameter, or else if no model was
provided sets the numeric parameter to one. It sets all abstract
parameters to the model value given to DeclareAbstractParameter.
Overrides must not change the number of parameters.)""";

        } SetDefaultParameters;

        // drake::systems::LeafSystem::SetDefaultState
        struct /* SetDefaultState */ {

          // drake/systems/framework/leaf_system.h:182
          const char* doc = R"""()""";

        } SetDefaultState;

        // drake::systems::LeafSystem::get_num_continuous_states
        struct /* get_num_continuous_states */ {

          // drake/systems/framework/leaf_system.h:277
          const char* doc = R"""()""";

        } get_num_continuous_states;

      } LeafSystem;

      // drake::systems::LinearSystem
      struct /* LinearSystem */ {

        // drake/systems/primitives/linear_system.h:44
        const char* doc =
R"""(A discrete OR continuous linear system.

If time_period>0.0, then the linear system will have the following
discrete- time state update: @f[ x[n+1] = A x[n] + B u[n], @f]

or if time_period==0.0, then the linear system will have the following
continuous-time state update: @f[\dot{x} = A x + B u. @f]

In both cases, the system will have the output: @f[y = C x + D u, @f]
where `u` denotes the input vector, `x` denotes the state vector, and
`y` denotes the output vector.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.

See also:
    AffineSystem

See also:
    MatrixGain)""";

        // drake::systems::LinearSystem::LinearSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/linear_system.h:46
          const char* doc = R"""()""";

          // drake/systems/primitives/linear_system.h:46
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/linear_system.h:59
          const char* doc_3 =
R"""(Constructs a LinearSystem with a fixed set of coefficient matrices
`A`, `B`,`C`, and `D`. The coefficient matrices must obey the
following dimensions: | Matrix | Num Rows | Num Columns |
|:-------:|:-----------:|:-----------:| | A | num states | num states
| | B | num states | num inputs | | C | num outputs | num states | | D
| num outputs | num inputs |

Subclasses must use the protected constructor, not this one.)""";

          // drake/systems/primitives/linear_system.h:67
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/linear_system.h:87
          const char* doc_5 =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.)""";

        } ctor;

        // drake::systems::LinearSystem::MakeLinearSystem
        struct /* MakeLinearSystem */ {

          // drake/systems/primitives/linear_system.h:74
          const char* doc =
R"""(Creates a unique pointer to LinearSystem<T> by decomposing
``dynamics`` and ``outputs`` using ``state_vars`` and ``input_vars``.

Throws:
    s runtime_error if either ``dynamics`` or ``outputs`` is not
    linear in ``state_vars`` and ``input_vars``.)""";

        } MakeLinearSystem;

      } LinearSystem;

      // drake::systems::LinearTimeVaryingData
      struct /* LinearTimeVaryingData */ {

        // drake/systems/primitives/time_varying_data.h:104
        const char* doc =
R"""(Stores matrix data necessary to construct a linear time varying system
as a piecewise polynomial trajectory. The trajectory matrices must
adhere to the following dimensions: | Matrix | Num Rows | Num Columns
| |:-------:|:-----------:|:-----------:| | A | num states | num
states | | B | num states | num inputs | | C | num outputs | num
states | | D | num outputs | num inputs |)""";

        // drake::systems::LinearTimeVaryingData::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/primitives/time_varying_data.h:105
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::LinearTimeVaryingData::LinearTimeVaryingData
        struct /* ctor */ {

          // drake/systems/primitives/time_varying_data.h:105
          const char* doc = R"""()""";

          // drake/systems/primitives/time_varying_data.h:105
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/time_varying_data.h:108
          const char* doc_3 = R"""(Default constructor.)""";

          // drake/systems/primitives/time_varying_data.h:118
          const char* doc_4 =
R"""(Fully-parameterized constructor of vector of MatrixXd; these are
ultimately converted into PiecewisePolynomialTrajectories, whose i-th
element corresponds to time = i * time_period. These vectors are only
well-defined when time_period > 0 (e.g. for discrete-time systems).
The matrix values are interpolated linearly in between time steps.

Parameter ``time_period``:
    The time period from which to construct the time vector.
    time_period must be greater than zero.)""";

          // drake/systems/primitives/time_varying_data.h:125
          const char* doc_5 =
R"""(Fully-parameterized constructor of PiecewisePolynomials.)""";

        } ctor;

      } LinearTimeVaryingData;

      // drake::systems::Linearize
      struct /* Linearize */ {

        // drake/systems/primitives/linear_system.h:198
        const char* doc =
R"""(Takes the first-order Taylor expansion of a System around a nominal
operating point (defined by the Context).

This method currently supports linearizing around at most a single
vector input port and at most a single vector output port. For systems
with more ports, use ``input_port_index`` and ``output_port_index`` to
select the input for the newly constructed system. Any additional
input ports will be treated as constants (fixed at the value specified
in ``context``).

Parameter ``system``:
    The system or subsystem to linearize.

Parameter ``context``:
    Defines the nominal operating point about which the system should
    be linearized. See note below.

Parameter ``input_port_index``:
    A valid input port index for ``system`` or kNoInput or (default)
    kUseFirstInputIfItExists.

Parameter ``output_port_index``:
    A valid output port index for ``system`` or kNoOutput or (default)
    kUseFirstOutputIfItExists.

Parameter ``equilibrium_check_tolerance``:
    Specifies the tolerance on ensuring that the derivative vector
    isZero at the nominal operating point. @default 1e-6.

Returns:
    A LinearSystem that approximates the original system in the
    vicinity of the operating point. See note below.

Throws:
    s std::runtime_error if the system the operating point is not an
    equilibrium point of the system (within the specified tolerance)

Throws:
    s std::runtime_error if the system if the system is not (only)
    continuous or (only) discrete time with a single periodic update.

Note: All inputs in the Context must be connected, either to the
output of some upstream System within a Diagram (e.g., if system is a
reference to a subsystem in a Diagram), or to a constant value using,
e.g. context->FixInputPort(0,default_input);

Note: The inputs, states, and outputs of the returned system are NOT
the same as the original system. Denote x0,u0 as the nominal state and
input defined by the Context, and y0 as the value of the output at
(x0,u0), then the created systems inputs are (u-u0), states are
(x-x0), and outputs are (y-y0).)""";

      } Linearize;

      // drake::systems::LogOutput
      struct /* LogOutput */ {

        // drake/systems/primitives/signal_logger.h:85
        const char* doc =
R"""(Provides a convenience function for adding a SignalLogger, initialized
to the correct size, and connected to another output in a
DiagramBuilder.

```
DiagramBuilder<double> builder;
  auto foo = builder.AddSystem<Foo>("name", 3.14);
  auto logger = LogOutput(foo->get_output_port(), &builder);
```)""";

      } LogOutput;

      // drake::systems::MatrixGain
      struct /* MatrixGain */ {

        // drake/systems/primitives/matrix_gain.h:33
        const char* doc =
R"""(A system that specializes LinearSystem by setting coefficient matrices
`A`, `B`, and `C` to all be zero. Thus, the only non-zero coefficient
matrix is `D`. Specifically, given an input signal `u` and a state
`x`, the output of this system, `y`, is:

@f[ y = D u @f]

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.

See also:
    AffineSystem

See also:
    LinearSystem)""";

        // drake::systems::MatrixGain::MatrixGain<T>
        struct /* ctor */ {

          // drake/systems/primitives/matrix_gain.h:35
          const char* doc = R"""()""";

          // drake/systems/primitives/matrix_gain.h:35
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/matrix_gain.h:39
          const char* doc_3 =
R"""(A constructor where the gain matrix `D` is a square identity matrix of
size ``size``.)""";

          // drake/systems/primitives/matrix_gain.h:42
          const char* doc_4 =
R"""(A constructor where the gain matrix `D` is ``D``.)""";

          // drake/systems/primitives/matrix_gain.h:46
          const char* doc_5 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

      } MatrixGain;

      // drake::systems::Multiplexer
      struct /* Multiplexer */ {

        // drake/systems/primitives/multiplexer.h:27
        const char* doc =
R"""(This system combines multiple vector-valued inputs into a vector-
valued output. The input to this system directly feeds through to its
output.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following `T` values are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
Currently, no other values for `T` are supported.)""";

        // drake::systems::Multiplexer::Multiplexer<T>
        struct /* ctor */ {

          // drake/systems/primitives/multiplexer.h:29
          const char* doc = R"""()""";

          // drake/systems/primitives/multiplexer.h:29
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/multiplexer.h:33
          const char* doc_3 =
R"""(Constructs a Multiplexer with `num_scalar_inputs` scalar-valued input
ports, and one vector-valued output port of size `num_scalar_inputs`.)""";

          // drake/systems/primitives/multiplexer.h:38
          const char* doc_4 =
R"""(Constructs a Multiplexer with `input_sizes.size()` vector-valued input
ports where the i-th input has size `input_sizes[i]`, and one vector-
valued output port of size `sum(input_sizes)`.)""";

          // drake/systems/primitives/multiplexer.h:47
          const char* doc_5 =
R"""(Constructs a Multiplexer with model_vector.size() scalar-valued inputs
and one vector-valued output port whose size equals the size of
`model_vector`. In addition, the output type derives from that of
`model_vector`.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion.)""";

          // drake/systems/primitives/multiplexer.h:51
          const char* doc_6 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

      } Multiplexer;

      // drake::systems::NumericParameterTag
      struct /* NumericParameterTag */ {

        // drake/systems/framework/framework_common.h:57
        const char* doc = R"""()""";

      } NumericParameterTag;

      // drake::systems::ObservabilityMatrix
      struct /* ObservabilityMatrix */ {

        // drake/systems/primitives/linear_system.h:262
        const char* doc =
R"""(Returns the observability matrix: O = [ C; CA; ...; CA^{n-1} ].)""";

      } ObservabilityMatrix;

      // drake::systems::OutputPort
      struct /* OutputPort */ {

        // drake/systems/framework/output_port.h:71
        const char* doc =
R"""(An OutputPort belongs to a System and represents the properties of one
of that System's output ports. OutputPort objects are assigned
OutputPortIndex values in the order they are declared; these are
unique within a single System.

An output port can be considered a "window" into a System that permits
controlled exposure of one of the values contained in that System's
Context at run time. Input ports of other subsystems may be connected
to an output port to construct system diagrams with carefully managed
interdependencies.

The exposed value may be the result of an output computation, or it
may simply expose some other value contained in the Context, such as
the values of state variables. The Context handles caching of output
port values and tracks dependencies to ensure that the values are
valid with respect to their prerequisites. Leaf systems provide for
the production of output port values, by computation or forwarding
from other values within the associated leaf context. A diagram's
output ports, on the other hand, are exported from output ports of its
contained subsystems.

An output port's value is always stored as an AbstractValue, but we
also provide special handling for output ports known to have numeric
(vector) values. Vector-valued ports may specify a particular vector
length, or may leave that to be determined at runtime.

OutputPort objects support three important operations: - Allocate()
returns an object that can hold the port's value. - Calc()
unconditionally computes the port's value. - Eval() updates a cached
value if necessary.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::OutputPort::Allocate
        struct /* Allocate */ {

          // drake/systems/framework/output_port.h:98
          const char* doc =
R"""(Allocates a concrete object suitable for holding the value to be
exposed by this output port, and returns that as an AbstractValue. The
returned object will never be null. If Drake assertions are enabled
(typically only in Debug builds), validates for a vector-valued port
that the returned AbstractValue is actually a BasicVector-derived type
and that it has an acceptable size.

Note:
    If this is a vector-valued port, the underlying type is
    `Value<BasicVector<T>>`; downcast to `BasicVector<T>` before
    downcasting to the specific `BasicVector` subclass.)""";

        } Allocate;

        // drake::systems::OutputPort::Calc
        struct /* Calc */ {

          // drake/systems/framework/output_port.h:115
          const char* doc =
R"""(Unconditionally computes the value of this output port with respect to
the given context, into an already-allocated AbstractValue object
whose concrete type must be exactly the same as the type returned by
this port's allocator. If Drake assertions are enabled (typically only
in Debug builds), validates that the given `value` has exactly the
same concrete type as is returned by the Allocate() method.)""";

        } Calc;

        // drake::systems::OutputPort::DoAllocate
        struct /* DoAllocate */ {

          // drake/systems/framework/output_port.h:162
          const char* doc =
R"""(A concrete OutputPort must provide a way to allocate a suitable object
for holding the runtime value of this output port. The particulars may
depend on values and types of objects in the given Context.

Returns:
    A unique_ptr to the new value-holding object as an AbstractValue.)""";

        } DoAllocate;

        // drake::systems::OutputPort::DoCalc
        struct /* DoCalc */ {

          // drake/systems/framework/output_port.h:172
          const char* doc =
R"""(A concrete OutputPort must implement this method to calculate the
value this output port should have, given the supplied Context. The
value may be determined by computation or by copying from a source
value in the Context.

Parameter ``context``:
    A Context that has already been validated as compatible with the
    System whose output port this is.

Parameter ``value``:
    A pointer that has already be validated as non-null and pointing
    to an object of the right type to hold a value of this output
    port.)""";

        } DoCalc;

        // drake::systems::OutputPort::DoEval
        struct /* DoEval */ {

          // drake/systems/framework/output_port.h:182
          const char* doc =
R"""(A concrete OutputPort must provide access to the current value of this
output port stored within the given Context. If the value is already
up to date with respect to its prerequisites in `context`, no
computation should be performed. Otherwise, the implementation should
arrange for the value to be computed, typically but not necessarily by
invoking DoCalc().

Parameter ``context``:
    A Context that has already been validated as compatible with the
    System whose output port this is.)""";

        } DoEval;

        // drake::systems::OutputPort::Eval
        struct /* Eval */ {

          // drake/systems/framework/output_port.h:85
          const char* doc =
R"""(Returns a reference to the up-to-date value of this output port
contained in the given Context. This is the preferred way to obtain an
output port's value since it will not be recalculated once up to date.
If the value is not already up to date with respect to its
prerequisites, this port's Calc() method is used first to update the
value before the reference is returned. The Calc() method may be
arbitrarily expensive, but Eval() is constant time and _very_ fast if
the value is already up to date.)""";

        } Eval;

        // drake::systems::OutputPort::EvalAbstract
        struct /* EvalAbstract */ {

          // drake/systems/framework/output_port.h:128
          const char* doc =
R"""(Returns a reference to the value of this output port contained in the
given Context. If that value is not up to date with respect to its
prerequisites, the Calc() method above is used first to update the
value before the reference is returned.)""";

        } EvalAbstract;

        // drake::systems::OutputPort::GetPortIdString
        struct /* GetPortIdString */ {

          // drake/systems/framework/output_port.h:186
          const char* doc =
R"""(This is useful for error messages and produces a human-readable
identification of an offending output port.)""";

        } GetPortIdString;

        // drake::systems::OutputPort::OutputPort<T>
        struct /* ctor */ {

          // drake/systems/framework/output_port.h:73
          const char* doc = R"""()""";

          // drake/systems/framework/output_port.h:73
          const char* doc_2 = R"""()""";

          // drake/systems/framework/output_port.h:149
          const char* doc_3 =
R"""(Provides derived classes the ability to set the base class members at
construction. See OutputPortBase::OutputPortBase() for the meaning of
these parameters. @pre The `system` parameter must be the same object
as the `system_base` parameter.)""";

        } ctor;

        // drake::systems::OutputPort::get_system
        struct /* get_system */ {

          // drake/systems/framework/output_port.h:137
          const char* doc =
R"""(Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.)""";

        } get_system;

      } OutputPort;

      // drake::systems::OutputPortBase
      struct /* OutputPortBase */ {

        // drake/systems/framework/output_port_base.h:16
        const char* doc =
R"""(OutputPortBase handles the scalar type-independent aspects of an
OutputPort. An OutputPort belongs to a System and represents the
properties of one of that System's output ports.)""";

        // drake::systems::OutputPortBase::DoGetPrerequisite
        struct /* DoGetPrerequisite */ {

          // drake/systems/framework/output_port_base.h:83
          const char* doc =
R"""(Concrete output ports must implement this to return the prerequisite
dependency ticket for this port, which may be in the current System or
one of its immediate child subsystems.)""";

        } DoGetPrerequisite;

        // drake::systems::OutputPortBase::GetPrerequisite
        struct /* GetPrerequisite */ {

          // drake/systems/framework/output_port_base.h:52
          const char* doc = R"""()""";

        } GetPrerequisite;

        // drake::systems::OutputPortBase::OutputPortBase
        struct /* ctor */ {

          // drake/systems/framework/output_port_base.h:18
          const char* doc = R"""()""";

          // drake/systems/framework/output_port_base.h:18
          const char* doc_2 = R"""()""";

          // drake/systems/framework/output_port_base.h:72
          const char* doc_3 =
R"""(Provides derived classes the ability to set the base class members at
construction.

Parameter ``owning_system``:
    The System that owns this output port.

Parameter ``index``:
    The index to be assigned to this OutputPort.

Parameter ``ticket``:
    The DependencyTicket to be assigned to this OutputPort.

Parameter ``data_type``:
    Whether the port described is vector or abstract valued.

Parameter ``size``:
    If the port described is vector-valued, the number of elements
    expected, otherwise ignored.)""";

        } ctor;

        // drake::systems::OutputPortBase::get_data_type
        struct /* get_data_type */ {

          // drake/systems/framework/output_port_base.h:36
          const char* doc =
R"""(Gets the port data type specified at port construction. */)""";

        } get_data_type;

        // drake::systems::OutputPortBase::get_index
        struct /* get_index */ {

          // drake/systems/framework/output_port_base.h:25
          const char* doc =
R"""(Returns the index of this output port within the owning System. For a
Diagram, this will be the index within the Diagram, _not_ the index
within the LeafSystem whose output port was forwarded.)""";

        } get_index;

        // drake::systems::OutputPortBase::get_mutable_system_base
        struct /* get_mutable_system_base */ {

          // drake/systems/framework/output_port_base.h:76
          const char* doc = R"""()""";

        } get_mutable_system_base;

        // drake::systems::OutputPortBase::get_system_base
        struct /* get_system_base */ {

          // drake/systems/framework/output_port_base.h:45
          const char* doc =
R"""(Returns a reference to the System that owns this output port. Note
that for a diagram output port this will be the diagram, not the leaf
system whose output port was forwarded.)""";

        } get_system_base;

        // drake::systems::OutputPortBase::size
        struct /* size */ {

          // drake/systems/framework/output_port_base.h:40
          const char* doc =
R"""(Returns the fixed size expected for a vector-valued output port. Not
meaningful for abstract output ports.)""";

        } size;

        // drake::systems::OutputPortBase::ticket
        struct /* ticket */ {

          // drake/systems/framework/output_port_base.h:31
          const char* doc =
R"""(Returns the DependencyTicket for this output port within the owning
System.)""";

        } ticket;

      } OutputPortBase;

      // drake::systems::OutputPortTag
      struct /* OutputPortTag */ {

        // drake/systems/framework/framework_common.h:45
        const char* doc = R"""()""";

      } OutputPortTag;

      // drake::systems::Parameters
      struct /* Parameters */ {

        // drake/systems/framework/parameters.h:26
        const char* doc =
R"""(Parameters is a container for variables that parameterize a System so
that it can represent a family of related models. Parameters are
members of the Context. Parameters are not Inputs because they do not
flow from upstream Systems, and they are not State because the System
does not define update functions for them. If Parameters are modified,
they are modified by application-specific logic, extrinsic to the
System framework and to the flow of simulation time.

The Parameters include both vector-valued and abstract-valued
elements.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::Parameters::Clone
        struct /* Clone */ {

          // drake/systems/framework/parameters.h:133
          const char* doc = R"""(Returns a deep copy of the Parameters.)""";

        } Clone;

        // drake::systems::Parameters::Parameters<T>
        struct /* ctor */ {

          // drake/systems/framework/parameters.h:29
          const char* doc = R"""()""";

          // drake/systems/framework/parameters.h:29
          const char* doc_2 = R"""()""";

          // drake/systems/framework/parameters.h:32
          const char* doc_3 = R"""(Constructs an empty Parameters.)""";

          // drake/systems/framework/parameters.h:35
          const char* doc_4 =
R"""(Constructs Parameters both ``numeric`` and ``abstract``.)""";

          // drake/systems/framework/parameters.h:43
          const char* doc_5 =
R"""(Constructs Parameters that are purely ``numeric``.)""";

          // drake/systems/framework/parameters.h:47
          const char* doc_6 =
R"""(Constructs Parameters that are purely ``abstract``.)""";

          // drake/systems/framework/parameters.h:52
          const char* doc_7 =
R"""(Constructs Parameters in the common case where the parameters consist
of exactly one numeric vector.)""";

          // drake/systems/framework/parameters.h:59
          const char* doc_8 =
R"""(Constructs Parameters in the common case where the parameters consist
of exactly one abstract value.)""";

        } ctor;

        // drake::systems::Parameters::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/parameters.h:143
          const char* doc =
R"""(Initializes this state (regardless of scalar type) from a
Parameters<double>. All scalar types in Drake must support
initialization from doubles.)""";

        } SetFrom;

        // drake::systems::Parameters::get_abstract_parameter
        struct /* get_abstract_parameter */ {

          // drake/systems/framework/parameters.h:98
          const char* doc =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds.)""";

          // drake/systems/framework/parameters.h:111
          const char* doc_2 =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds, and throws if the parameter is not of type V.)""";

        } get_abstract_parameter;

        // drake::systems::Parameters::get_abstract_parameters
        struct /* get_abstract_parameters */ {

          // drake/systems/framework/parameters.h:122
          const char* doc = R"""()""";

        } get_abstract_parameters;

        // drake::systems::Parameters::get_mutable_abstract_parameter
        struct /* get_mutable_abstract_parameter */ {

          // drake/systems/framework/parameters.h:104
          const char* doc =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds.)""";

          // drake/systems/framework/parameters.h:118
          const char* doc_2 =
R"""(Returns the abstract-valued parameter at ``index``. Asserts if the
index is out of bounds, and throws if the parameter is not of type V.)""";

        } get_mutable_abstract_parameter;

        // drake::systems::Parameters::get_mutable_numeric_parameter
        struct /* get_mutable_numeric_parameter */ {

          // drake/systems/framework/parameters.h:82
          const char* doc =
R"""(Returns the vector-valued parameter at ``index``. Asserts if the index
is out of bounds.)""";

        } get_mutable_numeric_parameter;

        // drake::systems::Parameters::get_numeric_parameter
        struct /* get_numeric_parameter */ {

          // drake/systems/framework/parameters.h:76
          const char* doc =
R"""(Returns the vector-valued parameter at ``index``. Asserts if the index
is out of bounds.)""";

        } get_numeric_parameter;

        // drake::systems::Parameters::get_numeric_parameters
        struct /* get_numeric_parameters */ {

          // drake/systems/framework/parameters.h:86
          const char* doc = R"""()""";

        } get_numeric_parameters;

        // drake::systems::Parameters::num_abstract_parameters
        struct /* num_abstract_parameters */ {

          // drake/systems/framework/parameters.h:70
          const char* doc = R"""()""";

        } num_abstract_parameters;

        // drake::systems::Parameters::num_numeric_parameters
        struct /* num_numeric_parameters */ {

          // drake/systems/framework/parameters.h:66
          const char* doc = R"""()""";

        } num_numeric_parameters;

        // drake::systems::Parameters::set_abstract_parameters
        struct /* set_abstract_parameters */ {

          // drake/systems/framework/parameters.h:126
          const char* doc = R"""()""";

        } set_abstract_parameters;

        // drake::systems::Parameters::set_numeric_parameters
        struct /* set_numeric_parameters */ {

          // drake/systems/framework/parameters.h:90
          const char* doc = R"""()""";

        } set_numeric_parameters;

      } Parameters;

      // drake::systems::PassThrough
      struct /* PassThrough */ {

        // drake/systems/primitives/pass_through.h:39
        const char* doc =
R"""(A pass through system with input `u` and output `y = u`. This is
mathematically equivalent to a Gain system with its gain equal to one.
However this system incurs no computational cost. The input to this
system directly feeds through to its output. This system is used, for
instance, in PidController which is a Diagram composed of simple
framework primitives. In this case a PassThrough is used to connect
the exported input of the Diagram to the inputs of the Gain systems
for the proportioanal and integral constants of the controller. This
is necessary to provide an output port to which the internal Gain
subsystems connect. In this case the PassThrough is effectively
creating an output port that feeds through the input to the Diagram
and that can now be connected to the inputs of the inner subsystems to
the Diagram. A detailed discussion of the PidController can be found
at https://github.com/RobotLocomotion/drake/pull/3132.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::systems::PassThrough::DoCalcAbstractOutput
        struct /* DoCalcAbstractOutput */ {

          // drake/systems/primitives/pass_through-inl.h:67
          const char* doc = R"""()""";

          // drake/systems/primitives/pass_through.h:86
          const char* doc_2 = R"""()""";

        } DoCalcAbstractOutput;

        // drake::systems::PassThrough::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/pass_through-inl.h:57
          const char* doc =
R"""(Sets the output port to equal the input port.)""";

          // drake/systems/primitives/pass_through.h:81
          const char* doc_2 =
R"""(Sets the output port to equal the input port.)""";

        } DoCalcVectorOutput;

        // drake::systems::PassThrough::DoHasDirectFeedthrough
        struct /* DoHasDirectFeedthrough */ {

          // drake/systems/primitives/pass_through-inl.h:76
          const char* doc = R"""()""";

          // drake/systems/primitives/pass_through.h:91
          const char* doc_2 = R"""()""";

        } DoHasDirectFeedthrough;

        // drake::systems::PassThrough::PassThrough<T>
        struct /* ctor */ {

          // drake/systems/primitives/pass_through-inl.h:51
          const char* doc =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/pass_through.h:41
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/pass_through.h:41
          const char* doc_3 = R"""()""";

          // drake/systems/primitives/pass_through.h:45
          const char* doc_4 =
R"""(Constructs a pass through system (`y = u`).

Parameter ``vector_size``:
    number of elements in the signal to be processed.)""";

          // drake/systems/primitives/pass_through.h:50
          const char* doc_5 =
R"""(Constructs a pass through system (`y = u`).

Parameter ``abstract_model_value``:
    A model abstract value.)""";

          // drake/systems/primitives/pass_through.h:56
          const char* doc_6 =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::PassThrough::get_input_port
        struct /* get_input_port */ {

          // drake/systems/primitives/pass_through.h:64
          const char* doc = R"""(Returns the sole input port.)""";

          // drake/systems/primitives/pass_through.h:69
          const char* doc_2 = R"""()""";

        } get_input_port;

        // drake::systems::PassThrough::get_output_port
        struct /* get_output_port */ {

          // drake/systems/primitives/pass_through.h:72
          const char* doc = R"""(Returns the sole output port.)""";

          // drake/systems/primitives/pass_through.h:77
          const char* doc_2 = R"""()""";

        } get_output_port;

      } PassThrough;

      // drake::systems::PeriodicEventData
      struct /* PeriodicEventData */ {

        // drake/systems/framework/event.h:52
        const char* doc =
R"""(A token describing an event that recurs on a fixed period. The events
are triggered at time = offset_sec + i * period_sec, where i is a non-
negative integer.)""";

        // drake::systems::PeriodicEventData::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/framework/event.h:55
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::PeriodicEventData::PeriodicEventData
        struct /* ctor */ {

          // drake/systems/framework/event.h:54
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:55
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event.h:55
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::PeriodicEventData::offset_sec
        struct /* offset_sec */ {

          // drake/systems/framework/event.h:64
          const char* doc =
R"""(Gets the time after zero when this event should first occur.)""";

        } offset_sec;

        // drake::systems::PeriodicEventData::period_sec
        struct /* period_sec */ {

          // drake/systems/framework/event.h:58
          const char* doc =
R"""(Gets the period with which this event should recur.)""";

        } period_sec;

        // drake::systems::PeriodicEventData::set_offset_sec
        struct /* set_offset_sec */ {

          // drake/systems/framework/event.h:67
          const char* doc =
R"""(Sets the time after zero when this event should first occur.)""";

        } set_offset_sec;

        // drake::systems::PeriodicEventData::set_period_sec
        struct /* set_period_sec */ {

          // drake/systems/framework/event.h:61
          const char* doc =
R"""(Sets the period with which this event should recur.)""";

        } set_period_sec;

      } PeriodicEventData;

      // drake::systems::PeriodicEventDataComparator
      struct /* PeriodicEventDataComparator */ {

        // drake/systems/framework/event.h:317
        const char* doc =
R"""(Structure for comparing two PeriodicEventData objects for use in a map
container, using an arbitrary comparison method.)""";

        // drake::systems::PeriodicEventDataComparator::operator()
        struct /* operator_call */ {

          // drake/systems/framework/event.h:318
          const char* doc = R"""()""";

        } operator_call;

      } PeriodicEventDataComparator;

      // drake::systems::PiecewisePolynomialAffineSystem
      struct /* PiecewisePolynomialAffineSystem */ {

        // drake/systems/primitives/piecewise_polynomial_affine_system.h:31
        const char* doc =
R"""(A continuous- or discrete-time Affine Time-Varying system described by
a piecewise polynomial trajectory of system matrices.

Template parameter ``T``:
    The scalar element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::PiecewisePolynomialAffineSystem::A
        struct /* A */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:56
          const char* doc =
R"""(@name Implementations of PiecewisePolynomialAffineSystem<T>'s pure
virtual methods. @{)""";

        } A;

        // drake::systems::PiecewisePolynomialAffineSystem::B
        struct /* B */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:59
          const char* doc = R"""()""";

        } B;

        // drake::systems::PiecewisePolynomialAffineSystem::C
        struct /* C */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:65
          const char* doc = R"""()""";

        } C;

        // drake::systems::PiecewisePolynomialAffineSystem::D
        struct /* D */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:68
          const char* doc = R"""()""";

        } D;

        // drake::systems::PiecewisePolynomialAffineSystem::PiecewisePolynomialAffineSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:34
          const char* doc = R"""()""";

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:34
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:41
          const char* doc_3 =
R"""(Constructs a PiecewisePolynomialAffineSystem from a TimeVaryingData
structure.

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. @default 0.0)""";

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:49
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:82
          const char* doc_5 =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion and examples related to scalar-type
    conversion support for more details.)""";

        } ctor;

        // drake::systems::PiecewisePolynomialAffineSystem::f0
        struct /* f0 */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:62
          const char* doc = R"""()""";

        } f0;

        // drake::systems::PiecewisePolynomialAffineSystem::y0
        struct /* y0 */ {

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:71
          const char* doc = R"""()""";

        } y0;

      } PiecewisePolynomialAffineSystem;

      // drake::systems::PiecewisePolynomialLinearSystem
      struct /* PiecewisePolynomialLinearSystem */ {

        // drake/systems/primitives/piecewise_polynomial_linear_system.h:31
        const char* doc =
R"""(A continuous- or discrete-time Linear Time-Varying system described by
a piecewise polynomial trajectory of system matrices.

Template parameter ``T``:
    The scalar element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::PiecewisePolynomialLinearSystem::A
        struct /* A */ {

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:56
          const char* doc =
R"""(@name Implementations of PiecewisePolynomialLinearSystem<T>'s pure
virtual methods. @{)""";

        } A;

        // drake::systems::PiecewisePolynomialLinearSystem::B
        struct /* B */ {

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:59
          const char* doc = R"""()""";

        } B;

        // drake::systems::PiecewisePolynomialLinearSystem::C
        struct /* C */ {

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:62
          const char* doc = R"""()""";

        } C;

        // drake::systems::PiecewisePolynomialLinearSystem::D
        struct /* D */ {

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:65
          const char* doc = R"""()""";

        } D;

        // drake::systems::PiecewisePolynomialLinearSystem::PiecewisePolynomialLinearSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:34
          const char* doc = R"""()""";

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:34
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:41
          const char* doc_3 =
R"""(Constructs a PiecewisePolynomialLinearSystem from a
LinearTimeVaryingData structure.

Parameter ``time_period``:
    Defines the period of the discrete time system; use
    time_period=0.0 to denote a continuous time system. @default 0.0)""";

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:49
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:76
          const char* doc_5 =
R"""(Constructor that specifies scalar-type conversion support.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion and examples related to scalar-type
    conversion support for more details.)""";

        } ctor;

      } PiecewisePolynomialLinearSystem;

      // drake::systems::PointContactDetail
      struct /* PointContactDetail */ {

        // drake/multibody/rigid_body_plant/point_contact_detail.h:22
        const char* doc =
R"""(An implementation of the ContactDetail where the contact details
consist of a single ContactForce.

Template parameter ``T``:
    The scalar type. It must be a valid Eigen scalar.

Instantiated templates for the following ScalarTypes are provided: -
double - AutoDiffXd)""";

        // drake::systems::PointContactDetail::Clone
        struct /* Clone */ {

          // drake/multibody/rigid_body_plant/point_contact_detail.h:27
          const char* doc = R"""()""";

        } Clone;

        // drake::systems::PointContactDetail::ComputeContactForce
        struct /* ComputeContactForce */ {

          // drake/multibody/rigid_body_plant/point_contact_detail.h:28
          const char* doc = R"""()""";

        } ComputeContactForce;

        // drake::systems::PointContactDetail::PointContactDetail<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/point_contact_detail.h:24
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/point_contact_detail.h:24
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/point_contact_detail.h:26
          const char* doc_3 = R"""()""";

        } ctor;

      } PointContactDetail;

      // drake::systems::PublishEvent
      struct /* PublishEvent */ {

        // drake/systems/framework/event.h:332
        const char* doc =
R"""(This class represents a publish event. It has an optional callback
function to do custom handling of this event given const Context and
const PublishEvent object references.

See also:
    System::Publish for more details.)""";

        // drake::systems::PublishEvent::PublishEvent<T>
        struct /* ctor */ {

          // drake/systems/framework/event.h:335
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:347
          const char* doc_2 =
R"""(Makes a PublishEvent with no trigger type, no event data, and no
specified callback function.)""";

          // drake/systems/framework/event.h:351
          const char* doc_3 =
R"""(Makes a PublishEvent with no trigger type, no event data, and the
specified callback function.)""";

          // drake/systems/framework/event.h:358
          const char* doc_4 = R"""()""";

          // drake/systems/framework/event.h:364
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::systems::PublishEvent::add_to_composite
        struct /* add_to_composite */ {

          // drake/systems/framework/event.h:373
          const char* doc =
R"""(Assuming that ``events`` is not null, this function makes a deep copy
of this event and adds the deep copy to ``events``'s collection of
publish events.)""";

        } add_to_composite;

        // drake::systems::PublishEvent::handle
        struct /* handle */ {

          // drake/systems/framework/event.h:383
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``
and `this`.)""";

        } handle;

        // drake::systems::PublishEvent::is_discrete_update
        struct /* is_discrete_update */ {

          // drake/systems/framework/event.h:337
          const char* doc = R"""()""";

        } is_discrete_update;

      } PublishEvent;

      // drake::systems::RigidBodyPlant
      struct /* RigidBodyPlant */ {

        // drake/multibody/rigid_body_plant/contact_results.h:14
        const char* doc =
R"""(This class provides a System interface around a multibody dynamics
model of the world represented by a RigidBodyTree.

The RigidBodyPlant provides a number of input and output ports. The
number and types of port accessors depends on the number of model
instances within the RigidBodyTree with actuators. The following lists
the accessors for obtaining the input and output ports of the
RigidBodyPlant. These accessors are typically used when "wiring up" a
RigidBodyPlant within a Diagram using DiagramBuilder. See, for
example, DiagramBuilder::Connect(), DiagramBuilder::ExportInput(), and
DiagramBuilder::ExportOutput().

<B>Plant-Centric Port Accessors:</B>

- actuator_command_input_port(): Contains the command vector for the
RigidBodyTree's actuators. This method can only be called when there
is only one model instance in the RigidBodyTree, as determined by
get_num_model_instances(), and this model instance has at least one
actuator. The size of this vector equals the number of
RigidBodyActuator's in the RigidBodyTree. Each RigidBodyActuator maps
to a single-DOF joint (currently actuation cannot be applied to
multiple-DOF joints). The units of the actuation are the same as the
units of the generalized force on the joint. In addition, actuators
allow for a gear box reduction factor and for actuation limits which
are only used by controllers; the RigidBodyPlant does not apply these
limits. The gear box factor effectively is a multiplier on the input
actuation to the RigidBodyPlant.

- state_output_port(): A vector-valued port containing the state
vector, `x`, of the system. This is useful for downstream systems that
require `x`, which includes DrakeVisualizer. The state vector, `x`,
consists of generalized positions followed by generalized velocities.
Semantics of `x` can be obtained using the following methods:

- RigidBodyPlant<T>::get_num_states() -
RigidBodyTree<T>::get_num_positions() -
RigidBodyTree<T>::get_num_velocities() -
RigidBodyTree<T>::get_position_name() -
RigidBodyTree<T>::get_velocity_name()

- state_derivative_output_port(): A vector-valued port containing the
time derivative `xcdot` of the state vector. The order of indices
within the vector is identical to state_output_port() as explained
above.

- kinematics_results_output_port(): An abstract-valued port containing
a KinematicsResults object allowing access to the results from
kinematics computations for each RigidBody in the RigidBodyTree.

- contact_results_output_port(): An abstract-valued port containing a
ContactsResults object allowing access to the results from contact
computations.

<B>Model-Instance-Centric Port Accessors:</B>

- model_instance_actuator_command_input_port(): Contains the command
vector for the actuators belonging to a particular model instance
within the RigidBodyTree. This method can only be called using the
model instance ID of a model with actuators. To determine if a model
instance possesses actuators, use model_instance_has_actuators().

- model_instance_state_output_port(): A vector-valued port containing
the state vector for a particular model instance in the RigidBodyTree.

The RigidBodyPlant's state consists of a vector containing the
generalized positions followed by the generalized velocities of the
system. This state is applied to a RigidBodyTree, which is a multibody
model that consists of a set of rigid bodies connected through joints
in a tree structure. Bodies may have a collision model, in which case,
collisions are considered. In addition, the model may contain loop
constraints described by RigidBodyLoop instances in the multibody
model. Even though loop constraints are a particular case of holonomic
constraints, general holonomic constraints are not yet supported. For
simulating discretized RigidBodyPlant systems, an additional
(discrete) scalar state variable stores the last time that the
system's state was updated.

The system dynamics is given by the set of multibody equations written
in generalized coordinates including loop joints as a set of holonomic
constraints like so:

```
H(q) * vdot + C(q, v) = tau_actuators + tau_constraints.
```

where `q` is the vector of generalized coordinates (or positions), `v`
is the vector of generalized velocities, `C` includes the velocity-
dependent Coriolis and gyroscopic forces, `tau_actuators` is the
vector of externally applied generalized forces and finally
`tau_constraints` is the vector of generalized forces due to
constraints. `tau_constraints` is computed as

```
tau_constraints = -J^T * lambda
```

where `lambda` is the vector of Lagrange multipliers representing the
constraint forces and `J` is the constraint Jacobian. The time
derivative of the generalized coordinates is then obtained from the
generalized velocities as

```
qdot = N(q) * v
```

where `N(q)` is a transformation matrix only dependent on the
positions.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar. Instantiated
    templates for the following kinds of T's are provided: - double -
    AutoDiffXd

Throws:
    s std::runtime_error The AutodiffXd implementation has some
    restrictions: - The collision detection code does not yet support
    AutoDiff, and calls to RigidBodyTree that would have required that
    gradient information will throw a std::runtime_error. Currently,
    the implication is that AutoDiff calls for RigidBodyPlants with
    Context that do not require gradients of the contact forces will
    succeed, but calls where Context results in non-zero contact
    forces will throw. - DoCalcDiscreteVariableUpdates does not yet
    support AutoDiff, and will throw if called. In practice this means
    that AutoDiff of the dynamics are only available if the
    RigidBodyPlant is constructed with `timestep=0`.)""";

        // drake/multibody/rigid_body_plant/kinematics_results.h:14
        const char* doc_2 =
R"""(This class provides a System interface around a multibody dynamics
model of the world represented by a RigidBodyTree.

The RigidBodyPlant provides a number of input and output ports. The
number and types of port accessors depends on the number of model
instances within the RigidBodyTree with actuators. The following lists
the accessors for obtaining the input and output ports of the
RigidBodyPlant. These accessors are typically used when "wiring up" a
RigidBodyPlant within a Diagram using DiagramBuilder. See, for
example, DiagramBuilder::Connect(), DiagramBuilder::ExportInput(), and
DiagramBuilder::ExportOutput().

<B>Plant-Centric Port Accessors:</B>

- actuator_command_input_port(): Contains the command vector for the
RigidBodyTree's actuators. This method can only be called when there
is only one model instance in the RigidBodyTree, as determined by
get_num_model_instances(), and this model instance has at least one
actuator. The size of this vector equals the number of
RigidBodyActuator's in the RigidBodyTree. Each RigidBodyActuator maps
to a single-DOF joint (currently actuation cannot be applied to
multiple-DOF joints). The units of the actuation are the same as the
units of the generalized force on the joint. In addition, actuators
allow for a gear box reduction factor and for actuation limits which
are only used by controllers; the RigidBodyPlant does not apply these
limits. The gear box factor effectively is a multiplier on the input
actuation to the RigidBodyPlant.

- state_output_port(): A vector-valued port containing the state
vector, `x`, of the system. This is useful for downstream systems that
require `x`, which includes DrakeVisualizer. The state vector, `x`,
consists of generalized positions followed by generalized velocities.
Semantics of `x` can be obtained using the following methods:

- RigidBodyPlant<T>::get_num_states() -
RigidBodyTree<T>::get_num_positions() -
RigidBodyTree<T>::get_num_velocities() -
RigidBodyTree<T>::get_position_name() -
RigidBodyTree<T>::get_velocity_name()

- state_derivative_output_port(): A vector-valued port containing the
time derivative `xcdot` of the state vector. The order of indices
within the vector is identical to state_output_port() as explained
above.

- kinematics_results_output_port(): An abstract-valued port containing
a KinematicsResults object allowing access to the results from
kinematics computations for each RigidBody in the RigidBodyTree.

- contact_results_output_port(): An abstract-valued port containing a
ContactsResults object allowing access to the results from contact
computations.

<B>Model-Instance-Centric Port Accessors:</B>

- model_instance_actuator_command_input_port(): Contains the command
vector for the actuators belonging to a particular model instance
within the RigidBodyTree. This method can only be called using the
model instance ID of a model with actuators. To determine if a model
instance possesses actuators, use model_instance_has_actuators().

- model_instance_state_output_port(): A vector-valued port containing
the state vector for a particular model instance in the RigidBodyTree.

The RigidBodyPlant's state consists of a vector containing the
generalized positions followed by the generalized velocities of the
system. This state is applied to a RigidBodyTree, which is a multibody
model that consists of a set of rigid bodies connected through joints
in a tree structure. Bodies may have a collision model, in which case,
collisions are considered. In addition, the model may contain loop
constraints described by RigidBodyLoop instances in the multibody
model. Even though loop constraints are a particular case of holonomic
constraints, general holonomic constraints are not yet supported. For
simulating discretized RigidBodyPlant systems, an additional
(discrete) scalar state variable stores the last time that the
system's state was updated.

The system dynamics is given by the set of multibody equations written
in generalized coordinates including loop joints as a set of holonomic
constraints like so:

```
H(q) * vdot + C(q, v) = tau_actuators + tau_constraints.
```

where `q` is the vector of generalized coordinates (or positions), `v`
is the vector of generalized velocities, `C` includes the velocity-
dependent Coriolis and gyroscopic forces, `tau_actuators` is the
vector of externally applied generalized forces and finally
`tau_constraints` is the vector of generalized forces due to
constraints. `tau_constraints` is computed as

```
tau_constraints = -J^T * lambda
```

where `lambda` is the vector of Lagrange multipliers representing the
constraint forces and `J` is the constraint Jacobian. The time
derivative of the generalized coordinates is then obtained from the
generalized velocities as

```
qdot = N(q) * v
```

where `N(q)` is a transformation matrix only dependent on the
positions.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar. Instantiated
    templates for the following kinds of T's are provided: - double -
    AutoDiffXd

Throws:
    s std::runtime_error The AutodiffXd implementation has some
    restrictions: - The collision detection code does not yet support
    AutoDiff, and calls to RigidBodyTree that would have required that
    gradient information will throw a std::runtime_error. Currently,
    the implication is that AutoDiff calls for RigidBodyPlants with
    Context that do not require gradients of the contact forces will
    succeed, but calls where Context results in non-zero contact
    forces will throw. - DoCalcDiscreteVariableUpdates does not yet
    support AutoDiff, and will throw if called. In practice this means
    that AutoDiff of the dynamics are only available if the
    RigidBodyPlant is constructed with `timestep=0`.)""";

        // drake/multibody/rigid_body_plant/rigid_body_plant.h:138
        const char* doc_3 =
R"""(This class provides a System interface around a multibody dynamics
model of the world represented by a RigidBodyTree.

The RigidBodyPlant provides a number of input and output ports. The
number and types of port accessors depends on the number of model
instances within the RigidBodyTree with actuators. The following lists
the accessors for obtaining the input and output ports of the
RigidBodyPlant. These accessors are typically used when "wiring up" a
RigidBodyPlant within a Diagram using DiagramBuilder. See, for
example, DiagramBuilder::Connect(), DiagramBuilder::ExportInput(), and
DiagramBuilder::ExportOutput().

<B>Plant-Centric Port Accessors:</B>

- actuator_command_input_port(): Contains the command vector for the
RigidBodyTree's actuators. This method can only be called when there
is only one model instance in the RigidBodyTree, as determined by
get_num_model_instances(), and this model instance has at least one
actuator. The size of this vector equals the number of
RigidBodyActuator's in the RigidBodyTree. Each RigidBodyActuator maps
to a single-DOF joint (currently actuation cannot be applied to
multiple-DOF joints). The units of the actuation are the same as the
units of the generalized force on the joint. In addition, actuators
allow for a gear box reduction factor and for actuation limits which
are only used by controllers; the RigidBodyPlant does not apply these
limits. The gear box factor effectively is a multiplier on the input
actuation to the RigidBodyPlant.

- state_output_port(): A vector-valued port containing the state
vector, `x`, of the system. This is useful for downstream systems that
require `x`, which includes DrakeVisualizer. The state vector, `x`,
consists of generalized positions followed by generalized velocities.
Semantics of `x` can be obtained using the following methods:

- RigidBodyPlant<T>::get_num_states() -
RigidBodyTree<T>::get_num_positions() -
RigidBodyTree<T>::get_num_velocities() -
RigidBodyTree<T>::get_position_name() -
RigidBodyTree<T>::get_velocity_name()

- state_derivative_output_port(): A vector-valued port containing the
time derivative `xcdot` of the state vector. The order of indices
within the vector is identical to state_output_port() as explained
above.

- kinematics_results_output_port(): An abstract-valued port containing
a KinematicsResults object allowing access to the results from
kinematics computations for each RigidBody in the RigidBodyTree.

- contact_results_output_port(): An abstract-valued port containing a
ContactsResults object allowing access to the results from contact
computations.

<B>Model-Instance-Centric Port Accessors:</B>

- model_instance_actuator_command_input_port(): Contains the command
vector for the actuators belonging to a particular model instance
within the RigidBodyTree. This method can only be called using the
model instance ID of a model with actuators. To determine if a model
instance possesses actuators, use model_instance_has_actuators().

- model_instance_state_output_port(): A vector-valued port containing
the state vector for a particular model instance in the RigidBodyTree.

The RigidBodyPlant's state consists of a vector containing the
generalized positions followed by the generalized velocities of the
system. This state is applied to a RigidBodyTree, which is a multibody
model that consists of a set of rigid bodies connected through joints
in a tree structure. Bodies may have a collision model, in which case,
collisions are considered. In addition, the model may contain loop
constraints described by RigidBodyLoop instances in the multibody
model. Even though loop constraints are a particular case of holonomic
constraints, general holonomic constraints are not yet supported. For
simulating discretized RigidBodyPlant systems, an additional
(discrete) scalar state variable stores the last time that the
system's state was updated.

The system dynamics is given by the set of multibody equations written
in generalized coordinates including loop joints as a set of holonomic
constraints like so:

```
H(q) * vdot + C(q, v) = tau_actuators + tau_constraints.
```

where `q` is the vector of generalized coordinates (or positions), `v`
is the vector of generalized velocities, `C` includes the velocity-
dependent Coriolis and gyroscopic forces, `tau_actuators` is the
vector of externally applied generalized forces and finally
`tau_constraints` is the vector of generalized forces due to
constraints. `tau_constraints` is computed as

```
tau_constraints = -J^T * lambda
```

where `lambda` is the vector of Lagrange multipliers representing the
constraint forces and `J` is the constraint Jacobian. The time
derivative of the generalized coordinates is then obtained from the
generalized velocities as

```
qdot = N(q) * v
```

where `N(q)` is a transformation matrix only dependent on the
positions.

Template parameter ``T``:
    The scalar type. Must be a valid Eigen scalar. Instantiated
    templates for the following kinds of T's are provided: - double -
    AutoDiffXd

Throws:
    s std::runtime_error The AutodiffXd implementation has some
    restrictions: - The collision detection code does not yet support
    AutoDiff, and calls to RigidBodyTree that would have required that
    gradient information will throw a std::runtime_error. Currently,
    the implication is that AutoDiff calls for RigidBodyPlants with
    Context that do not require gradients of the contact forces will
    succeed, but calls where Context results in non-zero contact
    forces will throw. - DoCalcDiscreteVariableUpdates does not yet
    support AutoDiff, and will throw if called. In practice this means
    that AutoDiff of the dynamics are only available if the
    RigidBodyPlant is constructed with `timestep=0`.)""";

        // drake::systems::RigidBodyPlant::AllocateContinuousState
        struct /* AllocateContinuousState */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:410
          const char* doc = R"""()""";

        } AllocateContinuousState;

        // drake::systems::RigidBodyPlant::AllocateDiscreteState
        struct /* AllocateDiscreteState */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:411
          const char* doc = R"""()""";

        } AllocateDiscreteState;

        // drake::systems::RigidBodyPlant::DoCalcConservativePower
        struct /* DoCalcConservativePower */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:439
          const char* doc = R"""()""";

        } DoCalcConservativePower;

        // drake::systems::RigidBodyPlant::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:418
          const char* doc = R"""()""";

        } DoCalcDiscreteVariableUpdates;

        // drake::systems::RigidBodyPlant::DoCalcKineticEnergy
        struct /* DoCalcKineticEnergy */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:435
          const char* doc = R"""()""";

        } DoCalcKineticEnergy;

        // drake::systems::RigidBodyPlant::DoCalcNonConservativePower
        struct /* DoCalcNonConservativePower */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:443
          const char* doc = R"""()""";

        } DoCalcNonConservativePower;

        // drake::systems::RigidBodyPlant::DoCalcPotentialEnergy
        struct /* DoCalcPotentialEnergy */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:431
          const char* doc = R"""()""";

        } DoCalcPotentialEnergy;

        // drake::systems::RigidBodyPlant::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:415
          const char* doc = R"""()""";

        } DoCalcTimeDerivatives;

        // drake::systems::RigidBodyPlant::DoHasDirectFeedthrough
        struct /* DoHasDirectFeedthrough */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:426
          const char* doc = R"""()""";

        } DoHasDirectFeedthrough;

        // drake::systems::RigidBodyPlant::DoMapQDotToVelocity
        struct /* DoMapQDotToVelocity */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:452
          const char* doc = R"""()""";

        } DoMapQDotToVelocity;

        // drake::systems::RigidBodyPlant::DoMapVelocityToQDot
        struct /* DoMapVelocityToQDot */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:447
          const char* doc = R"""()""";

        } DoMapVelocityToQDot;

        // drake::systems::RigidBodyPlant::EvaluateActuatorInputs
        struct /* EvaluateActuatorInputs */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:406
          const char* doc = R"""()""";

        } EvaluateActuatorInputs;

        // drake::systems::RigidBodyPlant::FindInstancePositionIndexFromWorldIndex
        struct /* FindInstancePositionIndexFromWorldIndex */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:282
          const char* doc =
R"""(Returns the index into the output port for `model_instance_id` which
corresponds to the world position index of `world_position_index`, or
throws if the position index does not correspond to the model id.)""";

        } FindInstancePositionIndexFromWorldIndex;

        // drake::systems::RigidBodyPlant::GetStateVector
        struct /* GetStateVector */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:386
          const char* doc = R"""(@})""";

        } GetStateVector;

        // drake::systems::RigidBodyPlant::JointLimitForce
        struct /* JointLimitForce */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:275
          const char* doc =
R"""(Computes the force exerted by the stop when a joint hits its limit,
using a linear stiffness model. Exposed for unit testing of the
formula.

Linear stiffness formula (and definition of "dissipation") from: https
://simtk.org/api_docs/simbody/latest/classSimTK_1_1Force_1_1MobilityLi
nearStop.html#details)""";

        } JointLimitForce;

        // drake::systems::RigidBodyPlant::RigidBodyPlant<T>
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:140
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:140
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:152
          const char* doc_3 =
R"""(Instantiates a RigidBodyPlant from a Multi-Body Dynamics (MBD) model
of the world in `tree`. `tree` must not be `nullptr`.

Parameter ``tree``:
    the dynamic model to use with this plant.

Parameter ``timestep``:
    a non-negative value specifying the update period of the model;
    0.0 implies continuous-time dynamics with derivatives, and values
    > 0.0 result in discrete-time dynamics implementing a
    discretization of the dynamics equation. @default 0.0.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:157
          const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:400
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::systems::RigidBodyPlant::SetDefaultState
        struct /* SetDefaultState */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:243
          const char* doc =
R"""(Sets the state in `context` so that generalized positions and
velocities are zero. For quaternion based joints the quaternion is set
to be the identity (or equivalently a zero rotation).)""";

        } SetDefaultState;

        // drake::systems::RigidBodyPlant::SetModelInstancePositions
        struct /* SetModelInstancePositions */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:224
          const char* doc =
R"""(Sets the generalized coordinates of the model instance specified by
`model_instance_id` to the values in `position`.)""";

        } SetModelInstancePositions;

        // drake::systems::RigidBodyPlant::actuator_command_input_port
        struct /* actuator_command_input_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:296
          const char* doc =
R"""(Returns a the actuator command input port. This method can only be
called when there is only one model instance in the RigidBodyTree.
Otherwise, a std::runtime_error will be thrown. It returns the same
port as model_instance_actuator_command_input_port() using input
parameter RigidBodyTreeConstants::kFirstNonWorldModelInstanceId.)""";

        } actuator_command_input_port;

        // drake::systems::RigidBodyPlant::contact_results_output_port
        struct /* contact_results_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:379
          const char* doc = R"""(Returns the ContactResults output port.)""";

        } contact_results_output_port;

        // drake::systems::RigidBodyPlant::get_input_size
        struct /* get_input_size */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:212
          const char* doc =
R"""(Returns the size of the input vector to the system. This equals the
number of actuators.)""";

        } get_input_size;

        // drake::systems::RigidBodyPlant::get_num_actuators
        struct /* get_num_actuators */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:201
          const char* doc = R"""(Returns the number of actuators.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:204
          const char* doc_2 =
R"""(Returns the number of actuators for a specific model instance.)""";

        } get_num_actuators;

        // drake::systems::RigidBodyPlant::get_num_bodies
        struct /* get_num_bodies */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:175
          const char* doc =
R"""(Returns the number of bodies in the world.)""";

        } get_num_bodies;

        // drake::systems::RigidBodyPlant::get_num_model_instances
        struct /* get_num_model_instances */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:208
          const char* doc =
R"""(Returns the number of model instances in the world, not including the
world.)""";

        } get_num_model_instances;

        // drake::systems::RigidBodyPlant::get_num_positions
        struct /* get_num_positions */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:178
          const char* doc =
R"""(Returns the number of generalized coordinates of the model.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:182
          const char* doc_2 =
R"""(Returns the number of generalized coordinates for a specific model
instance.)""";

        } get_num_positions;

        // drake::systems::RigidBodyPlant::get_num_states
        struct /* get_num_states */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:193
          const char* doc =
R"""(Returns the size of the continuous state of the system which equals
get_num_positions() plus get_num_velocities().)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:198
          const char* doc_2 =
R"""(Returns the size of the continuous state of a specific model instance
which equals get_num_positions() plus get_num_velocities().)""";

        } get_num_states;

        // drake::systems::RigidBodyPlant::get_num_velocities
        struct /* get_num_velocities */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:185
          const char* doc =
R"""(Returns the number of generalized velocities of the model.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:189
          const char* doc_2 =
R"""(Returns the number of generalized velocities for a specific model
instance.)""";

        } get_num_velocities;

        // drake::systems::RigidBodyPlant::get_output_size
        struct /* get_output_size */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:216
          const char* doc =
R"""(Returns the size of the output vector of the system. This equals the
size of the continuous state vector.)""";

        } get_output_size;

        // drake::systems::RigidBodyPlant::get_rigid_body_tree
        struct /* get_rigid_body_tree */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:172
          const char* doc =
R"""(Returns a constant reference to the multibody dynamics model of the
world.)""";

        } get_rigid_body_tree;

        // drake::systems::RigidBodyPlant::get_time_step
        struct /* get_time_step */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:395
          const char* doc =
R"""(Get the time step used to construct the plant. If the step is zero,
the system is continuous. Otherwise, the step corresponds to the
update rate (seconds per update).)""";

        } get_time_step;

        // drake::systems::RigidBodyPlant::is_state_discrete
        struct /* is_state_discrete */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:390
          const char* doc =
R"""(Gets whether this system is modeled using discrete state.)""";

        } is_state_discrete;

        // drake::systems::RigidBodyPlant::kinematics_results_output_port
        struct /* kinematics_results_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:374
          const char* doc =
R"""(Returns the KinematicsResults output port.)""";

        } kinematics_results_output_port;

        // drake::systems::RigidBodyPlant::model_instance_actuator_command_input_port
        struct /* model_instance_actuator_command_input_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:318
          const char* doc =
R"""(Returns the input port for a specific model instance. This method can
only be called when this class is instantiated with constructor
parameter `export_model_instance_centric_ports` equal to `true`.)""";

        } model_instance_actuator_command_input_port;

        // drake::systems::RigidBodyPlant::model_instance_has_actuators
        struct /* model_instance_has_actuators */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:313
          const char* doc =
R"""(Returns true if and only if the model instance with the provided
`model_instance_id` has actuators. This is useful when trying to
determine whether it's safe to call
model_instance_actuator_command_input_port().)""";

        } model_instance_has_actuators;

        // drake::systems::RigidBodyPlant::model_instance_state_output_port
        struct /* model_instance_state_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:348
          const char* doc =
R"""(Returns the output port containing the state of a particular model
with instance ID equal to `model_instance_id`. Throws a
std::runtime_error if `model_instance_id` does not exist. This method
can only be called when this class is instantiated with constructor
parameter `export_model_instance_centric_ports` equal to `true`.)""";

        } model_instance_state_output_port;

        // drake::systems::RigidBodyPlant::model_instance_torque_output_port
        struct /* model_instance_torque_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:370
          const char* doc =
R"""(Returns the output port containing the measured joint torques of a
particular model with ``model_instance_id``.)""";

        } model_instance_torque_output_port;

        // drake::systems::RigidBodyPlant::set_contact_model_parameters
        struct /* set_contact_model_parameters */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:163
          const char* doc =
R"""(Sets the parameters of the compliance _model_. To set material
parameters, use the CompliantMaterial instance associated with the
collision element.)""";

        } set_contact_model_parameters;

        // drake::systems::RigidBodyPlant::set_default_compliant_material
        struct /* set_default_compliant_material */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:168
          const char* doc =
R"""(Sets the compliant material values to use for default-configured
material properties on collision elements (see CompliantMaterial for
details).)""";

        } set_default_compliant_material;

        // drake::systems::RigidBodyPlant::set_position
        struct /* set_position */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:220
          const char* doc =
R"""(Sets the generalized coordinate `position_index` to the value
`position`.)""";

        } set_position;

        // drake::systems::RigidBodyPlant::set_state_vector
        struct /* set_state_vector */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:233
          const char* doc =
R"""(Sets the continuous state vector of the system to be `x`.)""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:237
          const char* doc_2 =
R"""(Sets the continuous state vector of the system to be `x`.)""";

        } set_state_vector;

        // drake::systems::RigidBodyPlant::set_velocity
        struct /* set_velocity */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:230
          const char* doc =
R"""(Sets the generalized velocity `velocity_index` to the value
`velocity`.)""";

        } set_velocity;

        // drake::systems::RigidBodyPlant::state_derivative_output_port
        struct /* state_derivative_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:338
          const char* doc =
R"""(Returns the plant-centric state derivative output port. The size of
this port is equal to get_num_states(). @pre This RigidBodyPlant is
using continuous-time dynamics.)""";

        } state_derivative_output_port;

        // drake::systems::RigidBodyPlant::state_output_port
        struct /* state_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:331
          const char* doc =
R"""(Returns the plant-centric state output port. The size of this port is
equal to get_num_states().)""";

        } state_output_port;

        // drake::systems::RigidBodyPlant::torque_output_port
        struct /* torque_output_port */ {

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:354
          const char* doc =
R"""(Returns the output port containing measured joint torques.

Throws:
    s std::runtime_error if this RigidBodyTree contains more than one
    model instances.)""";

        } torque_output_port;

      } RigidBodyPlant;

      // drake::systems::RungeKutta2Integrator
      struct /* RungeKutta2Integrator */ {

        // drake/systems/analysis/runge_kutta2_integrator.h:15
        const char* doc =
R"""(A second-order, explicit Runge Kutta integrator.)""";

        // drake::systems::RungeKutta2Integrator::RungeKutta2Integrator<T>
        struct /* ctor */ {

          // drake/systems/analysis/runge_kutta2_integrator.h:17
          const char* doc = R"""()""";

          // drake/systems/analysis/runge_kutta2_integrator.h:17
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/runge_kutta2_integrator.h:32
          const char* doc_3 =
R"""(Constructs fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``pointer``:
    to the context (nullptr is ok, but the caller must set a non-null
    context before Initialize()-ing the integrator).

See also:
    Initialize())""";

        } ctor;

        // drake::systems::RungeKutta2Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/runge_kutta2_integrator.h:46
          const char* doc =
R"""(Integrator does not provide an error estimate.)""";

        } get_error_estimate_order;

        // drake::systems::RungeKutta2Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/runge_kutta2_integrator.h:43
          const char* doc =
R"""(The RK2 integrator does not support error estimation.)""";

        } supports_error_estimation;

      } RungeKutta2Integrator;

      // drake::systems::RungeKutta3Integrator
      struct /* RungeKutta3Integrator */ {

        // drake/systems/analysis/runge_kutta3_integrator.h:58
        const char* doc =
R"""(A third-order Runge Kutta integrator with a third order error
estimate.

Template parameter ``T``:
    A double or autodiff type.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd

For a discussion of this Runge-Kutta method, see [Butcher, 1987]. The
embedded error estimate was derived using the method mentioned in
[Hairer, 1993].

The Butcher tableaux for this integrator follows:

```
|
0      |
1/2    | 1/2
1      | -1          2
---------------------------------------------------------------------------
         1/6         2/3       1/6
         0           1         0
```

where the second to last row is the 3rd-order propagated solution and
the last row is the 2nd-order midpoint used for the error estimate.

The following documentation is pulled from Simbody's implementation of
this integrator: "This is a 3-stage, first-same-as-last (FSAL) 3rd
order method which gives us an embedded 2nd order method as well, so
we can extract a 3rd-order error estimate for the 2nd-order result,
which error estimate can then be used for step size control, since it
will behave as h^3. We then propagate the 3rd order result (whose
error is unknown), which Hairer calls 'local extrapolation'. We call
the initial state (t0,y0) and want (t0+h,y1). We are given the initial
derivative f0=f(t0,y0), which most likely is left over from an
evaluation at the end of the last step."

- [Butcher, 1987] J. C. Butcher. The Numerical Analysis of Ordinary
Differential Equations. John Wiley & Sons, 1987. p. 325. - [Hairer,
1993] E. Hairer, S. Noersett, and G. Wanner. Solving ODEs I. 2nd rev.
ed. Springer, 1993. p. 166.)""";

        // drake::systems::RungeKutta3Integrator::RungeKutta3Integrator<T>
        struct /* ctor */ {

          // drake/systems/analysis/runge_kutta3_integrator.h:60
          const char* doc = R"""()""";

          // drake/systems/analysis/runge_kutta3_integrator.h:60
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/runge_kutta3_integrator.h:64
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::RungeKutta3Integrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/runge_kutta3_integrator.h:78
          const char* doc =
R"""(This integrator provides third order error estimates.)""";

        } get_error_estimate_order;

        // drake::systems::RungeKutta3Integrator::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/runge_kutta3_integrator.h:75
          const char* doc =
R"""(The integrator supports error estimation.)""";

        } supports_error_estimation;

      } RungeKutta3Integrator;

      // drake::systems::Saturation
      struct /* Saturation */ {

        // drake/systems/primitives/saturation.h:42
        const char* doc =
R"""(An element-wise hard saturation block with inputs signal `u`,
saturation values $ u_{min} $ and/or $ u_{max} $, and output `y`
respectively as in:

@f[ y = u, u_{min} < u < u_{min} @f] @f[ y = u_{min}, u \le u_{min}
@f] @f[ y = u_{max}, u \ge u_{max} @f]

The input to this system directly feeds through to its output.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression

Note that $ u_{min} $, and $ u_{max} $, and $ u $ are all vectors of
same dimension, and the following condition holds elementwise in
runtime.

@f[ u_{min} <= u_{max} @f]

The quantities $ u_{min} $, and $ u_{max} $ can be supplied as inputs
in separate ports or be initialised as constants using the appropriate
constructor by passing their default value. If these quantities are
not defined as constants but they are not connected to appropriate
sources, their values are taken by default to be $ u_{min} = -\infty
$, and $ u_{max} = \infty $ respectively. In this "variable"
configuration, at least one of the input ports must be connected.)""";

        // drake::systems::Saturation::Saturation<T>
        struct /* ctor */ {

          // drake/systems/primitives/saturation.h:44
          const char* doc = R"""()""";

          // drake/systems/primitives/saturation.h:44
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/saturation.h:54
          const char* doc_3 =
R"""(Constructs a variable Saturation system where the upper and lower
values are represented by vectors of identical size and can be
supplied via the max_value_port and min_value_port respectively.

Parameter ``input_size``:
    sets size of the input and output ports.

Please consult this class's description for the requirements of
``u_min`` and ``u_max`` to be supplied via the corresponding ports.)""";

          // drake/systems/primitives/saturation.h:67
          const char* doc_4 =
R"""(Constructs a constant Saturation system where the upper and lower
values are represented by vectors of identical size supplied via this
constructor.

Parameter ``u_min``:
    the lower (vector) limit to the saturation.

Parameter ``u_max``:
    the upper (vector) limit to the saturation.

Please consult this class's description for the requirements of
``u_min`` and ``u_max``.)""";

        } ctor;

        // drake::systems::Saturation::get_input_port
        struct /* get_input_port */ {

          // drake/systems/primitives/saturation.h:70
          const char* doc = R"""()""";

          // drake/systems/primitives/saturation.h:76
          const char* doc_2 = R"""(Returns the input port.)""";

        } get_input_port;

        // drake::systems::Saturation::get_max_value_port
        struct /* get_max_value_port */ {

          // drake/systems/primitives/saturation.h:87
          const char* doc = R"""(Returns the max value port.)""";

        } get_max_value_port;

        // drake::systems::Saturation::get_min_value_port
        struct /* get_min_value_port */ {

          // drake/systems/primitives/saturation.h:81
          const char* doc = R"""(Returns the min value port.)""";

        } get_min_value_port;

        // drake::systems::Saturation::get_output_port
        struct /* get_output_port */ {

          // drake/systems/primitives/saturation.h:73
          const char* doc = R"""()""";

          // drake/systems/primitives/saturation.h:93
          const char* doc_2 = R"""(Returns the output port.)""";

        } get_output_port;

        // drake::systems::Saturation::get_size
        struct /* get_size */ {

          // drake/systems/primitives/saturation.h:98
          const char* doc = R"""(Returns the size.)""";

        } get_size;

      } Saturation;

      // drake::systems::ScalarDenseOutput
      struct /* ScalarDenseOutput */ {

        // drake/systems/analysis/scalar_dense_output.h:17
        const char* doc =
R"""(A DenseOutput class interface extension to deal with scalar ODE
solutions. A ScalarDenseOutput instance is also a DenseOutput instance
with single element vector values (i.e. size() == 1). As such, its
value can evaluated in both scalar and vectorial form (via
EvaluateScalar() and Evaluate(), respectively).

Template parameter ``T``:
    A valid Eigen scalar type.)""";

        // drake::systems::ScalarDenseOutput::DoEvaluate
        struct /* DoEvaluate */ {

          // drake/systems/analysis/scalar_dense_output.h:39
          const char* doc = R"""()""";

        } DoEvaluate;

        // drake::systems::ScalarDenseOutput::DoEvaluateScalar
        struct /* DoEvaluateScalar */ {

          // drake/systems/analysis/scalar_dense_output.h:48
          const char* doc = R"""()""";

        } DoEvaluateScalar;

        // drake::systems::ScalarDenseOutput::EvaluateScalar
        struct /* EvaluateScalar */ {

          // drake/systems/analysis/scalar_dense_output.h:30
          const char* doc =
R"""(Evaluates output at the given time ``t``.

Parameter ``t``:
    Time at which to evaluate output.

Returns:
    Output scalar value. @pre Output is not empty i.e. is_empty() is
    false.

Throws:
    s std::logic_error if any of the preconditions is not met.

Throws:
    s std::runtime_error if given ``t`` is not within output's domain
    i.e. ``t`` ∉ [start_time(), end_time()].)""";

        } EvaluateScalar;

        // drake::systems::ScalarDenseOutput::ScalarDenseOutput<T>
        struct /* ctor */ {

          // drake/systems/analysis/scalar_dense_output.h:19
          const char* doc = R"""()""";

          // drake/systems/analysis/scalar_dense_output.h:19
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/scalar_dense_output.h:37
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::ScalarDenseOutput::do_size
        struct /* do_size */ {

          // drake/systems/analysis/scalar_dense_output.h:43
          const char* doc = R"""()""";

        } do_size;

      } ScalarDenseOutput;

      // drake::systems::ScalarInitialValueProblem
      struct /* ScalarInitialValueProblem */ {

        // drake/systems/analysis/scalar_initial_value_problem.h:56
        const char* doc =
R"""(A thin wrapper of the InitialValueProblem class to provide a simple
interface when solving scalar initial value problems i.e. when
evaluating the x(t; 𝐤) solution function to the given ODE dx/dt = f(t,
x; 𝐤), where f : t ⨯ x → ℝ , t ∈ ℝ, x ∈ ℝ, 𝐤 ∈ ℝᵐ, along with an
initial condition x(t₀; 𝐤) = x₀. The parameter vector 𝐤 allows for
generic IVP definitions, which can later be solved for any instance of
said vector.

Note the distinction from general initial value problems where f : t ⨯
𝐱 → ℝⁿ and 𝐱 ∈ ℝⁿ, addressed by the class being wrapped. While every
scalar initial value problem could be written in vector form, this
wrapper keeps both problem definition and solution in their scalar
form with almost zero overhead, leading to clearer code if applicable.
Moreover, this scalar form facilitates single-dimensional quadrature
using methods for solving initial value problems.

See InitialValueProblem class documentation for information on caching
support and dense output usage for improved efficiency in scalar IVP
solving.

For further insight into its use, consider the following examples of
scalar IVPs:

- The population growth of an hypothetical bacteria colony is
described by dN/dt = r * N. The colony has N₀ subjects at time t₀. In
this context, x ≜ N, x₀ ≜ N₀, 𝐤 ≜ [r], dx/dt = f(t, x; 𝐤) = 𝐤₁ * x.

- The charge Q stored in the capacitor of a (potentially equivalent)
series RC circuit driven by a time varying voltage source E(t) can be
described by dQ/dt = (E(t) - Q / Cs) / Rs, where Rs refers to the
resistor's resistance and Cs refers to the capacitor's capacitance. In
this context, and assuming an initial stored charge Q₀ at time t₀, x ≜
Q, 𝐤 ≜ [Rs, Cs], x₀ ≜ Q₀, dx/dt = f(t, x; 𝐤) = (E(t) - x / 𝐤₂) / 𝐤₁.

Template parameter ``T``:
    The ℝ domain scalar type, which must be a valid Eigen scalar.

Note:
    Instantiated templates for the following scalar types ``T`` are
    provided: - double)""";

        // drake::systems::ScalarInitialValueProblem::DenseSolve
        struct /* DenseSolve */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:162
          const char* doc =
R"""(Solves and yields an approximation of the IVP solution x(t; 𝐤) for the
closed time interval between the initial time t₀ and the given final
time ``tf``, using initial state x₀ and parameter vector 𝐤 present in
``values`` (falling back to the ones given on construction if not
given).

To this end, the wrapped IntegratorBase instance solves this scalar
IVP, advancing time and state from t₀ and x₀ = x(t₀) to ``tf`` and
x(``tf``), creating a scalar dense output over that [t₀, ``tf``]
interval along the way.

Parameter ``tf``:
    The IVP will be solved up to this time. Usually, t₀ < ``tf`` as an
    empty dense output would result if t₀ = ``tf``.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    A dense approximation to x(t; 𝐤) with x(t₀; 𝐤) = x₀, defined for
    t₀ ≤ t ≤ tf.

Note:
    The larger the given ``tf`` value is, the larger the approximated
    interval will be. See documentation of the specific dense output
    technique in use for reference on performance impact as this
    interval grows. @pre Given ``tf`` must be larger than or equal to
    the specified initial time t₀ (either given or default). @pre If
    given, the dimension of the initial state vector ``values``.x0
    must match that of the default initial state vector in the default
    specified values given on construction. @pre If given, the
    dimension of the parameter vector ``values``.k must match that of
    the parameter vector in the default specified values given on
    construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } DenseSolve;

        // drake::systems::ScalarInitialValueProblem::ScalarInitialValueProblem<T>
        struct /* ctor */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:58
          const char* doc = R"""()""";

          // drake/systems/analysis/scalar_initial_value_problem.h:58
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/scalar_initial_value_problem.h:104
          const char* doc_3 =
R"""(Constructs an scalar IVP described by the given
``scalar_ode_function``, using given ``default_values``.t0 and
``default_values``.x0 as initial conditions, and parameterized with
``default_values``.k by default.

Parameter ``scalar_ode_function``:
    The ODE function f(t, x; 𝐤) that describes the state evolution
    over time.

Parameter ``default_values``:
    The values specified by default for this IVP, i.e. default initial
    time t₀ ∈ ℝ and state x₀ ∈ ℝ, and default parameter vector 𝐤 ∈ ℝᵐ.
    @pre An initial time ``default_values``.t0 is provided. @pre An
    initial state ``default_values``.x0 is provided. @pre An parameter
    vector ``default_values``.k is provided.

Throws:
    s std::logic_error if preconditions are not met.)""";

        } ctor;

        // drake::systems::ScalarInitialValueProblem::Solve
        struct /* Solve */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:130
          const char* doc =
R"""(Solves the IVP for time ``tf``, using the initial time t₀, initial
state x₀ and parameter vector 𝐤 present in ``values``, falling back to
the ones given on construction if not given.

Parameter ``tf``:
    The IVP will be solved for this time.

Parameter ``values``:
    IVP initial conditions and parameters.

Returns:
    The IVP solution x(``tf``; 𝐤) for x(t₀; 𝐤) = x₀. @pre Given ``tf``
    must be larger than or equal to the specified initial time t₀
    (either given or default). @pre If given, the dimension of the
    parameter vector ``values``.k must match that of the parameter
    vector in the default specified values given on construction.

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } Solve;

        // drake::systems::ScalarInitialValueProblem::SpecifiedValues
        struct /* SpecifiedValues */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:72
          const char* doc =
R"""(A collection of values i.e. initial time t₀, initial state x₀ and
parameter vector 𝐤 to further specify the ODE system (in order to
become a scalar initial value problem).)""";

          // drake::systems::ScalarInitialValueProblem::SpecifiedValues::SpecifiedValues
          struct /* ctor */ {

            // drake/systems/analysis/scalar_initial_value_problem.h:74
            const char* doc =
R"""(Default constructor, leaving all values unspecified.)""";

            // drake/systems/analysis/scalar_initial_value_problem.h:81
            const char* doc_2 =
R"""(Constructor specifying all values.

Parameter ``t0_in``:
    Specified initial time t₀.

Parameter ``x0_in``:
    Specified initial state x₀.

Parameter ``k_in``:
    Specified parameter vector 𝐤.)""";

          } ctor;

          // drake::systems::ScalarInitialValueProblem::SpecifiedValues::k
          struct /* k */ {

            // drake/systems/analysis/scalar_initial_value_problem.h:88
            const char* doc = R"""(< The parameter vector 𝐤 for the IVP.)""";

          } k;

          // drake::systems::ScalarInitialValueProblem::SpecifiedValues::t0
          struct /* t0 */ {

            // drake/systems/analysis/scalar_initial_value_problem.h:86
            const char* doc = R"""(< The initial time t₀ for the IVP.)""";

          } t0;

          // drake::systems::ScalarInitialValueProblem::SpecifiedValues::x0
          struct /* x0 */ {

            // drake/systems/analysis/scalar_initial_value_problem.h:87
            const char* doc = R"""(< The initial state x₀ for the IVP.)""";

          } x0;

        } SpecifiedValues;

        // drake::systems::ScalarInitialValueProblem::get_integrator
        struct /* get_integrator */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:197
          const char* doc =
R"""(Gets a pointer to the internal integrator instance.)""";

        } get_integrator;

        // drake::systems::ScalarInitialValueProblem::get_mutable_integrator
        struct /* get_mutable_integrator */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:202
          const char* doc =
R"""(Gets a pointer to the internal mutable integrator instance.)""";

        } get_mutable_integrator;

        // drake::systems::ScalarInitialValueProblem::reset_integrator
        struct /* reset_integrator */ {

          // drake/systems/analysis/scalar_initial_value_problem.h:191
          const char* doc =
R"""(Resets the internal integrator instance by in-place construction of
the given integrator type.

A usage example is shown below.

```
{.cpp}
   scalar_ivp.reset_integrator<RungeKutta2Integrator<T>>(max_step);
```

Parameter ``args``:
    The integrator type-specific arguments.

Returns:
    The new integrator instance.

Template parameter ``Integrator``:
    The integrator type, which must be an IntegratorBase subclass.

Template parameter ``Args``:
    The integrator specific argument types. @warning This operation
    invalidates pointers returned by
    ScalarInitialValueProblem::get_integrator() and
    ScalarInitialValueProblem::get_mutable_integrator().)""";

        } reset_integrator;

      } ScalarInitialValueProblem;

      // drake::systems::ScalarViewDenseOutput
      struct /* ScalarViewDenseOutput */ {

        // drake/systems/analysis/scalar_view_dense_output.h:21
        const char* doc =
R"""(A ScalarDenseOutput class implementation that wraps a DenseOutput
class instance and behaves as a view to one of its elements.

Template parameter ``T``:
    A valid Eigen scalar.)""";

        // drake::systems::ScalarViewDenseOutput::DoEvaluateScalar
        struct /* DoEvaluateScalar */ {

          // drake/systems/analysis/scalar_view_dense_output.h:53
          const char* doc = R"""()""";

        } DoEvaluateScalar;

        // drake::systems::ScalarViewDenseOutput::ScalarViewDenseOutput<T>
        struct /* ctor */ {

          // drake/systems/analysis/scalar_view_dense_output.h:23
          const char* doc = R"""()""";

          // drake/systems/analysis/scalar_view_dense_output.h:23
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/scalar_view_dense_output.h:33
          const char* doc_3 =
R"""(Constructs a view of another DenseOutput instance.

Parameter ``base_output``:
    Base dense output to operate with.

Parameter ``n``:
    The nth scalar element (0-indexed) of the output value to view.

Throws:
    s std::runtime_error if ``base_output`` is nullptr.

Throws:
    s std::runtime_error if given ``n`` does not refer to a valid base
    output dimension i.e. ``n`` ∉ [0, `base_output`->size()).)""";

        } ctor;

        // drake::systems::ScalarViewDenseOutput::base_output_
        struct /* base_output_ */ {

          // drake/systems/analysis/scalar_view_dense_output.h:70
          const char* doc = R"""()""";

        } base_output_;

        // drake::systems::ScalarViewDenseOutput::do_end_time
        struct /* do_end_time */ {

          // drake/systems/analysis/scalar_view_dense_output.h:65
          const char* doc = R"""()""";

        } do_end_time;

        // drake::systems::ScalarViewDenseOutput::do_is_empty
        struct /* do_is_empty */ {

          // drake/systems/analysis/scalar_view_dense_output.h:57
          const char* doc = R"""()""";

        } do_is_empty;

        // drake::systems::ScalarViewDenseOutput::do_start_time
        struct /* do_start_time */ {

          // drake/systems/analysis/scalar_view_dense_output.h:61
          const char* doc = R"""()""";

        } do_start_time;

        // drake::systems::ScalarViewDenseOutput::get_base_output
        struct /* get_base_output */ {

          // drake/systems/analysis/scalar_view_dense_output.h:48
          const char* doc =
R"""(Returns the base dense output upon which the view operates.)""";

        } get_base_output;

        // drake::systems::ScalarViewDenseOutput::n_
        struct /* n_ */ {

          // drake/systems/analysis/scalar_view_dense_output.h:73
          const char* doc = R"""()""";

        } n_;

      } ScalarViewDenseOutput;

      // drake::systems::SemiExplicitEulerIntegrator
      struct /* SemiExplicitEulerIntegrator */ {

        // drake/systems/analysis/semi_explicit_euler_integrator.h:66
        const char* doc =
R"""(A first-order, semi-explicit Euler integrator. State is updated in the
following manner:

```
v(t₀+h) = v(t₀) + dv/dt(t₀) * h
dq/dt  = N * v(t₀+h)
q(t₀+h) = q(t₀) + dq/dt * h
```

where `v` are the generalized velocity variables and `q` are
generalized coordinates. `h` is the integration step size, and `N` is
a matrix (dependent upon `q(t₀)`) that maps velocities to time
derivatives of generalized coordinates. For rigid body systems in 2D,
for example, `N` will generally be an identity matrix. For a single
rigid body in 3D, `N` and its pseudo-inverse (`N` is generally non-
square but always left invertible) are frequently used to transform
between time derivatives of Euler parameters (unit quaternions) and
angular velocities (and vice versa), [Nikravesh 1988].

Note that these equations imply that the velocity variables are
updated first and that these new velocities are then used to update
the generalized coordinates (compare to ExplicitEulerIntegrator, where
the generalized coordinates are updated using the previous velocity
variables).

When a mechanical system is Hamiltonian (informally meaning that the
system is not subject to velocity-dependent forces), the semi-explicit
Euler integrator is a symplectic (energy conserving) integrator.
Symplectic integrators advertise energetically consistent behavior
with large step sizes compared to non-symplectic integrators. Multi-
body systems are not Hamiltonian, even in the absence of externally
applied velocity-dependent forces, due to the presence of both
Coriolis and gyroscopic forces. This integrator thus does not
generally conserve energy for such systems.

<h4>Association between time stepping and the semi-explicit Euler
integrator:</h4> Though many time stepping approaches use the
formulations above, these equations do not represent a "time stepping
scheme". The semi-explicit Euler integration equations can be applied
from one point in state space to another, assuming smoothness in
between, just like any other integrator using the following process:
(1) a simulator integrates to discontinuities, (2) the state of the
ODE/DAE is re-initialized, and (3) integration continues.

In contrast, time stepping schemes enforce all constraints at a single
time in the integration process: though a billiard break may consist
of tens of collisions occurring sequentially over a millisecond of
time, a time stepping method will treat all of these collisions as
occurring simultaneously.

- [Nikravesh 1988] P. Nikravesh. Computer-Aided Analysis of Mechanical
Systems. Prentice Hall. New Jersey, 1988. - [Stewart 2000] D. Stewart.
Rigid-body Dynamics with Friction and Impact. SIAM Review, 42:1, 2000.)""";

        // drake::systems::SemiExplicitEulerIntegrator::SemiExplicitEulerIntegrator<T>
        struct /* ctor */ {

          // drake/systems/analysis/semi_explicit_euler_integrator.h:68
          const char* doc = R"""()""";

          // drake/systems/analysis/semi_explicit_euler_integrator.h:68
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/semi_explicit_euler_integrator.h:85
          const char* doc_3 =
R"""(Constructs a fixed-step integrator for a given system using the given
context for initial conditions.

Parameter ``system``:
    A reference to the system to be simulated.

Parameter ``max_step_size``:
    The maximum (fixed) step size; the integrator will not take larger
    step sizes than this.

Parameter ``context``:
    Pointer to the context (nullptr is ok, but the caller must set a
    non-null context before Initialize()-ing the integrator).

See also:
    Initialize())""";

        } ctor;

        // drake::systems::SemiExplicitEulerIntegrator::get_error_estimate_order
        struct /* get_error_estimate_order */ {

          // drake/systems/analysis/semi_explicit_euler_integrator.h:98
          const char* doc =
R"""(Gets the error estimate order (returns zero, since error estimation is
not provided).)""";

        } get_error_estimate_order;

        // drake::systems::SemiExplicitEulerIntegrator::supports_error_estimation
        struct /* supports_error_estimation */ {

          // drake/systems/analysis/semi_explicit_euler_integrator.h:103
          const char* doc =
R"""(Integrator does not support accuracy estimation.)""";

        } supports_error_estimation;

      } SemiExplicitEulerIntegrator;

      // drake::systems::SignalLog
      struct /* SignalLog */ {

        // drake/systems/primitives/signal_log.h:15
        const char* doc =
R"""(This class serves as an in-memory cache of time-dependent vector
values.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::SignalLog::AddData
        struct /* AddData */ {

          // drake/systems/primitives/signal_log.h:49
          const char* doc =
R"""(Adds a `sample` to the data set with the associated `time` value.

Parameter ``time``:
    The time value for this sample.

Parameter ``sample``:
    A vector of data of the declared size for this log.)""";

        } AddData;

        // drake::systems::SignalLog::SignalLog<T>
        struct /* ctor */ {

          // drake/systems/primitives/signal_log.h:17
          const char* doc = R"""()""";

          // drake/systems/primitives/signal_log.h:17
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/signal_log.h:24
          const char* doc_3 =
R"""(Constructs the signal log.

Parameter ``input_size``:
    Dimension of the per-time step data set.

Parameter ``batch_allocation_size``:
    Storage is (re)allocated in blocks of size (input_size X
    batch_allocation_size).)""";

        } ctor;

        // drake::systems::SignalLog::data
        struct /* data */ {

          // drake/systems/primitives/signal_log.h:32
          const char* doc = R"""(Accesses the logged data. */)""";

        } data;

        // drake::systems::SignalLog::get_input_size
        struct /* get_input_size */ {

          // drake/systems/primitives/signal_log.h:52
          const char* doc =
R"""(Reports the size of the log's input vector. */)""";

        } get_input_size;

        // drake::systems::SignalLog::reset
        struct /* reset */ {

          // drake/systems/primitives/signal_log.h:38
          const char* doc = R"""(Reset the logged data. */)""";

        } reset;

        // drake::systems::SignalLog::sample_times
        struct /* sample_times */ {

          // drake/systems/primitives/signal_log.h:27
          const char* doc = R"""(Accesses the logged time stamps. */)""";

        } sample_times;

      } SignalLog;

      // drake::systems::SignalLogger
      struct /* SignalLogger */ {

        // drake/systems/primitives/signal_logger.h:33
        const char* doc =
R"""(A sink block which logs its input to memory. This data is then
retrievable (e.g. after a simulation) via a handful of accessor
methods. This class essentially holds a large Eigen matrix for data
storage, where each column corresponds to a data point. This system
saves a data point and the context time whenever its Publish() method
is called.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

        // drake::systems::SignalLogger::SignalLogger<T>
        struct /* ctor */ {

          // drake/systems/primitives/signal_logger.h:35
          const char* doc = R"""()""";

          // drake/systems/primitives/signal_logger.h:35
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/signal_logger.h:42
          const char* doc_3 =
R"""(Construct the signal logger system.

Parameter ``input_size``:
    Dimension of the (single) input port. This corresponds to the
    number of rows of the data matrix.

Parameter ``batch_allocation_size``:
    Storage is (re)allocated in blocks of input_size-by-
    batch_allocation_size.)""";

        } ctor;

        // drake::systems::SignalLogger::data
        struct /* data */ {

          // drake/systems/primitives/signal_logger.h:56
          const char* doc = R"""(Access the logged data.)""";

        } data;

        // drake::systems::SignalLogger::get_input_port
        struct /* get_input_port */ {

          // drake/systems/primitives/signal_logger.h:64
          const char* doc = R"""(Returns the only input port.)""";

        } get_input_port;

        // drake::systems::SignalLogger::reset
        struct /* reset */ {

          // drake/systems/primitives/signal_logger.h:61
          const char* doc = R"""()""";

        } reset;

        // drake::systems::SignalLogger::sample_times
        struct /* sample_times */ {

          // drake/systems/primitives/signal_logger.h:51
          const char* doc =
R"""(Access the (simulation) time of the logged data.)""";

        } sample_times;

        // drake::systems::SignalLogger::set_publish_period
        struct /* set_publish_period */ {

          // drake/systems/primitives/signal_logger.h:47
          const char* doc =
R"""(Sets the publishing period of this system. See
LeafSystem::DeclarePeriodicPublish() for details about the semantics
of parameter `period`.)""";

        } set_publish_period;

      } SignalLogger;

      // drake::systems::Simulator
      struct /* Simulator */ {

        // drake/systems/analysis/simulator.h:69
        const char* doc =
R"""(A forward dynamics solver for hybrid dynamic systems represented by
`System<T>` objects. Starting with an initial Context for a given
System, Simulator advances time and produces a series of Context
values that forms a trajectory satisfying the system's dynamic
equations to a specified accuracy. Only the Context is modified by a
Simulator; the System is const.

A Drake System is a continuous/discrete/hybrid dynamic system where
the continuous part is a DAE, that is, it is expected to consist of a
set of differential equations and bilateral algebraic constraints. The
set of active constraints may change as a result of particular events,
such as contact.

Given a current Context, we expect a System to provide us with -
derivatives for the continuous differential equations that already
satisfy the differentiated form of the constraints (typically,
acceleration constraints), - a projection method for least-squares
correction of violated higher-level constraints (position and velocity
level), - a time-of-next-update method that can be used to adjust the
integrator step size in preparation for a discrete update, - a method
that can update discrete variables when their update time is reached,
- witness (guard) functions for event isolation, - event handlers
(reset functions) for making appropriate changes to state and mode
variables when an event has been isolated.

The continuous parts of the trajectory are advanced using a numerical
integrator. Different integrators have different properties; if you
know about that you can choose the one that is most appropriate for
your application. Otherwise, a default is provided which is adequate
for most systems.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided and
available to link against in the containing library: - double -
AutoDiffXd

Other instantiations are permitted but take longer to compile.)""";

        // drake::systems::Simulator::GetCurrentWitnessTimeIsolation
        struct /* GetCurrentWitnessTimeIsolation */ {

          // drake/systems/analysis/simulator.h:318
          const char* doc =
R"""(Gets the length of the interval used for witness function time
isolation. The length of the interval is computed differently,
depending on context, to support multiple applications, as described
below:

* **Simulations using error controlled integrators**: the isolation
time interval will be scaled by the product of the system's
characteristic time and the accuracy stored in the Context. *
**Simulations using integrators taking fixed steps**: the isolation
time interval will be determined differently depending on whether the
accuracy is set in the Context or not. If the accuracy *is* set in the
Context, the nominally fixed steps for integrating continuous state
will be subdivided until events have been isolated to the requisite
interval length, which is scaled by the step size times the accuracy
in the Context. If accuracy is not set in the Context, event isolation
will not be performed.

The isolation window length will never be smaller than the
integrator's working minimum tolerance (see
IntegratorBase::get_working_minimum_step_size());

Returns:
    the isolation window if the Simulator should be isolating witness-
    triggered events in time, or returns empty otherwise (indicating
    that any witness-triggered events should trigger at the end of a
    time interval over which continuous state is integrated).

Throws:
    s std::logic_error if the accuracy is not set in the Context and
    the integrator is not operating in fixed step mode (see
    IntegratorBase::get_fixed_step_mode().)""";

          // drake/systems/analysis/simulator.h:646
          const char* doc_2 =
R"""(Gets the length of the interval used for witness function time
isolation. The length of the interval is computed differently,
depending on context, to support multiple applications, as described
below:

* **Simulations using error controlled integrators**: the isolation
time interval will be scaled by the product of the system's
characteristic time and the accuracy stored in the Context. *
**Simulations using integrators taking fixed steps**: the isolation
time interval will be determined differently depending on whether the
accuracy is set in the Context or not. If the accuracy *is* set in the
Context, the nominally fixed steps for integrating continuous state
will be subdivided until events have been isolated to the requisite
interval length, which is scaled by the step size times the accuracy
in the Context. If accuracy is not set in the Context, event isolation
will not be performed.

The isolation window length will never be smaller than the
integrator's working minimum tolerance (see
IntegratorBase::get_working_minimum_step_size());

Returns:
    the isolation window if the Simulator should be isolating witness-
    triggered events in time, or returns empty otherwise (indicating
    that any witness-triggered events should trigger at the end of a
    time interval over which continuous state is integrated).

Throws:
    s std::logic_error if the accuracy is not set in the Context and
    the integrator is not operating in fixed step mode (see
    IntegratorBase::get_fixed_step_mode().)""";

        } GetCurrentWitnessTimeIsolation;

        // drake::systems::Simulator::Initialize
        struct /* Initialize */ {

          // drake/systems/analysis/simulator.h:94
          const char* doc =
R"""(Prepares the Simulator for a simulation. If the initial Context does
not satisfy the System's constraints, an attempt is made to modify the
values of the continuous state variables to satisfy the constraints.
This method will throw `std::logic_error` if the combination of
options doesn't make sense, and `std::runtime_error` if it is unable
to find a constraint-satisfying initial condition.)""";

          // drake/systems/analysis/simulator.h:463
          const char* doc_2 =
R"""(Prepares the Simulator for a simulation. If the initial Context does
not satisfy the System's constraints, an attempt is made to modify the
values of the continuous state variables to satisfy the constraints.
This method will throw `std::logic_error` if the combination of
options doesn't make sense, and `std::runtime_error` if it is unable
to find a constraint-satisfying initial condition.)""";

        } Initialize;

        // drake::systems::Simulator::ResetStatistics
        struct /* ResetStatistics */ {

          // drake/systems/analysis/simulator.h:236
          const char* doc =
R"""(Forget accumulated statistics. Statistics are reset to the values they
have post construction or immediately after `Initialize()`.)""";

        } ResetStatistics;

        // drake::systems::Simulator::Simulator<T>
        struct /* ctor */ {

          // drake/systems/analysis/simulator.h:71
          const char* doc = R"""()""";

          // drake/systems/analysis/simulator.h:71
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/simulator.h:85
          const char* doc_3 =
R"""(Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).

The Simulator holds an internal, non-owned reference to the System
object so you must ensure that `system` has a longer lifetime than the
Simulator. It also owns a compatible Context internally that takes on
each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from `system`.)""";

          // drake/systems/analysis/simulator.h:430
          const char* doc_4 =
R"""(Create a Simulator that can advance a given System through time to
produce a trajectory consisting of a sequence of Context values. The
System must not have unresolved input ports if the values of those
ports are necessary for computations performed during simulation (see
class documentation).

The Simulator holds an internal, non-owned reference to the System
object so you must ensure that `system` has a longer lifetime than the
Simulator. It also owns a compatible Context internally that takes on
each of the trajectory values. You may optionally provide a Context
that will be used as the initial condition for the simulation;
otherwise the Simulator will obtain a default Context from `system`.)""";

        } ctor;

        // drake::systems::Simulator::StepTo
        struct /* StepTo */ {

          // drake/systems/analysis/simulator.h:110
          const char* doc =
R"""(Advance the System's trajectory until `boundary_time` is reached in
the context or some other termination condition occurs. A variety of
`std::runtime_error` conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a `try-
catch` block and display the `what()` message.

We recommend that you call `Initialize()` prior to making the first
call to `StepTo()`. However, if you don't it will be called for you
the first time you attempt a step, possibly resulting in unexpected
error conditions. See documentation for `Initialize()` for the error
conditions it might produce.)""";

          // drake/systems/analysis/simulator.h:554
          const char* doc_2 =
R"""(Advance the System's trajectory until `boundary_time` is reached in
the context or some other termination condition occurs. A variety of
`std::runtime_error` conditions are possible here, as well as error
conditions that may be thrown by the System when it is asked to
perform computations. Be sure to enclose your simulation in a `try-
catch` block and display the `what()` message.

We recommend that you call `Initialize()` prior to making the first
call to `StepTo()`. However, if you don't it will be called for you
the first time you attempt a step, possibly resulting in unexpected
error conditions. See documentation for `Initialize()` for the error
conditions it might produce.)""";

        } StepTo;

        // drake::systems::Simulator::get_actual_realtime_rate
        struct /* get_actual_realtime_rate */ {

          // drake/systems/analysis/simulator.h:167
          const char* doc =
R"""(Return the rate that simulated time has progressed relative to real
time. A return of 1 means the simulation just matched real time, 2
means the simulation was twice as fast as real time, 0.5 means it was
running in 2X slow motion, etc.

The value returned here is calculated as follows:

```
simulated_time_now - initial_simulated_time
  rate = -------------------------------------------
               realtime_now - initial_realtime
```

The `initial` times are recorded when Initialize() or
ResetStatistics() is called. The returned rate is undefined if
Initialize() has not yet been called.

Returns:
    The rate achieved since the last Initialize() or ResetStatistics()
    call.

See also:
    set_target_realtime_rate())""";

        } get_actual_realtime_rate;

        // drake::systems::Simulator::get_context
        struct /* get_context */ {

          // drake/systems/analysis/simulator.h:192
          const char* doc =
R"""(Returns a const reference to the internally-maintained Context holding
the most recent step in the trajectory. This is suitable for
publishing or extracting information about this trajectory step. Do
not call this method if there is no Context.)""";

        } get_context;

        // drake::systems::Simulator::get_integrator
        struct /* get_integrator */ {

          // drake/systems/analysis/simulator.h:256
          const char* doc =
R"""(Gets a pointer to the integrator used to advance the continuous
aspects of the system.)""";

        } get_integrator;

        // drake::systems::Simulator::get_mutable_context
        struct /* get_mutable_context */ {

          // drake/systems/analysis/simulator.h:202
          const char* doc =
R"""(Returns a mutable reference to the internally-maintained Context
holding the most recent step in the trajectory. This is suitable for
use in updates, sampling operations, event handlers, and constraint
projection. You can also modify this prior to calling Initialize() to
set initial conditions. Do not call this method if there is no
Context.)""";

        } get_mutable_context;

        // drake::systems::Simulator::get_mutable_integrator
        struct /* get_mutable_integrator */ {

          // drake/systems/analysis/simulator.h:260
          const char* doc =
R"""(Gets a pointer to the mutable integrator used to advance the
continuous aspects of the system.)""";

        } get_mutable_integrator;

        // drake::systems::Simulator::get_num_discrete_updates
        struct /* get_num_discrete_updates */ {

          // drake/systems/analysis/simulator.h:247
          const char* doc =
R"""(Gets the number of discrete variable updates performed since the last
Initialize() call.)""";

        } get_num_discrete_updates;

        // drake::systems::Simulator::get_num_publishes
        struct /* get_num_publishes */ {

          // drake/systems/analysis/simulator.h:240
          const char* doc =
R"""(Gets the number of publishes made since the last Initialize() or
ResetStatistics() call.)""";

        } get_num_publishes;

        // drake::systems::Simulator::get_num_steps_taken
        struct /* get_num_steps_taken */ {

          // drake/systems/analysis/simulator.h:243
          const char* doc =
R"""(Gets the number of integration steps since the last Initialize() call.)""";

        } get_num_steps_taken;

        // drake::systems::Simulator::get_num_unrestricted_updates
        struct /* get_num_unrestricted_updates */ {

          // drake/systems/analysis/simulator.h:251
          const char* doc =
R"""(Gets the number of "unrestricted" updates performed since the last
Initialize() call.)""";

        } get_num_unrestricted_updates;

        // drake::systems::Simulator::get_publish_every_time_step
        struct /* get_publish_every_time_step */ {

          // drake/systems/analysis/simulator.h:186
          const char* doc =
R"""(Returns true if the simulation should invoke Publish on the System
under simulation every time step. By default, returns true.)""";

        } get_publish_every_time_step;

        // drake::systems::Simulator::get_system
        struct /* get_system */ {

          // drake/systems/analysis/simulator.h:322
          const char* doc =
R"""(Gets a constant reference to the system.

Note:
    a mutable reference is not available.)""";

        } get_system;

        // drake::systems::Simulator::get_target_realtime_rate
        struct /* get_target_realtime_rate */ {

          // drake/systems/analysis/simulator.h:144
          const char* doc =
R"""(Return the real time rate target currently in effect. The default is
zero, meaning the Simulator runs as fast as possible. You can change
the target with set_target_realtime_rate().)""";

        } get_target_realtime_rate;

        // drake::systems::Simulator::has_context
        struct /* has_context */ {

          // drake/systems/analysis/simulator.h:209
          const char* doc =
R"""(Returns `true` if this Simulator has an internally-maintained Context.
This is always true unless `reset_context()` has been called.)""";

        } has_context;

        // drake::systems::Simulator::release_context
        struct /* release_context */ {

          // drake/systems/analysis/simulator.h:228
          const char* doc =
R"""(Transfer ownership of this Simulator's internal Context to the caller.
The Simulator will no longer contain a Context. The caller must not
attempt to advance the simulator in time after that point.

See also:
    reset_context())""";

        } release_context;

        // drake::systems::Simulator::reset_context
        struct /* reset_context */ {

          // drake/systems/analysis/simulator.h:218
          const char* doc =
R"""(Replace the internally-maintained Context with a different one. The
current Context is deleted. This is useful for supplying a new set of
initial conditions. You should invoke Initialize() after replacing the
Context.

Parameter ``context``:
    The new context, which may be null. If the context is null, a new
    context must be set before attempting to step the system forward.)""";

        } reset_context;

        // drake::systems::Simulator::reset_integrator
        struct /* reset_integrator */ {

          // drake/systems/analysis/simulator.h:271
          const char* doc =
R"""(Resets the integrator with a new one. An example usage is:

```
simulator.reset_integrator(std::move(integrator));
```

The Simulator must be reinitialized after resetting the integrator to
ensure the integrator is properly initialized. You can do that
explicitly with the Initialize() method or it will be done implicitly
at the first time step.)""";

          // drake/systems/analysis/simulator.h:285
          const char* doc_2 =
R"""(Resets the integrator with a new one using factory construction. An
example usage is:

```
simulator.reset_integrator<ExplicitEulerIntegrator<double>>
              (sys, DT, context).
```

See the base overload for `reset_integrator` for more details.)""";

        } reset_integrator;

        // drake::systems::Simulator::set_publish_at_initialization
        struct /* set_publish_at_initialization */ {

          // drake/systems/analysis/simulator.h:179
          const char* doc =
R"""(Sets whether the simulation should invoke Publish in Initialize().)""";

        } set_publish_at_initialization;

        // drake::systems::Simulator::set_publish_every_time_step
        struct /* set_publish_every_time_step */ {

          // drake/systems/analysis/simulator.h:174
          const char* doc =
R"""(Sets whether the simulation should invoke Publish on the System under
simulation during every time step. If enabled, Publish will be invoked
after discrete updates and before continuous integration. Regardless
of whether publishing every time step is enabled, Publish will be
invoked at Simulator initialize time, and as
System<T>::CalcNextUpdateTime requests.)""";

        } set_publish_every_time_step;

        // drake::systems::Simulator::set_target_realtime_rate
        struct /* set_target_realtime_rate */ {

          // drake/systems/analysis/simulator.h:137
          const char* doc =
R"""(Slow the simulation down to *approximately* synchronize with real time
when it would otherwise run too fast. Normally the Simulator takes
steps as quickly as it can. You can request that it slow down to
synchronize with real time by providing a realtime rate greater than
zero here.

@warning No guarantees can be made about how accurately the simulation
can be made to track real time, even if computation is fast enough.
That's because the system utilities used to implement this do not
themselves provide such guarantees. So this is likely to work nicely
for visualization purposes where human perception is the only concern.
For any other uses you should consider whether approximate real time
is adequate for your purposes.

Note:
    If the full-speed simulation is already slower than real time you
    can't speed it up with this call! Instead consider requesting less
    integration accuracy, using a faster integration method or fixed
    time step, or using a simpler model.

Parameter ``realtime_rate``:
    Desired rate relative to real time. Set to 1 to track real time, 2
    to run twice as fast as real time, 0.5 for half speed, etc. Zero
    or negative restores the rate to its default of 0, meaning the
    simulation will proceed as fast as possible.)""";

        } set_target_realtime_rate;

      } Simulator;

      // drake::systems::Sine
      struct /* Sine */ {

        // drake/systems/primitives/sine.h:36
        const char* doc =
R"""(A sine system which outputs `y = a * sin(f * t + p)` and first and
second derivatives w.r.t. the time parameter `t`. The block parameters
are: `a` the amplitude, `f` the frequency (radians/second), and `p`
the phase (radians), all of which are constant vectors provided at
construction time. This system has one or zero input ports and three
vector valued output ports (`y` and its first two derivatives). The
user can specify whether to use simulation time as the source of
values for the time variable or an external source. If an external
time source is specified, the system is created with an input port for
the time source. Otherwise, the system is created with zero input
ports.

This class uses Drake's `-inl.h` pattern. When seeing linker errors
from this class, please refer to https://drake.mit.edu/cxx_inl.html.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.

To use other specific scalar types see sine-inl.h.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::Sine::CalcArg
        struct /* CalcArg */ {

          // drake/systems/primitives/sine-inl.h:158
          const char* doc = R"""()""";

          // drake/systems/primitives/sine.h:111
          const char* doc_2 = R"""()""";

        } CalcArg;

        // drake::systems::Sine::CalcFirstDerivativeOutput
        struct /* CalcFirstDerivativeOutput */ {

          // drake/systems/primitives/sine-inl.h:134
          const char* doc = R"""()""";

          // drake/systems/primitives/sine.h:106
          const char* doc_2 = R"""()""";

        } CalcFirstDerivativeOutput;

        // drake::systems::Sine::CalcSecondDerivativeOutput
        struct /* CalcSecondDerivativeOutput */ {

          // drake/systems/primitives/sine-inl.h:146
          const char* doc = R"""()""";

          // drake/systems/primitives/sine.h:108
          const char* doc_2 = R"""()""";

        } CalcSecondDerivativeOutput;

        // drake::systems::Sine::CalcValueOutput
        struct /* CalcValueOutput */ {

          // drake/systems/primitives/sine-inl.h:124
          const char* doc = R"""()""";

          // drake/systems/primitives/sine.h:104
          const char* doc_2 = R"""()""";

        } CalcValueOutput;

        // drake::systems::Sine::Sine<T>
        struct /* ctor */ {

          // drake/systems/primitives/sine-inl.h:16
          const char* doc =
R"""(Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.

Parameter ``amplitude``:
    the sine wave amplitude

Parameter ``frequency``:
    the sine wave frequency (radians/second)

Parameter ``phase``:
    the sine wave phase (radians)

Parameter ``size``:
    number of elements in the output signal.

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port of size ``size`` is created.)""";

          // drake/systems/primitives/sine-inl.h:23
          const char* doc_2 =
R"""(Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.

Parameter ``amplitudes``:
    the sine wave amplitudes

Parameter ``frequencies``:
    the sine wave frequencies (radians/second)

Parameter ``phases``:
    the sine wave phases (radians)

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port is created.)""";

          // drake/systems/primitives/sine-inl.h:63
          const char* doc_3 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/sine.h:38
          const char* doc_4 = R"""()""";

          // drake/systems/primitives/sine.h:38
          const char* doc_5 = R"""()""";

          // drake/systems/primitives/sine.h:50
          const char* doc_6 =
R"""(Constructs a Sine system where the amplitude, frequency, and phase is
applied to every input.

Parameter ``amplitude``:
    the sine wave amplitude

Parameter ``frequency``:
    the sine wave frequency (radians/second)

Parameter ``phase``:
    the sine wave phase (radians)

Parameter ``size``:
    number of elements in the output signal.

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port of size ``size`` is created.)""";

          // drake/systems/primitives/sine.h:62
          const char* doc_7 =
R"""(Constructs a Sine system where different amplitudes, frequencies, and
phases can be applied to each sine wave.

Parameter ``amplitudes``:
    the sine wave amplitudes

Parameter ``frequencies``:
    the sine wave frequencies (radians/second)

Parameter ``phases``:
    the sine wave phases (radians)

Parameter ``is_time_based``:
    indicates whether to use the simulation time as the source for the
    sine wave time variable, or use an external source, in which case
    an input port is created.)""";

          // drake/systems/primitives/sine.h:69
          const char* doc_8 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::Sine::amplitude
        struct /* amplitude */ {

          // drake/systems/primitives/sine-inl.h:68
          const char* doc =
R"""(Returns the amplitude constant. This method should only be called if
the amplitude can be represented as a scalar value, i.e., every
element in the amplitude vector is the same. It will abort if the
amplitude cannot be represented as a single scalar value.)""";

          // drake/systems/primitives/sine.h:75
          const char* doc_2 =
R"""(Returns the amplitude constant. This method should only be called if
the amplitude can be represented as a scalar value, i.e., every
element in the amplitude vector is the same. It will abort if the
amplitude cannot be represented as a single scalar value.)""";

        } amplitude;

        // drake::systems::Sine::amplitude_
        struct /* amplitude_ */ {

          // drake/systems/primitives/sine.h:114
          const char* doc = R"""()""";

        } amplitude_;

        // drake::systems::Sine::amplitude_vector
        struct /* amplitude_vector */ {

          // drake/systems/primitives/sine-inl.h:109
          const char* doc = R"""(Returns the amplitude vector constant.)""";

          // drake/systems/primitives/sine.h:95
          const char* doc_2 = R"""(Returns the amplitude vector constant.)""";

        } amplitude_vector;

        // drake::systems::Sine::first_derivative_output_port_index_
        struct /* first_derivative_output_port_index_ */ {

          // drake/systems/primitives/sine.h:123
          const char* doc = R"""()""";

        } first_derivative_output_port_index_;

        // drake::systems::Sine::frequency
        struct /* frequency */ {

          // drake/systems/primitives/sine-inl.h:80
          const char* doc =
R"""(Returns the frequency constant. This method should only be called if
the frequency can be represented as a scalar value, i.e., every
element in the frequency vector is the same. It will abort if the
frequency cannot be represented as a single scalar value.)""";

          // drake/systems/primitives/sine.h:81
          const char* doc_2 =
R"""(Returns the frequency constant. This method should only be called if
the frequency can be represented as a scalar value, i.e., every
element in the frequency vector is the same. It will abort if the
frequency cannot be represented as a single scalar value.)""";

        } frequency;

        // drake::systems::Sine::frequency_
        struct /* frequency_ */ {

          // drake/systems/primitives/sine.h:115
          const char* doc = R"""()""";

        } frequency_;

        // drake::systems::Sine::frequency_vector
        struct /* frequency_vector */ {

          // drake/systems/primitives/sine-inl.h:114
          const char* doc = R"""(Returns the frequency vector constant.)""";

          // drake/systems/primitives/sine.h:98
          const char* doc_2 = R"""(Returns the frequency vector constant.)""";

        } frequency_vector;

        // drake::systems::Sine::is_const_amplitude_
        struct /* is_const_amplitude_ */ {

          // drake/systems/primitives/sine.h:118
          const char* doc = R"""()""";

        } is_const_amplitude_;

        // drake::systems::Sine::is_const_frequency_
        struct /* is_const_frequency_ */ {

          // drake/systems/primitives/sine.h:119
          const char* doc = R"""()""";

        } is_const_frequency_;

        // drake::systems::Sine::is_const_phase_
        struct /* is_const_phase_ */ {

          // drake/systems/primitives/sine.h:120
          const char* doc = R"""()""";

        } is_const_phase_;

        // drake::systems::Sine::is_time_based
        struct /* is_time_based */ {

          // drake/systems/primitives/sine-inl.h:104
          const char* doc =
R"""(Returns a boolean indicting whether to use simulation time as the
source of values for the time variable or an external source. Returns
true if the simulation time is used as the source, and returns false
otherwise.)""";

          // drake/systems/primitives/sine.h:92
          const char* doc_2 =
R"""(Returns a boolean indicting whether to use simulation time as the
source of values for the time variable or an external source. Returns
true if the simulation time is used as the source, and returns false
otherwise.)""";

        } is_time_based;

        // drake::systems::Sine::is_time_based_
        struct /* is_time_based_ */ {

          // drake/systems/primitives/sine.h:117
          const char* doc = R"""()""";

        } is_time_based_;

        // drake::systems::Sine::phase
        struct /* phase */ {

          // drake/systems/primitives/sine-inl.h:92
          const char* doc =
R"""(Returns the phase constant. This method should only be called if the
phase can be represented as a scalar value, i.e., every element in the
phase vector is the same. It will abort if the phase cannot be
represented as a single scalar value.)""";

          // drake/systems/primitives/sine.h:87
          const char* doc_2 =
R"""(Returns the phase constant. This method should only be called if the
phase can be represented as a scalar value, i.e., every element in the
phase vector is the same. It will abort if the phase cannot be
represented as a single scalar value.)""";

        } phase;

        // drake::systems::Sine::phase_
        struct /* phase_ */ {

          // drake/systems/primitives/sine.h:116
          const char* doc = R"""()""";

        } phase_;

        // drake::systems::Sine::phase_vector
        struct /* phase_vector */ {

          // drake/systems/primitives/sine-inl.h:119
          const char* doc = R"""(Returns the phase vector constant.)""";

          // drake/systems/primitives/sine.h:101
          const char* doc_2 = R"""(Returns the phase vector constant.)""";

        } phase_vector;

        // drake::systems::Sine::second_derivative_output_port_index_
        struct /* second_derivative_output_port_index_ */ {

          // drake/systems/primitives/sine.h:124
          const char* doc = R"""()""";

        } second_derivative_output_port_index_;

        // drake::systems::Sine::value_output_port_index_
        struct /* value_output_port_index_ */ {

          // drake/systems/primitives/sine.h:122
          const char* doc = R"""()""";

        } value_output_port_index_;

      } Sine;

      // drake::systems::SingleOutputVectorSource
      struct /* SingleOutputVectorSource */ {

        // drake/systems/framework/single_output_vector_source.h:24
        const char* doc =
R"""(A base class that specializes LeafSystem for use with no input ports,
and only a single, vector output port. Subclasses should override the
protected method

```
void DoCalcOutput(const Context<T>&, Eigen::VectorBlock<VectorX<T>>*) const;
```

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::SingleOutputVectorSource::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/framework/single_output_vector_source.h:89
          const char* doc =
R"""(Provides a convenience method for SingleOutputVectorSource subclasses.
This method performs the same logical operation as
System::DoCalcOutput but provides the single output's VectorBlock
instead. Subclasses should override this method, and not the base
class method (which is `final`).)""";

        } DoCalcVectorOutput;

        // drake::systems::SingleOutputVectorSource::SingleOutputVectorSource<T>
        struct /* ctor */ {

          // drake/systems/framework/single_output_vector_source.h:26
          const char* doc = R"""()""";

          // drake/systems/framework/single_output_vector_source.h:26
          const char* doc_2 = R"""()""";

          // drake/systems/framework/single_output_vector_source.h:31
          const char* doc_3 =
R"""(Deleted default constructor. Child classes must either supply the
vector size to the single-argument constructor of `int`, or supply a
model vector to the single-argument constructor of `const
BasicVector<T>&`.)""";

          // drake/systems/framework/single_output_vector_source.h:49
          const char* doc_4 =
R"""(Creates a source with the given sole output port configuration.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion. Use a
    different constructor overload if such conversion is desired.)""";

          // drake/systems/framework/single_output_vector_source.h:57
          const char* doc_5 =
R"""(Creates a source with output type and dimension of the
``model_vector``.

Note:
    Objects created using this constructor overload do not support
    system scalar conversion. See system_scalar_conversion. Use a
    different constructor overload if such conversion is desired.)""";

          // drake/systems/framework/single_output_vector_source.h:67
          const char* doc_6 =
R"""(Creates a source with the given sole output port configuration.

Note:
    objects created using this constructor may support system scalar
    conversion. See system_scalar_conversion.

Parameter ``converter``:
    is per LeafSystem::LeafSystem constructor documentation; see that
    function documentation for details.)""";

          // drake/systems/framework/single_output_vector_source.h:77
          const char* doc_7 =
R"""(Creates a source with output type and dimension of the
``model_vector``.

Note:
    objects created using this constructor may support system scalar
    conversion. See system_scalar_conversion.

Parameter ``converter``:
    is per LeafSystem::LeafSystem constructor documentation; see that
    function documentation for details.)""";

        } ctor;

        // drake::systems::SingleOutputVectorSource::get_output_port
        struct /* get_output_port */ {

          // drake/systems/framework/single_output_vector_source.h:36
          const char* doc = R"""(Returns the sole output port.)""";

          // drake/systems/framework/single_output_vector_source.h:41
          const char* doc_2 = R"""()""";

        } get_output_port;

      } SingleOutputVectorSource;

      // drake::systems::State
      struct /* State */ {

        // drake/systems/framework/state.h:27
        const char* doc =
R"""(State is a container for all the data comprising the complete state of
a particular System at a particular moment. Any field in State may be
empty if it is not applicable to the System in question. A System may
not maintain state in any place other than a State object.

A State `x` contains three types of state variables: - ContinuousState
`xc` - DiscreteState `xd` - AbstractState `xa`

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::State::CopyFrom
        struct /* CopyFrom */ {

          // drake/systems/framework/state.h:111
          const char* doc =
R"""(Copies the values from another State of the same scalar type into this
State.)""";

        } CopyFrom;

        // drake::systems::State::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/state.h:119
          const char* doc =
R"""(Initializes this state (regardless of scalar type) from a
State<double>. All scalar types in Drake must support initialization
from doubles.)""";

        } SetFrom;

        // drake::systems::State::State<T>
        struct /* ctor */ {

          // drake/systems/framework/state.h:30
          const char* doc = R"""()""";

          // drake/systems/framework/state.h:30
          const char* doc_2 = R"""()""";

          // drake/systems/framework/state.h:32
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::State::get_abstract_state
        struct /* get_abstract_state */ {

          // drake/systems/framework/state.h:83
          const char* doc = R"""()""";

          // drake/systems/framework/state.h:96
          const char* doc_2 =
R"""(Returns a const pointer to the abstract component of the state at
``index``. Asserts if ``index`` doesn't exist.)""";

        } get_abstract_state;

        // drake::systems::State::get_continuous_state
        struct /* get_continuous_state */ {

          // drake/systems/framework/state.h:43
          const char* doc = R"""()""";

        } get_continuous_state;

        // drake::systems::State::get_discrete_state
        struct /* get_discrete_state */ {

          // drake/systems/framework/state.h:58
          const char* doc = R"""()""";

          // drake/systems/framework/state.h:68
          const char* doc_2 = R"""()""";

        } get_discrete_state;

        // drake::systems::State::get_mutable_abstract_state
        struct /* get_mutable_abstract_state */ {

          // drake/systems/framework/state.h:88
          const char* doc = R"""()""";

          // drake/systems/framework/state.h:104
          const char* doc_2 =
R"""(Returns a mutable pointer to element ``index`` of the abstract state.
Asserts if ``index`` doesn't exist.)""";

        } get_mutable_abstract_state;

        // drake::systems::State::get_mutable_continuous_state
        struct /* get_mutable_continuous_state */ {

          // drake/systems/framework/state.h:48
          const char* doc = R"""()""";

        } get_mutable_continuous_state;

        // drake::systems::State::get_mutable_discrete_state
        struct /* get_mutable_discrete_state */ {

          // drake/systems/framework/state.h:63
          const char* doc = R"""()""";

          // drake/systems/framework/state.h:73
          const char* doc_2 = R"""()""";

        } get_mutable_discrete_state;

        // drake::systems::State::set_abstract_state
        struct /* set_abstract_state */ {

          // drake/systems/framework/state.h:78
          const char* doc = R"""()""";

        } set_abstract_state;

        // drake::systems::State::set_continuous_state
        struct /* set_continuous_state */ {

          // drake/systems/framework/state.h:38
          const char* doc = R"""()""";

        } set_continuous_state;

        // drake::systems::State::set_discrete_state
        struct /* set_discrete_state */ {

          // drake/systems/framework/state.h:53
          const char* doc = R"""()""";

        } set_discrete_state;

      } State;

      // drake::systems::StepInfo
      struct /* StepInfo */ {

        // drake/systems/framework/context.h:21
        const char* doc =
R"""(Contains information about the independent variable including time and
step number.)""";

        // drake::systems::StepInfo::time_sec
        struct /* time_sec */ {

          // drake/systems/framework/context.h:25
          const char* doc =
R"""(The time, in seconds. For typical T implementations based on doubles,
time resolution will gradually degrade as time increases.)""";

        } time_sec;

      } StepInfo;

      // drake::systems::StepwiseDenseOutput
      struct /* StepwiseDenseOutput */ {

        // drake/systems/analysis/stepwise_dense_output.h:25
        const char* doc =
R"""(A DenseOutput class interface extension, geared towards step-wise
construction procedures. Outputs of this kind are to be built
incrementally by means of discrete updates that extend its domain.
Nature of an update remains implementation specific.

To allow for update rectification (i.e. drop and replacement), in case
it fails to meet certain criteria (e.g. not within tolerances),
construction can be deferred to a consolidation step. In between
consolidations, updates can be rolled back (i.e. discarded) one by one
on a last-input-first-output basis. Implementations are thus
encouraged to keep recent updates in a light weight form, deferring
heavier computations and construction of a better suited
representation for evaluation. As such, evaluation is bound to succeed
only after consolidation.

Template parameter ``T``:
    A valid Eigen scalar type.)""";

        // drake::systems::StepwiseDenseOutput::Consolidate
        struct /* Consolidate */ {

          // drake/systems/analysis/stepwise_dense_output.h:51
          const char* doc =
R"""(Consolidates latest updates.

All updates since last call or construction are put into a form that
is suitable for evaluation.

Remark:
    s This process is irreversible. @pre Updates have taken place
    since instantiation or last consolidation. @post The extents
    covered by updates since instantiation or last consolidation can
    be evaluated (via Evaluate()). @post Time extents covered by
    updates can be evaluated (via start_time()/end_time()).

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } Consolidate;

        // drake::systems::StepwiseDenseOutput::Rollback
        struct /* Rollback */ {

          // drake/systems/analysis/stepwise_dense_output.h:36
          const char* doc =
R"""(Rolls back (drops) the last update.

Remark:
    s This process is irreversible. @pre Updates have taken place
    since instantiation or last consolidation (via Consolidate()).

Throws:
    s std::logic_error if any of the preconditions is not met.)""";

        } Rollback;

        // drake::systems::StepwiseDenseOutput::StepwiseDenseOutput<T>
        struct /* ctor */ {

          // drake/systems/analysis/stepwise_dense_output.h:27
          const char* doc = R"""()""";

          // drake/systems/analysis/stepwise_dense_output.h:27
          const char* doc_2 = R"""()""";

          // drake/systems/analysis/stepwise_dense_output.h:54
          const char* doc_3 = R"""()""";

        } ctor;

      } StepwiseDenseOutput;

      // drake::systems::SubsystemIndexTag
      struct /* SubsystemIndexTag */ {

        // drake/systems/framework/framework_common.h:37
        const char* doc = R"""()""";

      } SubsystemIndexTag;

      // drake::systems::Subvector
      struct /* Subvector */ {

        // drake/systems/framework/subvector.h:20
        const char* doc =
R"""(Subvector is a concrete class template that implements VectorBase by
providing a sliced view of a VectorBase.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::Subvector::GetAtIndex
        struct /* GetAtIndex */ {

          // drake/systems/framework/subvector.h:48
          const char* doc = R"""()""";

          // drake/systems/framework/subvector.h:53
          const char* doc_2 = R"""()""";

        } GetAtIndex;

        // drake::systems::Subvector::Subvector<T>
        struct /* ctor */ {

          // drake/systems/framework/subvector.h:23
          const char* doc = R"""()""";

          // drake/systems/framework/subvector.h:23
          const char* doc_2 = R"""()""";

          // drake/systems/framework/subvector.h:29
          const char* doc_3 =
R"""(Constructs a subvector of vector that consists of num_elements
starting at first_element.

Parameter ``vector``:
    The vector to slice. Must not be nullptr. Must remain valid for
    the lifetime of this object.)""";

          // drake/systems/framework/subvector.h:44
          const char* doc_4 =
R"""(Constructs an empty subvector.

Parameter ``vector``:
    The vector to slice. Must not be nullptr. Must remain valid for
    the lifetime of this object.)""";

        } ctor;

        // drake::systems::Subvector::size
        struct /* size */ {

          // drake/systems/framework/subvector.h:46
          const char* doc = R"""()""";

        } size;

      } Subvector;

      // drake::systems::Supervector
      struct /* Supervector */ {

        // drake/systems/framework/supervector.h:23
        const char* doc =
R"""(Supervector is a concrete class template that implements VectorBase by
concatenating multiple VectorBases, which it does not own.

Template parameter ``T``:
    A mathematical type compatible with Eigen's Scalar.)""";

        // drake::systems::Supervector::GetAtIndex
        struct /* GetAtIndex */ {

          // drake/systems/framework/supervector.h:43
          const char* doc = R"""()""";

          // drake/systems/framework/supervector.h:48
          const char* doc_2 = R"""()""";

        } GetAtIndex;

        // drake::systems::Supervector::Supervector<T>
        struct /* ctor */ {

          // drake/systems/framework/supervector.h:26
          const char* doc = R"""()""";

          // drake/systems/framework/supervector.h:26
          const char* doc_2 = R"""()""";

          // drake/systems/framework/supervector.h:30
          const char* doc_3 =
R"""(Constructs a supervector consisting of all the vectors in subvectors,
which must live at least as long as this supervector.)""";

        } ctor;

        // drake::systems::Supervector::size
        struct /* size */ {

          // drake/systems/framework/supervector.h:39
          const char* doc = R"""()""";

        } size;

      } Supervector;

      // drake::systems::System
      struct /* System */ {

        // drake/systems/framework/input_port.h:15
        const char* doc =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/output_port.h:29
        const char* doc_2 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/system.h:80
        const char* doc_3 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/system_output.h:17
        const char* doc_4 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/system_scalar_converter.h:21
        const char* doc_5 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/system_type_tag.h:8
        const char* doc_6 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake/systems/framework/witness_function.h:16
        const char* doc_7 =
R"""(Base class for all System functionality that is dependent on the
templatized scalar type T for input, state, parameters, and outputs.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::System::AddConstraint
        struct /* AddConstraint */ {

          // drake/systems/framework/system.h:1675
          const char* doc =
R"""(Adds an already-created constraint to the list of constraints for this
System. Ownership of the SystemConstraint is transferred to this
system.)""";

        } AddConstraint;

        // drake::systems::System::AddTriggeredWitnessFunctionToCompositeEventCollection
        struct /* AddTriggeredWitnessFunctionToCompositeEventCollection */ {

          // drake/systems/framework/system.h:1439
          const char* doc =
R"""(Add `event` to `events` due to a witness function triggering. `events`
should be allocated with this system's
AllocateCompositeEventCollection. Neither `event` nor `events` can be
nullptr. Additionally, `event` must contain event data
(event->get_event_data() must not be nullptr) and the type of that
data must be WitnessTriggeredEventData.)""";

        } AddTriggeredWitnessFunctionToCompositeEventCollection;

        // drake::systems::System::AllocateCompositeEventCollection
        struct /* AllocateCompositeEventCollection */ {

          // drake/systems/framework/system.h:105
          const char* doc =
R"""(Allocates a CompositeEventCollection for this system. The allocated
instance is used for registering events; for example, Simulator passes
this object to System::CalcNextUpdateTime() to allow the system to
register upcoming events.)""";

        } AllocateCompositeEventCollection;

        // drake::systems::System::AllocateContext
        struct /* AllocateContext */ {

          // drake/systems/framework/system.h:95
          const char* doc =
R"""(Returns a Context<T> suitable for use with this System<T>.)""";

        } AllocateContext;

        // drake::systems::System::AllocateDiscreteVariables
        struct /* AllocateDiscreteVariables */ {

          // drake/systems/framework/system.h:171
          const char* doc =
R"""(Returns a DiscreteState of the same dimensions as the discrete_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to Update. By default, allocates nothing.
Systems with discrete state variables should override.)""";

        } AllocateDiscreteVariables;

        // drake::systems::System::AllocateFixedInputs
        struct /* AllocateFixedInputs */ {

          // drake/systems/framework/system.h:276
          const char* doc =
R"""(For each input port, allocates a fixed input of the concrete type that
this System requires, and binds it to the port, disconnecting any
prior input. Does not assign any values to the fixed inputs.)""";

        } AllocateFixedInputs;

        // drake::systems::System::AllocateForcedDiscreteUpdateEventCollection
        struct /* AllocateForcedDiscreteUpdateEventCollection */ {

          // drake/systems/framework/system.h:1058
          const char* doc = R"""()""";

        } AllocateForcedDiscreteUpdateEventCollection;

        // drake::systems::System::AllocateForcedPublishEventCollection
        struct /* AllocateForcedPublishEventCollection */ {

          // drake/systems/framework/system.h:1055
          const char* doc = R"""()""";

        } AllocateForcedPublishEventCollection;

        // drake::systems::System::AllocateForcedUnrestrictedUpdateEventCollection
        struct /* AllocateForcedUnrestrictedUpdateEventCollection */ {

          // drake/systems/framework/system.h:1061
          const char* doc = R"""()""";

        } AllocateForcedUnrestrictedUpdateEventCollection;

        // drake::systems::System::AllocateInputAbstract
        struct /* AllocateInputAbstract */ {

          // drake/systems/framework/system.h:125
          const char* doc =
R"""(Given an input port, allocates the abstract storage. Subclasses with a
abstract input ports must override the NVI implementation of this
function, DoAllocateInputAbstract, to return an appropriate
AbstractValue. The ``input_port`` must match a port declared via
DeclareInputPort.)""";

        } AllocateInputAbstract;

        // drake::systems::System::AllocateInputVector
        struct /* AllocateInputVector */ {

          // drake/systems/framework/system.h:112
          const char* doc =
R"""(Given an input port, allocates the vector storage. The default
implementation in this class allocates a BasicVector. Subclasses must
override the NVI implementation of this function,
DoAllocateInputVector, to return input vector types other than
BasicVector. The ``input_port`` must match a port declared via
DeclareInputPort.)""";

        } AllocateInputVector;

        // drake::systems::System::AllocateOutput
        struct /* AllocateOutput */ {

          // drake/systems/framework/system.h:138
          const char* doc =
R"""(Returns a container that can hold the values of all of this System's
output ports. It is sized with the number of output ports and uses
each output port's allocation method to provide an object of the right
type for that port.)""";

          // drake/systems/framework/system.h:151
          const char* doc_2 = R"""()""";

        } AllocateOutput;

        // drake::systems::System::AllocateTimeDerivatives
        struct /* AllocateTimeDerivatives */ {

          // drake/systems/framework/system.h:162
          const char* doc =
R"""(Returns a ContinuousState of the same size as the continuous_state
allocated in CreateDefaultContext. The simulator will provide this
state as the output argument to EvalTimeDerivatives.

By default, allocates no derivatives. Systems with continuous state
variables should override.)""";

        } AllocateTimeDerivatives;

        // drake::systems::System::CalcConservativePower
        struct /* CalcConservativePower */ {

          // drake/systems/framework/system.h:896
          const char* doc =
R"""(Calculates and returns the conservative power represented by the
current contents of the given `context`. Prefer
EvalConservativePower() to avoid unnecessary recalculation.

See also:
    EvalConservativePower() for more information.)""";

        } CalcConservativePower;

        // drake::systems::System::CalcConstraintErrorNorm
        struct /* CalcConstraintErrorNorm */ {

          // drake/systems/framework/system.h:652
          const char* doc =
R"""(Computes the norm on constraint error (used as a metric for comparing
errors between the outputs of algebraic equations applied to two
different state variable instances). This norm need be neither
continuous nor differentiable.

Throws:
    s std::logic_error if the dimension of ``err`` is not equivalent
    to the output of get_num_constraint_equations().)""";

        } CalcConstraintErrorNorm;

        // drake::systems::System::CalcDiscreteVariableUpdates
        struct /* CalcDiscreteVariableUpdates */ {

          // drake/systems/framework/system.h:697
          const char* doc =
R"""(This method is the public entry point for dispatching all discrete
variable update event handlers. Using all the discrete update handlers
in ``events``, the method calculates the update `xd(n+1)` to discrete
variables `xd(n)` in ``context`` and outputs the results to
``discrete_state``. See documentation for
DispatchDiscreteVariableUpdateHandler() for more details.)""";

          // drake/systems/framework/system.h:710
          const char* doc_2 =
R"""(This method forces a discrete update on the system given a
``context``, and the updated discrete state is stored in
``discrete_state``. The discrete update event will have a trigger type
of kForced, with no attribute or custom callback.)""";

        } CalcDiscreteVariableUpdates;

        // drake::systems::System::CalcKineticEnergy
        struct /* CalcKineticEnergy */ {

          // drake/systems/framework/system.h:886
          const char* doc =
R"""(Calculates and returns the kinetic energy represented by the current
configuration and velocity provided in `context`. Prefer
EvalKineticEnergy() to avoid unnecessary recalculation.

See also:
    EvalKineticEnergy() for more information.)""";

        } CalcKineticEnergy;

        // drake::systems::System::CalcNextUpdateTime
        struct /* CalcNextUpdateTime */ {

          // drake/systems/framework/system.h:771
          const char* doc =
R"""(This method is called by a Simulator during its calculation of the
size of the next continuous step to attempt. The System returns the
next time at which some discrete action must be taken, and records
what those actions ought to be in ``events``. Upon reaching that time,
the simulator will merge ``events`` with the other
CompositeEventCollection instances scheduled through mechanisms (e.g.
GetPerStepEvents()), and the merged CompositeEventCollection will be
passed to all event handling mechanisms.

``events`` cannot be null. ``events`` will be cleared on entry.)""";

        } CalcNextUpdateTime;

        // drake::systems::System::CalcNonConservativePower
        struct /* CalcNonConservativePower */ {

          // drake/systems/framework/system.h:906
          const char* doc =
R"""(Calculates and returns the non-conservative power represented by the
current contents of the given `context`. Prefer
EvalNonConservativePower() to avoid unnecessary recalculation.

See also:
    EvalNonConservativePower() for more information.)""";

        } CalcNonConservativePower;

        // drake::systems::System::CalcOutput
        struct /* CalcOutput */ {

          // drake/systems/framework/system.h:858
          const char* doc =
R"""(Utility method that computes for _every_ output port i the value y(i)
that should result from the current contents of the given Context.
Note that individual output port values can be calculated using
`get_output_port(i).Calc()`; this method invokes that for each output
port in index order. The result may depend on time and the current
values of input ports, parameters, and state variables. The result is
written to `outputs` which must already have been allocated to have
the right number of entries of the right types.)""";

        } CalcOutput;

        // drake::systems::System::CalcPotentialEnergy
        struct /* CalcPotentialEnergy */ {

          // drake/systems/framework/system.h:876
          const char* doc =
R"""(Calculates and returns the potential energy represented by the current
configuration provided in `context`. Prefer EvalPotentialEnergy() to
avoid unnecessary recalculation.

See also:
    EvalPotentialEnergy() for more information.)""";

        } CalcPotentialEnergy;

        // drake::systems::System::CalcTimeDerivatives
        struct /* CalcTimeDerivatives */ {

          // drake/systems/framework/system.h:684
          const char* doc =
R"""(Calculates the time derivatives `xcdot` of the continuous state `xc`
into a given output argument. Prefer EvalTimeDerivatives() instead to
avoid unnecessary recomputation.

See also:
    EvalTimeDerivatives() for more information.

Parameter ``context``:
    The Context whose contents will be used to evaluate the
    derivatives.

Parameter ``derivatives``:
    The time derivatives `xcdot`. Must be the same size as the
    continuous state vector in `context`.)""";

        } CalcTimeDerivatives;

        // drake::systems::System::CalcUnrestrictedUpdate
        struct /* CalcUnrestrictedUpdate */ {

          // drake/systems/framework/system.h:725
          const char* doc =
R"""(This method is the public entry point for dispatching all unrestricted
update event handlers. Using all the unrestricted update handers in
``events``, it updates *any* state variables in the ``context``, and
outputs the results to ``state``. It does not allow the dimensionality
of the state variables to change. See the documentation for
DispatchUnrestrictedUpdateHandler() for more details.

Throws:
    s std::logic_error if the dimensionality of the state variables
    changes in the callback.)""";

          // drake/systems/framework/system.h:756
          const char* doc_2 =
R"""(This method forces an unrestricted update on the system given a
``context``, and the updated state is stored in ``state``. The
unrestricted update event will have a trigger type of kForced, with no
additional data, attribute or custom callback.

See also:
    CalcUnrestrictedUpdate(const Context<T>&, const
    EventCollection<UnrestrictedUpdateEvent<T>>*, State<T>* state) for
    more information.)""";

        } CalcUnrestrictedUpdate;

        // drake::systems::System::CalcVelocityChangeFromConstraintImpulses
        struct /* CalcVelocityChangeFromConstraintImpulses */ {

          // drake/systems/framework/system.h:635
          const char* doc =
R"""(Computes the change in velocity from applying the given constraint
forces to the system at the given context.

Parameter ``context``:
    the current system state, provision of which also yields the
    ability of the constraints to be dependent upon the current system
    state (as might be the case with a piecewise differential
    algebraic equation).

Parameter ``J``:
    a m × n constraint Jacobian matrix of the `m` constraint equations
    `g()` differentiated with respect to the `n` configuration
    variables `q` (i.e., `J` should be `∂g/∂q`). If the time
    derivatives of the generalized coordinates of the system are not
    identical to the generalized velocity (in general they need not
    be, e.g., if generalized coordinates use unit unit quaternions to
    represent 3D orientation), `J` should instead be defined as
    `∂g/∂q⋅N`, where `N ≡ ∂q/∂ꝗ` is the Jacobian matrix (dependent on
    `q`) of the generalized coordinates with respect to the quasi-
    coordinates (ꝗ, pronounced "qbar", where dꝗ/dt are the generalized
    velocities).

Parameter ``lambda``:
    the vector of constraint forces (of same dimension as the number
    of rows in the Jacobian matrix, ``J``)

Returns:
    a `n` dimensional vector, where `n` is the dimension of the quasi-
    coordinates.)""";

        } CalcVelocityChangeFromConstraintImpulses;

        // drake::systems::System::CalcWitnessValue
        struct /* CalcWitnessValue */ {

          // drake/systems/framework/system.h:1428
          const char* doc =
R"""(Evaluates a witness function at the given context.)""";

        } CalcWitnessValue;

        // drake::systems::System::CheckSystemConstraintsSatisfied
        struct /* CheckSystemConstraintsSatisfied */ {

          // drake/systems/framework/system.h:1123
          const char* doc =
R"""(Returns true if ``context`` satisfies all of the registered
SystemConstraints with tolerance ``tol``.

See also:
    SystemConstraint::CheckSatisfied.)""";

        } CheckSystemConstraintsSatisfied;

        // drake::systems::System::CheckValidContextT
        struct /* CheckValidContextT */ {

          // drake/systems/framework/system.h:1170
          const char* doc =
R"""(Checks that ``context`` is consistent for this System template.
Supports any scalar type, but expects T by default.

Throws:
    exception unless `context` is valid for this system.

Template parameter ``T1``:
    the scalar type of the Context to check.)""";

        } CheckValidContextT;

        // drake::systems::System::CheckValidOutput
        struct /* CheckValidOutput */ {

          // drake/systems/framework/system.h:1144
          const char* doc =
R"""(Checks that ``output`` is consistent with the number and size of
output ports declared by the system.

Throws:
    exception unless `output` is non-null and valid for this system.)""";

        } CheckValidOutput;

        // drake::systems::System::CopyContinuousStateVector
        struct /* CopyContinuousStateVector */ {

          // drake/systems/framework/system.h:1199
          const char* doc =
R"""(Returns a copy of the continuous state vector `xc` into an Eigen
vector.)""";

        } CopyContinuousStateVector;

        // drake::systems::System::CreateDefaultContext
        struct /* CreateDefaultContext */ {

          // drake/systems/framework/system.h:177
          const char* doc =
R"""(This convenience method allocates a context using AllocateContext()
and sets its default values using SetDefaultContext().)""";

        } CreateDefaultContext;

        // drake::systems::System::DeclareAbstractInputPort
        struct /* DeclareAbstractInputPort */ {

          // drake/systems/framework/system.h:1667
          const char* doc =
R"""(Adds an abstract-valued port to the input topology.

Returns:
    the declared port.)""";

        } DeclareAbstractInputPort;

        // drake::systems::System::DeclareInputPort
        struct /* DeclareInputPort */ {

          // drake/systems/framework/system.h:1642
          const char* doc =
R"""(Adds a port with the specified ``type`` and ``size`` to the input
topology.

If ``name`` is provided, input port names must be unique for this
system (passing in a duplicate name will throw std::logic_error). If
``name`` is not provided (or the empty string), then a default value
of e.g. "u2", where 2 is the input number will be provided.

If the port is intended to model a random noise or disturbance input,
``random_type`` can (optionally) be used to label it as such; doing so
enables algorithms for design and analysis (e.g. state estimation) to
reason explicitly about randomness at the system level. All random
input ports are assumed to be statistically independent.

Throws:
    s std::logic_error.

Returns:
    the declared port.)""";

        } DeclareInputPort;

        // drake::systems::System::DispatchDiscreteVariableUpdateHandler
        struct /* DispatchDiscreteVariableUpdateHandler */ {

          // drake/systems/framework/system.h:1537
          const char* doc =
R"""(This function dispatches all discrete update events to the appropriate
handlers. ``discrete_state`` cannot be null.)""";

        } DispatchDiscreteVariableUpdateHandler;

        // drake::systems::System::DispatchPublishHandler
        struct /* DispatchPublishHandler */ {

          // drake/systems/framework/system.h:1531
          const char* doc =
R"""(This function dispatches all publish events to the appropriate
handlers.)""";

        } DispatchPublishHandler;

        // drake::systems::System::DispatchUnrestrictedUpdateHandler
        struct /* DispatchUnrestrictedUpdateHandler */ {

          // drake/systems/framework/system.h:1544
          const char* doc =
R"""(This function dispatches all unrestricted update events to the
appropriate handlers. ``state`` cannot be null.)""";

        } DispatchUnrestrictedUpdateHandler;

        // drake::systems::System::DoAllocateInputAbstract
        struct /* DoAllocateInputAbstract */ {

          // drake/systems/framework/system.h:1695
          const char* doc =
R"""(Allocates an abstract input of the leaf type that the System requires
on the port specified by ``input_port``. Caller owns the returned
memory.)""";

        } DoAllocateInputAbstract;

        // drake::systems::System::DoAllocateInputVector
        struct /* DoAllocateInputVector */ {

          // drake/systems/framework/system.h:1690
          const char* doc =
R"""(Allocates an input vector of the leaf type that the System requires on
the port specified by ``input_port``. Caller owns the returned memory.)""";

        } DoAllocateInputVector;

        // drake::systems::System::DoCalcConservativePower
        struct /* DoCalcConservativePower */ {

          // drake/systems/framework/system.h:1833
          const char* doc =
R"""(Override this method to return the rate Pc at which mechanical energy
is being converted _from_ potential energy _to_ kinetic energy by this
system in the given Context. By default, returns zero. Physical
systems should override. You may assume that `context` has already
been validated before it is passed to you here.

See EvalConservativePower() for details on what you must compute here.
In particular, this quantity must be _positive_ when potential energy
is _decreasing_, and your conservative power method must _not_ depend
explicitly on time or any input port values.)""";

        } DoCalcConservativePower;

        // drake::systems::System::DoCalcConstraintErrorNorm
        struct /* DoCalcConstraintErrorNorm */ {

          // drake/systems/framework/system.h:1990
          const char* doc =
R"""(Computes the norm of the constraint error. This default implementation
computes a Euclidean norm of the error. Derived classes can override
this function, which is called by CalcConstraintErrorNorm(). This norm
need be neither continuous nor differentiable.

See also:
    CalcConstraintErrorNorm() for parameter documentation.)""";

        } DoCalcConstraintErrorNorm;

        // drake::systems::System::DoCalcKineticEnergy
        struct /* DoCalcKineticEnergy */ {

          // drake/systems/framework/system.h:1818
          const char* doc =
R"""(Override this method for physical systems to calculate the kinetic
energy KE currently present in the motion provided in the given
Context. The default implementation returns 0 which is correct for
non-physical systems. You may assume that `context` has already been
validated before it is passed to you here.

See EvalKineticEnergy() for details on what you must compute here. In
particular, your kinetic energy method must _not_ depend explicitly on
time or any input port values.)""";

        } DoCalcKineticEnergy;

        // drake::systems::System::DoCalcNextUpdateTime
        struct /* DoCalcNextUpdateTime */ {

          // drake/systems/framework/system.h:1751
          const char* doc =
R"""(Computes the next time at which this System must perform a discrete
action.

Override this method if your System has any discrete actions which
must interrupt the continuous simulation. This method is called only
from the public non-virtual CalcNextUpdateTime() which will already
have error-checked the parameters so you don't have to. You may assume
that ``context`` has already been validated and ``events`` pointer is
not null.

The default implementation returns with the next sample time being
Infinity and no events added to ``events``.)""";

        } DoCalcNextUpdateTime;

        // drake::systems::System::DoCalcNonConservativePower
        struct /* DoCalcNonConservativePower */ {

          // drake/systems/framework/system.h:1848
          const char* doc =
R"""(Override this method to return the rate Pnc at which work W is done on
the system by non-conservative forces. By default, returns zero.
Physical systems should override. You may assume that `context` has
already been validated before it is passed to you here.

See EvalNonConservativePower() for details on what you must compute
here. In particular, this quantity must be _negative_ if the non-
conservative forces are _dissipative_, positive otherwise. Your non-
conservative power method can depend on anything you find in the given
Context, including time and input ports.)""";

        } DoCalcNonConservativePower;

        // drake::systems::System::DoCalcPotentialEnergy
        struct /* DoCalcPotentialEnergy */ {

          // drake/systems/framework/system.h:1804
          const char* doc =
R"""(Override this method for physical systems to calculate the potential
energy PE currently stored in the configuration provided in the given
Context. The default implementation returns 0 which is correct for
non-physical systems. You may assume that `context` has already been
validated before it is passed to you here.

See EvalPotentialEnergy() for details on what you must compute here.
In particular, your potential energy method must _not_ depend
explicitly on time, velocities, or any input port values.)""";

        } DoCalcPotentialEnergy;

        // drake::systems::System::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/systems/framework/system.h:1731
          const char* doc =
R"""(Override this if you have any continuous state variables `xc` in your
concrete System to calculate their time derivatives. The `derivatives`
vector will correspond elementwise with the state vector
`Context.state.continuous_state.get_state()`. Thus, if the state in
the Context has second-order structure `xc=[q,v,z]`, that same
structure applies to the derivatives.

This method is called only from the public non-virtual
CalcTimeDerivatives() which will already have error-checked the
parameters so you don't have to. In particular, implementations may
assume that the given Context is valid for this System; that the
`derivatives` pointer is non-null, and that the referenced object has
the same constituent structure as was produced by
AllocateTimeDerivatives().

The default implementation does nothing if the `derivatives` vector is
size zero and aborts otherwise.)""";

        } DoCalcTimeDerivatives;

        // drake::systems::System::DoCalcVelocityChangeFromConstraintImpulses
        struct /* DoCalcVelocityChangeFromConstraintImpulses */ {

          // drake/systems/framework/system.h:1976
          const char* doc =
R"""(Computes the change in velocity from applying the given constraint
forces to the system at the given context. Derived classes can
override this function, which is called by
CalcVelocityChangeFromConstraintImpulses().

Returns:
    the zero vector of dimension of the dimension of the quasi-
    coordinates, by default.

See also:
    CalcVelocityChangeFromConstraintImpulses() for parameter
    documentation.)""";

        } DoCalcVelocityChangeFromConstraintImpulses;

        // drake::systems::System::DoCalcWitnessValue
        struct /* DoCalcWitnessValue */ {

          // drake/systems/framework/system.h:1483
          const char* doc =
R"""(Derived classes will implement this method to evaluate a witness
function at the given context.)""";

        } DoCalcWitnessValue;

        // drake::systems::System::DoEvalConstraintEquations
        struct /* DoEvalConstraintEquations */ {

          // drake/systems/framework/system.h:1948
          const char* doc =
R"""(Evaluates the constraint equations for the system at the generalized
coordinates and generalized velocity specified by the context. The
context allows the set of constraints to be dependent upon the current
system state (as might be the case with a piecewise differential
algebraic equation). The default implementation of this function
returns a zero-dimensional vector. Derived classes can override this
function, which is called by EvalConstraintEquations().

See also:
    EvalConstraintEquations() for parameter documentation.

Returns:
    a vector of dimension get_num_constraint_equations(); the zero
    vector indicates that the algebraic constraints are all satisfied.)""";

        } DoEvalConstraintEquations;

        // drake::systems::System::DoEvalConstraintEquationsDot
        struct /* DoEvalConstraintEquationsDot */ {

          // drake/systems/framework/system.h:1963
          const char* doc =
R"""(Computes the time derivative of each constraint equation, evaluated at
the generalized coordinates and generalized velocity specified by the
context. The context allows the set of constraints to be dependent
upon the current system state (as might be the case with a piecewise
differential algebraic equation). The default implementation of this
function returns a zero-dimensional vector. Derived classes can
override this function, which is called by
EvalConstraintEquationsDot().

Returns:
    a vector of dimension get_num_constraint_equations().

See also:
    EvalConstraintEquationsDot() for parameter documentation.)""";

        } DoEvalConstraintEquationsDot;

        // drake::systems::System::DoGetInitializationEvents
        struct /* DoGetInitializationEvents */ {

          // drake/systems/framework/system.h:1789
          const char* doc =
R"""(Implement this method to return any events to be handled at the
simulator's initialization step. ``events`` is cleared in the public
non-virtual GetInitializationEvents(). You may assume that ``context``
has already been validated and that ``events`` is not null. ``events``
can be changed freely by the overriding implementation.

The default implementation returns without changing ``events``.

See also:
    GetInitializationEvents())""";

        } DoGetInitializationEvents;

        // drake::systems::System::DoGetMutableTargetSystemCompositeEventCollection
        struct /* DoGetMutableTargetSystemCompositeEventCollection */ {

          // drake/systems/framework/system.h:1025
          const char* doc = R"""()""";

        } DoGetMutableTargetSystemCompositeEventCollection;

        // drake::systems::System::DoGetMutableTargetSystemContext
        struct /* DoGetMutableTargetSystemContext */ {

          // drake/systems/framework/system.h:983
          const char* doc = R"""()""";

        } DoGetMutableTargetSystemContext;

        // drake::systems::System::DoGetMutableTargetSystemState
        struct /* DoGetMutableTargetSystemState */ {

          // drake/systems/framework/system.h:999
          const char* doc = R"""()""";

        } DoGetMutableTargetSystemState;

        // drake::systems::System::DoGetPerStepEvents
        struct /* DoGetPerStepEvents */ {

          // drake/systems/framework/system.h:1775
          const char* doc =
R"""(Implement this method to return any events to be handled before the
simulator integrates the system's continuous state at each time step.
``events`` is cleared in the public non-virtual GetPerStepEvents()
before that method calls this function. You may assume that
``context`` has already been validated and that ``events`` is not
null. ``events`` can be changed freely by the overriding
implementation.

The default implementation returns without changing ``events``.

See also:
    GetPerStepEvents())""";

        } DoGetPerStepEvents;

        // drake::systems::System::DoGetPeriodicEvents
        struct /* DoGetPeriodicEvents */ {

          // drake/systems/framework/system.h:1764
          const char* doc =
R"""(Implement this method to return all periodic triggered events.

See also:
    GetPeriodicEvents() for a detailed description of the returned
    variable.

Note:
    The default implementation returns an empty map.)""";

        } DoGetPeriodicEvents;

        // drake::systems::System::DoGetTargetSystemCompositeEventCollection
        struct /* DoGetTargetSystemCompositeEventCollection */ {

          // drake/systems/framework/system.h:1035
          const char* doc = R"""()""";

        } DoGetTargetSystemCompositeEventCollection;

        // drake::systems::System::DoGetTargetSystemContext
        struct /* DoGetTargetSystemContext */ {

          // drake/systems/framework/system.h:991
          const char* doc = R"""()""";

        } DoGetTargetSystemContext;

        // drake::systems::System::DoGetTargetSystemContinuousState
        struct /* DoGetTargetSystemContinuousState */ {

          // drake/systems/framework/system.h:1015
          const char* doc =
R"""(Returns ``xc`` if ``target_system`` equals `this`, nullptr otherwise.
Should not be directly called.)""";

        } DoGetTargetSystemContinuousState;

        // drake::systems::System::DoGetTargetSystemState
        struct /* DoGetTargetSystemState */ {

          // drake/systems/framework/system.h:1007
          const char* doc =
R"""(Returns ``state`` if ``target_system`` equals `this`, nullptr
otherwise. Should not be directly called.)""";

        } DoGetTargetSystemState;

        // drake::systems::System::DoGetWitnessFunctions
        struct /* DoGetWitnessFunctions */ {

          // drake/systems/framework/system.h:1492
          const char* doc =
R"""(Derived classes can override this method to provide witness functions
active for the given state. The default implementation does nothing.
On entry to this function, the context will have already been
validated and the vector of witness functions will have been validated
to be both empty and non-null.)""";

        } DoGetWitnessFunctions;

        // drake::systems::System::DoMapQDotToVelocity
        struct /* DoMapQDotToVelocity */ {

          // drake/systems/framework/system.h:1871
          const char* doc =
R"""(Provides the substantive implementation of MapQDotToVelocity().

The default implementation uses the identity mapping, and correctly
does nothing if the System does not have second-order state variables.
It throws std::runtime_error if the `generalized_velocity` and `qdot`
are not the same size, but that is not enough to guarantee that the
default implementation is adequate. Child classes must override this
function if qdot != v (even if they are the same size). This occurs,
for example, if a joint uses roll-pitch-yaw rotation angles for
orientation but angular velocity for rotational rate rather than
rotation angle derivatives.

If you implement this method you are required to use no more than
`O(nq)` time where `nq` is the size of `qdot`, so that the System can
meet the performance guarantee made for the public interface, and you
must also implement DoMapVelocityToQDot(). Implementations may assume
that `qdot` has already been validated to be the same size as `q` in
the given Context, and that `generalized_velocity` is non-null.)""";

        } DoMapQDotToVelocity;

        // drake::systems::System::DoMapVelocityToQDot
        struct /* DoMapVelocityToQDot */ {

          // drake/systems/framework/system.h:1904
          const char* doc =
R"""(Provides the substantive implementation of MapVelocityToQDot().

The default implementation uses the identity mapping, and correctly
does nothing if the System does not have second-order state variables.
It throws std::runtime_error if the `generalized_velocity` (`v`) and
`qdot` are not the same size, but that is not enough to guarantee that
the default implementation is adequate. Child classes must override
this function if `qdot != v` (even if they are the same size). This
occurs, for example, if a joint uses roll-pitch-yaw rotation angles
for orientation but angular velocity for rotational rate rather than
rotation angle derivatives.

If you implement this method you are required to use no more than
`O(nq)` time where `nq` is the size of `qdot`, so that the System can
meet the performance guarantee made for the public interface, and you
must also implement DoMapQDotToVelocity(). Implementations may assume
that `generalized_velocity` has already been validated to be the same
size as `v` in the given Context, and that `qdot` is non-null.)""";

        } DoMapVelocityToQDot;

        // drake::systems::System::EvalConservativePower
        struct /* EvalConservativePower */ {

          // drake/systems/framework/system.h:482
          const char* doc =
R"""(Returns a reference to the cached value of the conservative power
(Pc), evaluating first if necessary using CalcConservativePower().

The returned Pc represents the rate at which mechanical energy is
being converted _from_ potential energy (PE) _to_ kinetic energy (KE)
by this system in the given Context. This quantity will be _positive_
when PE is _decreasing_. By definition here, conservative power may
depend only on quantities that explicitly contribute to PE and KE. See
EvalPotentialEnergy() and EvalKineticEnergy() for details.

Power due to non-conservative forces (e.g. dampers) can contribute to
the rate of change of KE. Therefore this method alone cannot be used
to determine whether KE is increasing or decreasing, only whether the
conservative power is adding or removing kinetic energy.
EvalNonConservativePower() can be used in conjunction with this method
to find the total rate of change of KE.

Non-physical systems where Pc is not meaningful will return Pc = 0.

Parameter ``context``:
    The Context whose contents may be used to evaluate conservative
    power.

Returns ``Pc``:
    The conservative power in watts (W or J/s) represented by the
    contents of the given `context`.

See also:
    CalcConservativePower(), EvalNonConservativePower(),
    EvalPotentialEnergy(), EvalKineticEnergy())""";

        } EvalConservativePower;

        // drake::systems::System::EvalConstraintEquations
        struct /* EvalConstraintEquations */ {

          // drake/systems/framework/system.h:600
          const char* doc =
R"""(Evaluates the constraint equations for the system at the generalized
coordinates and generalized velocity specified by the context. The
context allows the set of constraints to be dependent upon the current
system state (as might be the case with a system modeled using
piecewise differential algebraic equations).

Returns:
    a vector of dimension get_num_constraint_equations(); the zero
    vector indicates that the algebraic constraints are all satisfied.)""";

        } EvalConstraintEquations;

        // drake::systems::System::EvalConstraintEquationsDot
        struct /* EvalConstraintEquationsDot */ {

          // drake/systems/framework/system.h:610
          const char* doc =
R"""(Computes the time derivative of each constraint equation, evaluated at
the generalized coordinates and generalized velocity specified by the
context. The context allows the set of constraints to be dependent
upon the current system state (as might be the case with a system
modeled using piecewise differential algebraic equations).

Returns:
    a vector of dimension get_num_constraint_equations().)""";

        } EvalConstraintEquationsDot;

        // drake::systems::System::EvalEigenVectorInput
        struct /* EvalEigenVectorInput */ {

          // drake/systems/framework/system.h:565
          const char* doc =
R"""(Returns the value of the vector-valued input port with the given
`port_index` as an Eigen vector. Causes the value to become up to date
first if necessary. See EvalAbstractInput() for more information.

@pre `port_index` selects an existing input port of this System. @pre
the port must have been declared to be vector-valued. @pre the port
must be evaluable (connected or fixed).

See also:
    EvalVectorInput())""";

        } EvalEigenVectorInput;

        // drake::systems::System::EvalKineticEnergy
        struct /* EvalKineticEnergy */ {

          // drake/systems/framework/system.h:451
          const char* doc =
R"""(Returns a reference to the cached value of the kinetic energy (KE),
evaluating first if necessary using CalcKineticEnergy().

By definition here, kinetic energy depends only on "configuration" and
"velocity" (e.g. angular and translational velocity) of moving masses
which includes a subset of the state variables, and parameters that
affect configuration, velocities, or mass properties. The calculated
value may also be affected by the accuracy value supplied in the
Context. KE cannot depend explicitly on time (∂KE/∂t = 0) or input
port values (∂KE/∂u = 0).

Non-physical systems where KE is not meaningful will return KE = 0.

Parameter ``context``:
    The Context whose configuration and velocity variables may be used
    to evaluate kinetic energy.

Returns ``KE``:
    The kinetic energy in joules (J) represented by the configuration
    and velocity given in `context`.

See also:
    CalcKineticEnergy())""";

        } EvalKineticEnergy;

        // drake::systems::System::EvalNonConservativePower
        struct /* EvalNonConservativePower */ {

          // drake/systems/framework/system.h:508
          const char* doc =
R"""(Returns a reference to the cached value of the non-conservative power
(Pnc), evaluating first if necessary using CalcNonConservativePower().

The returned Pnc represents the rate at which work W is done on the
system by non-conservative forces. Pnc is _negative_ if the non-
conservative forces are _dissipative_, positive otherwise. Time
integration of Pnc yields work W, and the total mechanical energy `E =
PE + KE − W` should be conserved by any physically-correct model, to
within integration accuracy of W. Power is in watts (J/s). (Watts are
abbreviated W but not to be confused with work!) Any values in the
supplied Context (including time and input ports) may contribute to
the computation of non-conservative power.

Non-physical systems where Pnc is not meaningful will return Pnc = 0.

Parameter ``context``:
    The Context whose contents may be used to evaluate non-
    conservative power.

Returns ``Pnc``:
    The non-conservative power in watts (W or J/s) represented by the
    contents of the given `context`.

See also:
    CalcNonConservativePower(), EvalConservativePower())""";

        } EvalNonConservativePower;

        // drake::systems::System::EvalPotentialEnergy
        struct /* EvalPotentialEnergy */ {

          // drake/systems/framework/system.h:428
          const char* doc =
R"""(Returns a reference to the cached value of the potential energy (PE),
evaluating first if necessary using CalcPotentialEnergy().

By definition here, potential energy depends only on "configuration"
(e.g. orientation and position), which includes a subset of the state
variables, and parameters that affect configuration or conservative
forces (such as lengths and masses). The calculated value may also be
affected by the accuracy value supplied in the Context. PE cannot
depend explicitly on time (∂PE/∂t = 0), velocities (∂PE/∂v = 0), or
input port values (∂PE/∂u = 0).

Non-physical systems where PE is not meaningful will return PE = 0.

Parameter ``context``:
    The Context whose configuration variables may be used to evaluate
    potential energy.

Returns ``PE``:
    The potential energy in joules (J) represented by the
    configuration given in `context`.

See also:
    CalcPotentialEnergy())""";

        } EvalPotentialEnergy;

        // drake::systems::System::EvalTimeDerivatives
        struct /* EvalTimeDerivatives */ {

          // drake/systems/framework/system.h:403
          const char* doc =
R"""(Returns a reference to the cached value of the continuous state
variable time derivatives, evaluating first if necessary using
CalcTimeDerivatives().

This method returns the time derivatives `xcdot` of the continuous
state `xc`. The referenced return object will correspond elementwise
with the continuous state in the given Context. Thus, if the state in
the Context has second-order structure `xc=[q v z]`, that same
structure applies to the derivatives so we will have `xcdot=[qdot vdot
zdot]`.

Parameter ``context``:
    The Context whose time, input port, parameter, state, and accuracy
    values may be used to evaluate the derivatives.

Returns ``xcdot``:
    The time derivatives of `xc` returned as a reference to an object
    of the same type and size as this Context's continuous state.

See also:
    CalcTimeDerivatives())""";

        } EvalTimeDerivatives;

        // drake::systems::System::EvalVectorInput
        struct /* EvalVectorInput */ {

          // drake/systems/framework/system.h:529
          const char* doc =
R"""(Returns the value of the vector-valued input port with the given
`port_index` as a BasicVector or a specific subclass `Vec` derived
from BasicVector. Causes the value to become up to date first if
necessary. See EvalAbstractInput() for more information.

The result is returned as a pointer to the input port's value of type
`Vec<T>` or nullptr if the port is not connected.

@pre `port_index` selects an existing input port of this System. @pre
the port must have been declared to be vector-valued. @pre the port's
value must be of type Vec<T>.

Template parameter ``Vec``:
    The template type of the input vector, which must be a subclass of
    BasicVector.)""";

        } EvalVectorInput;

        // drake::systems::System::FixInputPortsFrom
        struct /* FixInputPortsFrom */ {

          // drake/systems/framework/system.h:1369
          const char* doc =
R"""(Fixes all of the input ports in ``target_context`` to their current
values in ``other_context``, as evaluated by ``other_system``. Throws
an exception unless `other_context` and `target_context` both have the
same shape as this System, and the `other_system`. Ignores
disconnected inputs.)""";

        } FixInputPortsFrom;

        // drake::systems::System::GetDirectFeedthroughs
        struct /* GetDirectFeedthroughs */ {

          // drake/systems/framework/system.h:296
          const char* doc =
R"""(Reports all direct feedthroughs from input ports to output ports. For
a system with m input ports: `I = i₀, i₁, ..., iₘ₋₁`, and n output
ports, `O = o₀, o₁, ..., oₙ₋₁`, the return map will contain pairs (u,
v) such that - 0 ≤ u < m, - 0 ≤ v < n, - and there _might_ be a direct
feedthrough from input iᵤ to each output oᵥ.)""";

        } GetDirectFeedthroughs;

        // drake::systems::System::GetGraphvizFragment
        struct /* GetGraphvizFragment */ {

          // drake/systems/framework/system.h:1223
          const char* doc =
R"""(Appends a Graphviz fragment to the ``dot`` stream. The fragment must
be valid Graphviz when wrapped in a `digraph` or `subgraph` stanza.
Does nothing by default.)""";

        } GetGraphvizFragment;

        // drake::systems::System::GetGraphvizId
        struct /* GetGraphvizId */ {

          // drake/systems/framework/system.h:1243
          const char* doc =
R"""(Returns an opaque integer that uniquely identifies this system in the
Graphviz output.)""";

        } GetGraphvizId;

        // drake::systems::System::GetGraphvizInputPortToken
        struct /* GetGraphvizInputPortToken */ {

          // drake/systems/framework/system.h:1229
          const char* doc =
R"""(Appends a fragment to the ``dot`` stream identifying the graphviz node
representing ``port``. Does nothing by default.)""";

        } GetGraphvizInputPortToken;

        // drake::systems::System::GetGraphvizOutputPortToken
        struct /* GetGraphvizOutputPortToken */ {

          // drake/systems/framework/system.h:1236
          const char* doc =
R"""(Appends a fragment to the ``dot`` stream identifying the graphviz node
representing ``port``. Does nothing by default.)""";

        } GetGraphvizOutputPortToken;

        // drake::systems::System::GetGraphvizString
        struct /* GetGraphvizString */ {

          // drake/systems/framework/system.h:1211
          const char* doc =
R"""(Returns a Graphviz string describing this System. To render the
string, use the Graphviz tool, ``dot``.
http://www.graphviz.org/Documentation/dotguide.pdf)""";

        } GetGraphvizString;

        // drake::systems::System::GetInitializationEvents
        struct /* GetInitializationEvents */ {

          // drake/systems/framework/system.h:808
          const char* doc =
R"""(This method is called by Simulator::Initialize() to gather all update
and publish events that need to be handled at initialization before
the simulator starts integration.

``events`` cannot be null. ``events`` will be cleared on entry.)""";

        } GetInitializationEvents;

        // drake::systems::System::GetMemoryObjectName
        struct /* GetMemoryObjectName */ {

          // drake/systems/framework/system.h:1073
          const char* doc =
R"""(Returns a name for this System based on a stringification of its type
name and memory address. This is intended for use in diagnostic output
and should not be used for behavioral logic, because the
stringification of the type name may produce differing results across
platforms and because the address can vary from run to run.)""";

        } GetMemoryObjectName;

        // drake::systems::System::GetMutableOutputVector
        struct /* GetMutableOutputVector */ {

          // drake/systems/framework/system.h:2005
          const char* doc =
R"""(Returns a mutable Eigen expression for a vector valued output port
with index ``port_index`` in this system. All input ports that
directly depend on this output port will be notified that upstream
data has changed, and may invalidate cache entries as a result.)""";

        } GetMutableOutputVector;

        // drake::systems::System::GetPerStepEvents
        struct /* GetPerStepEvents */ {

          // drake/systems/framework/system.h:795
          const char* doc =
R"""(This method is called by Simulator::Initialize() to gather all update
and publish events that are to be handled in StepTo() at the point
before Simulator integrates continuous state. It is assumed that these
events remain constant throughout the simulation. The "step" here
refers to the major time step taken by the Simulator. During every
simulation step, the simulator will merge ``events`` with the other
CompositeEventCollection instances generated by other types of event
triggering mechanism (e.g., CalcNextUpdateTime()), and the merged
CompositeEventCollection objects will be passed to the appropriate
handlers before Simulator integrates the continuous state.

``events`` cannot be null. ``events`` will be cleared on entry.)""";

        } GetPerStepEvents;

        // drake::systems::System::GetPeriodicEvents
        struct /* GetPeriodicEvents */ {

          // drake/systems/framework/system.h:846
          const char* doc =
R"""(Gets all periodic triggered events for a system. Each periodic
attribute (offset and period, in seconds) is mapped to one or more
update events that are to be triggered at the proper times.)""";

        } GetPeriodicEvents;

        // drake::systems::System::GetUniquePeriodicDiscreteUpdateAttribute
        struct /* GetUniquePeriodicDiscreteUpdateAttribute */ {

          // drake/systems/framework/system.h:825
          const char* doc =
R"""(Gets whether there exists a unique periodic attribute that triggers
one or more discrete update events (and, if so, returns that unique
periodic attribute). Thus, this method can be used (1) as a test to
determine whether a system's dynamics are at least partially governed
by difference equations and (2) to obtain the difference equation
update times.

Returns:
    optional<PeriodicEventData> Contains the periodic trigger
    attributes if the unique periodic attribute exists, otherwise
    `nullopt`.)""";

        } GetUniquePeriodicDiscreteUpdateAttribute;

        // drake::systems::System::GetWitnessFunctions
        struct /* GetWitnessFunctions */ {

          // drake/systems/framework/system.h:1419
          const char* doc =
R"""(Gets the witness functions active for the given state.
DoGetWitnessFunctions() does the actual work. The vector of active
witness functions are expected to change only upon an unrestricted
update.

Parameter ``context``:
    a valid context for the System (aborts if not true).

Parameter ``w``:
    a valid pointer to an empty vector that will store pointers to the
    witness functions active for the current state. The method aborts
    if witnesses is null or non-empty.)""";

        } GetWitnessFunctions;

        // drake::systems::System::HasAnyDirectFeedthrough
        struct /* HasAnyDirectFeedthrough */ {

          // drake/systems/framework/system.h:300
          const char* doc =
R"""(Returns `true` if any of the inputs to the system might be directly
fed through to any of its outputs and `false` otherwise.)""";

        } HasAnyDirectFeedthrough;

        // drake::systems::System::HasDirectFeedthrough
        struct /* HasDirectFeedthrough */ {

          // drake/systems/framework/system.h:306
          const char* doc =
R"""(Returns true if there might be direct-feedthrough from any input port
to the given ``output_port``, and false otherwise.)""";

          // drake/systems/framework/system.h:316
          const char* doc_2 =
R"""(Returns true if there might be direct-feedthrough from the given
``input_port`` to the given ``output_port``, and false otherwise.)""";

        } HasDirectFeedthrough;

        // drake::systems::System::MapQDotToVelocity
        struct /* MapQDotToVelocity */ {

          // drake/systems/framework/system.h:956
          const char* doc =
R"""(Transforms the time derivative `qdot` of the generalized configuration
`q` to generalized velocities `v`. `v` and `qdot` are related linearly
by `qdot = N(q) * v`, where `N` is a block diagonal matrix. For
example, in a multibody system there will be one block of `N` per tree
joint. Although `N` is not necessarily square, its left pseudo-inverse
`N+` can be used to invert that relationship without residual error,
provided that `qdot` is in the range space of `N` (that is, if it
*could* have been produced as `qdot=N*v` for some `v`). Using the
configuration `q` from the given Context this method calculates `v =
N+ * qdot` (where `N+=N+(q)`) for a given `qdot`. This computation
requires only `O(nq)` time where `nq` is the size of `qdot`. Note that
this method does not take `qdot` from the Context.

See the alternate signature if you already have `qdot` in an Eigen
VectorX object; this signature will copy the VectorBase into an Eigen
object before performing the computation.

See also:
    MapVelocityToQDot())""";

          // drake/systems/framework/system.h:965
          const char* doc_2 =
R"""(Transforms the given time derivative `qdot` of generalized
configuration `q` to generalized velocity `v`. This signature takes
`qdot` as an Eigen VectorX object for faster speed. See the other
signature of MapQDotToVelocity() for additional information.)""";

        } MapQDotToVelocity;

        // drake::systems::System::MapVelocityToQDot
        struct /* MapVelocityToQDot */ {

          // drake/systems/framework/system.h:923
          const char* doc =
R"""(Transforms a given generalized velocity `v` to the time derivative
`qdot` of the generalized configuration `q` taken from the supplied
Context. `v` and `qdot` are related linearly by `qdot = N(q) * v`,
where `N` is a block diagonal matrix. For example, in a multibody
system there will be one block of `N` per tree joint. This computation
requires only `O(nq)` time where `nq` is the size of `qdot`. Note that
`v` is *not* taken from the Context; it is given as an argument here.

See the alternate signature if you already have the generalized
velocity in an Eigen VectorX object; this signature will copy the
VectorBase into an Eigen object before performing the computation.

See also:
    MapQDotToVelocity())""";

          // drake/systems/framework/system.h:932
          const char* doc_2 =
R"""(Transforms the given generalized velocity to the time derivative of
generalized configuration. See the other signature of
MapVelocityToQDot() for more information.)""";

        } MapVelocityToQDot;

        // drake::systems::System::Publish
        struct /* Publish */ {

          // drake/systems/framework/system.h:348
          const char* doc =
R"""(This method is the public entry point for dispatching all publish
event handlers. It checks the validity of ``context``, and directly
calls DispatchPublishHandler. ``events`` is a homogeneous collection
of publish events, which is typically the publish portion of the
heterogeneous event collection generated by CalcNextUpdateTime or
GetPerStepEvents.

Note:
    When publishing is scheduled at particular times, those times
    likely will not coincide with integrator step times. A Simulator
    may interpolate to generate a suitable Context, or it may adjust
    the integrator step size so that a step begins exactly at the next
    publication time. In the latter case the change in step size may
    affect the numerical result somewhat since a smaller integrator
    step produces a more accurate solution.)""";

          // drake/systems/framework/system.h:359
          const char* doc_2 =
R"""(Forces a publish on the system, given a ``context``. The publish event
will have a trigger type of kForced, with no additional data,
attribute or custom callback. The Simulator can be configured to call
this in Simulator::Initialize() and at the start of each continuous
integration step. See the Simulator API for more details.)""";

        } Publish;

        // drake::systems::System::SetDefaultContext
        struct /* SetDefaultContext */ {

          // drake/systems/framework/system.h:195
          const char* doc = R"""()""";

        } SetDefaultContext;

        // drake::systems::System::SetDefaultParameters
        struct /* SetDefaultParameters */ {

          // drake/systems/framework/system.h:190
          const char* doc =
R"""(Assigns default values to all parameters. Overrides must not change
the number of parameters.)""";

        } SetDefaultParameters;

        // drake::systems::System::SetDefaultState
        struct /* SetDefaultState */ {

          // drake/systems/framework/system.h:185
          const char* doc =
R"""(Assigns default values to all elements of the state. Overrides must
not change the number of state variables.)""";

        } SetDefaultState;

        // drake::systems::System::SetRandomContext
        struct /* SetRandomContext */ {

          // drake/systems/framework/system.h:252
          const char* doc = R"""()""";

        } SetRandomContext;

        // drake::systems::System::SetRandomParameters
        struct /* SetRandomParameters */ {

          // drake/systems/framework/system.h:243
          const char* doc =
R"""(Assigns random values to all parameters. This default implementation
calls SetDefaultParameters; override this method to provide random
parameters using the stdc++ random library, e.g.:

```
std::uniform_real_distribution<T> uniform();
  parameters->get_mutable_numeric_parameter(0)
            ->SetAtIndex(0, uniform(*generator));
```

Overrides must not change the number of state variables.

See also:
    stochastic_systems)""";

        } SetRandomParameters;

        // drake::systems::System::SetRandomState
        struct /* SetRandomState */ {

          // drake/systems/framework/system.h:226
          const char* doc =
R"""(Assigns random values to all elements of the state. This default
implementation calls SetDefaultState; override this method to provide
random initial conditions using the stdc++ random library, e.g.:

```
std::normal_distribution<T> gaussian();
  state->get_mutable_continuous_state()->get_mutable_vector()
       ->SetAtIndex(0, gaussian(*generator));
```

Overrides must not change the number of state variables.

See also:
    stochastic_systems)""";

        } SetRandomState;

        // drake::systems::System::System<T>
        struct /* ctor */ {

          // drake/systems/framework/system.h:83
          const char* doc = R"""()""";

          // drake/systems/framework/system.h:83
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system.h:1562
          const char* doc_3 =
R"""(Constructs an empty System base class object and allocates base class
resources, possibly supporting scalar-type conversion support
(AutoDiff, etc.) using ``converter``.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

        } ctor;

        // drake::systems::System::ToAutoDiffXd
        struct /* ToAutoDiffXd */ {

          // drake/systems/framework/system.h:1265
          const char* doc =
R"""(Creates a deep copy of this System, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.

Throws:
    exception if this System does not support autodiff

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

          // drake/systems/framework/system.h:1285
          const char* doc_2 =
R"""(Creates a deep copy of `from`, transmogrified to use the autodiff
scalar type, with a dynamic-sized vector of partial derivatives. The
result is never nullptr.

Throws:
    exception if `from` does not support autodiff

Usage:

```
MySystem<double> plant;
  std::unique_ptr<MySystem<AutoDiffXd>> ad_plant =
      systems::System<double>::ToAutoDiffXd(plant);
```

Template parameter ``S``:
    The specific System type to accept and return.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

        } ToAutoDiffXd;

        // drake::systems::System::ToAutoDiffXdMaybe
        struct /* ToAutoDiffXdMaybe */ {

          // drake/systems/framework/system.h:1301
          const char* doc =
R"""(Creates a deep copy of this system exactly like ToAutoDiffXd(), but
returns nullptr if this System does not support autodiff, instead of
throwing an exception.)""";

        } ToAutoDiffXdMaybe;

        // drake::systems::System::ToSymbolic
        struct /* ToSymbolic */ {

          // drake/systems/framework/system.h:1321
          const char* doc =
R"""(Creates a deep copy of this System, transmogrified to use the symbolic
scalar type. The result is never nullptr.

Throws:
    exception if this System does not support symbolic

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

          // drake/systems/framework/system.h:1340
          const char* doc_2 =
R"""(Creates a deep copy of `from`, transmogrified to use the symbolic
scalar type. The result is never nullptr.

Throws:
    exception if this System does not support symbolic

Usage:

```
MySystem<double> plant;
  std::unique_ptr<MySystem<symbolic::Expression>> sym_plant =
      systems::System<double>::ToSymbolic(plant);
```

Template parameter ``S``:
    The specific System pointer type to return.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.)""";

        } ToSymbolic;

        // drake::systems::System::ToSymbolicMaybe
        struct /* ToSymbolicMaybe */ {

          // drake/systems/framework/system.h:1356
          const char* doc =
R"""(Creates a deep copy of this system exactly like ToSymbolic(), but
returns nullptr if this System does not support symbolic, instead of
throwing an exception.)""";

        } ToSymbolicMaybe;

        // drake::systems::System::do_get_num_constraint_equations
        struct /* do_get_num_constraint_equations */ {

          // drake/systems/framework/system.h:1932
          const char* doc =
R"""(Gets the number of constraint equations for this system from the given
context. The context is supplied in case the number of constraints is
dependent upon the current state (as might be the case with a
piecewise differential algebraic equation). Derived classes can
override this function, which is called by
get_num_constraint_equations().

See also:
    get_num_constraint_equations() for parameter documentation.

Returns:
    zero by default)""";

        } do_get_num_constraint_equations;

        // drake::systems::System::get_constraint
        struct /* get_constraint */ {

          // drake/systems/framework/system.h:1108
          const char* doc =
R"""(Returns the constraint at index ``constraint_index``.

Throws:
    s ValueError for an invalid constraint_index.)""";

        } get_constraint;

        // drake::systems::System::get_forced_discrete_update_events
        struct /* get_forced_discrete_update_events */ {

          // drake/systems/framework/system.h:2023
          const char* doc = R"""()""";

        } get_forced_discrete_update_events;

        // drake::systems::System::get_forced_publish_events
        struct /* get_forced_publish_events */ {

          // drake/systems/framework/system.h:2018
          const char* doc = R"""()""";

        } get_forced_publish_events;

        // drake::systems::System::get_forced_unrestricted_update_events
        struct /* get_forced_unrestricted_update_events */ {

          // drake/systems/framework/system.h:2028
          const char* doc = R"""()""";

        } get_forced_unrestricted_update_events;

        // drake::systems::System::get_input_port
        struct /* get_input_port */ {

          // drake/systems/framework/system.h:1084
          const char* doc =
R"""(Returns the typed input port at index ``port_index``.)""";

        } get_input_port;

        // drake::systems::System::get_num_constraint_equations
        struct /* get_num_constraint_equations */ {

          // drake/systems/framework/system.h:588
          const char* doc =
R"""(Gets the number of constraint equations for this system using the
given context (useful in case the number of constraints is dependent
upon the current state (as might be the case with a system modeled
using piecewise differential algebraic equations).)""";

        } get_num_constraint_equations;

        // drake::systems::System::get_num_constraints
        struct /* get_num_constraints */ {

          // drake/systems/framework/system.h:1097
          const char* doc =
R"""(Returns the number of constraints specified for the system.)""";

        } get_num_constraints;

        // drake::systems::System::get_num_continuous_states
        struct /* get_num_continuous_states */ {

          // drake/systems/framework/system.h:1104
          const char* doc =
R"""(Returns the dimension of the continuous state vector that has been
declared until now.)""";

        } get_num_continuous_states;

        // drake::systems::System::get_output_port
        struct /* get_output_port */ {

          // drake/systems/framework/system.h:1091
          const char* doc =
R"""(Returns the typed output port at index ``port_index``.)""";

        } get_output_port;

        // drake::systems::System::get_system_scalar_converter
        struct /* get_system_scalar_converter */ {

          // drake/systems/framework/system.h:1407
          const char* doc =
R"""((Advanced) Returns the SystemScalarConverter for this object. This is
an expert-level API intended for framework authors. Most users should
prefer the convenience helpers such as System::ToAutoDiffXd.)""";

        } get_system_scalar_converter;

        // drake::systems::System::set_forced_discrete_update_events
        struct /* set_forced_discrete_update_events */ {

          // drake/systems/framework/system.h:2037
          const char* doc = R"""()""";

        } set_forced_discrete_update_events;

        // drake::systems::System::set_forced_publish_events
        struct /* set_forced_publish_events */ {

          // drake/systems/framework/system.h:2032
          const char* doc = R"""()""";

        } set_forced_publish_events;

        // drake::systems::System::set_forced_unrestricted_update_events
        struct /* set_forced_unrestricted_update_events */ {

          // drake/systems/framework/system.h:2042
          const char* doc = R"""()""";

        } set_forced_unrestricted_update_events;

      } System;

      // drake::systems::SystemBase
      struct /* SystemBase */ {

        // drake/systems/framework/context_base.h:596
        const char* doc =
R"""(Provides non-templatized functionality shared by the templatized
System classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake/systems/framework/input_port_base.h:13
        const char* doc_2 =
R"""(Provides non-templatized functionality shared by the templatized
System classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake/systems/framework/output_port_base.h:11
        const char* doc_3 =
R"""(Provides non-templatized functionality shared by the templatized
System classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake/systems/framework/system_base.h:29
        const char* doc_4 =
R"""(Provides non-templatized functionality shared by the templatized
System classes.

Terminology: in general a Drake System is a tree structure composed of
"subsystems", which are themselves System objects. The corresponding
Context is a parallel tree structure composed of "subcontexts", which
are themselves Context objects. There is a one-to-one correspondence
between subsystems and subcontexts. Within a given System (Context),
its child subsystems (subcontexts) are indexed using a SubsystemIndex;
there is no separate SubcontextIndex since the numbering must be
identical.)""";

        // drake::systems::SystemBase::AddAbstractParameter
        struct /* AddAbstractParameter */ {

          // drake/systems/framework/system_base.h:814
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new abstract parameter with
the given `index`. @pre The supplied index must be the next available
one; that is, indexes must be assigned sequentially.)""";

        } AddAbstractParameter;

        // drake::systems::SystemBase::AddAbstractState
        struct /* AddAbstractState */ {

          // drake/systems/framework/system_base.h:792
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new abstract state variable
with the given `index`. @pre The supplied index must be the next
available one; that is, indexes must be assigned sequentially.)""";

        } AddAbstractState;

        // drake::systems::SystemBase::AddDiscreteStateGroup
        struct /* AddDiscreteStateGroup */ {

          // drake/systems/framework/system_base.h:781
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new discrete variable group
with the given `index`. @pre The supplied index must be the next
available one; that is, indexes must be assigned sequentially.)""";

        } AddDiscreteStateGroup;

        // drake::systems::SystemBase::AddInputPort
        struct /* AddInputPort */ {

          // drake/systems/framework/system_base.h:757
          const char* doc =
R"""((Internal use only) Adds an already-constructed input port to this
System. Insists that the port already contains a reference to this
System, and that the port's index is already set to the next available
input port index for this System.)""";

        } AddInputPort;

        // drake::systems::SystemBase::AddNumericParameter
        struct /* AddNumericParameter */ {

          // drake/systems/framework/system_base.h:803
          const char* doc =
R"""((Internal use only) Assigns a ticket to a new numeric parameter with
the given `index`. @pre The supplied index must be the next available
one; that is, indexes must be assigned sequentially.)""";

        } AddNumericParameter;

        // drake::systems::SystemBase::AddOutputPort
        struct /* AddOutputPort */ {

          // drake/systems/framework/system_base.h:770
          const char* doc =
R"""((Internal use only) Adds an already-constructed output port to this
System. Insists that the port already contains a reference to this
System, and that the port's index is already set to the next available
output port index for this System.)""";

        } AddOutputPort;

        // drake::systems::SystemBase::AllocateContext
        struct /* AllocateContext */ {

          // drake/systems/framework/system_base.h:84
          const char* doc =
R"""(Returns a Context suitable for use with this System. Context resources
are allocated based on resource requests that were made during System
construction.)""";

        } AllocateContext;

        // drake::systems::SystemBase::CheckValidContext
        struct /* CheckValidContext */ {

          // drake/systems/framework/system_base.h:448
          const char* doc =
R"""(Checks whether the given context is valid for this System and throws
an exception with a helpful message if not. This is *very* expensive
and should generally be done only in Debug builds, like this:

```
DRAKE_ASSERT_VOID(CheckValidContext(context));
```)""";

        } CheckValidContext;

        // drake::systems::SystemBase::DeclareCacheEntry
        struct /* DeclareCacheEntry */ {

          // drake/systems/framework/system_base.h:336
          const char* doc =
R"""(@anchor DeclareCacheEntry_primary Declares a new CacheEntry in this
System using the least-restrictive definitions for the associated
functions. Prefer one of the more-convenient signatures below if you
can. The new cache entry is assigned a unique CacheIndex and
DependencyTicket, which can be obtained from the returned CacheEntry.
The function signatures here are:

```
std::unique_ptr<AbstractValue> Alloc();
void Calc(const ContextBase&, AbstractValue*);
```

where the AbstractValue objects must resolve to the same concrete
type.

Parameter ``description``:
    A human-readable description of this cache entry, most useful for
    debugging and documentation. Not interpreted in any way by Drake;
    it is retained by the cache entry and used to generate the
    description for the corresponding CacheEntryValue in the Context.

Parameter ``alloc_function``:
    Given a Context, returns a heap-allocated AbstractValue object
    suitable for holding a value for this cache entry.

Parameter ``calc_function``:
    Provides the computation that maps from a given Context to the
    current value that this cache entry should have, and writes that
    value to a given object of the type returned by `alloc_function`.

Parameter ``prerequisites_of_calc``:
    Provides the DependencyTicket list containing a ticket for _every_
    Context value on which `calc_function` may depend when it computes
    its result. Defaults to `{all_sources_ticket()}` if unspecified.
    If the cache value is truly independent of the Context (rare!) say
    so explicitly by providing the list `{nothing_ticket()}`; an
    explicitly empty list `{}` is forbidden.

Returns:
    a const reference to the newly-created CacheEntry.

Throws:
    s std::logic_error if given an explicitly empty prerequisite list.)""";

          // drake/systems/framework/system_base.h:355
          const char* doc_2 =
R"""(Declares a cache entry by specifying member functions to use both for
the allocator and calculator. The signatures are:

```
ValueType MySystem::MakeValueType() const;
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase`, `MyContext` is
a class derived from `ContextBase`, and `ValueType` is any concrete
type such that `Value<ValueType>` is permitted. (The method names are
arbitrary.) Template arguments will be deduced and do not need to be
specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" for more information about the
parameters and behavior.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:376
          const char* doc_3 =
R"""(@anchor DeclareCacheEntry_model_and_calc Declares a cache entry by
specifying a model value of concrete type `ValueType` and a calculator
function that is a class member function (method) with signature:

```
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase`, `MyContext` is
a class derived from `ContextBase`, and `ValueType` is any concrete
type such that `Value<ValueType>` is permitted. (The method names are
arbitrary.) Template arguments will be deduced and do not need to be
specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" above for more information about the
parameters and behavior.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:391
          const char* doc_4 =
R"""(Declares a cache entry by specifying a model value of concrete type
`ValueType` and a calculator function that is a class member function
(method) with signature:

```
ValueType MySystem::CalcCacheValue(const MyContext&) const;
```

Other than the calculator signature, this is identical to the other
DeclareCacheEntry_model_and_calc "model and calculator signature",
please look there for more information.)""";

          // drake/systems/framework/system_base.h:420
          const char* doc_5 =
R"""(@anchor DeclareCacheEntry_calc_only Declares a cache entry by
specifying only a calculator function that is a class member function
(method) with signature:

```
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase` and `MyContext`
is a class derived from `ContextBase`. `ValueType` is a concrete type
such that (a) `Value<ValueType>` is permitted, and (b) `ValueType` is
default constructible. That allows us to create a model value using
`Value<ValueType>{}` (value initialized so numerical types will be
zeroed in the model). (The method name is arbitrary.) Template
arguments will be deduced and do not need to be specified. See the
first DeclareCacheEntry() signature above for more information about
the parameters and behavior.

Note:
    The default constructor will be called once immediately to create
    a model value, and subsequent allocations will just copy the model
    value without invoking the constructor again. If you want the
    constructor invoked again at each allocation (not common), use one
    of the other signatures to explicitly provide a method for the
    allocator to call; that method can then invoke the `ValueType`
    default constructor each time it is called.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:435
          const char* doc_6 =
R"""(Declares a cache entry by specifying only a calculator function that
is a class member function (method) with signature:

```
ValueType MySystem::CalcCacheValue(const MyContext&) const;
```

Other than the calculator method's signature, this is identical to the
other DeclareCacheEntry_calc_only "calculator-only signature"; please
look there for more information.)""";

          // drake/systems/framework/system_base.h:1024
          const char* doc_7 =
R"""(Declares a cache entry by specifying member functions to use both for
the allocator and calculator. The signatures are:

```
ValueType MySystem::MakeValueType() const;
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase`, `MyContext` is
a class derived from `ContextBase`, and `ValueType` is any concrete
type such that `Value<ValueType>` is permitted. (The method names are
arbitrary.) Template arguments will be deduced and do not need to be
specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" for more information about the
parameters and behavior.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:1054
          const char* doc_8 =
R"""(@anchor DeclareCacheEntry_model_and_calc Declares a cache entry by
specifying a model value of concrete type `ValueType` and a calculator
function that is a class member function (method) with signature:

```
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase`, `MyContext` is
a class derived from `ContextBase`, and `ValueType` is any concrete
type such that `Value<ValueType>` is permitted. (The method names are
arbitrary.) Template arguments will be deduced and do not need to be
specified. See the DeclareCacheEntry_primary "primary
DeclareCacheEntry() signature" above for more information about the
parameters and behavior.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:1092
          const char* doc_9 =
R"""(Declares a cache entry by specifying a model value of concrete type
`ValueType` and a calculator function that is a class member function
(method) with signature:

```
ValueType MySystem::CalcCacheValue(const MyContext&) const;
```

Other than the calculator signature, this is identical to the other
DeclareCacheEntry_model_and_calc "model and calculator signature",
please look there for more information.)""";

          // drake/systems/framework/system_base.h:1122
          const char* doc_10 =
R"""(@anchor DeclareCacheEntry_calc_only Declares a cache entry by
specifying only a calculator function that is a class member function
(method) with signature:

```
void MySystem::CalcCacheValue(const MyContext&, ValueType*) const;
```

where `MySystem` is a class derived from `SystemBase` and `MyContext`
is a class derived from `ContextBase`. `ValueType` is a concrete type
such that (a) `Value<ValueType>` is permitted, and (b) `ValueType` is
default constructible. That allows us to create a model value using
`Value<ValueType>{}` (value initialized so numerical types will be
zeroed in the model). (The method name is arbitrary.) Template
arguments will be deduced and do not need to be specified. See the
first DeclareCacheEntry() signature above for more information about
the parameters and behavior.

Note:
    The default constructor will be called once immediately to create
    a model value, and subsequent allocations will just copy the model
    value without invoking the constructor again. If you want the
    constructor invoked again at each allocation (not common), use one
    of the other signatures to explicitly provide a method for the
    allocator to call; that method can then invoke the `ValueType`
    default constructor each time it is called.

See also:
    drake::systems::Value)""";

          // drake/systems/framework/system_base.h:1139
          const char* doc_11 =
R"""(Declares a cache entry by specifying only a calculator function that
is a class member function (method) with signature:

```
ValueType MySystem::CalcCacheValue(const MyContext&) const;
```

Other than the calculator method's signature, this is identical to the
other DeclareCacheEntry_calc_only "calculator-only signature"; please
look there for more information.)""";

        } DeclareCacheEntry;

        // drake::systems::SystemBase::DeclareCacheEntryWithKnownTicket
        struct /* DeclareCacheEntryWithKnownTicket */ {

          // drake/systems/framework/system_base.h:825
          const char* doc =
R"""((Internal use only) This is for cache entries associated with pre-
defined tickets, for example the cache entry for time derivatives. See
the public API for the most-general DeclareCacheEntry() signature for
the meanings of the other parameters here.)""";

        } DeclareCacheEntryWithKnownTicket;

        // drake::systems::SystemBase::DoAllocateContext
        struct /* DoAllocateContext */ {

          // drake/systems/framework/system_base.h:946
          const char* doc =
R"""(Derived class implementations should allocate a suitable concrete
Context type, then invoke the above InitializeContextBase() method. A
Diagram must then invoke AllocateContext() to obtain each of the
subcontexts for its DiagramContext, and must set up inter-subcontext
dependencies among its children and between itself and its children.
Then context resources such as parameters and state should be
allocated.)""";

        } DoAllocateContext;

        // drake::systems::SystemBase::DoCheckValidContext
        struct /* DoCheckValidContext */ {

          // drake/systems/framework/system_base.h:952
          const char* doc =
R"""(Derived classes must implement this to verify that the supplied
Context is suitable, and throw an exception if not. This is a runtime
check but may be expensive so is not guaranteed to be invoked except
in Debug builds.)""";

        } DoCheckValidContext;

        // drake::systems::SystemBase::EvalAbstractInput
        struct /* EvalAbstractInput */ {

          // drake/systems/framework/system_base.h:127
          const char* doc =
R"""(Returns the value of the input port with the given `port_index` as an
AbstractValue, which is permitted for ports of any type. Causes the
value to become up to date first if necessary, delegating to our
parent Diagram. Returns a pointer to the port's value, or nullptr if
the port is not connected. If you know the actual type, use one of the
more-specific signatures.

@pre `port_index` selects an existing input port of this System.

See also:
    EvalInputValue(), System::EvalVectorInput(),
    System::EvalEigenVectorInput())""";

        } EvalAbstractInput;

        // drake::systems::SystemBase::EvalAbstractInputImpl
        struct /* EvalAbstractInputImpl */ {

          // drake/systems/framework/system_base.h:863
          const char* doc =
R"""((Internal use only) Shared code for updating an input port and
returning a pointer to its abstract value, or nullptr if the port is
not connected. `func` should be the user-visible API function name
obtained with __func__.)""";

        } EvalAbstractInputImpl;

        // drake::systems::SystemBase::EvalInputValue
        struct /* EvalInputValue */ {

          // drake/systems/framework/system_base.h:149
          const char* doc =
R"""(Returns the value of an abstract-valued input port with the given
`port_index` as a value of known type `V`. Causes the value to become
up to date first if necessary. See EvalAbstractInput() for more
information.

The result is returned as a pointer to the input port's value of type
`V`, or nullptr if the port is not connected.

@pre `port_index` selects an existing input port of this System. @pre
the port's value must be retrievable from the stored abstract value
using `AbstractValue::GetValue<V>`.

Template parameter ``V``:
    The type of data expected.)""";

        } EvalInputValue;

        // drake::systems::SystemBase::GetInputPortBaseOrThrow
        struct /* GetInputPortBaseOrThrow */ {

          // drake/systems/framework/system_base.h:907
          const char* doc =
R"""((Internal use only) Returns the InputPortBase at index `port_index`,
throwing ValueError we don't like the port index. The name of the
public API method that received the bad index is provided in `func`
and is included in the error message.)""";

        } GetInputPortBaseOrThrow;

        // drake::systems::SystemBase::GetOutputPortBaseOrThrow
        struct /* GetOutputPortBaseOrThrow */ {

          // drake/systems/framework/system_base.h:921
          const char* doc =
R"""((Internal use only) Returns the OutputPortBase at index `port_index`,
throwing ValueError we don't like the port index. The name of the
public API method that received the bad index is provided in `func`
and is included in the error message.)""";

        } GetOutputPortBaseOrThrow;

        // drake::systems::SystemBase::GetSystemName
        struct /* GetSystemName */ {

          // drake/systems/framework/system_base.h:56
          const char* doc =
R"""(Returns a human-readable name for this system, for use in messages and
logging. This will be the same as returned by get_name(), unless that
would be an empty string. In that case we return a non-unique
placeholder name, currently just "_" (a lone underscore).)""";

        } GetSystemName;

        // drake::systems::SystemBase::GetSystemPathname
        struct /* GetSystemPathname */ {

          // drake/systems/framework/system_base.h:64
          const char* doc =
R"""(Generates and returns a human-readable full path name of this
subsystem, for use in messages and logging. The name starts from the
root System, with "::" delimiters between parent and child subsystems,
with the individual subsystems represented by their names as returned
by GetSystemName().)""";

        } GetSystemPathname;

        // drake::systems::SystemBase::GetSystemType
        struct /* GetSystemType */ {

          // drake/systems/framework/system_base.h:71
          const char* doc =
R"""(Returns the most-derived type of this concrete System object as a
human-readable string suitable for use in error messages. The format
is as generated by NiceTypeName and will include namespace
qualification if present.

See also:
    NiceTypeName for more specifics.)""";

        } GetSystemType;

        // drake::systems::SystemBase::InitializeContextBase
        struct /* InitializeContextBase */ {

          // drake/systems/framework/system_base.h:938
          const char* doc =
R"""(This method must be invoked from within derived class
DoAllocateContext() implementations right after the concrete Context
object has been allocated. It allocates cache entries, sets up all
intra-Context dependencies, and marks the ContextBase as initialized
so that we can verify proper derived-class behavior. @pre The supplied
context must not be null and must not already have been initialized.)""";

        } InitializeContextBase;

        // drake::systems::SystemBase::SystemBase
        struct /* ctor */ {

          // drake/systems/framework/system_base.h:31
          const char* doc = R"""()""";

          // drake/systems/framework/system_base.h:31
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system_base.h:749
          const char* doc_3 =
R"""((Internal use only) Default constructor. */)""";

        } ctor;

        // drake::systems::SystemBase::ThrowCantEvaluateInputPort
        struct /* ThrowCantEvaluateInputPort */ {

          // drake/systems/framework/system_base.h:900
          const char* doc =
R"""(Throws std::logic_error because someone called API method `func`, that
requires this input port to be evaluatable, but the port was neither
fixed nor connected.)""";

        } ThrowCantEvaluateInputPort;

        // drake::systems::SystemBase::ThrowIfContextNotCompatible
        struct /* ThrowIfContextNotCompatible */ {

          // drake/systems/framework/system_base.h:77
          const char* doc =
R"""(Throws an exception with an appropriate message if the given `context`
is not compatible with this System. Restrictions may vary for
different systems; the error message should explain. This can be an
expensive check so you may want to limit it to Debug builds.)""";

        } ThrowIfContextNotCompatible;

        // drake::systems::SystemBase::ThrowInputPortHasWrongType
        struct /* ThrowInputPortHasWrongType */ {

          // drake/systems/framework/system_base.h:893
          const char* doc =
R"""(Throws std::logic_error because someone called API method `func`
claiming the input port had some value type that was wrong.)""";

        } ThrowInputPortHasWrongType;

        // drake::systems::SystemBase::ThrowInputPortIndexOutOfRange
        struct /* ThrowInputPortIndexOutOfRange */ {

          // drake/systems/framework/system_base.h:877
          const char* doc =
R"""(Throws ValueError to report bad input `port_index` that was passed to
API method `func`.)""";

        } ThrowInputPortIndexOutOfRange;

        // drake::systems::SystemBase::ThrowNegativePortIndex
        struct /* ThrowNegativePortIndex */ {

          // drake/systems/framework/system_base.h:872
          const char* doc = R"""()""";

        } ThrowNegativePortIndex;

        // drake::systems::SystemBase::ThrowNotAVectorInputPort
        struct /* ThrowNotAVectorInputPort */ {

          // drake/systems/framework/system_base.h:888
          const char* doc =
R"""(Throws std::logic_error because someone misused API method `func`,
that is only allowed for declared-vector input ports, on an abstract
port whose index is given here.)""";

        } ThrowNotAVectorInputPort;

        // drake::systems::SystemBase::ThrowOutputPortIndexOutOfRange
        struct /* ThrowOutputPortIndexOutOfRange */ {

          // drake/systems/framework/system_base.h:882
          const char* doc =
R"""(Throws ValueError to report bad output `port_index` that was passed to
API method `func`.)""";

        } ThrowOutputPortIndexOutOfRange;

        // drake::systems::SystemBase::abstract_parameter_ticket
        struct /* abstract_parameter_ticket */ {

          // drake/systems/framework/system_base.h:592
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular abstract
parameter paᵢ.

See also:
    pa_ticket() to obtain a ticket for _all_ abstract parameters.)""";

        } abstract_parameter_ticket;

        // drake::systems::SystemBase::abstract_state_ticket
        struct /* abstract_state_ticket */ {

          // drake/systems/framework/system_base.h:552
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular abstract state
variable xaᵢ.

See also:
    xa_ticket() to obtain a ticket for _all_ abstract variables.)""";

        } abstract_state_ticket;

        // drake::systems::SystemBase::accuracy_ticket
        struct /* accuracy_ticket */ {

          // drake/systems/framework/system_base.h:501
          const char* doc =
R"""(Returns a ticket indicating dependence on the accuracy setting in the
Context. This is the same ticket for all systems and refers to the
same accuracy value.)""";

        } accuracy_ticket;

        // drake::systems::SystemBase::all_input_ports_ticket
        struct /* all_input_ports_ticket */ {

          // drake/systems/framework/system_base.h:622
          const char* doc =
R"""(Returns a ticket indicating dependence on _all_ input ports u of this
system.

See also:
    input_port_ticket() to obtain a ticket for just one input port.)""";

        } all_input_ports_ticket;

        // drake::systems::SystemBase::all_parameters_ticket
        struct /* all_parameters_ticket */ {

          // drake/systems/framework/system_base.h:607
          const char* doc =
R"""(Returns a ticket indicating dependence on _all_ parameters p in this
system, including numeric parameters pn, and abstract parameters pa.)""";

        } all_parameters_ticket;

        // drake::systems::SystemBase::all_sources_ticket
        struct /* all_sources_ticket */ {

          // drake/systems/framework/system_base.h:631
          const char* doc =
R"""(Returns a ticket indicating dependence on every possible independent
source value, including time, accuracy, state, input ports, and
parameters (but not cache entries). This is the default dependency for
computations that have not specified anything more refined.

See also:
    cache_entry_ticket() to obtain a ticket for a cache entry.)""";

        } all_sources_ticket;

        // drake::systems::SystemBase::all_state_ticket
        struct /* all_state_ticket */ {

          // drake/systems/framework/system_base.h:570
          const char* doc =
R"""(Returns a ticket indicating dependence on _all_ state variables x in
this system, including continuous variables xc, discrete (numeric)
variables xd, and abstract state variables xa. This does not imply
dependence on time, accuracy, parameters, or inputs; those must be
specified separately. If you mean to express dependence on all
possible value sources, use all_sources_ticket() instead.)""";

        } all_state_ticket;

        // drake::systems::SystemBase::assign_next_dependency_ticket
        struct /* assign_next_dependency_ticket */ {

          // drake/systems/framework/system_base.h:841
          const char* doc =
R"""((Internal use only) Assigns the next unused dependency ticket number,
unique only within a particular system. Each call to this method
increments the ticket number.)""";

        } assign_next_dependency_ticket;

        // drake::systems::SystemBase::cache_entry_ticket
        struct /* cache_entry_ticket */ {

          // drake/systems/framework/system_base.h:639
          const char* doc =
R"""(Returns a ticket indicating dependence on the cache entry indicated by
`index`. Note that cache entries are _not_ included in the
`all_sources` ticket so must be listed separately. @pre `index`
selects an existing cache entry in this System.)""";

        } cache_entry_ticket;

        // drake::systems::SystemBase::configuration_ticket
        struct /* configuration_ticket */ {

          // drake/systems/framework/system_base.h:662
          const char* doc = R"""()""";

        } configuration_ticket;

        // drake::systems::SystemBase::discrete_state_ticket
        struct /* discrete_state_ticket */ {

          // drake/systems/framework/system_base.h:537
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular discrete state
variable xdᵢ (may be a vector). (We sometimes refer to this as a
"discrete variable group".)

See also:
    xd_ticket() to obtain a ticket for _all_ discrete variables.)""";

        } discrete_state_ticket;

        // drake::systems::SystemBase::get_cache_entry
        struct /* get_cache_entry */ {

          // drake/systems/framework/system_base.h:217
          const char* doc =
R"""(Return a reference to a CacheEntry given its `index`. */)""";

        } get_cache_entry;

        // drake::systems::SystemBase::get_input_port_base
        struct /* get_input_port_base */ {

          // drake/systems/framework/system_base.h:184
          const char* doc =
R"""(Returns a reference to an InputPort given its `port_index`. @pre
`port_index` selects an existing input port of this System.)""";

        } get_input_port_base;

        // drake::systems::SystemBase::get_name
        struct /* get_name */ {

          // drake/systems/framework/system_base.h:50
          const char* doc =
R"""(Returns the name last supplied to set_name(), if any. Diagrams built
with DiagramBuilder will always have a default name for every
contained subsystem for which no user-provided name is available.
Systems created by copying with a scalar type change have the same
name as the source system. An empty string is returned if no name has
been set.)""";

        } get_name;

        // drake::systems::SystemBase::get_num_input_ports
        struct /* get_num_input_ports */ {

          // drake/systems/framework/system_base.h:172
          const char* doc =
R"""(Returns the number of input ports currently allocated in this System.
These are indexed from 0 to get_num_input_ports()-1.)""";

        } get_num_input_ports;

        // drake::systems::SystemBase::get_num_output_ports
        struct /* get_num_output_ports */ {

          // drake/systems/framework/system_base.h:178
          const char* doc =
R"""(Returns the number of output ports currently allocated in this System.
These are indexed from 0 to get_num_output_ports()-1.)""";

        } get_num_output_ports;

        // drake::systems::SystemBase::get_num_total_inputs
        struct /* get_num_total_inputs */ {

          // drake/systems/framework/system_base.h:196
          const char* doc =
R"""(Returns the total dimension of all of the vector-valued input ports
(as if they were muxed).)""";

        } get_num_total_inputs;

        // drake::systems::SystemBase::get_num_total_outputs
        struct /* get_num_total_outputs */ {

          // drake/systems/framework/system_base.h:204
          const char* doc =
R"""(Returns the total dimension of all of the vector-valued output ports
(as if they were muxed).)""";

        } get_num_total_outputs;

        // drake::systems::SystemBase::get_output_port_base
        struct /* get_output_port_base */ {

          // drake/systems/framework/system_base.h:190
          const char* doc =
R"""(Returns a reference to an OutputPort given its `port_index`. @pre
`port_index` selects an existing output port of this System.)""";

        } get_output_port_base;

        // drake::systems::SystemBase::get_parent_service
        struct /* get_parent_service */ {

          // drake/systems/framework/system_base.h:834
          const char* doc =
R"""(Returns a pointer to the service interface of the immediately
enclosing Diagram if one has been set, otherwise nullptr.)""";

        } get_parent_service;

        // drake::systems::SystemBase::input_port_ticket
        struct /* input_port_ticket */ {

          // drake/systems/framework/system_base.h:614
          const char* doc =
R"""(Returns a ticket indicating dependence on input port uᵢ indicated by
`index`. @pre `index` selects an existing input port of this System.)""";

        } input_port_ticket;

        // drake::systems::SystemBase::ke_ticket
        struct /* ke_ticket */ {

          // drake/systems/framework/system_base.h:697
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the kinetic energy
calculation.

See also:
    System::EvalKineticEnergy())""";

        } ke_ticket;

        // drake::systems::SystemBase::kinematics_ticket
        struct /* kinematics_ticket */ {

          // drake/systems/framework/system_base.h:676
          const char* doc = R"""()""";

        } kinematics_ticket;

        // drake::systems::SystemBase::nothing_ticket
        struct /* nothing_ticket */ {

          // drake/systems/framework/system_base.h:488
          const char* doc =
R"""(Returns a ticket indicating that a computation does not depend on
*any* source value; that is, it is a constant. If this appears in a
prerequisite list, it must be the only entry.)""";

        } nothing_ticket;

        // drake::systems::SystemBase::num_abstract_parameters
        struct /* num_abstract_parameters */ {

          // drake/systems/framework/system_base.h:742
          const char* doc =
R"""(Returns the number of declared abstract parameters. */)""";

        } num_abstract_parameters;

        // drake::systems::SystemBase::num_abstract_states
        struct /* num_abstract_states */ {

          // drake/systems/framework/system_base.h:731
          const char* doc =
R"""(Returns the number of declared abstract state variables. */)""";

        } num_abstract_states;

        // drake::systems::SystemBase::num_cache_entries
        struct /* num_cache_entries */ {

          // drake/systems/framework/system_base.h:212
          const char* doc =
R"""(Returns the number nc of cache entries currently allocated in this
System. These are indexed from 0 to nc-1.)""";

        } num_cache_entries;

        // drake::systems::SystemBase::num_discrete_state_groups
        struct /* num_discrete_state_groups */ {

          // drake/systems/framework/system_base.h:726
          const char* doc =
R"""(Returns the number of declared discrete state groups (each group is a
vector-valued discrete state variable).)""";

        } num_discrete_state_groups;

        // drake::systems::SystemBase::num_numeric_parameters
        struct /* num_numeric_parameters */ {

          // drake/systems/framework/system_base.h:737
          const char* doc =
R"""(Returns the number of declared numeric parameters (each of these is a
vector-valued parameter).)""";

        } num_numeric_parameters;

        // drake::systems::SystemBase::numeric_parameter_ticket
        struct /* numeric_parameter_ticket */ {

          // drake/systems/framework/system_base.h:577
          const char* doc =
R"""(Returns a ticket indicating dependence on a particular numeric
parameter pnᵢ (may be a vector).

See also:
    pn_ticket() to obtain a ticket for _all_ numeric parameters.)""";

        } numeric_parameter_ticket;

        // drake::systems::SystemBase::output_port_ticket
        struct /* output_port_ticket */ {

          // drake/systems/framework/system_base.h:719
          const char* doc =
R"""((Internal use only) Returns a ticket indicating dependence on the
output port indicated by `index`. No user-definable quantities in a
system can meaningfully depend on that system's own output ports. @pre
`index` selects an existing output port of this System.)""";

        } output_port_ticket;

        // drake::systems::SystemBase::pa_ticket
        struct /* pa_ticket */ {

          // drake/systems/framework/system_base.h:601
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the abstract
parameters pa in the current Context.

See also:
    abstract_parameter_ticket() to obtain a ticket for just one
    abstract parameter.)""";

        } pa_ticket;

        // drake::systems::SystemBase::pc_ticket
        struct /* pc_ticket */ {

          // drake/systems/framework/system_base.h:704
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the conservative power
calculation.

See also:
    System::EvalConservativePower())""";

        } pc_ticket;

        // drake::systems::SystemBase::pe_ticket
        struct /* pe_ticket */ {

          // drake/systems/framework/system_base.h:690
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the potential energy
calculation.

See also:
    System::EvalPotentialEnergy())""";

        } pe_ticket;

        // drake::systems::SystemBase::pn_ticket
        struct /* pn_ticket */ {

          // drake/systems/framework/system_base.h:585
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the numerical
parameters in the current Context.

See also:
    numeric_parameter_ticket() to obtain a ticket for just one numeric
    parameter.)""";

        } pn_ticket;

        // drake::systems::SystemBase::pnc_ticket
        struct /* pnc_ticket */ {

          // drake/systems/framework/system_base.h:711
          const char* doc =
R"""(Returns a ticket for the cache entry that holds the non-conservative
power calculation.

See also:
    System::EvalNonConservativePower())""";

        } pnc_ticket;

        // drake::systems::SystemBase::q_ticket
        struct /* q_ticket */ {

          // drake/systems/framework/system_base.h:508
          const char* doc =
R"""(Returns a ticket indicating that a computation depends on
configuration state variables q. There is no ticket representing just
one of the state variables qᵢ.)""";

        } q_ticket;

        // drake::systems::SystemBase::set_name
        struct /* set_name */ {

          // drake/systems/framework/system_base.h:40
          const char* doc =
R"""(Sets the name of the system. Do not use the path delimiter character
':' in the name. When creating a Diagram, names of sibling subsystems
should be unique. DiagramBuilder uses this method to assign a unique
default name if none is provided.)""";

        } set_name;

        // drake::systems::SystemBase::set_parent_service
        struct /* set_parent_service */ {

          // drake/systems/framework/system_base.h:851
          const char* doc =
R"""((Internal use only) Declares that `parent_service` is the service
interface of the Diagram that owns this subsystem. Aborts if the
parent service has already been set to something else.)""";

        } set_parent_service;

        // drake::systems::SystemBase::time_ticket
        struct /* time_ticket */ {

          // drake/systems/framework/system_base.h:494
          const char* doc =
R"""(Returns a ticket indicating dependence on time. This is the same
ticket for all systems and refers to the same time value.)""";

        } time_ticket;

        // drake::systems::SystemBase::v_ticket
        struct /* v_ticket */ {

          // drake/systems/framework/system_base.h:516
          const char* doc =
R"""(Returns a ticket indicating dependence on velocity state variables v.
This does _not_ also indicate a dependence on configuration variables
q -- you must list that explicitly or use kinematics_ticket() instead.
There is no ticket representing just one of the state variables vᵢ.)""";

        } v_ticket;

        // drake::systems::SystemBase::xa_ticket
        struct /* xa_ticket */ {

          // drake/systems/framework/system_base.h:560
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the abstract state
variables in the current Context.

See also:
    abstract_state_ticket() to obtain a ticket for just one abstract
    state variable.)""";

        } xa_ticket;

        // drake::systems::SystemBase::xc_ticket
        struct /* xc_ticket */ {

          // drake/systems/framework/system_base.h:529
          const char* doc =
R"""(Returns a ticket indicating dependence on _all_ of the continuous
state variables q, v, or z.)""";

        } xc_ticket;

        // drake::systems::SystemBase::xcdot_ticket
        struct /* xcdot_ticket */ {

          // drake/systems/framework/system_base.h:683
          const char* doc =
R"""(Returns a ticket for the cache entry that holds time derivatives of
the continuous variables.

See also:
    EvalTimeDerivatives())""";

        } xcdot_ticket;

        // drake::systems::SystemBase::xd_ticket
        struct /* xd_ticket */ {

          // drake/systems/framework/system_base.h:545
          const char* doc =
R"""(Returns a ticket indicating dependence on all of the numerical
discrete state variables, in any discrete variable group.

See also:
    discrete_state_ticket() to obtain a ticket for just one discrete
    state variable.)""";

        } xd_ticket;

        // drake::systems::SystemBase::z_ticket
        struct /* z_ticket */ {

          // drake/systems/framework/system_base.h:523
          const char* doc =
R"""(Returns a ticket indicating dependence on any or all of the
miscellaneous continuous state variables z. There is no ticket
representing just one of the state variables zᵢ.)""";

        } z_ticket;

      } SystemBase;

      // drake::systems::SystemConstraint
      struct /* SystemConstraint */ {

        // drake/systems/framework/system_constraint.h:56
        const char* doc =
R"""(A SystemConstraint is a generic base-class for constraints on Systems.

A SystemConstraint is a means to inform our algorithms *about* the
implemented system behavior -- declaring the constraint does not
*cause* the system behavior to change. It is meant to improve analysis
by telling our algorithms that "all valid solutions of this dynamical
system will satisfy the following (in)equalities". Examples could
include conserved quantities or joint limits on a mechanism.

This class is intentionally similar to, but (so far) independent from
solvers::Constraint. This is primarily because there is no notion of
decision variables in the system classes (yet); rather each individual
algorithm (e.g. trajectory optimization, or system identification)
constructs decision variables for the particular mathematical program
that is being formulated, and must bind the system constraint to those
variables (e.g. by populating the Context with the decision variables
and calling Calc).

See also:
    LeafSystem<T>::DeclareEqualityConstraint and
    LeafSystem<T>::DeclareInequalityConstraint for use cases.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.)""";

        // drake::systems::SystemConstraint::Calc
        struct /* Calc */ {

          // drake/systems/framework/system_constraint.h:86
          const char* doc =
R"""(Evaluates the function pointer passed in through the constructor,
writing the output to ``value``. ``value`` will be (non-
conservatively) resized to match the constraint function output.)""";

        } Calc;

        // drake::systems::SystemConstraint::CheckSatisfied
        struct /* CheckSatisfied */ {

          // drake/systems/framework/system_constraint.h:96
          const char* doc =
R"""(Evaluates the function pointer, and check if all of the outputs are
within the desired bounds.)""";

        } CheckSatisfied;

        // drake::systems::SystemConstraint::SystemConstraint<T>
        struct /* ctor */ {

          // drake/systems/framework/system_constraint.h:58
          const char* doc = R"""()""";

          // drake/systems/framework/system_constraint.h:58
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system_constraint.h:74
          const char* doc_3 =
R"""(Constructs the SystemConstraint.

Parameter ``count``:
    the number of constraints (size of the value vector).

Parameter ``type``:
    the SystemConstraintType.

Parameter ``description``:
    a human-readable description useful for debugging.)""";

        } ctor;

        // drake::systems::SystemConstraint::description
        struct /* description */ {

          // drake/systems/framework/system_constraint.h:124
          const char* doc = R"""()""";

        } description;

        // drake::systems::SystemConstraint::is_equality_constraint
        struct /* is_equality_constraint */ {

          // drake/systems/framework/system_constraint.h:121
          const char* doc = R"""()""";

        } is_equality_constraint;

        // drake::systems::SystemConstraint::size
        struct /* size */ {

          // drake/systems/framework/system_constraint.h:119
          const char* doc = R"""()""";

        } size;

        // drake::systems::SystemConstraint::type
        struct /* type */ {

          // drake/systems/framework/system_constraint.h:120
          const char* doc = R"""()""";

        } type;

      } SystemConstraint;

      // drake::systems::SystemConstraintTag
      struct /* SystemConstraintTag */ {

        // drake/systems/framework/system_constraint.h:20
        const char* doc = R"""()""";

      } SystemConstraintTag;

      // drake::systems::SystemConstraintType
      struct /* SystemConstraintType */ {

        // drake/systems/framework/system_constraint.h:22
        const char* doc = R"""()""";

        // drake::systems::SystemConstraintType::kEquality
        struct /* kEquality */ {

          // drake/systems/framework/system_constraint.h:23
          const char* doc = R"""(< The constraint is of the form f(x)=0.)""";

        } kEquality;

        // drake::systems::SystemConstraintType::kInequality
        struct /* kInequality */ {

          // drake/systems/framework/system_constraint.h:24
          const char* doc = R"""(< The constraint is of the form f(x)≥0.)""";

        } kInequality;

      } SystemConstraintType;

      // drake::systems::SystemImpl
      struct /* SystemImpl */ {

        // drake/systems/framework/system.h:41
        const char* doc = R"""()""";

        // drake::systems::SystemImpl::GetMemoryObjectName
        struct /* GetMemoryObjectName */ {

          // drake/systems/framework/system.h:47
          const char* doc = R"""()""";

        } GetMemoryObjectName;

        // drake::systems::SystemImpl::SystemImpl
        struct /* ctor */ {

          // drake/systems/framework/system.h:43
          const char* doc = R"""()""";

          // drake/systems/framework/system.h:43
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system.h:44
          const char* doc_3 = R"""()""";

        } ctor;

      } SystemImpl;

      // drake::systems::SystemOutput
      struct /* SystemOutput */ {

        // drake/systems/framework/system_output.h:30
        const char* doc =
R"""(Conveniently stores a snapshot of the values of every output port of a
System. There is framework support for allocating the right types and
filling them in but otherwise this is not used internally. Note that
there is never any live connection between a SystemOutput object and
the System whose output values it has captured.

A `SystemOutput<T>` object can only be obtained using
`System<T>::AllocateOutput()` or by copying an existing SystemOutput
object.

Template parameter ``T``:
    The type of the output data. Must be a valid Eigen scalar.)""";

        // drake::systems::SystemOutput::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/framework/system_output.h:32
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::SystemOutput::GetMutableData
        struct /* GetMutableData */ {

          // drake/systems/framework/system_output.h:63
          const char* doc =
R"""((Advanced) Returns mutable access to an AbstractValue object that is
suitable for holding the value of output port `index` of the
allocating System. This works for any output port regardless of it
actual type. Most users should just call `System<T>::CalcOutputs()` to
get all the output port values at once.)""";

        } GetMutableData;

        // drake::systems::SystemOutput::GetMutableVectorData
        struct /* GetMutableVectorData */ {

          // drake/systems/framework/system_output.h:73
          const char* doc =
R"""((Advanced) Returns mutable access to a `BasicVector<T>` object that is
suitable for holding the value of output port `index` of the
allocating System. The object's concrete type is preserved from the
output port. Most users should just call `System<T>::CalcOutputs()` to
get all the output port values at once. Throws std::bad_cast if the
port is not vector-valued.)""";

        } GetMutableVectorData;

        // drake::systems::SystemOutput::SystemOutput<T>
        struct /* ctor */ {

          // drake/systems/framework/system_output.h:32
          const char* doc = R"""()""";

          // drake/systems/framework/system_output.h:32
          const char* doc_2 = R"""()""";

        } ctor;

        // drake::systems::SystemOutput::get_data
        struct /* get_data */ {

          // drake/systems/framework/system_output.h:45
          const char* doc =
R"""(Returns the last-saved value of output port `index` as an
AbstractValue. This works for any output port regardless of it actual
type.)""";

        } get_data;

        // drake::systems::SystemOutput::get_num_ports
        struct /* get_num_ports */ {

          // drake/systems/framework/system_output.h:38
          const char* doc =
R"""(Returns the number of output ports specified for this SystemOutput
during allocation.)""";

        } get_num_ports;

        // drake::systems::SystemOutput::get_vector_data
        struct /* get_vector_data */ {

          // drake/systems/framework/system_output.h:53
          const char* doc =
R"""(Returns the last-saved value of output port `index` as a
`BasicVector<T>`, although the actual concrete type is preserved from
the actual output port. Throws std::bad_cast if the port is not
vector-valued.)""";

        } get_vector_data;

      } SystemOutput;

      // drake::systems::SystemScalarConverter
      struct /* SystemScalarConverter */ {

        // drake/systems/framework/system_scalar_converter.h:35
        const char* doc =
R"""(Helper class to convert a System<U> into a System<T>, intended for
internal use by the System framework, not directly by users.

For user-facing documentation see system_scalar_conversion.

Because it is not templated on a System subclass, this class can be
used by LeafSystem without any direct knowledge of the subtypes being
converted. In other words, it enables a runtime flavor of the CRTP.

Throughout this class, the template type `S` must be the most-derived
concrete System subclass. This object may only be used to convert
System<U> objects of runtime type S<U>, not subclasses of S<U>.)""";

        // drake::systems::SystemScalarConverter::Add
        struct /* Add */ {

          // drake/systems/framework/system_scalar_converter.h:129
          const char* doc =
R"""(Registers the std::function to be used to convert a System<U> into a
System<T>. A pair of types can be registered (added) at most once.)""";

          // drake/systems/framework/system_scalar_converter.h:192
          const char* doc_2 =
R"""(Registers the std::function to be used to convert a System<U> into a
System<T>. A pair of types can be registered (added) at most once.)""";

        } Add;

        // drake::systems::SystemScalarConverter::AddIfSupported
        struct /* AddIfSupported */ {

          // drake/systems/framework/system_scalar_converter.h:135
          const char* doc =
R"""(Adds converter for an S<U> into an S<T>, iff scalar_conversion::Traits
says its supported. The converter uses S's scalar-type converting copy
constructor.)""";

        } AddIfSupported;

        // drake::systems::SystemScalarConverter::Convert
        struct /* Convert */ {

          // drake/systems/framework/system_scalar_converter.h:157
          const char* doc =
R"""(Converts a System<U> into a System<T>. This is the API that LeafSystem
uses to provide a default implementation of DoToAutoDiffXd, etc.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";

          // drake/systems/framework/system_scalar_converter.h:212
          const char* doc_2 =
R"""(Converts a System<U> into a System<T>. This is the API that LeafSystem
uses to provide a default implementation of DoToAutoDiffXd, etc.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";

        } Convert;

        // drake::systems::SystemScalarConverter::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/framework/system_scalar_converter.h:37
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation
        struct /* GuaranteedSubtypePreservation */ {

          // drake/systems/framework/system_scalar_converter.h:83
          const char* doc =
R"""(A configuration option for our constructor, controlling whether or not
the Convert implementation requires that the System subclass type is
preserved.)""";

          // drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation::kDisabled
          struct /* kDisabled */ {

            // drake/systems/framework/system_scalar_converter.h:91
            const char* doc =
R"""(The argument to Convert need not be the exact type S that was used to
populate the SystemScalarConverter -- it can be either exactly that S,
or a subtype of that S. This permits subtype information to be lost
across conversion.)""";

          } kDisabled;

          // drake::systems::SystemScalarConverter::GuaranteedSubtypePreservation::kEnabled
          struct /* kEnabled */ {

            // drake/systems/framework/system_scalar_converter.h:86
            const char* doc =
R"""(The argument to Convert must be of the exact type S that was used to
populate the SystemScalarConverter.)""";

          } kEnabled;

        } GuaranteedSubtypePreservation;

        // drake::systems::SystemScalarConverter::IsConvertible
        struct /* IsConvertible */ {

          // drake/systems/framework/system_scalar_converter.h:149
          const char* doc =
R"""(Returns true iff this object can convert a System<U> into a System<T>,
i.e., whether Convert() will return non-null.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";

          // drake/systems/framework/system_scalar_converter.h:206
          const char* doc_2 =
R"""(Returns true iff this object can convert a System<U> into a System<T>,
i.e., whether Convert() will return non-null.

Template parameter ``U``:
    the donor scalar type (to convert from)

Template parameter ``T``:
    the resulting scalar type (to convert into))""";

        } IsConvertible;

        // drake::systems::SystemScalarConverter::RemoveUnlessAlsoSupportedBy
        struct /* RemoveUnlessAlsoSupportedBy */ {

          // drake/systems/framework/system_scalar_converter.h:141
          const char* doc =
R"""(Removes from this converter all pairs where `other.IsConvertible<T,
U>` is false. The subtype `S` need not be the same between this and
`other`.)""";

        } RemoveUnlessAlsoSupportedBy;

        // drake::systems::SystemScalarConverter::SystemScalarConverter
        struct /* ctor */ {

          // drake/systems/framework/system_scalar_converter.h:37
          const char* doc = R"""()""";

          // drake/systems/framework/system_scalar_converter.h:37
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system_scalar_converter.h:42
          const char* doc_3 =
R"""(Creates an object that returns nullptr for all Convert() requests. The
single-argument constructor below is the typical way to create a
useful instance of this type.)""";

          // drake/systems/framework/system_scalar_converter.h:77
          const char* doc_4 =
R"""(Creates an object that uses S's scalar-type converting copy
constructor. That constructor takes the form of, e.g.:

```
template <typename T>
class Foo {
  template <typename U>
  explicit Foo(const Foo<U>& other);
};
```

This constructor only creates a converter between a limited set of
types, specifically:

- double - drake::AutoDiffXd - drake::symbolic::Expression

By default, all non-identity pairs (pairs where T and U differ) drawn
from the above list can be used for T and U. Systems may specialize
scalar_conversion::Traits to disable support for some or all of these
conversions, or after construction may call Add<T, U>() on the
returned object to enable support for additional custom types.

Template parameter ``S``:
    is the System type to convert

This an implicit conversion constructor (not marked `explicit`), in
order to make calling code substantially more readable, with
relatively little risk of an unwanted accidental conversion happening.

See system_scalar_conversion for additional overview documentation.)""";

          // drake/systems/framework/system_scalar_converter.h:100
          const char* doc_5 =
R"""((Advanced) Creates using S's scalar-type converting copy constructor.
Behaves exactly like SystemScalarConverter(SystemTypeTag<S>), but with
the additional option to turn off guaranteed subtype preservation of
the System being converted. In general, subtype preservation is an
important invariant during scalar conversion, so be cautious about
disabling it.)""";

        } ctor;

        // drake::systems::SystemScalarConverter::empty
        struct /* empty */ {

          // drake/systems/framework/system_scalar_converter.h:119
          const char* doc =
R"""(Returns true iff no conversions are supported. (In other words,
whether this is a default-constructed object.))""";

        } empty;

      } SystemScalarConverter;

      // drake::systems::SystemSymbolicInspector
      struct /* SystemSymbolicInspector */ {

        // drake/systems/framework/system_symbolic_inspector.h:38
        const char* doc =
R"""(The SystemSymbolicInspector uses symbolic::Expressions to analyze
various properties of the System, such as time invariance and input-
to-output sparsity, along with many others.

A SystemSymbolicInspector is only interesting if the Context contains
purely vector-valued elements. If any abstract-valued elements are
present, the SystemSymbolicInspector will not be able to parse the
governing equations reliably.

It would be possible to report system properties for a specific
configuration of the abstract inputs, state, or parameters. We
intentionally do not provide such an analysis, because it would invite
developers to shoot themselves in the foot by accidentally overstating
sparsity, for instance if a given input affects a given output in some
modes, but not the mode tested.

Even with that limitation on scope, SystemSymbolicInspector has risks,
if the System contains C++ native conditionals like "if" or "switch".
symbolic::Expression does not provide an implicit conversion to
`bool`, so it is unlikely that anyone will accidentally write a System
that both uses native conditionals and compiles with a
symbolic::Expression scalar type. However, it is possible, for
instance using an explicit cast, or `std::equal_to`.)""";

        // drake::systems::SystemSymbolicInspector::HasAffineDynamics
        struct /* HasAffineDynamics */ {

          // drake/systems/framework/system_symbolic_inspector.h:61
          const char* doc =
R"""(Returns true iff all of the derivatives and discrete updates have at
most an affine dependence on state and input. Note that the return
value does NOT depend on the output methods (they may be affine or
not).)""";

        } HasAffineDynamics;

        // drake::systems::SystemSymbolicInspector::IsConnectedInputToOutput
        struct /* IsConnectedInputToOutput */ {

          // drake/systems/framework/system_symbolic_inspector.h:51
          const char* doc =
R"""(Returns true if the input port at the given ``input_port_index`` is or
might possibly be a term in the output at the given
``output_port_index``.)""";

        } IsConnectedInputToOutput;

        // drake::systems::SystemSymbolicInspector::IsTimeInvariant
        struct /* IsTimeInvariant */ {

          // drake/systems/framework/system_symbolic_inspector.h:56
          const char* doc =
R"""(Returns true if there is no dependence on time in the dynamics
(continuous nor discrete) nor the outputs.)""";

        } IsTimeInvariant;

        // drake::systems::SystemSymbolicInspector::SystemSymbolicInspector
        struct /* ctor */ {

          // drake/systems/framework/system_symbolic_inspector.h:43
          const char* doc =
R"""(Constructs a SystemSymbolicInspector for the given ``system`` by
initializing every vector-valued element in the Context with symbolic
variables.)""";

          // drake/systems/framework/system_symbolic_inspector.h:47
          const char* doc_2 = R"""()""";

          // drake/systems/framework/system_symbolic_inspector.h:47
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::SystemSymbolicInspector::constraints
        struct /* constraints */ {

          // drake/systems/framework/system_symbolic_inspector.h:128
          const char* doc =
R"""(Returns a reference to the symbolic representation of the constraints.)""";

        } constraints;

        // drake::systems::SystemSymbolicInspector::continuous_state
        struct /* continuous_state */ {

          // drake/systems/framework/system_symbolic_inspector.h:81
          const char* doc =
R"""(Returns a reference to the symbolic representation of the continuous
state.)""";

        } continuous_state;

        // drake::systems::SystemSymbolicInspector::derivatives
        struct /* derivatives */ {

          // drake/systems/framework/system_symbolic_inspector.h:107
          const char* doc =
R"""(Returns a copy of the symbolic representation of the continuous-time
dynamics.)""";

        } derivatives;

        // drake::systems::SystemSymbolicInspector::discrete_state
        struct /* discrete_state */ {

          // drake/systems/framework/system_symbolic_inspector.h:88
          const char* doc =
R"""(Returns a reference to the symbolic representation of the discrete
state.

Parameter ``i``:
    The discrete state group number.)""";

        } discrete_state;

        // drake::systems::SystemSymbolicInspector::discrete_update
        struct /* discrete_update */ {

          // drake/systems/framework/system_symbolic_inspector.h:114
          const char* doc =
R"""(Returns a reference to the symbolic representation of the discrete-
time dynamics.

Parameter ``i``:
    The discrete state group number.)""";

        } discrete_update;

        // drake::systems::SystemSymbolicInspector::input
        struct /* input */ {

          // drake/systems/framework/system_symbolic_inspector.h:74
          const char* doc =
R"""(Returns a reference to the symbolic representation of the input.

Parameter ``i``:
    The input port number.)""";

        } input;

        // drake::systems::SystemSymbolicInspector::numeric_parameters
        struct /* numeric_parameters */ {

          // drake/systems/framework/system_symbolic_inspector.h:99
          const char* doc =
R"""(Returns a reference to the symbolic representation of the numeric
parameters.

Parameter ``i``:
    The numeric parameter group number.)""";

        } numeric_parameters;

        // drake::systems::SystemSymbolicInspector::output
        struct /* output */ {

          // drake/systems/framework/system_symbolic_inspector.h:122
          const char* doc =
R"""(Returns a reference to the symbolic representation of the output.

Parameter ``i``:
    The output port number.)""";

        } output;

        // drake::systems::SystemSymbolicInspector::time
        struct /* time */ {

          // drake/systems/framework/system_symbolic_inspector.h:70
          const char* doc =
R"""(@name Reference symbolic components A set of accessor methods that
provide direct access to the symbolic forms of the System. This class
carefully sets up and names all of the symbolic elements of the
Context, and other methods should be able to reap the benefits. @{
Returns a reference to the symbolic representation of time.)""";

        } time;

      } SystemSymbolicInspector;

      // drake::systems::SystemTypeTag
      struct /* SystemTypeTag */ {

        // drake/systems/framework/system_type_tag.h:29
        const char* doc =
R"""(A tag object that denotes a System subclass `S` in function
signatures.

For example, `SystemTypeTag<MySystem>{}` will create a dummy object
that can be used to call functions that look like:

```
template <template <typename> class S>
const char* get_foo(SystemTypeTag<S>) { return S<double>::get_foo(); }

int main() {
   std::cout << get_foo(SystemTypeTag<MySystem>{});
}
```

In this case, we could directly call get_foo<MySystem>() by specifying
the template argument, but that is not always possible. In particular,
tag objects are acutely useful when calling templated constructors,
because there is no other mechanism for the caller to specify the
template type.)""";

        // drake::systems::SystemTypeTag::SystemTypeTag<S>
        struct /* ctor */ {

          // drake/systems/framework/system_type_tag.h:30
          const char* doc = R"""()""";

        } ctor;

      } SystemTypeTag;

      // drake::systems::TimeVaryingAffineSystem
      struct /* TimeVaryingAffineSystem */ {

        // drake/systems/primitives/affine_system.h:41
        const char* doc =
R"""(Base class for a discrete- or continuous-time, time-varying affine
system, with potentially time-varying coefficients.

@system{TimeVaryingAffineSystem, @input_port{u(t)}, @output_port{y(t)}
}

If `time_period > 0.0`, then the affine system will have the state
update: @f[ x(t+h) = A(t) x(t) + B(t) u(t) + f_0(t), @f] where `h` is
the time_period. If `time_period == 0.0`, then the system will have
the time derivatives: @f[ \dot{x}(t) = A(t) x(t) + B(t) u(t) + f_0(t),
@f] where `u` denotes the input vector, `x` denotes the state vector.

In both cases, the system will have the output: @f[ y(t) = C(t) x(t) +
D(t) u(t) + y_0(t), @f] where `y` denotes the output vector.

Template parameter ``T``:
    The scalar element type, which must be a valid Eigen scalar.

See also:
    AffineSystem)""";

        // drake::systems::TimeVaryingAffineSystem::A
        struct /* A */ {

          // drake/systems/primitives/affine_system.h:57
          const char* doc =
R"""(@name Methods To Be Implemented by Subclasses

Implementations must define these, and the returned matrices must be
sized to match the `num_states`, `num_inputs`, and `num_outputs`
specified in the constructor. @{)""";

        } A;

        // drake::systems::TimeVaryingAffineSystem::B
        struct /* B */ {

          // drake/systems/primitives/affine_system.h:58
          const char* doc = R"""()""";

        } B;

        // drake::systems::TimeVaryingAffineSystem::C
        struct /* C */ {

          // drake/systems/primitives/affine_system.h:60
          const char* doc = R"""()""";

        } C;

        // drake::systems::TimeVaryingAffineSystem::CalcOutputY
        struct /* CalcOutputY */ {

          // drake/systems/primitives/affine_system.h:88
          const char* doc =
R"""(Computes @f[ y(t) = C(t) x(t) + D(t) u(t) + y_0(t), @f] with by
calling `C(t)`, `D(t)`, and `y0(t)` with runtime size checks. Derived
classes may override this for performance reasons.)""";

        } CalcOutputY;

        // drake::systems::TimeVaryingAffineSystem::D
        struct /* D */ {

          // drake/systems/primitives/affine_system.h:61
          const char* doc = R"""()""";

        } D;

        // drake::systems::TimeVaryingAffineSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {

          // drake/systems/primitives/affine_system.h:100
          const char* doc =
R"""(Computes @f[ x(t+h) = A(t) x(t) + B(t) u(t) + f_0(t), @f] with by
calling `A(t)`, `B(t)`, and `f0(t)` with runtime size checks. Derived
classes may override this for performance reasons.)""";

        } DoCalcDiscreteVariableUpdates;

        // drake::systems::TimeVaryingAffineSystem::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/systems/primitives/affine_system.h:94
          const char* doc =
R"""(Computes @f[ \dot{x}(t) = A(t) x(t) + B(t) u(t) + f_0(t), @f] with by
calling `A(t)`, `B(t)`, and `f0(t)` with runtime size checks. Derived
classes may override this for performance reasons.)""";

        } DoCalcTimeDerivatives;

        // drake::systems::TimeVaryingAffineSystem::TimeVaryingAffineSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/affine_system.h:43
          const char* doc = R"""()""";

          // drake/systems/primitives/affine_system.h:43
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/affine_system.h:81
          const char* doc_3 =
R"""(Constructor.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.

Parameter ``num_states``:
    size of the system's state vector

Parameter ``num_inputs``:
    size of the system's input vector

Parameter ``num_outputs``:
    size of the system's output vector

Parameter ``time_period``:
    discrete update period, or 0.0 to use continuous time)""";

        } ctor;

        // drake::systems::TimeVaryingAffineSystem::f0
        struct /* f0 */ {

          // drake/systems/primitives/affine_system.h:59
          const char* doc = R"""()""";

        } f0;

        // drake::systems::TimeVaryingAffineSystem::get_input_port
        struct /* get_input_port */ {

          // drake/systems/primitives/affine_system.h:46
          const char* doc =
R"""(Returns the input port containing the externally applied input.)""";

        } get_input_port;

        // drake::systems::TimeVaryingAffineSystem::get_output_port
        struct /* get_output_port */ {

          // drake/systems/primitives/affine_system.h:49
          const char* doc =
R"""(Returns the output port containing the output state.)""";

        } get_output_port;

        // drake::systems::TimeVaryingAffineSystem::num_inputs
        struct /* num_inputs */ {

          // drake/systems/primitives/affine_system.h:67
          const char* doc = R"""()""";

        } num_inputs;

        // drake::systems::TimeVaryingAffineSystem::num_outputs
        struct /* num_outputs */ {

          // drake/systems/primitives/affine_system.h:68
          const char* doc = R"""()""";

        } num_outputs;

        // drake::systems::TimeVaryingAffineSystem::num_states
        struct /* num_states */ {

          // drake/systems/primitives/affine_system.h:66
          const char* doc = R"""()""";

        } num_states;

        // drake::systems::TimeVaryingAffineSystem::time_period
        struct /* time_period */ {

          // drake/systems/primitives/affine_system.h:65
          const char* doc = R"""(@})""";

        } time_period;

        // drake::systems::TimeVaryingAffineSystem::y0
        struct /* y0 */ {

          // drake/systems/primitives/affine_system.h:62
          const char* doc = R"""()""";

        } y0;

      } TimeVaryingAffineSystem;

      // drake::systems::TimeVaryingData
      struct /* TimeVaryingData */ {

        // drake/systems/primitives/time_varying_data.h:58
        const char* doc =
R"""(Stores matrix data necessary to construct an affine time varying
system as a piecewise polynomial trajectory. The trajectory matrices
must adhere to the following dimensions: | Matrix | Num Rows | Num
Columns | |:-------:|:-----------:|:-----------:| | A | num states |
num states | | B | num states | num inputs | | C | num outputs | num
states | | D | num outputs | num inputs | | f0 | num states | 1 | | y0
| num outputs | 1 |)""";

        // drake::systems::TimeVaryingData::A
        struct /* A */ {

          // drake/systems/primitives/time_varying_data.h:87
          const char* doc = R"""()""";

        } A;

        // drake::systems::TimeVaryingData::B
        struct /* B */ {

          // drake/systems/primitives/time_varying_data.h:88
          const char* doc = R"""()""";

        } B;

        // drake::systems::TimeVaryingData::C
        struct /* C */ {

          // drake/systems/primitives/time_varying_data.h:90
          const char* doc = R"""()""";

        } C;

        // drake::systems::TimeVaryingData::D
        struct /* D */ {

          // drake/systems/primitives/time_varying_data.h:91
          const char* doc = R"""()""";

        } D;

        // drake::systems::TimeVaryingData::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/primitives/time_varying_data.h:59
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::TimeVaryingData::TimeVaryingData
        struct /* ctor */ {

          // drake/systems/primitives/time_varying_data.h:59
          const char* doc = R"""()""";

          // drake/systems/primitives/time_varying_data.h:59
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/time_varying_data.h:62
          const char* doc_3 = R"""(Default constructor.)""";

          // drake/systems/primitives/time_varying_data.h:72
          const char* doc_4 =
R"""(Fully-parameterized constructor of vector of MatrixXd; these are
ultimately converted into PiecewisePolynomialTrajectories, whose i-th
element corresponds to time = i * time_period. These vectors are only
well-defined when time_period > 0 (e.g. for discrete-time systems).
The matrix values are interpolated linearly in between time steps.

Parameter ``time_period``:
    The time period from which to construct the time vector.
    time_period must be greater than zero.)""";

          // drake/systems/primitives/time_varying_data.h:80
          const char* doc_5 =
R"""(Fully-parameterized constructor of PiecewisePolynomials.)""";

        } ctor;

        // drake::systems::TimeVaryingData::f0
        struct /* f0 */ {

          // drake/systems/primitives/time_varying_data.h:89
          const char* doc = R"""()""";

        } f0;

        // drake::systems::TimeVaryingData::y0
        struct /* y0 */ {

          // drake/systems/primitives/time_varying_data.h:92
          const char* doc = R"""()""";

        } y0;

      } TimeVaryingData;

      // drake::systems::TimeVaryingLinearSystem
      struct /* TimeVaryingLinearSystem */ {

        // drake/systems/primitives/linear_system.h:119
        const char* doc =
R"""(Base class for a discrete or continuous linear time-varying (LTV)
system.

If `time_period > 0.0`, the system will have the following discrete-
time state update: @f[ x(t+h) = A(t) x(t) + B(t) u(t), @f] where `h`
is the time_period. If `time_period == 0.0`, the system will have the
following continuous-time state update: @f[ \dot{x}(t) = A(t) x(t) +
B(t) u(t), @f]

both with the output: @f[ y(t) = C(t) x(t) + D(t) u(t). @f]

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::TimeVaryingLinearSystem::TimeVaryingLinearSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/linear_system.h:121
          const char* doc = R"""()""";

          // drake/systems/primitives/linear_system.h:121
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/linear_system.h:134
          const char* doc_3 =
R"""(Constructor.

Parameter ``converter``:
    scalar-type conversion support helper (i.e., AutoDiff, etc.); pass
    a default-constructed object if such support is not desired. See
    system_scalar_conversion for detailed background and examples
    related to scalar-type conversion support.

Parameter ``num_states``:
    size of the system's state vector

Parameter ``num_inputs``:
    size of the system's input vector

Parameter ``num_outputs``:
    size of the system's output vector

Parameter ``time_period``:
    discrete update period, or 0.0 to use continuous time)""";

        } ctor;

      } TimeVaryingLinearSystem;

      // drake::systems::TrajectorySource
      struct /* TrajectorySource */ {

        // drake/systems/primitives/trajectory_source.h:28
        const char* doc =
R"""(A source block that generates the value of a Trajectory for a given
time. The output is vector values, and may vary with the time (as
reflected in the context) at which the output is evaluated.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double

They are already available to link against in the containing library.
No other values for T are currently supported.)""";

        // drake::systems::TrajectorySource::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/trajectory_source.h:49
          const char* doc =
R"""(Outputs a vector of values evaluated at the context time of the
trajectory and up to its Nth derivatives, where the trajectory and N
are passed to the constructor. The size of the vector is: (1 +
output_derivative_order) * rows of the trajectory passed to the
constructor.)""";

        } DoCalcVectorOutput;

        // drake::systems::TrajectorySource::TrajectorySource<T>
        struct /* ctor */ {

          // drake/systems/primitives/trajectory_source.h:30
          const char* doc = R"""()""";

          // drake/systems/primitives/trajectory_source.h:30
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/trajectory_source.h:37
          const char* doc_3 =
R"""(Parameter ``trajectory``:
    Trajectory used by the system.

Parameter ``output_derivative_order``:
    The number of times to take the derivative. Must be greater than
    or equal to zero.

Parameter ``zero_derivatives_beyond_limits``:
    All derivatives will be zero before the start time or after the
    end time of ``trajectory``.)""";

        } ctor;

      } TrajectorySource;

      // drake::systems::UnrestrictedUpdateEvent
      struct /* UnrestrictedUpdateEvent */ {

        // drake/systems/framework/event.h:482
        const char* doc =
R"""(This class represents an unrestricted update event. It has an optional
callback function to do custom handling of this event given const
Context and const UnrestrictedUpdateEvent object references, and
writes the updates to a mutable, non-null State object.)""";

        // drake::systems::UnrestrictedUpdateEvent::UnrestrictedUpdateEvent<T>
        struct /* ctor */ {

          // drake/systems/framework/event.h:485
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:498
          const char* doc_2 =
R"""(Makes an UnrestrictedUpdateEvent with no trigger type, no event data,
and no specified callback function.)""";

          // drake/systems/framework/event.h:502
          const char* doc_3 =
R"""(Makes a UnrestrictedUpdateEvent with no trigger type, no event data,
and the specified callback function.)""";

          // drake/systems/framework/event.h:509
          const char* doc_4 = R"""()""";

          // drake/systems/framework/event.h:515
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::systems::UnrestrictedUpdateEvent::add_to_composite
        struct /* add_to_composite */ {

          // drake/systems/framework/event.h:525
          const char* doc =
R"""(Assuming that ``events`` is not null, this function makes a deep copy
of this event and adds the deep copy to ``events``'s collection of
unrestricted update events.)""";

        } add_to_composite;

        // drake::systems::UnrestrictedUpdateEvent::handle
        struct /* handle */ {

          // drake/systems/framework/event.h:535
          const char* doc =
R"""(Calls the optional callback function, if one exists, with ``context``,
`this` and ``discrete_state``.)""";

        } handle;

        // drake::systems::UnrestrictedUpdateEvent::is_discrete_update
        struct /* is_discrete_update */ {

          // drake/systems/framework/event.h:487
          const char* doc = R"""()""";

        } is_discrete_update;

      } UnrestrictedUpdateEvent;

      // drake::systems::Value
      struct /* Value */ {

        // drake/systems/framework/value.h:22
        const char* doc =
R"""(A container class for an arbitrary type T. User-defined classes that
require additional type-erased features should subclass Value<T>,
taking care to define the copy constructors and override Clone().

Template parameter ``T``:
    Must be copy-constructible or cloneable.)""";

        // drake/systems/framework/value.h:252
        const char* doc_2 =
R"""(A container class for an arbitrary type T. User-defined classes that
require additional type-erased features should subclass Value<T>,
taking care to define the copy constructors and override Clone().

Template parameter ``T``:
    Must be copy-constructible or cloneable.)""";

        // drake::systems::Value::Clone
        struct /* Clone */ {

          // drake/systems/framework/value.h:341
          const char* doc = R"""()""";

        } Clone;

        // drake::systems::Value::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/value.h:345
          const char* doc = R"""()""";

        } SetFrom;

        // drake::systems::Value::SetFromOrThrow
        struct /* SetFromOrThrow */ {

          // drake/systems/framework/value.h:349
          const char* doc = R"""()""";

        } SetFromOrThrow;

        // drake::systems::Value::Value<T>
        struct /* ctor */ {

          // drake/systems/framework/value.h:254
          const char* doc = R"""()""";

          // drake/systems/framework/value.h:254
          const char* doc_2 = R"""()""";

          // drake/systems/framework/value.h:264
          const char* doc_3 = R"""()""";

          // drake/systems/framework/value.h:267
          const char* doc_4 =
R"""(Constructs a Value<T> by copying or cloning the given value ``v``.)""";

          // drake/systems/framework/value.h:292
          const char* doc_5 = R"""()""";

          // drake/systems/framework/value.h:309
          const char* doc_6 = R"""()""";

          // drake/systems/framework/value.h:316
          const char* doc_7 =
R"""(Constructs a Value<T> by copying or moving the given value ``v``. @pre
v is non-null)""";

        } ctor;

        // drake::systems::Value::get_mutable_value
        struct /* get_mutable_value */ {

          // drake/systems/framework/value.h:361
          const char* doc =
R"""(Returns a mutable reference to the stored value.)""";

        } get_mutable_value;

        // drake::systems::Value::get_value
        struct /* get_value */ {

          // drake/systems/framework/value.h:358
          const char* doc =
R"""(Returns a const reference to the stored value.)""";

        } get_value;

        // drake::systems::Value::set_value
        struct /* set_value */ {

          // drake/systems/framework/value.h:364
          const char* doc =
R"""(Replaces the stored value with a new one.)""";

        } set_value;

        // drake::systems::Value::type_info
        struct /* type_info */ {

          // drake/systems/framework/value.h:353
          const char* doc = R"""()""";

        } type_info;

      } Value;

      // drake::systems::VectorBase
      struct /* VectorBase */ {

        // drake/systems/framework/vector_base.h:27
        const char* doc =
R"""(VectorBase is an abstract base class that real-valued signals between
Systems and real-valued System state vectors must implement. Classes
that inherit from VectorBase will typically provide names for the
elements of the vector, and may also provide other computations for
the convenience of Systems handling the signal. The vector is always a
column vector. It may or may not be contiguous in memory. Contiguous
subclasses should typically inherit from BasicVector, not from
VectorBase directly.

Template parameter ``T``:
    Must be a Scalar compatible with Eigen.)""";

        // drake::systems::VectorBase::CalcInequalityConstraint
        struct /* CalcInequalityConstraint */ {

          // drake/systems/framework/vector_base.h:178
          const char* doc =
R"""(Populates a vector ``value`` suitable for a SystemConstraint
inequality constraint. For all indices `i` in the result vector, the
validity constraint is `result[i] >= 0`. For a given subclass type,
the size of the result must not vary over time. The VectorBase default
implementation sets the ``value`` to be empty (no constraints).)""";

        } CalcInequalityConstraint;

        // drake::systems::VectorBase::CopyToVector
        struct /* CopyToVector */ {

          // drake/systems/framework/vector_base.h:98
          const char* doc =
R"""(Copies the entire state to a vector with no semantics.

Implementations should ensure this operation is O(N) in the size of
the value and allocates only the O(N) memory that it returns.)""";

        } CopyToVector;

        // drake::systems::VectorBase::DoPlusEqScaled
        struct /* DoPlusEqScaled */ {

          // drake/systems/framework/vector_base.h:196
          const char* doc =
R"""(Adds in multiple scaled vectors to this vector. All vectors are
guaranteed to be the same size.

You should override this method if possible with a more efficient
approach that leverages structure; the default implementation performs
element-by-element computations that are likely inefficient, but even
this implementation minimizes memory accesses for efficiency. If the
vector is contiguous, for example, implementations that leverage SIMD
operations should be far more efficient. Overriding implementations
should ensure that this operation remains O(N) in the size of the
value and allocates no memory.)""";

        } DoPlusEqScaled;

        // drake::systems::VectorBase::GetAtIndex
        struct /* GetAtIndex */ {

          // drake/systems/framework/vector_base.h:45
          const char* doc =
R"""(Returns the element at the given index in the vector. Throws
std::runtime_error if the index is >= size().

Implementations should ensure this operation is O(1) and allocates no
memory.)""";

          // drake/systems/framework/vector_base.h:52
          const char* doc_2 =
R"""(Returns the element at the given index in the vector. Throws
std::runtime_error if the index is >= size().

Implementations should ensure this operation is O(1) and allocates no
memory.)""";

        } GetAtIndex;

        // drake::systems::VectorBase::NormInf
        struct /* NormInf */ {

          // drake/systems/framework/vector_base.h:160
          const char* doc =
R"""(Computes the infinity norm for this vector.

You should override this method if possible with a more efficient
approach that leverages structure; the default implementation performs
element-by-element computations that are likely inefficient. If the
vector is contiguous, for example, Eigen implementations should be far
more efficient. Overriding implementations should ensure that this
operation remains O(N) in the size of the value and allocates no
memory.)""";

        } NormInf;

        // drake::systems::VectorBase::PlusEqScaled
        struct /* PlusEqScaled */ {

          // drake/systems/framework/vector_base.h:123
          const char* doc =
R"""(Add in scaled vector ``rhs`` to this vector. Both vectors must be the
same size.)""";

          // drake/systems/framework/vector_base.h:129
          const char* doc_2 =
R"""(Add in multiple scaled vectors to this vector. All vectors must be the
same size.)""";

        } PlusEqScaled;

        // drake::systems::VectorBase::ScaleAndAddToVector
        struct /* ScaleAndAddToVector */ {

          // drake/systems/framework/vector_base.h:113
          const char* doc =
R"""(Adds a scaled version of this vector to Eigen vector ``vec``, which
must be the same size.

Implementations may override this default implementation with a more
efficient approach, for instance if this vector is contiguous.
Implementations should ensure this operation remains O(N) in the size
of the value and allocates no memory.)""";

        } ScaleAndAddToVector;

        // drake::systems::VectorBase::SetAtIndex
        struct /* SetAtIndex */ {

          // drake/systems/framework/vector_base.h:59
          const char* doc =
R"""(Replaces the state at the given index with the value. Throws
std::runtime_error if the index is >= size().)""";

        } SetAtIndex;

        // drake::systems::VectorBase::SetFrom
        struct /* SetFrom */ {

          // drake/systems/framework/vector_base.h:68
          const char* doc =
R"""(Replaces the entire vector with the contents of ``value``. Throws
std::runtime_error if ``value`` is not a column vector with size()
rows.

Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.)""";

        } SetFrom;

        // drake::systems::VectorBase::SetFromVector
        struct /* SetFromVector */ {

          // drake/systems/framework/vector_base.h:80
          const char* doc =
R"""(Replaces the entire vector with the contents of ``value``. Throws
std::runtime_error if ``value`` is not a column vector with size()
rows.

Implementations should ensure this operation is O(N) in the size of
the value and allocates no memory.)""";

        } SetFromVector;

        // drake::systems::VectorBase::SetZero
        struct /* SetZero */ {

          // drake/systems/framework/vector_base.h:87
          const char* doc = R"""()""";

        } SetZero;

        // drake::systems::VectorBase::VectorBase<T>
        struct /* ctor */ {

          // drake/systems/framework/vector_base.h:30
          const char* doc = R"""()""";

          // drake/systems/framework/vector_base.h:30
          const char* doc_2 = R"""()""";

          // drake/systems/framework/vector_base.h:183
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::VectorBase::operator+=
        struct /* operator_iadd */ {

          // drake/systems/framework/vector_base.h:142
          const char* doc = R"""(Add in vector ``rhs`` to this vector.)""";

        } operator_iadd;

        // drake::systems::VectorBase::operator-=
        struct /* operator_isub */ {

          // drake/systems/framework/vector_base.h:147
          const char* doc =
R"""(Subtract in vector ``rhs`` to this vector.)""";

        } operator_isub;

        // drake::systems::VectorBase::operator[]
        struct /* operator_array */ {

          // drake/systems/framework/vector_base.h:54
          const char* doc = R"""()""";

          // drake/systems/framework/vector_base.h:55
          const char* doc_2 = R"""()""";

        } operator_array;

        // drake::systems::VectorBase::size
        struct /* size */ {

          // drake/systems/framework/vector_base.h:38
          const char* doc =
R"""(Returns the number of elements in the vector.

Implementations should ensure this operation is O(1) and allocates no
memory.)""";

        } size;

      } VectorBase;

      // drake::systems::VectorSystem
      struct /* VectorSystem */ {

        // drake/systems/framework/vector_system.h:29
        const char* doc =
R"""(A base class that specializes LeafSystem for use with only zero or one
vector input ports, and only zero or one vector output ports.

By default, this base class does not declare any state; subclasses may
optionally declare continuous or discrete state, but not both;
subclasses may not declare abstract state.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.)""";

        // drake::systems::VectorSystem::CalcVectorOutput
        struct /* CalcVectorOutput */ {

          // drake/systems/framework/vector_system.h:181
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorOutput().)""";

        } CalcVectorOutput;

        // drake::systems::VectorSystem::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {

          // drake/systems/framework/vector_system.h:149
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorDiscreteVariableUpdates().)""";

        } DoCalcDiscreteVariableUpdates;

        // drake::systems::VectorSystem::DoCalcTimeDerivatives
        struct /* DoCalcTimeDerivatives */ {

          // drake/systems/framework/vector_system.h:121
          const char* doc =
R"""(Converts the parameters to Eigen::VectorBlock form, then delegates to
DoCalcVectorTimeDerivatives().)""";

        } DoCalcTimeDerivatives;

        // drake::systems::VectorSystem::DoCalcVectorDiscreteVariableUpdates
        struct /* DoCalcVectorDiscreteVariableUpdates */ {

          // drake/systems/framework/vector_system.h:298
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as
System::DoCalcDiscreteVariableUpdates but provides VectorBlocks to
represent the input, discrete state, and discrete updates. Subclasses
should override this method, and not the base class method (which is
`final`).

The ``state`` will be either empty or the discrete state, depending on
whether discrete state was declared at context-creation time.

By default, this function does nothing if the ``next_state`` is empty,
and throws an exception otherwise.)""";

        } DoCalcVectorDiscreteVariableUpdates;

        // drake::systems::VectorSystem::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/framework/vector_system.h:258
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as System::DoCalcOutput but
provides VectorBlocks to represent the input, state, and output.
Subclasses with outputs should override this method, and not the base
class method (which is `final`).

The ``state`` will be either empty, the continuous state, or the
discrete state, depending on which (or none) was declared at context-
creation time.

The ``input`` will be empty (zero-sized) when this System is declared
to be non-direct-feedthrough.

By default, this function does nothing if the ``output`` is empty, and
throws an exception otherwise.)""";

        } DoCalcVectorOutput;

        // drake::systems::VectorSystem::DoCalcVectorTimeDerivatives
        struct /* DoCalcVectorTimeDerivatives */ {

          // drake/systems/framework/vector_system.h:277
          const char* doc =
R"""(Provides a convenience method for VectorSystem subclasses. This method
performs the same logical operation as System::DoCalcTimeDerivatives
but provides VectorBlocks to represent the input, continuous state,
and derivatives. Subclasses should override this method, and not the
base class method (which is `final`). The ``state`` will be either
empty or the continuous state, depending on whether continuous state
was declared at context-creation time.

By default, this function does nothing if the ``derivatives`` are
empty, and throws an exception otherwise.)""";

        } DoCalcVectorTimeDerivatives;

        // drake::systems::VectorSystem::EvalVectorInput
        struct /* EvalVectorInput */ {

          // drake/systems/framework/vector_system.h:91
          const char* doc =
R"""(Causes the vector-valued input port to become up-to-date, and returns
the port's value as an Eigen vector. If the system has zero inputs,
then returns an empty vector.)""";

        } EvalVectorInput;

        // drake::systems::VectorSystem::GetVectorState
        struct /* GetVectorState */ {

          // drake/systems/framework/vector_system.h:103
          const char* doc =
R"""(Returns a reference to an Eigen vector version of the state from
within the Context.)""";

        } GetVectorState;

        // drake::systems::VectorSystem::VectorSystem<T>
        struct /* ctor */ {

          // drake/systems/framework/vector_system.h:31
          const char* doc = R"""()""";

          // drake/systems/framework/vector_system.h:31
          const char* doc_2 = R"""()""";

          // drake/systems/framework/vector_system.h:62
          const char* doc_3 =
R"""(Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created.

Does *not* declare scalar-type conversion support (AutoDiff, etc.). To
enable AutoDiff support, use the SystemScalarConverter-based
constructor. (For that, see system_scalar_conversion at the example
titled "Example using drake::systems::VectorSystem as the base
class".))""";

          // drake/systems/framework/vector_system.h:77
          const char* doc_4 =
R"""(Creates a system with one input port and one output port of the given
sizes, when the sizes are non-zero. Either size can be zero, in which
case no input (or output) port is created. This constructor allows
subclasses to declare scalar-type conversion support (AutoDiff, etc.).

The scalar-type conversion support will use ``converter``. To enable
scalar-type conversion support, pass a `SystemTypeTag<S>{}` where `S`
must be the exact class of `this` being constructed.

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support, especially the example
titled "Example using drake::systems::VectorSystem as the base class".)""";

        } ctor;

        // drake::systems::VectorSystem::get_input_port
        struct /* get_input_port */ {

          // drake/systems/framework/vector_system.h:36
          const char* doc = R"""(Returns the sole input port.)""";

          // drake/systems/framework/vector_system.h:42
          const char* doc_2 = R"""()""";

        } get_input_port;

        // drake::systems::VectorSystem::get_output_port
        struct /* get_output_port */ {

          // drake/systems/framework/vector_system.h:45
          const char* doc = R"""(Returns the sole output port.)""";

          // drake/systems/framework/vector_system.h:51
          const char* doc_2 = R"""()""";

        } get_output_port;

      } VectorSystem;

      // drake::systems::ViewerDrawTranslator
      struct /* ViewerDrawTranslator */ {

        // drake/multibody/rigid_body_plant/viewer_draw_translator.h:21
        const char* doc =
R"""(Specializes `LcmAndVectorBaseTranslator` to handle LCM messages of
type `drake::lcmt_viewer_draw`. It translates between a
VectorBase<double> that contains the position or state vector of a
RigidBodyTree, and a `drake::lcmt_viewer_draw` message.)""";

        // drake::systems::ViewerDrawTranslator::Deserialize
        struct /* Deserialize */ {

          // drake/multibody/rigid_body_plant/viewer_draw_translator.h:42
          const char* doc =
R"""(**This method must not be called.** It is not implemented and will
abort if called. The method <i>could</i> be implement should the need
arise.)""";

        } Deserialize;

        // drake::systems::ViewerDrawTranslator::Serialize
        struct /* Serialize */ {

          // drake/multibody/rigid_body_plant/viewer_draw_translator.h:46
          const char* doc = R"""()""";

        } Serialize;

        // drake::systems::ViewerDrawTranslator::ViewerDrawTranslator
        struct /* ctor */ {

          // drake/multibody/rigid_body_plant/viewer_draw_translator.h:23
          const char* doc = R"""()""";

          // drake/multibody/rigid_body_plant/viewer_draw_translator.h:23
          const char* doc_2 = R"""()""";

          // drake/multibody/rigid_body_plant/viewer_draw_translator.h:36
          const char* doc_3 =
R"""(A constructor that sets the expected size of both the LCM message and
VectorBase vector to be the size of the position vector of ``tree``.
However, the Serialize() method will also accept input the size of the
state vector of ``tree``, which is the sum of the number of position
and velocity states in ``tree``.

Parameter ``tree``:
    A reference to the RigidBodyTree with which to obtain the pose of
    each RigidBody to be included in the `drake::lcmt_viewer_draw` LCM
    message. This reference must remain valid for the lifetime of this
    object.)""";

        } ctor;

      } ViewerDrawTranslator;

      // drake::systems::WitnessFunction
      struct /* WitnessFunction */ {

        // drake/systems/framework/event.h:16
        const char* doc =
R"""(Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::DeclareWitnessFunction().

For the ensuing discussion, consider two times (`t₀` and `t₁ > t₀`)
and states corresponding to those times (`x(t₀)` and `x(t₁)`). A
witness function, `w(t, x)`, "triggers" only when it crosses zero at a
time `t*` where `t₀ < t* ≤ t₁`. Note the half-open interval. For an
example of a witness function, consider the "signed distance" (i.e.,
Euclidean distance when bodies are disjoint and minimum translational
distance when bodies intersect) between two rigid bodies; this witness
function can be used to determine both the time of impact for rigid
bodies and their states at that time of impact.

Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, `w(t₀, x(t₀)) ≠ 0`, `w(t₁, x(t₁)) = 0`, and `w(t₂, x(t₂)) ≠
0`, for some t₂ > t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if `w(t₀, x(t₀)) ≠ 0`, `w(t*, x(t*)) = 0`, and `w(t₁,
x(t₁)) = 0`, for `t* ∈ (t₀, t₁)`. We can define the trigger condition
formally over interval `[t₀, t₁]` using the function:

```
T(w, t₀, x(t₀), t₁) =   1   if w(t₀, x(t₀)) ≠ 0 and
                               w(t₀, x(t₀))⋅w(t₁, x(t₁)) ≤ 0
                        0   if w(t₀, x(t₀)) = 0 or
                               w(t₀, x(t₀))⋅w(t₁, x(t₁)) > 0
```

We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.

A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
"bracketed" over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.

A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length *and that each function evaluation (which
requires numerical integration) is extraordinarily expensive*. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it's a reliable choice and always converges linearly.)""";

        // drake/systems/framework/witness_function.h:91
        const char* doc_2 =
R"""(Class that stores a function that is able to help determine the time
and state at which a step of the initial value problem integration of
a System should end, which may be done for any number of purposes,
including publishing or state reinitialization (i.e., event handling).
System authors declare witness functions through
LeafSystem::DeclareWitnessFunction().

For the ensuing discussion, consider two times (`t₀` and `t₁ > t₀`)
and states corresponding to those times (`x(t₀)` and `x(t₁)`). A
witness function, `w(t, x)`, "triggers" only when it crosses zero at a
time `t*` where `t₀ < t* ≤ t₁`. Note the half-open interval. For an
example of a witness function, consider the "signed distance" (i.e.,
Euclidean distance when bodies are disjoint and minimum translational
distance when bodies intersect) between two rigid bodies; this witness
function can be used to determine both the time of impact for rigid
bodies and their states at that time of impact.

Precision in the definition of the witness function is necessary,
because we want the witness function to trigger only once if, for
example, `w(t₀, x(t₀)) ≠ 0`, `w(t₁, x(t₁)) = 0`, and `w(t₂, x(t₂)) ≠
0`, for some t₂ > t₁. In other words, if the witness function is
evaluated over the intervals [t₀, t₁] and [t₁, t₂], meaning that the
zero occurs precisely at an interval endpoint, the witness function
should trigger once. Similarly, the witness function should trigger
exactly once if `w(t₀, x(t₀)) ≠ 0`, `w(t*, x(t*)) = 0`, and `w(t₁,
x(t₁)) = 0`, for `t* ∈ (t₀, t₁)`. We can define the trigger condition
formally over interval `[t₀, t₁]` using the function:

```
T(w, t₀, x(t₀), t₁) =   1   if w(t₀, x(t₀)) ≠ 0 and
                               w(t₀, x(t₀))⋅w(t₁, x(t₁)) ≤ 0
                        0   if w(t₀, x(t₀)) = 0 or
                               w(t₀, x(t₀))⋅w(t₁, x(t₁)) > 0
```

We wish for the witness function to trigger if the trigger function
evaluates to one. The trigger function can be further modified, if
desired, to incorporate the constraint that the witness function
should trigger only when crossing from positive values to negative
values, or vice versa.

A good witness function should not cross zero repeatedly over a small
interval of time (relative to the maximum designated integration step
size) or over small changes in state; when a witness function has been
"bracketed" over an interval of time (i.e., it changes sign), that
witness function will ideally cross zero only once in that interval.

A witness function trigger time is isolated only to a small interval
of time (as described in Simulator). The disadvantage of this scheme
is that it always requires the length of the interval to be reduced to
the requisite length *and that each function evaluation (which
requires numerical integration) is extraordinarily expensive*. If, for
example, the (slow) bisection algorithm were used to isolate the time
interval, the number of integrations necessary to cut the interval
from a length of ℓ to a length of ε will be log₂(ℓ / ε). Bisection is
just one of several possible algorithms for isolating the time
interval, though it's a reliable choice and always converges linearly.)""";

        // drake::systems::WitnessFunction::CalcWitnessValue
        struct /* CalcWitnessValue */ {

          // drake/systems/framework/witness_function.h:183
          const char* doc =
R"""(Evaluates the witness function at the given context.)""";

        } CalcWitnessValue;

        // drake::systems::WitnessFunction::WitnessFunction<T>
        struct /* ctor */ {

          // drake/systems/framework/witness_function.h:93
          const char* doc = R"""()""";

          // drake/systems/framework/witness_function.h:93
          const char* doc_2 = R"""()""";

          // drake/systems/framework/witness_function.h:118
          const char* doc_3 = R"""()""";

          // drake/systems/framework/witness_function.h:127
          const char* doc_4 = R"""()""";

          // drake/systems/framework/witness_function.h:144
          const char* doc_5 = R"""()""";

          // drake/systems/framework/witness_function.h:161
          const char* doc_6 = R"""()""";

        } ctor;

        // drake::systems::WitnessFunction::description
        struct /* description */ {

          // drake/systems/framework/witness_function.h:177
          const char* doc =
R"""(Gets the description of this witness function (used primarily for
logging and debugging).)""";

        } description;

        // drake::systems::WitnessFunction::direction_type
        struct /* direction_type */ {

          // drake/systems/framework/witness_function.h:180
          const char* doc =
R"""(Gets the direction(s) under which this witness function triggers.)""";

        } direction_type;

        // drake::systems::WitnessFunction::get_event
        struct /* get_event */ {

          // drake/systems/framework/witness_function.h:226
          const char* doc =
R"""(Gets the event that will be dispatched when the witness function
triggers. A null pointer indicates that no event will be dispatched.)""";

        } get_event;

        // drake::systems::WitnessFunction::get_mutable_event
        struct /* get_mutable_event */ {

          // drake/systems/framework/witness_function.h:230
          const char* doc =
R"""(Gets a mutable pointer to the event that will occur when the witness
function triggers.)""";

        } get_mutable_event;

        // drake::systems::WitnessFunction::get_system
        struct /* get_system */ {

          // drake/systems/framework/witness_function.h:189
          const char* doc =
R"""(Gets a reference to the System used by this witness function.)""";

        } get_system;

        // drake::systems::WitnessFunction::set_event
        struct /* set_event */ {

          // drake/systems/framework/witness_function.h:220
          const char* doc =
R"""(Sets the event that will be dispatched when the witness function
triggers. If ``e`` is null, no event will be dispatched.)""";

        } set_event;

        // drake::systems::WitnessFunction::should_trigger
        struct /* should_trigger */ {

          // drake/systems/framework/witness_function.h:194
          const char* doc =
R"""(Checks whether the witness function should trigger using given values
at w0 and wf. Note that this function is not specific to a particular
witness function.)""";

        } should_trigger;

      } WitnessFunction;

      // drake::systems::WitnessFunctionDirection
      struct /* WitnessFunctionDirection */ {

        // drake/systems/framework/witness_function.h:18
        const char* doc = R"""()""";

        // drake::systems::WitnessFunctionDirection::kCrossesZero
        struct /* kCrossesZero */ {

          // drake/systems/framework/witness_function.h:34
          const char* doc =
R"""(Witness function triggers *any time* the function crosses/touches
zero, *except* when the witness function evaluates to zero at the
beginning of the interval. Conceptually equivalent to
kPositiveThenNonNegative OR kNegativeThenNonNegative.)""";

        } kCrossesZero;

        // drake::systems::WitnessFunctionDirection::kNegativeThenNonNegative
        struct /* kNegativeThenNonNegative */ {

          // drake/systems/framework/witness_function.h:28
          const char* doc =
R"""(Witness function triggers when the function crosses or touches zero
after an initial negative evaluation.)""";

        } kNegativeThenNonNegative;

        // drake::systems::WitnessFunctionDirection::kNone
        struct /* kNone */ {

          // drake/systems/framework/witness_function.h:20
          const char* doc =
R"""(This witness function will never be triggered.)""";

        } kNone;

        // drake::systems::WitnessFunctionDirection::kPositiveThenNonPositive
        struct /* kPositiveThenNonPositive */ {

          // drake/systems/framework/witness_function.h:24
          const char* doc =
R"""(Witness function triggers when the function crosses or touches zero
after an initial positive evaluation.)""";

        } kPositiveThenNonPositive;

      } WitnessFunctionDirection;

      // drake::systems::WitnessTriggeredEventData
      struct /* WitnessTriggeredEventData */ {

        // drake/systems/framework/event.h:90
        const char* doc =
R"""(Class for storing data from a witness function triggering to be passed
to event handlers. A witness function isolates the time to a
(typically small) window during which the witness function crosses
zero. The time and state at both sides of this window are passed to
the event handler so that the system can precisely determine the
reason that the witness function triggered.)""";

        // drake::systems::WitnessTriggeredEventData::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/systems/framework/event.h:93
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::systems::WitnessTriggeredEventData::WitnessTriggeredEventData<T>
        struct /* ctor */ {

          // drake/systems/framework/event.h:92
          const char* doc = R"""()""";

          // drake/systems/framework/event.h:93
          const char* doc_2 = R"""()""";

          // drake/systems/framework/event.h:93
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::systems::WitnessTriggeredEventData::set_t0
        struct /* set_t0 */ {

          // drake/systems/framework/event.h:111
          const char* doc =
R"""(Sets the time at the left end of the window. Note that `t0` should be
smaller than `tf` after both values are set.)""";

        } set_t0;

        // drake::systems::WitnessTriggeredEventData::set_tf
        struct /* set_tf */ {

          // drake/systems/framework/event.h:119
          const char* doc =
R"""(Sets the time at the right end of the window. Note that `tf` should be
larger than `t0` after both values are set.)""";

        } set_tf;

        // drake::systems::WitnessTriggeredEventData::set_triggered_witness
        struct /* set_triggered_witness */ {

          // drake/systems/framework/event.h:101
          const char* doc =
R"""(Sets the witness function that triggered the event handler.)""";

        } set_triggered_witness;

        // drake::systems::WitnessTriggeredEventData::set_xc0
        struct /* set_xc0 */ {

          // drake/systems/framework/event.h:127
          const char* doc =
R"""(Sets a pointer to the continuous state at the left end of the
isolation window.)""";

        } set_xc0;

        // drake::systems::WitnessTriggeredEventData::set_xcf
        struct /* set_xcf */ {

          // drake/systems/framework/event.h:135
          const char* doc =
R"""(Sets a pointer to the continuous state at the right end of the
isolation window.)""";

        } set_xcf;

        // drake::systems::WitnessTriggeredEventData::t0
        struct /* t0 */ {

          // drake/systems/framework/event.h:107
          const char* doc =
R"""(Gets the time at the left end of the window. Default is NaN (which
indicates that the value is invalid).)""";

        } t0;

        // drake::systems::WitnessTriggeredEventData::tf
        struct /* tf */ {

          // drake/systems/framework/event.h:115
          const char* doc =
R"""(Gets the time at the right end of the window. Default is NaN (which
indicates that the value is invalid).)""";

        } tf;

        // drake::systems::WitnessTriggeredEventData::triggered_witness
        struct /* triggered_witness */ {

          // drake/systems/framework/event.h:96
          const char* doc =
R"""(Gets the witness function that triggered the event handler.)""";

        } triggered_witness;

        // drake::systems::WitnessTriggeredEventData::xc0
        struct /* xc0 */ {

          // drake/systems/framework/event.h:123
          const char* doc =
R"""(Gets a pointer to the continuous state at the left end of the
isolation window.)""";

        } xc0;

        // drake::systems::WitnessTriggeredEventData::xcf
        struct /* xcf */ {

          // drake/systems/framework/event.h:131
          const char* doc =
R"""(Gets a pointer to the continuous state at the right end of the
isolation window.)""";

        } xcf;

      } WitnessTriggeredEventData;

      // drake::systems::WrapToSystem
      struct /* WrapToSystem */ {

        // drake/systems/primitives/wrap_to_system.h:25
        const char* doc =
R"""(An element-wise wrapping block that transforms the specified indices
of the input signal `u` into the interval `[low, high)`. Precisely,
the output element `i` is given the value: outputᵢ = inputᵢ +
kᵢ*(highᵢ-lowᵢ) for the unique integer value `kᵢ` that lands the
output in the desired interval.

Instantiated templates for the following scalar types ``T`` are
provided: - double - AutoDiffXd - symbolic::Expression)""";

        // drake::systems::WrapToSystem::WrapToSystem<T>
        struct /* ctor */ {

          // drake/systems/primitives/wrap_to_system.h:27
          const char* doc = R"""()""";

          // drake/systems/primitives/wrap_to_system.h:27
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/wrap_to_system.h:32
          const char* doc_3 =
R"""(Constructs a system to pass through a fixed-size input vector to the
output. Additional calls to set_interval() are required to produce any
wrapping behavior.)""";

        } ctor;

        // drake::systems::WrapToSystem::get_size
        struct /* get_size */ {

          // drake/systems/primitives/wrap_to_system.h:41
          const char* doc = R"""(Returns the size.)""";

        } get_size;

        // drake::systems::WrapToSystem::set_interval
        struct /* set_interval */ {

          // drake/systems/primitives/wrap_to_system.h:38
          const char* doc =
R"""(Sets the system to wrap the ``index`` element of the input vector to
the interval `[low, high)`. If this method is called multiple times
for the same index, then only the last interval will be used. ``low``
and ``high`` should be finite, and low < high.)""";

        } set_interval;

      } WrapToSystem;

      // drake::systems::ZeroOrderHold
      struct /* ZeroOrderHold */ {

        // drake/systems/primitives/zero_order_hold.h:21
        const char* doc =
R"""(A ZeroOrderHold block with input `u`, which may be vector-valued
(discrete or continuous) or abstract, and discrete output `y`, where
the y is sampled from u with a fixed period.

Note:
    For an abstract-valued ZeroOrderHold, transmografication is not
    supported since AbstractValue does not support it.)""";

        // drake::systems::ZeroOrderHold::DoCalcAbstractOutput
        struct /* DoCalcAbstractOutput */ {

          // drake/systems/primitives/zero_order_hold-inl.h:84
          const char* doc = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:82
          const char* doc_2 = R"""()""";

        } DoCalcAbstractOutput;

        // drake::systems::ZeroOrderHold::DoCalcDiscreteVariableUpdates
        struct /* DoCalcDiscreteVariableUpdates */ {

          // drake/systems/primitives/zero_order_hold-inl.h:73
          const char* doc = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:76
          const char* doc_2 = R"""()""";

        } DoCalcDiscreteVariableUpdates;

        // drake::systems::ZeroOrderHold::DoCalcUnrestrictedUpdate
        struct /* DoCalcUnrestrictedUpdate */ {

          // drake/systems/primitives/zero_order_hold-inl.h:95
          const char* doc = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:87
          const char* doc_2 = R"""()""";

        } DoCalcUnrestrictedUpdate;

        // drake::systems::ZeroOrderHold::DoCalcVectorOutput
        struct /* DoCalcVectorOutput */ {

          // drake/systems/primitives/zero_order_hold-inl.h:64
          const char* doc = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:71
          const char* doc_2 = R"""()""";

        } DoCalcVectorOutput;

        // drake::systems::ZeroOrderHold::DoHasDirectFeedthrough
        struct /* DoHasDirectFeedthrough */ {

          // drake/systems/primitives/zero_order_hold-inl.h:109
          const char* doc = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:66
          const char* doc_2 = R"""()""";

        } DoHasDirectFeedthrough;

        // drake::systems::ZeroOrderHold::ZeroOrderHold<T>
        struct /* ctor */ {

          // drake/systems/primitives/zero_order_hold-inl.h:57
          const char* doc =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";

          // drake/systems/primitives/zero_order_hold.h:23
          const char* doc_2 = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:23
          const char* doc_3 = R"""()""";

          // drake/systems/primitives/zero_order_hold.h:28
          const char* doc_4 =
R"""(Constructs a ZeroOrderHold system with the given ``period_sec``, over
a vector-valued input of size `vector_size`. The default initial value
for this system will be zero.)""";

          // drake/systems/primitives/zero_order_hold.h:34
          const char* doc_5 =
R"""(Constructs a ZeroOrderHold system with the given ``period_sec``, over
a abstract-valued input `abstract_model_value`. The default initial
value for this system will be `abstract_model_value`.)""";

          // drake/systems/primitives/zero_order_hold.h:40
          const char* doc_6 =
R"""(Scalar-type converting copy constructor. See system_scalar_conversion.)""";

        } ctor;

        // drake::systems::ZeroOrderHold::get_input_port
        struct /* get_input_port */ {

          // drake/systems/primitives/zero_order_hold.h:48
          const char* doc = R"""(Returns the sole input port.)""";

          // drake/systems/primitives/zero_order_hold.h:53
          const char* doc_2 = R"""()""";

        } get_input_port;

        // drake::systems::ZeroOrderHold::get_output_port
        struct /* get_output_port */ {

          // drake/systems/primitives/zero_order_hold.h:56
          const char* doc = R"""(Returns the sole output port.)""";

          // drake/systems/primitives/zero_order_hold.h:61
          const char* doc_2 = R"""()""";

        } get_output_port;

      } ZeroOrderHold;

      // analysis
      struct /* analysis */ {

        // drake::systems::analysis::SampleBasedLyapunovAnalysis
        struct /* SampleBasedLyapunovAnalysis */ {

          // drake/systems/analysis/lyapunov.h:55
          const char* doc =
R"""(Sets up a linear program to search for the coefficients of a Lyapunov
function that satisfies the Lyapunov conditions at a set of sample
points. ∀xᵢ, V(xᵢ) ≥ 0, ∀xᵢ, V̇(xᵢ) = ∂V/∂x f(xᵢ) ≤ 0. In order to
provide boundary conditions to the problem, and improve numerical
conditioning, we additionally impose the constraint V(x₀) = 0, and add
an objective that pushes V̇(xᵢ) towards -1 (time-to-go): min ∑ |V̇(xᵢ)
+ 1|.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=lyapunov
. It currently requires that the system to be optimized has only
continuous state and it is assumed to be time invariant.

Parameter ``system``:
    to be verified. We currently require that the system has only
    continuous state, and it is assumed to be time invariant. Unlike
    many analysis algorithms, the system does *not* need to support
    conversion to other ScalarTypes (double is sufficient).

Parameter ``context``:
    is used only to specify any parameters of the system, and to fix
    any input ports. The system/context must have all inputs assigned.

Parameter ``basis_functions``:
    must define an AutoDiffXd function that takes the state vector as
    an input argument and returns the vector of values of the basis
    functions at that state. The Lyapunov function will then have the
    form V(x) = ∑ pᵢ φᵢ(x), where `p` is the vector to be solved for
    and `φ(x)` is the vector of basis function evaluations returned by
    this function.

Parameter ``state_samples``:
    is a list of sample states (one per column) at which to apply the
    optimization constraints and the objective.

Parameter ``V_zero_state``:
    is a particular state, x₀, where we impose the condition: V(x₀) =
    0.

Returns:
    params the VectorXd of parameters, p, that satisfies the Lyapunov
    conditions described above. The resulting Lyapunov function is
    V(x) = ∑ pᵢ φᵢ(x),)""";

        } SampleBasedLyapunovAnalysis;

      } analysis;

      // controllers
      struct /* controllers */ {

        // drake::systems::controllers::CartesianSetpoint
        struct /* CartesianSetpoint */ {

          // drake/systems/controllers/setpoint.h:33
          const char* doc =
R"""(This is used to compute target spatial acceleration, which is the
input to the inverse dynamics controller. The target acceleration is
computed by: acceleration_d = Kp*(x* - x) + Kd*(xd* - xd) + xdd*,
where x is pose, xd is velocity, and xdd is acceleration. Variables
with superscript * are the set points, and Kp and Kd are the position
and velocity gains.

Pose "difference" is computed as: H^w_d = E * H^w_m, E = H^w_d *
H^w_m.inverse(), where H^w_d = desired orientation in the world frame,
H^w_m = measured orientation in the world frame, E = a small rotation
in the world frame from measured to desired.

The first terms 3 are angular accelerations, and the last 3 are linear
accelerations.)""";

          // drake::systems::controllers::CartesianSetpoint::CartesianSetpoint<Scalar>
          struct /* ctor */ {

            // drake/systems/controllers/setpoint.h:35
            const char* doc = R"""()""";

            // drake/systems/controllers/setpoint.h:35
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/setpoint.h:37
            const char* doc_3 = R"""()""";

            // drake/systems/controllers/setpoint.h:52
            const char* doc_4 =
R"""(Parameter ``pose_d``:
    Desired pose

Parameter ``vel_d``:
    Desired velocity

Parameter ``acc_d``:
    Desired feedforward acceleration

Parameter ``Kp``:
    Position gain

Parameter ``Kd``:
    Velocity gain)""";

          } ctor;

          // drake::systems::controllers::CartesianSetpoint::ComputeTargetAcceleration
          struct /* ComputeTargetAcceleration */ {

            // drake/systems/controllers/setpoint.h:68
            const char* doc =
R"""(Computes target acceleration using PD feedback + feedfoward
acceleration.

Parameter ``pose``:
    Measured pose

Parameter ``vel``:
    Measured velocity

Returns:
    Computed spatial acceleration.)""";

          } ComputeTargetAcceleration;

          // drake::systems::controllers::CartesianSetpoint::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/controllers/setpoint.h:35
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::controllers::CartesianSetpoint::Kd
          struct /* Kd */ {

            // drake/systems/controllers/setpoint.h:122
            const char* doc = R"""()""";

          } Kd;

          // drake::systems::controllers::CartesianSetpoint::Kp
          struct /* Kp */ {

            // drake/systems/controllers/setpoint.h:121
            const char* doc = R"""()""";

          } Kp;

          // drake::systems::controllers::CartesianSetpoint::desired_acceleration
          struct /* desired_acceleration */ {

            // drake/systems/controllers/setpoint.h:120
            const char* doc = R"""()""";

          } desired_acceleration;

          // drake::systems::controllers::CartesianSetpoint::desired_pose
          struct /* desired_pose */ {

            // drake/systems/controllers/setpoint.h:118
            const char* doc = R"""()""";

          } desired_pose;

          // drake::systems::controllers::CartesianSetpoint::desired_velocity
          struct /* desired_velocity */ {

            // drake/systems/controllers/setpoint.h:119
            const char* doc = R"""()""";

          } desired_velocity;

          // drake::systems::controllers::CartesianSetpoint::is_valid
          struct /* is_valid */ {

            // drake/systems/controllers/setpoint.h:105
            const char* doc = R"""()""";

          } is_valid;

          // drake::systems::controllers::CartesianSetpoint::mutable_Kd
          struct /* mutable_Kd */ {

            // drake/systems/controllers/setpoint.h:129
            const char* doc = R"""()""";

          } mutable_Kd;

          // drake::systems::controllers::CartesianSetpoint::mutable_Kp
          struct /* mutable_Kp */ {

            // drake/systems/controllers/setpoint.h:128
            const char* doc = R"""()""";

          } mutable_Kp;

          // drake::systems::controllers::CartesianSetpoint::mutable_desired_acceleration
          struct /* mutable_desired_acceleration */ {

            // drake/systems/controllers/setpoint.h:127
            const char* doc = R"""()""";

          } mutable_desired_acceleration;

          // drake::systems::controllers::CartesianSetpoint::mutable_desired_pose
          struct /* mutable_desired_pose */ {

            // drake/systems/controllers/setpoint.h:125
            const char* doc = R"""()""";

          } mutable_desired_pose;

          // drake::systems::controllers::CartesianSetpoint::mutable_desired_velocity
          struct /* mutable_desired_velocity */ {

            // drake/systems/controllers/setpoint.h:126
            const char* doc = R"""()""";

          } mutable_desired_velocity;

        } CartesianSetpoint;

        // drake::systems::controllers::DiscreteTimeLinearQuadraticRegulator
        struct /* DiscreteTimeLinearQuadraticRegulator */ {

          // drake/systems/controllers/linear_quadratic_regulator.h:62
          const char* doc =
R"""(Computes the optimal feedback controller, u=-Kx, and the optimal cost-
to-go J = x'Sx for the problem:

@f[ x[n+1] = Ax[n] + Bu[n] @f] @f[ \min_u \sum_0^\infty x'Qx + u'Ru
@f]

Parameter ``A``:
    The state-space dynamics matrix of size num_states x num_states.

Parameter ``B``:
    The state-space input matrix of size num_states x num_inputs.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Returns:
    A structure that contains the optimal feedback gain K and the
    quadratic cost term S. The optimal feedback control is u = -Kx;

Throws:
    s std::runtime_error if R is not positive definite.)""";

        } DiscreteTimeLinearQuadraticRegulator;

        // drake::systems::controllers::DynamicProgrammingOptions
        struct /* DynamicProgrammingOptions */ {

          // drake/systems/controllers/dynamic_programming.h:20
          const char* doc =
R"""(Consolidates the many possible options to be passed to the dynamic
programming algorithms.)""";

          // drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition
          struct /* PeriodicBoundaryCondition */ {

            // drake/systems/controllers/dynamic_programming.h:30
            const char* doc =
R"""(For algorithms that rely on approximations of the state-dynamics (as
in FittedValueIteration), this is a list of state dimensions for which
the state space maximum value should be "wrapped around" to ensure
that all values are in the range [low, high). The classic example is
for angles that are wrapped around at 2π.)""";

            // drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::PeriodicBoundaryCondition
            struct /* ctor */ {

              // drake/systems/controllers/dynamic_programming.h:31
              const char* doc = R"""()""";

            } ctor;

            // drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::high
            struct /* high */ {

              // drake/systems/controllers/dynamic_programming.h:34
              const char* doc = R"""()""";

            } high;

            // drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::low
            struct /* low */ {

              // drake/systems/controllers/dynamic_programming.h:33
              const char* doc = R"""()""";

            } low;

            // drake::systems::controllers::DynamicProgrammingOptions::PeriodicBoundaryCondition::state_index
            struct /* state_index */ {

              // drake/systems/controllers/dynamic_programming.h:32
              const char* doc = R"""()""";

            } state_index;

          } PeriodicBoundaryCondition;

          // drake::systems::controllers::DynamicProgrammingOptions::convergence_tol
          struct /* convergence_tol */ {

            // drake/systems/controllers/dynamic_programming.h:41
            const char* doc =
R"""(Value iteration methods converge when the value function stops
changing (typically evaluated with the l∞ norm). This value sets that
threshold.)""";

          } convergence_tol;

          // drake::systems::controllers::DynamicProgrammingOptions::discount_factor
          struct /* discount_factor */ {

            // drake/systems/controllers/dynamic_programming.h:23
            const char* doc =
R"""(A value between (0,1] that discounts future rewards.

See also:
    FittedValueIteration.)""";

          } discount_factor;

          // drake::systems::controllers::DynamicProgrammingOptions::periodic_boundary_conditions
          struct /* periodic_boundary_conditions */ {

            // drake/systems/controllers/dynamic_programming.h:36
            const char* doc = R"""()""";

          } periodic_boundary_conditions;

          // drake::systems::controllers::DynamicProgrammingOptions::visualization_callback
          struct /* visualization_callback */ {

            // drake/systems/controllers/dynamic_programming.h:50
            const char* doc =
R"""(If callable, this method is invoked during each major iteration of the
dynamic programming algorithm, in order to facilitate e.g. graphical
inspection/debugging of the results. Note: the first call happens at
iteration 1 (after the value iteration has run once), not zero.)""";

          } visualization_callback;

        } DynamicProgrammingOptions;

        // drake::systems::controllers::FittedValueIteration
        struct /* FittedValueIteration */ {

          // drake/systems/controllers/dynamic_programming.h:88
          const char* doc =
R"""(Implements Fitted Value Iteration on a (triangulated) Barycentric
Mesh, which designs a state-feedback policy to minimize the infinite-
horizon cost ∑ γⁿ g(x[n],u[n]), where γ is the discount factor in
``options``.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=dp . It
currently requires that the system to be optimized has only continuous
state and it is assumed to be time invariant. This code makes a
discrete-time approximation (using ``timestep``) for the value
iteration update.

Parameter ``simulator``:
    contains the reference to the System being optimized and to a
    Context for that system, which may contain non-default Parameters,
    etc. The ``simulator`` is run for ``timestep`` seconds from every
    point on the mesh in order to approximate the dynamics; all of the
    simulation parameters (integrator, etc) are relevant during that
    evaluation.

Parameter ``cost_function``:
    is the continuous-time instantaneous cost. This implementation of
    the discrete-time formulation above uses the approximation g(x,u)
    = timestep*cost_function(x,u).

Parameter ``state_grid``:
    defines the mesh on the state space used to represent the cost-to-
    go function and the resulting policy.

Parameter ``input_grid``:
    defines the discrete action space used in the value iteration
    update.

Parameter ``timestep``:
    a time in seconds used for the discrete-time approximation.

Parameter ``options``:
    optional DynamicProgrammingOptions structure.

Returns:
    a std::pair containing the resulting policy, implemented as a
    BarycentricMeshSystem, and the RowVectorXd J that defines the
    expected cost-to-go on a BarycentricMesh using ``state_grid``. The
    policy has a single vector input (which is the continuous state of
    the system passed in through ``simulator``) and a single vector
    output (which is the input of the system passed in through
    ``simulator``).)""";

        } FittedValueIteration;

        // drake::systems::controllers::InverseDynamics
        struct /* InverseDynamics */ {

          // drake/systems/controllers/inverse_dynamics.h:40
          const char* doc =
R"""(Solves inverse dynamics with no consideration for joint actuator force
limits. The system also provides a pure gravity compensation mode.
This system provides a BasicVector input port for the state `(q, v)`,
where `q` is the generalized position and `v` is the generalized
velocity, and a BasicVector output port for the computed generalized
forces. There is an additional BasicVector input port for desired
acceleration when configured to be **not** in pure gravity
compensation mode.

InverseDynamicsController uses a PID controller to generate desired
acceleration and uses this class to compute generalized forces. This
class should be used directly if desired acceleration is computed
differently.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

See also:
    Constructors for descriptions of how (and which) forces are
    incorporated into the inverse dynamics computation.

Instantiated templates for the following kinds of T's are provided: -
double)""";

          // drake::systems::controllers::InverseDynamics::InverseDynamics<T>
          struct /* ctor */ {

            // drake/systems/controllers/inverse_dynamics.h:50
            const char* doc = R"""()""";

            // drake/systems/controllers/inverse_dynamics.h:50
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/inverse_dynamics.h:53
            const char* doc_3 = R"""()""";

            // drake/systems/controllers/inverse_dynamics.h:73
            const char* doc_4 =
R"""(Computes inverse dynamics for `tree`, where the computed force
`tau_id` is:

```
tau_id = `M(q)vd_d + C(q, v)v - tau_g(q) - tau_s(q) + tau_d(v)`
```

where `M(q)` is the mass matrix, `C(q, v)v` is the Coriolis term,
`tau_g(q)` is the gravity term, `q` is the generalized position, `v`
is the generalized velocity, `vd_d` is the desired generalized
acceleration, `tau_s` is computed via
`RigidBodyTree::CalcGeneralizedSpringForces()` and `tau_d` is computed
via `RigidBodyTree::frictionTorques()`. In gravity compensation mode,
the generalized force only includes the gravity term, that is, `tau_id
= -tau_g(q)`.

Parameter ``tree``:
    Pointer to the model. The life span of ``tree`` must be longer
    than this instance.

Parameter ``mode``:
    If set to kGravityCompensation, this instance will only consider
    the gravity term. It also will NOT have the desired acceleration
    input port.)""";

            // drake/systems/controllers/inverse_dynamics.h:76
            const char* doc_5 = R"""()""";

            // drake/systems/controllers/inverse_dynamics.h:105
            const char* doc_6 =
R"""(Computes the generalized force `tau_id` that needs to be applied so
that the multibody system undergoes a desired acceleration `vd_d`.
That is, `tau_id` is the result of an inverse dynamics computation
according to:

```
tau_id = M(q)vd_d + C(q, v)v - tau_g(q) - tau_app
```

where `M(q)` is the mass matrix, `C(q, v)v` is the bias term
containing Coriolis and gyroscopic effects, `tau_g(q)` is the vector
of generalized forces due to gravity and `tau_app` contains applied
forces from force elements added to the multibody model (this can
include damping, springs, etc. See
MultibodyTree::CalcForceElementsContribution()).

Parameter ``plant``:
    Pointer to the multibody plant model. The life span of ``plant``
    must be longer than that of this instance.

Parameter ``mode``:
    If set to kGravityCompensation, this instance will only consider
    the gravity term. It also will NOT have the desired acceleration
    input port. @pre The plant must be finalized (i.e.,
    plant.is_finalized() must return `true`).)""";

          } ctor;

          // drake::systems::controllers::InverseDynamics::InverseDynamicsMode
          struct /* InverseDynamicsMode */ {

            // drake/systems/controllers/inverse_dynamics.h:42
            const char* doc = R"""()""";

            // drake::systems::controllers::InverseDynamics::InverseDynamicsMode::kGravityCompensation
            struct /* kGravityCompensation */ {

              // drake/systems/controllers/inverse_dynamics.h:47
              const char* doc = R"""(Purely gravity compensation mode.)""";

            } kGravityCompensation;

            // drake::systems::controllers::InverseDynamics::InverseDynamicsMode::kInverseDynamics
            struct /* kInverseDynamics */ {

              // drake/systems/controllers/inverse_dynamics.h:44
              const char* doc = R"""(Full inverse computation mode.)""";

            } kInverseDynamics;

          } InverseDynamicsMode;

          // drake::systems::controllers::InverseDynamics::get_input_port_desired_acceleration
          struct /* get_input_port_desired_acceleration */ {

            // drake/systems/controllers/inverse_dynamics.h:118
            const char* doc =
R"""(Returns the input port for the desired acceleration.)""";

          } get_input_port_desired_acceleration;

          // drake::systems::controllers::InverseDynamics::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {

            // drake/systems/controllers/inverse_dynamics.h:111
            const char* doc =
R"""(Returns the input port for the estimated state.)""";

          } get_input_port_estimated_state;

          // drake::systems::controllers::InverseDynamics::get_output_port_force
          struct /* get_output_port_force */ {

            // drake/systems/controllers/inverse_dynamics.h:136
            const char* doc =
R"""(Returns the output port for the generalized forces that realize the
desired acceleration. The dimension of that force vector will be
identical to the dimensionality of the generalized velocities.)""";

          } get_output_port_force;

          // drake::systems::controllers::InverseDynamics::get_output_port_torque
          struct /* get_output_port_torque */ {

            // drake/systems/controllers/inverse_dynamics.h:127
            const char* doc =
R"""(Returns the output port for the actuation torques.)""";

          } get_output_port_torque;

          // drake::systems::controllers::InverseDynamics::is_pure_gravity_compensation
          struct /* is_pure_gravity_compensation */ {

            // drake/systems/controllers/inverse_dynamics.h:140
            const char* doc = R"""()""";

          } is_pure_gravity_compensation;

        } InverseDynamics;

        // drake::systems::controllers::InverseDynamicsController
        struct /* InverseDynamicsController */ {

          // drake/systems/controllers/inverse_dynamics_controller.h:56
          const char* doc =
R"""(A state feedback controller that uses a PidController to generate
desired accelerations, which are then converted into torques using
InverseDynamics. More specifically, the output of this controller is:
`torque = inverse_dynamics(q, v, vd_d)`, where `vd_d = kp(q* - q) +
kd(v* - v) + ki int(q* - q) + vd*`. `q` and `v` stand for the
generalized position and velocity, and `vd` is the generalized
acceleration. `*` indicates reference values.

This controller always has a BasicVector input port for estimated
robot state `(q, v)`, a BasicVector input port for reference robot
state `(q*, v*)` and a BasicVector output port for computed torque
`torque`. A constructor flag can be set to track reference
acceleration `vd*` as well. When set, a BasicVector input port is also
declared, and it's content is used as `vd*`. When unset, `vd*` is be
treated as zero.

Note that this class assumes the robot is fully actuated, its position
and velocity have the same dimension, and it does not have a floating
base. If violated, the program will abort. This controller was not
designed for closed loop systems: the controller accounts for neither
constraint forces nor actuator forces applied at loop constraints. Use
on such systems is not recommended.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

See also:
    InverseDynamics for an accounting of all forces incorporated into
    the inverse dynamics computation.

Instantiated templates for the following kinds of T's are provided: -
double)""";

          // drake::systems::controllers::InverseDynamicsController::InverseDynamicsController<T>
          struct /* ctor */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:59
            const char* doc = R"""()""";

            // drake/systems/controllers/inverse_dynamics_controller.h:59
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/inverse_dynamics_controller.h:73
            const char* doc_3 =
R"""(Constructs the controller that takes ownership of a given
RigidBodyTree unique pointer.

Parameter ``robot``:
    Unique pointer whose ownership will be transferred to this
    instance.

Parameter ``kp``:
    Position gain.

Parameter ``ki``:
    Integral gain.

Parameter ``kd``:
    Velocity gain.

Parameter ``has_reference_acceleration``:
    If true, there is an extra BasicVector input port for `vd*`. If
    false, `vd*` is treated as zero, and no extra input port is
    declared.)""";

            // drake/systems/controllers/inverse_dynamics_controller.h:100
            const char* doc_4 =
R"""(Constructs an inverse dynamics controller for the given `plant` model.
The InverseDynamicsController holds an internal, non-owned reference
to the MultibodyPlant object so you must ensure that `plant` has a
longer lifetime than `this` InverseDynamicsController.

Parameter ``plant``:
    The model of the plant for control.

Parameter ``kp``:
    Position gain.

Parameter ``ki``:
    Integral gain.

Parameter ``kd``:
    Velocity gain.

Parameter ``has_reference_acceleration``:
    If true, there is an extra BasicVector input port for `vd*`. If
    false, `vd*` is treated as zero, and no extra input port is
    declared. @pre `plant` has been finalized (plant.is_finalized()
    returns `true`).

Throws:
    s RuntimeError if - The plant is not finalized (see
    MultibodyPlant::Finalize()). - The number of generalized
    velocities is not equal to the number of generalized positions. -
    The model is not fully actuated. - Vector kp, ki and kd do not all
    have the same size equal to the number of generalized positions.)""";

          } ctor;

          // drake::systems::controllers::InverseDynamicsController::get_input_port_desired_acceleration
          struct /* get_input_port_desired_acceleration */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:117
            const char* doc =
R"""(Returns the input port for the reference acceleration.)""";

          } get_input_port_desired_acceleration;

          // drake::systems::controllers::InverseDynamicsController::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:133
            const char* doc =
R"""(Returns the input port for the desired state.)""";

          } get_input_port_desired_state;

          // drake::systems::controllers::InverseDynamicsController::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:126
            const char* doc =
R"""(Returns the input port for the estimated state.)""";

          } get_input_port_estimated_state;

          // drake::systems::controllers::InverseDynamicsController::get_multibody_plant_for_control
          struct /* get_multibody_plant_for_control */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:170
            const char* doc =
R"""(Returns a constant pointer to the MultibodyPlant used for control.

Returns:
    `nullptr` if `this` was constructed using a RigidBodyTree.)""";

          } get_multibody_plant_for_control;

          // drake::systems::controllers::InverseDynamicsController::get_output_port_control
          struct /* get_output_port_control */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:140
            const char* doc =
R"""(Returns the output port for computed control.)""";

          } get_output_port_control;

          // drake::systems::controllers::InverseDynamicsController::get_rigid_body_tree_for_control
          struct /* get_rigid_body_tree_for_control */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:161
            const char* doc =
R"""(Returns a pointer to the const RigidBodyTree used for control.

Returns:
    `nullptr` if `this` was constructed using a MultibodyPlant.)""";

          } get_rigid_body_tree_for_control;

          // drake::systems::controllers::InverseDynamicsController::get_robot_for_control
          struct /* get_robot_for_control */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:148
            const char* doc =
R"""(Returns a constant reference to the RigidBodyTree used for control.)""";

          } get_robot_for_control;

          // drake::systems::controllers::InverseDynamicsController::set_integral_value
          struct /* set_integral_value */ {

            // drake/systems/controllers/inverse_dynamics_controller.h:111
            const char* doc =
R"""(Sets the integral part of the PidController to ``value``. ``value``
must be a column vector of the appropriate size.)""";

          } set_integral_value;

        } InverseDynamicsController;

        // drake::systems::controllers::LinearModelPredictiveController
        struct /* LinearModelPredictiveController */ {

          // drake/systems/controllers/linear_model_predictive_controller.h:35
          const char* doc =
R"""(Implements a basic Model Predictive Controller that linearizes the
system about an equilibrium condition and regulates to the same point
by solving an optimal control problem over a finite time horizon. In
particular, MPC solves, at each time step k, the following problem to
find an optimal u(k) as a function of x(k):

@f[ \min_{u(k),\ldots,u(k+N),x(k+1),\ldots,x(k+N)} \Sum_{i=k}^{k+N}
((x(i) - xd(i))ᵀQ(x(i) - xd(i)) + (u(i) - ud(i))ᵀR(u(i) - ud(i))) @f]
@f[ \mathrm{s.t. } x(k+1) = A(k)x(k) + B(k)u(k) @f]

and subject to linear inequality constraints on the inputs and states,
where N is the horizon length, Q and R are cost matrices, and xd and
ud are the desired states and inputs, respectively. Note that the
present implementation solves the QP in whole at every time step,
discarding any information between steps.

Instantiated templates for the following kinds of T's are provided: -
double)""";

          // drake::systems::controllers::LinearModelPredictiveController::LinearModelPredictiveController<T>
          struct /* ctor */ {

            // drake/systems/controllers/linear_model_predictive_controller.h:37
            const char* doc = R"""()""";

            // drake/systems/controllers/linear_model_predictive_controller.h:37
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/linear_model_predictive_controller.h:64
            const char* doc_3 =
R"""(Constructor for an unconstrained MPC formulation with linearization
occurring about the provided base_context. Since this formulation is
devoid of any externally-imposed input/state constraints, the
controller essentially behaves the same as a finite-time LQR.

Parameter ``model``:
    The plant model of the System to be controlled.

Parameter ``base_context``:
    The fixed base point about which to linearize of the system and
    regulate the system. To be valid, ``base_context`` must correspond
    to an equilibrium point of the system.

Parameter ``Q``:
    A symmetric positive semi-definite state cost matrix of size
    (num_states x num_states).

Parameter ``R``:
    A symmetric positive definite control effort cost matrix of size
    (num_inputs x num_inputs).

Parameter ``time_period``:
    The discrete time period (in seconds) at which controller updates
    occur.

Parameter ``time_horizon``:
    The prediction time horizon (seconds).

@pre model must have discrete states of dimension num_states and
inputs of dimension num_inputs. @pre base_context must have discrete
states set as appropriate for the given ``model``. The input must also
be initialized via `base_context->FixInputPort(0, u0)`, or otherwise
initialized via Diagram.)""";

          } ctor;

          // drake::systems::controllers::LinearModelPredictiveController::get_control_port
          struct /* get_control_port */ {

            // drake/systems/controllers/linear_model_predictive_controller.h:74
            const char* doc = R"""()""";

          } get_control_port;

          // drake::systems::controllers::LinearModelPredictiveController::get_state_port
          struct /* get_state_port */ {

            // drake/systems/controllers/linear_model_predictive_controller.h:71
            const char* doc = R"""()""";

          } get_state_port;

        } LinearModelPredictiveController;

        // drake::systems::controllers::LinearProgrammingApproximateDynamicProgramming
        struct /* LinearProgrammingApproximateDynamicProgramming */ {

          // drake/systems/controllers/dynamic_programming.h:151
          const char* doc =
R"""(Implements the Linear Programming approach to approximate dynamic
programming. It optimizes the linear program

maximize ∑ Jₚ(x). subject to ∀x, ∀u, Jₚ(x) ≤ g(x,u) + γJₚ(f(x,u)),

where g(x,u) is the one-step cost, Jₚ(x) is a (linearly) parameterized
cost-to-go function with parameter vector p, and γ is the discount
factor in ``options``.

For background, and a description of this algorithm, see
http://underactuated.csail.mit.edu/underactuated.html?chapter=dp . It
currently requires that the system to be optimized has only continuous
state and it is assumed to be time invariant. This code makes a
discrete-time approximation (using ``timestep``) for the value
iteration update.

Parameter ``simulator``:
    contains the reference to the System being optimized and to a
    Context for that system, which may contain non-default Parameters,
    etc. The ``simulator`` is run for ``timestep`` seconds from every
    pair of input/state sample points in order to approximate the
    dynamics; all of the simulation parameters (integrator, etc) are
    relevant during that evaluation.

Parameter ``cost_function``:
    is the continuous-time instantaneous cost. This implementation of
    the discrete-time formulation above uses the approximation g(x,u)
    = timestep*cost_function(x,u).

Parameter ``linearly_parameterized_cost_to_go_function``:
    must define a function to approximate the cost-to-go, which takes
    the state vector as the first input and the parameter vector as
    the second input. This can be any function of the form Jₚ(x) = ∑
    pᵢ φᵢ(x). This algorithm will pass in a VectorX of
    symbolic::Variable in order to set up the linear program.

Parameter ``state_samples``:
    is a list of sample states (one per column) at which to apply the
    optimization constraints and the objective.

Parameter ``input_samples``:
    is a list of inputs (one per column) which are evaluated *at every
    sample point*.

Parameter ``timestep``:
    a time in seconds used for the discrete-time approximation.

Parameter ``options``:
    optional DynamicProgrammingOptions structure.

Returns:
    params the VectorXd of parameters that optimizes the supplied
    cost-to-go function.)""";

        } LinearProgrammingApproximateDynamicProgramming;

        // drake::systems::controllers::LinearQuadraticRegulator
        struct /* LinearQuadraticRegulator */ {

          // drake/systems/controllers/linear_quadratic_regulator.h:35
          const char* doc =
R"""(Computes the optimal feedback controller, u=-Kx, and the optimal cost-
to-go J = x'Sx for the problem:

@f[ \dot{x} = Ax + Bu @f] @f[ \min_u \int_0^\infty x'Qx + u'Ru + 2x'Nu
dt @f]

Parameter ``A``:
    The state-space dynamics matrix of size num_states x num_states.

Parameter ``B``:
    The state-space input matrix of size num_states x num_inputs.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs.

Returns:
    A structure that contains the optimal feedback gain K and the
    quadratic cost term S. The optimal feedback control is u = -Kx;

Throws:
    s std::runtime_error if R is not positive definite.)""";

          // drake/systems/controllers/linear_quadratic_regulator.h:91
          const char* doc_2 =
R"""(Creates a system that implements the optimal time-invariant linear
quadratic regulator (LQR). If ``system`` is a continuous-time system,
then solves the continuous-time LQR problem:

@f[ \min_u \int_0^\infty x^T(t)Qx(t) + u^T(t)Ru(t) dt. @f]

If ``system`` is a discrete-time system, then solves the discrete-time
LQR problem:

@f[ \min_u \sum_0^\infty x^T[n]Qx[n] + u^T[n]Ru[n]. @f]

Parameter ``system``:
    The System to be controlled.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs.

Returns:
    A system implementing the optimal controller in the original
    system coordinates.

Throws:
    s std::runtime_error if R is not positive definite.)""";

          // drake/systems/controllers/linear_quadratic_regulator.h:130
          const char* doc_3 =
R"""(Linearizes the System around the specified Context, computes the
optimal time-invariant linear quadratic regulator (LQR), and returns a
System which implements that regulator in the original System's
coordinates. If ``system`` is a continuous-time system, then solves
the continuous-time LQR problem:

@f[ \min_u \int_0^\infty (x-x_0)^TQ(x-x_0) + (u-u_0)^TR(u-u_0) dt. @f]

If ``system`` is a discrete-time system, then solves the discrete-time
LQR problem:

@f[ \min_u \sum_0^\infty (x-x_0)^TQ(x-x_0) + (u-u_0)^TR(u-u_0), @f]

where $ x_0 $ is the nominal state and $ u_0 $ is the nominal input.
The system is considered discrete if it has a single discrete state
vector and a single unique periodic update event declared.

Parameter ``system``:
    The System to be controlled.

Parameter ``context``:
    Defines the desired state and control input to regulate the system
    to. Note that this state/input must be an equilibrium point of the
    system. See drake::systems::Linearize for more details.

Parameter ``Q``:
    A symmetric positive semi-definite cost matrix of size num_states
    x num_states.

Parameter ``R``:
    A symmetric positive definite cost matrix of size num_inputs x
    num_inputs.

Parameter ``N``:
    A cost matrix of size num_states x num_inputs.

Returns:
    A system implementing the optimal controller in the original
    system coordinates.

Throws:
    s std::runtime_error if R is not positive definite.)""";

        } LinearQuadraticRegulator;

        // drake::systems::controllers::LinearQuadraticRegulatorResult
        struct /* LinearQuadraticRegulatorResult */ {

          // drake/systems/controllers/linear_quadratic_regulator.h:11
          const char* doc = R"""()""";

          // drake::systems::controllers::LinearQuadraticRegulatorResult::K
          struct /* K */ {

            // drake/systems/controllers/linear_quadratic_regulator.h:12
            const char* doc = R"""()""";

          } K;

          // drake::systems::controllers::LinearQuadraticRegulatorResult::S
          struct /* S */ {

            // drake/systems/controllers/linear_quadratic_regulator.h:13
            const char* doc = R"""()""";

          } S;

        } LinearQuadraticRegulatorResult;

        // drake::systems::controllers::PidControlledSystem
        struct /* PidControlledSystem */ {

          // drake/systems/controllers/pid_controlled_system.h:64
          const char* doc =
R"""(A system that encapsulates a PidController and a controlled System
(a.k.a the "plant").

The passed in plant must meet the following properties:

* Input port zero must be all of the control inputs (size U). When the
plant is a dynamics model, this is typically the generalized effort
(e.g., force or torque) command.

* The output port passed to the PidControlledSystem constructor must
be of size 2 * Q, where the first Q elements are the position states
of the plant, and the second Q elements are the velocity states of the
plant. Q >= U.

The resulting PidControlledSystem has two input ports with the
following properties:

* Input port zero is the feed forward control (size U), which will be
added onto the output of the PID controller. The sum is sent to the
plant's input.

* Input port one is the desired *controlled* states (2 * U) of the
plant, where the first half are the *controlled* positions, and the
second half are the *controlled* velocities.

All output ports of the plant are exposed as output ports of the
PidControlledSystem in the same order (and therefore with the same
index) as they appear in the plant.

Some of the constructors include a parameter called
`feedback_selector`. It is used to select the *controlled* states from
the plant's state output port. Let `S` be the gain matrix in parameter
`feedback_selector`. `S` must have dimensions of `(2 * U, 2 * Q)`.
Typically, `S` contains one `1` in each row, and zeros everywhere
else. `S` does not affect the desired state input. Let 'x' be the full
state of the plant (size 2 * Q), and 'x_d' be the desired state (size
2 * U), `S` is used to compute the state error as `x_err = S * x -
x_d`.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd)""";

          // drake::systems::controllers::PidControlledSystem::ConnectController
          struct /* ConnectController */ {

            // drake/systems/controllers/pid_controlled_system.h:159
            const char* doc =
R"""(Creates a PidController and uses ``builder`` to connect
``plant_input`` and ``plant_output`` from an existing plant. The
controlled states are selected by ``feedback_selector``.)""";

            // drake/systems/controllers/pid_controlled_system.h:169
            const char* doc_2 =
R"""(Creates a PidController and uses ``builder`` to connect
``plant_input`` and ``plant_output`` from an existing plant. The
plant's full state is used for feedback.)""";

          } ConnectController;

          // drake::systems::controllers::PidControlledSystem::ConnectControllerWithInputSaturation
          struct /* ConnectControllerWithInputSaturation */ {

            // drake/systems/controllers/pid_controlled_system.h:181
            const char* doc =
R"""(Creates a PidController with input saturation and uses ``builder`` to
connect ``plant_input`` and ``plant_output`` from an existing plant.
The controlled states are selected by ``feedback_selector``. The
output of the PidController is clipped to be within the specified
bounds. Note that using input limits along with integral gain constant
may cause the integrator to windup.)""";

            // drake/systems/controllers/pid_controlled_system.h:195
            const char* doc_2 =
R"""(Creates a PidController with input saturation and uses ``builder`` to
connect ``plant_input`` and ``plant_output`` from an existing plant.
The plant's full state is used for feedback. The output of the
PidController is clipped to be within the specified bounds. Note that
using input limits along with integral gain constant may cause the
integrator to windup.)""";

          } ConnectControllerWithInputSaturation;

          // drake::systems::controllers::PidControlledSystem::ConnectResult
          struct /* ConnectResult */ {

            // drake/systems/controllers/pid_controlled_system.h:149
            const char* doc = R"""(The return type of ConnectController.)""";

            // drake::systems::controllers::PidControlledSystem::ConnectResult::control_input_port
            struct /* control_input_port */ {

              // drake/systems/controllers/pid_controlled_system.h:151
              const char* doc = R"""(The feed forward control input.)""";

            } control_input_port;

            // drake::systems::controllers::PidControlledSystem::ConnectResult::state_input_port
            struct /* state_input_port */ {

              // drake/systems/controllers/pid_controlled_system.h:153
              const char* doc = R"""(The feedback state input.)""";

            } state_input_port;

          } ConnectResult;

          // drake::systems::controllers::PidControlledSystem::PidControlledSystem<T>
          struct /* ctor */ {

            // drake/systems/controllers/pid_controlled_system.h:66
            const char* doc = R"""()""";

            // drake/systems/controllers/pid_controlled_system.h:66
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/pid_controlled_system.h:77
            const char* doc_3 =
R"""(``plant`` full state is used for feedback control, and all the
dimensions have homogeneous gains specified by ``Kp``, ``Kd`` and
``Ki``.

Parameter ``plant``:
    The system to be controlled. This must not be `nullptr`.

Parameter ``Kp``:
    the proportional constant.

Parameter ``Ki``:
    the integral constant.

Parameter ``Kd``:
    the derivative constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.)""";

            // drake/systems/controllers/pid_controlled_system.h:89
            const char* doc_4 =
R"""(``plant`` full state is used for feedback control, and the vectorized
gains are specified by ``Kp``, ``Kd`` and ``Ki``.

Parameter ``plant``:
    The system to be controlled. This must not be `nullptr`.

Parameter ``Kp``:
    the proportional vector constant.

Parameter ``Ki``:
    the integral vector constant.

Parameter ``Kd``:
    the derivative vector constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.)""";

            // drake/systems/controllers/pid_controlled_system.h:107
            const char* doc_5 =
R"""(A constructor where the gains are scalar values and some of the
plant's output is part of the feedback signal as specified by
``feedback_selector``.

Parameter ``plant``:
    The system to be controlled. This must not be `nullptr`.

Parameter ``feedback_selector``:
    The matrix that selects which part of the plant's full state is
    fed back to the PID controller. For semantic details of this
    parameter, see this class's description.

Parameter ``Kp``:
    the proportional constant.

Parameter ``Ki``:
    the integral constant.

Parameter ``Kd``:
    the derivative constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.)""";

            // drake/systems/controllers/pid_controlled_system.h:124
            const char* doc_6 =
R"""(A constructor where the gains are vector values and some of the
plant's output is part of the feedback signal as specified by
``feedback_selector``.

Parameter ``plant``:
    The system to be controlled. This must not be `nullptr`.

Parameter ``feedback_selector``:
    The matrix that selects which part of the plant's full state is
    fed back to the PID controller. For semantic details of this
    parameter, see this class's description.

Parameter ``Kp``:
    the proportional vector constant.

Parameter ``Ki``:
    the integral vector constant.

Parameter ``Kd``:
    the derivative vector constant.

Parameter ``state_output_port_index``:
    identifies the output port on the plant that contains the (full)
    state information.)""";

          } ctor;

          // drake::systems::controllers::PidControlledSystem::get_control_input_port
          struct /* get_control_input_port */ {

            // drake/systems/controllers/pid_controlled_system.h:135
            const char* doc =
R"""(Returns:
    the input port for the feed forward control input.)""";

          } get_control_input_port;

          // drake::systems::controllers::PidControlledSystem::get_state_input_port
          struct /* get_state_input_port */ {

            // drake/systems/controllers/pid_controlled_system.h:140
            const char* doc =
R"""(Returns:
    the input port for the desired position/velocity state.)""";

          } get_state_input_port;

          // drake::systems::controllers::PidControlledSystem::get_state_output_port
          struct /* get_state_output_port */ {

            // drake/systems/controllers/pid_controlled_system.h:144
            const char* doc = R"""()""";

          } get_state_output_port;

          // drake::systems::controllers::PidControlledSystem::plant
          struct /* plant */ {

            // drake/systems/controllers/pid_controlled_system.h:132
            const char* doc = R"""()""";

          } plant;

        } PidControlledSystem;

        // drake::systems::controllers::PidController
        struct /* PidController */ {

          // drake/systems/controllers/pid_controller.h:45
          const char* doc =
R"""(Implements the PID controller. Given estimated state `x_in = (q_in,
v_in)`, the controlled state `x_c = (q_c, v_c)` is computed by `x_c =
P_x * x_in`, where `P_x` is a state projection matrix. The desired
state `x_d = (q_d, v_d)`, is in the same space as `x_c`. The output of
this controller is:

```
y = P_y * (kp * (q_d - q_c) + kd * (v_d - v_c) + ki * integral(q_d - q_c)),
```

where `P_y` is the output projection matrix.

This system has one continuous state, which is the integral of
position error, two input ports: estimated state `x_in` and desired
state `x_d`, and one output port `y`. Note that this class assumes
`|q_c| = |v_c|` and `|q_d| = |v_d|`. However, `|q_c|` does not have to
equal to `|q_d|`. One typical use case for non-identity `P_x` and
`P_y` is to select a subset of state for feedback.

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd - symbolic::Expression)""";

          // drake::systems::controllers::PidController::DoCalcTimeDerivatives
          struct /* DoCalcTimeDerivatives */ {

            // drake/systems/controllers/pid_controller.h:188
            const char* doc = R"""()""";

          } DoCalcTimeDerivatives;

          // drake::systems::controllers::PidController::GetGraphvizFragment
          struct /* GetGraphvizFragment */ {

            // drake/systems/controllers/pid_controller.h:186
            const char* doc =
R"""(Appends to ``dot`` a simplified Graphviz representation of the PID
controller, since the internal wiring is unimportant and hard for
human viewers to parse.)""";

          } GetGraphvizFragment;

          // drake::systems::controllers::PidController::PidController<T>
          struct /* ctor */ {

            // drake/systems/controllers/pid_controller.h:48
            const char* doc = R"""()""";

            // drake/systems/controllers/pid_controller.h:48
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/pid_controller.h:61
            const char* doc_3 =
R"""(Constructs a PID controller. `P_x` and `P_y` are identity matrices of
proper sizes. The estimated and desired state inputs are 2 * ``kp``'s
size, and the control output has ``kp``'s size.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    D gain.

Throws:
    s std::logic_error if ``kp``, ``ki`` and ``kd`` have different
    dimensions.)""";

            // drake/systems/controllers/pid_controller.h:75
            const char* doc_4 =
R"""(Constructs a PID controller. Calls the full constructor, with the
output projection matrix `P_y` being the identity matrix.

Parameter ``state_projection``:
    The state projection matrix `P_x`.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    D gain.

Throws:
    s std::logic_error if ``kp``, ``ki`` and ``kd`` have different
    dimensions or `P_x.row() != 2 * |kp|'.)""";

            // drake/systems/controllers/pid_controller.h:97
            const char* doc_5 =
R"""(Constructs a PID controller. This assumes that

```
1. |kp| = |kd| = |ki| = |q_d| = |v_d|
  2. 2 * |q_d| = P_x.rows
  3. |x_in| = P_x.cols
  4. |y| = P_y.rows
  4. |q_d| = P_y.cols
```

Parameter ``state_projection``:
    The state projection matrix `P_x`.

Parameter ``output_projection``:
    The output projection matrix `P_y`.

Parameter ``kp``:
    P gain.

Parameter ``ki``:
    I gain.

Parameter ``kd``:
    V gain.

Throws:
    s std::logic_error if any assumption is violated.)""";

            // drake/systems/controllers/pid_controller.h:104
            const char* doc_6 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion. */)""";

          } ctor;

          // drake::systems::controllers::PidController::get_Kd_singleton
          struct /* get_Kd_singleton */ {

            // drake/systems/controllers/pid_controller.h:131
            const char* doc =
R"""(Returns the derivative gain constant. This method should only be
called if the derivative gain can be represented as a scalar value,
i.e., every element in the derivative gain vector is the same. It will
throw a `std::runtime_error` if the derivative gain cannot be
represented as a scalar value.)""";

          } get_Kd_singleton;

          // drake::systems::controllers::PidController::get_Kd_vector
          struct /* get_Kd_vector */ {

            // drake/systems/controllers/pid_controller.h:146
            const char* doc = R"""(Returns the derivative gain vector.)""";

          } get_Kd_vector;

          // drake::systems::controllers::PidController::get_Ki_singleton
          struct /* get_Ki_singleton */ {

            // drake/systems/controllers/pid_controller.h:122
            const char* doc =
R"""(Returns the integral gain constant. This method should only be called
if the integral gain can be represented as a scalar value, i.e., every
element in the integral gain vector is the same. It will throw a
`std::runtime_error` if the integral gain cannot be represented as a
scalar value.)""";

          } get_Ki_singleton;

          // drake::systems::controllers::PidController::get_Ki_vector
          struct /* get_Ki_vector */ {

            // drake/systems/controllers/pid_controller.h:141
            const char* doc = R"""(Returns the integral gain vector.)""";

          } get_Ki_vector;

          // drake::systems::controllers::PidController::get_Kp_singleton
          struct /* get_Kp_singleton */ {

            // drake/systems/controllers/pid_controller.h:113
            const char* doc =
R"""(Returns the proportional gain constant. This method should only be
called if the proportional gain can be represented as a scalar value,
i.e., every element in the proportional gain vector is the same. It
will throw a `std::runtime_error` if the proportional gain cannot be
represented as a scalar value.)""";

          } get_Kp_singleton;

          // drake::systems::controllers::PidController::get_Kp_vector
          struct /* get_Kp_vector */ {

            // drake/systems/controllers/pid_controller.h:136
            const char* doc = R"""(Returns the proportional gain vector.)""";

          } get_Kp_vector;

          // drake::systems::controllers::PidController::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {

            // drake/systems/controllers/pid_controller.h:169
            const char* doc =
R"""(Returns the input port for the desired state.)""";

          } get_input_port_desired_state;

          // drake::systems::controllers::PidController::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {

            // drake/systems/controllers/pid_controller.h:162
            const char* doc =
R"""(Returns the input port for the estimated state.)""";

          } get_input_port_estimated_state;

          // drake::systems::controllers::PidController::get_output_port_control
          struct /* get_output_port_control */ {

            // drake/systems/controllers/pid_controller.h:176
            const char* doc =
R"""(Returns the output port for computed control.)""";

          } get_output_port_control;

          // drake::systems::controllers::PidController::set_integral_value
          struct /* set_integral_value */ {

            // drake/systems/controllers/pid_controller.h:152
            const char* doc =
R"""(Sets the integral part of the PidController to ``value``. ``value``
must be a column vector of the appropriate size.)""";

          } set_integral_value;

        } PidController;

        // drake::systems::controllers::StateFeedbackControllerInterface
        struct /* StateFeedbackControllerInterface */ {

          // drake/systems/controllers/state_feedback_controller_interface.h:17
          const char* doc =
R"""(Interface for state feedback controllers. This class needs to be
extended by concrete implementations. It provides named accessors to
actual and desired state input ports and control output port.)""";

          // drake::systems::controllers::StateFeedbackControllerInterface::StateFeedbackControllerInterface<T>
          struct /* ctor */ {

            // drake/systems/controllers/state_feedback_controller_interface.h:19
            const char* doc = R"""()""";

            // drake/systems/controllers/state_feedback_controller_interface.h:19
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/state_feedback_controller_interface.h:39
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::controllers::StateFeedbackControllerInterface::get_input_port_desired_state
          struct /* get_input_port_desired_state */ {

            // drake/systems/controllers/state_feedback_controller_interface.h:30
            const char* doc =
R"""(Returns the input port for the desired state.)""";

          } get_input_port_desired_state;

          // drake::systems::controllers::StateFeedbackControllerInterface::get_input_port_estimated_state
          struct /* get_input_port_estimated_state */ {

            // drake/systems/controllers/state_feedback_controller_interface.h:24
            const char* doc =
R"""(Returns the input port for the estimated state.)""";

          } get_input_port_estimated_state;

          // drake::systems::controllers::StateFeedbackControllerInterface::get_output_port_control
          struct /* get_output_port_control */ {

            // drake/systems/controllers/state_feedback_controller_interface.h:36
            const char* doc =
R"""(Returns the output port for computed control.)""";

          } get_output_port_control;

        } StateFeedbackControllerInterface;

        // drake::systems::controllers::VectorSetpoint
        struct /* VectorSetpoint */ {

          // drake/systems/controllers/setpoint.h:164
          const char* doc = R"""()""";

          // drake::systems::controllers::VectorSetpoint::ComputeTargetAcceleration
          struct /* ComputeTargetAcceleration */ {

            // drake/systems/controllers/setpoint.h:207
            const char* doc =
R"""(Computes target acceleration using PD feedback + feedforward
acceleration

Parameter ``idx``:
    Index

Parameter ``pos``:
    Measured position

Parameter ``vel``:
    Measured velocity

Returns:
    Computed acceleration)""";

            // drake/systems/controllers/setpoint.h:223
            const char* doc_2 =
R"""(Computes target acceleration using PD feedback + feedforward
acceleration

Parameter ``idx``:
    Index

Parameter ``pos``:
    Measured position

Parameter ``vel``:
    Measured velocity

Returns:
    Computed acceleration)""";

          } ComputeTargetAcceleration;

          // drake::systems::controllers::VectorSetpoint::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/controllers/setpoint.h:166
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::controllers::VectorSetpoint::Kd
          struct /* Kd */ {

            // drake/systems/controllers/setpoint.h:252
            const char* doc = R"""()""";

          } Kd;

          // drake::systems::controllers::VectorSetpoint::Kp
          struct /* Kp */ {

            // drake/systems/controllers/setpoint.h:251
            const char* doc = R"""()""";

          } Kp;

          // drake::systems::controllers::VectorSetpoint::VectorSetpoint<Scalar>
          struct /* ctor */ {

            // drake/systems/controllers/setpoint.h:166
            const char* doc = R"""()""";

            // drake/systems/controllers/setpoint.h:166
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/setpoint.h:168
            const char* doc_3 = R"""()""";

            // drake/systems/controllers/setpoint.h:170
            const char* doc_4 = R"""()""";

            // drake/systems/controllers/setpoint.h:185
            const char* doc_5 =
R"""(Parameter ``pos_d``:
    Desired position

Parameter ``vel_d``:
    Desired velocity

Parameter ``acc_d``:
    Desired feedforward acceleration

Parameter ``Kp``:
    Position gain

Parameter ``Kd``:
    Velocity gain)""";

          } ctor;

          // drake::systems::controllers::VectorSetpoint::desired_acceleration
          struct /* desired_acceleration */ {

            // drake/systems/controllers/setpoint.h:250
            const char* doc = R"""()""";

          } desired_acceleration;

          // drake::systems::controllers::VectorSetpoint::desired_position
          struct /* desired_position */ {

            // drake/systems/controllers/setpoint.h:248
            const char* doc = R"""()""";

          } desired_position;

          // drake::systems::controllers::VectorSetpoint::desired_velocity
          struct /* desired_velocity */ {

            // drake/systems/controllers/setpoint.h:249
            const char* doc = R"""()""";

          } desired_velocity;

          // drake::systems::controllers::VectorSetpoint::is_valid
          struct /* is_valid */ {

            // drake/systems/controllers/setpoint.h:235
            const char* doc = R"""()""";

          } is_valid;

          // drake::systems::controllers::VectorSetpoint::mutable_Kd
          struct /* mutable_Kd */ {

            // drake/systems/controllers/setpoint.h:260
            const char* doc = R"""()""";

          } mutable_Kd;

          // drake::systems::controllers::VectorSetpoint::mutable_Kp
          struct /* mutable_Kp */ {

            // drake/systems/controllers/setpoint.h:259
            const char* doc = R"""()""";

          } mutable_Kp;

          // drake::systems::controllers::VectorSetpoint::mutable_desired_acceleration
          struct /* mutable_desired_acceleration */ {

            // drake/systems/controllers/setpoint.h:258
            const char* doc = R"""()""";

          } mutable_desired_acceleration;

          // drake::systems::controllers::VectorSetpoint::mutable_desired_position
          struct /* mutable_desired_position */ {

            // drake/systems/controllers/setpoint.h:256
            const char* doc = R"""()""";

          } mutable_desired_position;

          // drake::systems::controllers::VectorSetpoint::mutable_desired_velocity
          struct /* mutable_desired_velocity */ {

            // drake/systems/controllers/setpoint.h:257
            const char* doc = R"""()""";

          } mutable_desired_velocity;

          // drake::systems::controllers::VectorSetpoint::size
          struct /* size */ {

            // drake/systems/controllers/setpoint.h:253
            const char* doc = R"""()""";

          } size;

        } VectorSetpoint;

        // drake::systems::controllers::ZMPPlanner
        struct /* ZMPPlanner */ {

          // drake/systems/controllers/zmp_planner.h:70
          const char* doc =
R"""(Given a desired two dimensional (X and Y) zero-moment point (ZMP)
trajectory parameterized as a piecewise polynomial, an optimal center
of mass (CoM) trajectory is planned using a linear inverted pendulum
model (LIPM). A second order value function (optimal cost-to-go) and a
linear policy are also computed along the optimal trajectory. The
system dynamics for the X and Y directions are decoupled, however, we
plan the XY motion together for convenience.

Let $ c $ be the CoM position, the The state of the system, $ x $, is
$ [c; \dot{c}] $, the control, $ u = \ddot{c} $, and $ y $ represents
the center of pressure (CoP). For the X direction, the LIPM dynamics
is: \f[ y = c - \frac{z}{g} * u, \f] where $ g $ is the gravity
constant and $ z $ is the CoM height. $ z $ is assumed to be constant
in LIPM. The full dynamics can also be written in the matrix form as:
\f[ \dot{x} = A x + B u \\ y = C x + D u \f]

The one step cost function $ L $ is defined as: \f[ L(y, u, t) = (y -
y_d(t))^T Q_y (y - y_d(t)) + u^T R u, \f] where $ Q_y $ and $ R $ are
weighting matrices, and $ y_d(t) $ is the desired ZMP trajectory at
time $ t $.

The value function is defined as \f[ V(x, t) = \min_{u[t:t_f]}
\bar{x}(t_f)^T S \bar{x}(t_f) + \int_{t}^{t_f} L(y, u, \tau) d\tau,
\f] subject to the dynamics, and $ t_f $ is the last time in the
desired ZMP trajectory, $ \bar{x} = [c - y_d(t_f); \dot{c}] $, $ S $
is the quadratic term from the infinite horizon continuous time LQR
solution solved with the same dynamics and one step cost function.

For this problem, $ V $ is known to have a quadratic form of: \f[ V(x,
t) = \bar{x}^T V_{xx} \bar{x} + \bar{x}^T V_x(t) + V_0(t), \f] and the
corresponding optimal control policy, $ u^* $, is linear w.r.t. to $ x
$: \f[ u^*(x, t) = K \bar{x} + u_0(t). \f]

See the following reference for more details about the algorithm:

[1] R. Tedrake, S. Kuindersma, R. Deits and K. Miura, "A closed-form
solution for real-time ZMP gait generation and feedback
stabilization," 2015 IEEE-RAS 15th International Conference on
Humanoid Robots (Humanoids), Seoul, 2015, pp. 936-940.)""";

          // drake::systems::controllers::ZMPPlanner::ComputeOptimalCoMdd
          struct /* ComputeOptimalCoMdd */ {

            // drake/systems/controllers/zmp_planner.h:111
            const char* doc =
R"""(Computes the optimal control (CoM acceleration) at `time` given CoM
state `x` using the linear policy. Should only be called after Plan is
called.

Parameter ``time``:
    , Current time.

Parameter ``x``:
    , Current state.

Returns:
    Optimal CoMdd.)""";

          } ComputeOptimalCoMdd;

          // drake::systems::controllers::ZMPPlanner::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/controllers/zmp_planner.h:72
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::controllers::ZMPPlanner::Plan
          struct /* Plan */ {

            // drake/systems/controllers/zmp_planner.h:93
            const char* doc =
R"""(Implements the algorithm in [1] that computes a nominal CoM
trajectory, and the corresponding second order value function and
linear policy.

None of the other public methods should be called until Plan is
called.

It is allowed to pass in a `zmp_d` with a non-stationary end point,
but the user should treat the result with caution, since the resulting
nominal CoM trajectory diverges exponentially fast past the end point.

Parameter ``zmp_d``:
    , Desired two dimensional ZMP trajectory.

Parameter ``x0``:
    , Initial CoM state.

Parameter ``height``:
    , CoM height from the ground.

Parameter ``gravity``:
    , Gravity constant, defaults to 9.81

Parameter ``Qy``:
    , Quadratic cost term on ZMP deviation from the desired, defaults
    to identity.

Parameter ``R``:
    , Quadratic cost term on CoM acceleration, defaults to zero.)""";

          } Plan;

          // drake::systems::controllers::ZMPPlanner::ZMPPlanner
          struct /* ctor */ {

            // drake/systems/controllers/zmp_planner.h:72
            const char* doc = R"""()""";

            // drake/systems/controllers/zmp_planner.h:72
            const char* doc_2 = R"""()""";

            // drake/systems/controllers/zmp_planner.h:74
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::controllers::ZMPPlanner::comdd_to_cop
          struct /* comdd_to_cop */ {

            // drake/systems/controllers/zmp_planner.h:123
            const char* doc =
R"""(Converts CoM acceleration to center of pressure (CoP) using cop = C *
x + D * u, which is equivalent to cop = com - z / g * comdd Should
only be called after Plan is called.

Parameter ``x``:
    , CoM position and velocity

Parameter ``u``:
    , CoM acceleration

Returns:
    center of pressure (CoP))""";

          } comdd_to_cop;

          // drake::systems::controllers::ZMPPlanner::get_A
          struct /* get_A */ {

            // drake/systems/controllers/zmp_planner.h:132
            const char* doc = R"""(Getter for A matrix.)""";

          } get_A;

          // drake::systems::controllers::ZMPPlanner::get_B
          struct /* get_B */ {

            // drake/systems/controllers/zmp_planner.h:140
            const char* doc = R"""(Getter for B matrix.)""";

          } get_B;

          // drake::systems::controllers::ZMPPlanner::get_C
          struct /* get_C */ {

            // drake/systems/controllers/zmp_planner.h:148
            const char* doc = R"""(Getter for C matrix.)""";

          } get_C;

          // drake::systems::controllers::ZMPPlanner::get_D
          struct /* get_D */ {

            // drake/systems/controllers/zmp_planner.h:156
            const char* doc = R"""(Getter for D matrix.)""";

          } get_D;

          // drake::systems::controllers::ZMPPlanner::get_Qy
          struct /* get_Qy */ {

            // drake/systems/controllers/zmp_planner.h:164
            const char* doc = R"""(Getter for Qy matrix.)""";

          } get_Qy;

          // drake::systems::controllers::ZMPPlanner::get_R
          struct /* get_R */ {

            // drake/systems/controllers/zmp_planner.h:172
            const char* doc = R"""(Getter for R matrix.)""";

          } get_R;

          // drake::systems::controllers::ZMPPlanner::get_Vx
          struct /* get_Vx */ {

            // drake/systems/controllers/zmp_planner.h:262
            const char* doc =
R"""(Returns the time varying first order term (s2 in [1]) of the value
function.)""";

            // drake/systems/controllers/zmp_planner.h:272
            const char* doc_2 =
R"""(Returns the time varying first order term (s2 in [1]) of the value
function.)""";

          } get_Vx;

          // drake::systems::controllers::ZMPPlanner::get_Vxx
          struct /* get_Vxx */ {

            // drake/systems/controllers/zmp_planner.h:253
            const char* doc =
R"""(Returns the time invariant second order term (S1 in [1]) of the value
function.)""";

          } get_Vxx;

          // drake::systems::controllers::ZMPPlanner::get_desired_zmp
          struct /* get_desired_zmp */ {

            // drake/systems/controllers/zmp_planner.h:180
            const char* doc =
R"""(Returns the desired ZMP evaluated at `time`.)""";

            // drake/systems/controllers/zmp_planner.h:217
            const char* doc_2 = R"""(Returns the desired ZMP trajectory.)""";

          } get_desired_zmp;

          // drake::systems::controllers::ZMPPlanner::get_final_desired_zmp
          struct /* get_final_desired_zmp */ {

            // drake/systems/controllers/zmp_planner.h:209
            const char* doc = R"""()""";

          } get_final_desired_zmp;

          // drake::systems::controllers::ZMPPlanner::get_nominal_com
          struct /* get_nominal_com */ {

            // drake/systems/controllers/zmp_planner.h:188
            const char* doc =
R"""(Returns the nominal CoM evaluated at `time`.)""";

            // drake/systems/controllers/zmp_planner.h:226
            const char* doc_2 = R"""(Returns the nominal CoM trajectory.)""";

          } get_nominal_com;

          // drake::systems::controllers::ZMPPlanner::get_nominal_comd
          struct /* get_nominal_comd */ {

            // drake/systems/controllers/zmp_planner.h:196
            const char* doc =
R"""(Returns the nominal CoM velocity evaluated at `time`.)""";

            // drake/systems/controllers/zmp_planner.h:235
            const char* doc_2 =
R"""(Returns the nominal CoM velocity trajectory.)""";

          } get_nominal_comd;

          // drake::systems::controllers::ZMPPlanner::get_nominal_comdd
          struct /* get_nominal_comdd */ {

            // drake/systems/controllers/zmp_planner.h:204
            const char* doc =
R"""(Returns the nominal CoM acceleration evaluated at `time`.)""";

            // drake/systems/controllers/zmp_planner.h:244
            const char* doc_2 =
R"""(Returns the nominal CoM acceleration trajectory.)""";

          } get_nominal_comdd;

          // drake::systems::controllers::ZMPPlanner::has_planned
          struct /* has_planned */ {

            // drake/systems/controllers/zmp_planner.h:101
            const char* doc = R"""(Returns true if Plan has been called.)""";

          } has_planned;

        } ZMPPlanner;

        // drake::systems::controllers::operator<<
        struct /* operator_lshift */ {

          // drake/systems/controllers/setpoint.h:148
          const char* doc = R"""()""";

          // drake/systems/controllers/setpoint.h:277
          const char* doc_2 = R"""()""";

        } operator_lshift;

      } controllers;

      // drake::systems::kAbstractValued
      struct /* kAbstractValued */ {

        // drake/systems/framework/framework_common.h:67
        const char* doc = R"""()""";

      } kAbstractValued;

      // drake::systems::kVectorValued
      struct /* kVectorValued */ {

        // drake/systems/framework/framework_common.h:66
        const char* doc = R"""()""";

      } kVectorValued;

      // lcm
      struct /* lcm */ {

        // drake::systems::lcm::LcmAndVectorBaseTranslator
        struct /* LcmAndVectorBaseTranslator */ {

          // drake/systems/lcm/lcm_and_vector_base_translator.h:18
          const char* doc =
R"""(Defines an abstract parent class of all translators that convert
between LCM message bytes and `drake::systems::VectorBase` objects.)""";

          // drake::systems::lcm::LcmAndVectorBaseTranslator::AllocateOutputVector
          struct /* AllocateOutputVector */ {

            // drake/systems/lcm/lcm_and_vector_base_translator.h:45
            const char* doc =
R"""(Allocates the vector storage for an output port of our LCM message
type, in case special storage is needed. A result of nullptr indicates
that no special vector is needed; the calling code can and should use
a default vector implementation such as BasicVector.

The default implementation in this class returns nullptr. Subclasses
that require custom VectorBase subtypes should override it.)""";

          } AllocateOutputVector;

          // drake::systems::lcm::LcmAndVectorBaseTranslator::Deserialize
          struct /* Deserialize */ {

            // drake/systems/lcm/lcm_and_vector_base_translator.h:64
            const char* doc =
R"""(Translates LCM message bytes into a `drake::systems::VectorBase`
object.

Parameter ``lcm_message_bytes``:
    A pointer to a buffer holding the LCM message's data.

Parameter ``lcm_message_length``:
    The number of bytes pointed to by the ``lcm_message_bytes``.

Parameter ``vector_base``:
    A pointer to where the translation of the LCM message should be
    stored. This pointer must not be `nullptr`.

Throws:
    s runtime_error If a received LCM message failed to be decoded, or
    if the decoded LCM message is incompatible with the
    ``vector_base``. This often occurs when the size of the
    ``vector_base`` does not equal or is incompatible with the size of
    the decoded LCM message.)""";

          } Deserialize;

          // drake::systems::lcm::LcmAndVectorBaseTranslator::LcmAndVectorBaseTranslator
          struct /* ctor */ {

            // drake/systems/lcm/lcm_and_vector_base_translator.h:20
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_and_vector_base_translator.h:20
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_and_vector_base_translator.h:27
            const char* doc_3 =
R"""(The constructor.

Parameter ``size``:
    The size of the vector in the `VectorBase`.)""";

          } ctor;

          // drake::systems::lcm::LcmAndVectorBaseTranslator::Serialize
          struct /* Serialize */ {

            // drake/systems/lcm/lcm_and_vector_base_translator.h:79
            const char* doc =
R"""(Translates a `drake::systems::VectorBase` object into LCM message
bytes.

Parameter ``time``:
    The current time in seconds. This value is typically obtained from
    drake::systems::Context::get_time().

Parameter ``vector_base``:
    The object to convert into an LCM message.

Parameter ``lcm_message_bytes``:
    The LCM message bytes. This pointer must not be `nullptr`.)""";

          } Serialize;

          // drake::systems::lcm::LcmAndVectorBaseTranslator::get_vector_size
          struct /* get_vector_size */ {

            // drake/systems/lcm/lcm_and_vector_base_translator.h:34
            const char* doc =
R"""(Returns the size of the vector in the `drake::systems::VectorBase`
object.)""";

          } get_vector_size;

        } LcmAndVectorBaseTranslator;

        // drake::systems::lcm::LcmDecoderSystem
        struct /* LcmDecoderSystem */ {

          // drake/systems/lcm/translator_system.h:135
          const char* doc =
R"""(A decoding system that converts a Lcm message of MsgTypedata to data
of DataType. This system has exactly one input port and one output
port. The input port is always of abstract value, which contains the
encoded Lcm message. If DataType is derived from
systems::VectorBase<double>, the output port will be vector valued.
The output port will be abstract valued otherwise. The input and
output ports' model values are specified by the translator instance
passed to the constructor.)""";

          // drake::systems::lcm::LcmDecoderSystem::LcmDecoderSystem<DataType, MsgType>
          struct /* ctor */ {

            // drake/systems/lcm/translator_system.h:137
            const char* doc = R"""()""";

            // drake/systems/lcm/translator_system.h:137
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/translator_system.h:152
            const char* doc_3 =
R"""(Constructor when DataType is derived from systems::VectorBase<double>.
Declares an abstract input port and a vector valued output port. Sets
the model values for the input and output ports to ``translator``'s
corresponding default values.

Parameter ``translator``:
    Translator, whose ownership is transferred to this.)""";

            // drake/systems/lcm/translator_system.h:172
            const char* doc_4 =
R"""(Constructor when DataType is not derived from
systems::VectorBase<double>. Declares an abstract input port and an
abstract valued output port. Sets the model values for the input and
output ports to ``translator``'s corresponding default values.

Parameter ``translator``:
    Translator, whose ownership is transferred to this.)""";

          } ctor;

          // drake::systems::lcm::LcmDecoderSystem::get_translator
          struct /* get_translator */ {

            // drake/systems/lcm/translator_system.h:183
            const char* doc =
R"""(Returns a const reference to the translator.)""";

          } get_translator;

        } LcmDecoderSystem;

        // drake::systems::lcm::LcmDrivenLoop
        struct /* LcmDrivenLoop */ {

          // drake/systems/lcm/lcm_driven_loop.h:103
          const char* doc =
R"""(This class implements a loop that's driven by a Lcm message. The
context time is explicitly slaved to the time in the received Lcm
message. This class is intended to provide a generalized way to
implement a message handling loop: an input message arrives, from
which a response is computed and published. A common use case is to
implement a distributed controller for a physical robot, where low
level communication with the hardware is handled in the device driver
(a separate process than the controller). The device driver sends a
message containing the estimated state. The controller processes that
message and sends back a command in response. The device driver
finally receives and executes the command.

This class is designed to be agnostic to different types of the
driving Lcm message to provide a generic API. The Lcm message is
internally encapsulated in AbstractValue, which erases its type. In
addition, the message time stamp is the only required information by
this class, which can be extracted by an instance of
LcmMessageToTimeInterface. It is assumed that the caller knows the
concrete type of the message, and is able to supply a time converter.

This class uses the Simulator class internally for event handling
(kPublishAction, kDiscreteUpdateAction, kUnrestrictedUpdateAction) and
continuous state integration (e.g. the I term in a PID). The main
message handling loop conceptually is:

```
while(context.time < stop_time) {
  msg = wait_for_message("channel");
  simulator.StepTo(msg.time);
  if (publish) {
    system.Publish(simulator.context);
  }
}
```

Since time is slaved to some outside source, the user needs to be
mindful of `system`'s configuration especially about event timing. For
example, let us assume that `system` is configured to perform a
discrete time action every 5ms (at 200Hz), and the necessary
computation for `system` to step forward in time is very small. Now,
suppose the driving message arrives at 1 Hz in real time. One would
observe 200 such actions occur in rapid succession followed by nearly
one second of silence. This is because `msg =
wait_for_message("channel")` takes about one second in real time, and
`simulator.StepTo(msg.time)`, which forwards the simulator's clock by
one second and performs 200 actions takes about 0 seconds in real
time. The root cause is that the 200Hz rate of the handler system is
tied to the internal virtual clock rather than real time. This problem
is less significant when the computation time for handling one message
is roughly the same as the interval between consecutive driving
messages.

This implementation relies on several assumptions: 1. The loop is
blocked only on one Lcm message. 2. It's pointless to for the handler
system to perform any computation without a new Lcm message, thus the
handler loop is blocking. 3. The computation for the given system
should be faster than the incoming message rate.)""";

          // drake::systems::lcm::LcmDrivenLoop::LcmDrivenLoop
          struct /* ctor */ {

            // drake/systems/lcm/lcm_driven_loop.h:105
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:105
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:124
            const char* doc_3 =
R"""(Constructor.

Parameter ``system``:
    Const reference to the handler system. Its life span must be
    longer than `this`.

Parameter ``driving_subscriber``:
    Const reference to the driving subscriber. Its life span must be
    longer than `this`.

Parameter ``context``:
    Unique pointer to a context allocated for ``system``. Can be
    nullptr, in which case a context will be allocated internally.

Parameter ``lcm``:
    Pointer to Lcm interface. Its life span must be longer than
    `this`. ``lcm`` cannot be nullptr, otherwise aborts.

Parameter ``time_converter``:
    Unique pointer to a converter that extracts time in seconds from
    the driving message time. Cannot be nullptr, otherwise `this`
    aborts. ``time_converter`` is necessary because of two reasons. 1:
    The Lcm message type agnostic design of this class. 2: Lcm
    messages lack a uniform time stamp field that has consistent
    units. So extracting the time stamp depends on the concrete
    message content.)""";

          } ctor;

          // drake::systems::lcm::LcmDrivenLoop::RunToSecondsAssumingInitialized
          struct /* RunToSecondsAssumingInitialized */ {

            // drake/systems/lcm/lcm_driven_loop.h:145
            const char* doc =
R"""(Starts the message handling loop assuming the context (e.g. state and
time) has already been properly initialized by the caller if
necessary.

Parameter ``stop_time``:
    End time in seconds relative to the time stamp in the driving Lcm
    message.)""";

          } RunToSecondsAssumingInitialized;

          // drake::systems::lcm::LcmDrivenLoop::WaitForMessage
          struct /* WaitForMessage */ {

            // drake/systems/lcm/lcm_driven_loop.h:137
            const char* doc =
R"""(Blocks the caller until a driving Lcm message is received, then
returns a const reference of AbstractValue to that message. The call
is assumed to know the type of the actual message and have means to
inspect the message.)""";

          } WaitForMessage;

          // drake::systems::lcm::LcmDrivenLoop::get_message_to_time_converter
          struct /* get_message_to_time_converter */ {

            // drake/systems/lcm/lcm_driven_loop.h:168
            const char* doc =
R"""(Returns a const reference to the message to seconds converter.)""";

          } get_message_to_time_converter;

          // drake::systems::lcm::LcmDrivenLoop::get_mutable_context
          struct /* get_mutable_context */ {

            // drake/systems/lcm/lcm_driven_loop.h:161
            const char* doc =
R"""(Returns a mutable reference to the context.)""";

          } get_mutable_context;

          // drake::systems::lcm::LcmDrivenLoop::set_publish_on_every_received_message
          struct /* set_publish_on_every_received_message */ {

            // drake/systems/lcm/lcm_driven_loop.h:154
            const char* doc =
R"""(Sets a flag that forces Publish() at the very beginning of the message
handling loop as well as inside the loop. To achieve "publish whenever
a new message has been handled", the user needs to make sure that no
subsystems have declared period publish, and ``flag`` is true.)""";

          } set_publish_on_every_received_message;

        } LcmDrivenLoop;

        // drake::systems::lcm::LcmEncoderSystem
        struct /* LcmEncoderSystem */ {

          // drake/systems/lcm/translator_system.h:64
          const char* doc =
R"""(An encoding system that converts data of DataType to a Lcm message of
MsgType. This system has exactly one input port and one output port.
The output port is always of abstract value, which contains the
encoded Lcm message. If DataType is derived from
systems::VectorBase<double>, the input port will be vector valued. The
input port will be abstract valued otherwise. The input and output
ports' model values are specified by the translator instance passed to
the constructor.)""";

          // drake::systems::lcm::LcmEncoderSystem::LcmEncoderSystem<DataType, MsgType>
          struct /* ctor */ {

            // drake/systems/lcm/translator_system.h:66
            const char* doc = R"""()""";

            // drake/systems/lcm/translator_system.h:66
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/translator_system.h:82
            const char* doc_3 =
R"""(Constructor when DataType is derived from systems::VectorBase<double>.
Declares a vector valued input port and an abstract output port. Sets
the model values for the input and output ports to ``translator``'s
corresponding default values.

Parameter ``translator``:
    Translator, whose ownership is transferred to this instance.)""";

            // drake/systems/lcm/translator_system.h:101
            const char* doc_4 =
R"""(Constructor when DataType is not derived from
systems::VectorBase<double>. Declares an abstract valued input port
and an abstract output port. Sets the model values for the input and
output ports to ``translator``'s corresponding default values.

Parameter ``translator``:
    Translator, whose ownership is transferred to this.)""";

          } ctor;

          // drake::systems::lcm::LcmEncoderSystem::get_translator
          struct /* get_translator */ {

            // drake/systems/lcm/translator_system.h:111
            const char* doc =
R"""(Returns a const reference to the translator.)""";

          } get_translator;

        } LcmEncoderSystem;

        // drake::systems::lcm::LcmLogPlaybackSystem
        struct /* LcmLogPlaybackSystem */ {

          // drake/systems/lcm/lcm_log_playback_system.h:19
          const char* doc =
R"""(Advances the cursor of a drake::lcm::DrakeLcmLog based on the
timestamps seen the Context that is used to simulate this System.

This is useful when a simulated Diagram contains
LcmSubscriberSystem(s) whose outputs should be determined by logged
data and when the log's cursor should advance automatically during
simulation.)""";

          // drake::systems::lcm::LcmLogPlaybackSystem::DoCalcNextUpdateTime
          struct /* DoCalcNextUpdateTime */ {

            // drake/systems/lcm/lcm_log_playback_system.h:33
            const char* doc = R"""()""";

          } DoCalcNextUpdateTime;

          // drake::systems::lcm::LcmLogPlaybackSystem::LcmLogPlaybackSystem
          struct /* ctor */ {

            // drake/systems/lcm/lcm_log_playback_system.h:21
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_log_playback_system.h:21
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_log_playback_system.h:28
            const char* doc_3 =
R"""(Constructs a playback system that advances the given ``log``.

Parameter ``log``:
    non-null pointer that is aliased and retained by this object.)""";

          } ctor;

        } LcmLogPlaybackSystem;

        // drake::systems::lcm::LcmMessageToTimeInterface
        struct /* LcmMessageToTimeInterface */ {

          // drake/systems/lcm/lcm_driven_loop.h:19
          const char* doc =
R"""(A generic translator interface that extracts time in seconds from an
abstract type.)""";

          // drake::systems::lcm::LcmMessageToTimeInterface::GetTimeInSeconds
          struct /* GetTimeInSeconds */ {

            // drake/systems/lcm/lcm_driven_loop.h:24
            const char* doc = R"""()""";

          } GetTimeInSeconds;

          // drake::systems::lcm::LcmMessageToTimeInterface::LcmMessageToTimeInterface
          struct /* ctor */ {

            // drake/systems/lcm/lcm_driven_loop.h:21
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:21
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:28
            const char* doc_3 = R"""()""";

          } ctor;

        } LcmMessageToTimeInterface;

        // drake::systems::lcm::LcmPublisherSystem
        struct /* LcmPublisherSystem */ {

          // drake/systems/lcm/lcm_publisher_system.h:38
          const char* doc =
R"""(Publishes an LCM message containing information from its input port.
Optionally sends a one-time initialization message.

Note:
    You should generally provide an LCM interface yourself, since
    there should normally be just one of these typically-heavyweight
    objects per program. However, if you're sure there isn't any other
    need for an LCM interface in your program, you can let
    LcmPublisherSystem allocate and maintain a drake::lcm::DrakeLcm
    object internally.)""";

          // drake::systems::lcm::LcmPublisherSystem::AddInitializationMessage
          struct /* AddInitializationMessage */ {

            // drake/systems/lcm/lcm_publisher_system.h:141
            const char* doc =
R"""(Specifies a message-publishing function to be invoked once from an
initialization event. If this method is not called, no initialization
event will be created.

You can only call this method once.

Throws:
    s std::logic_error if called a second time.

@pre The publisher function may not be null.)""";

          } AddInitializationMessage;

          // drake::systems::lcm::LcmPublisherSystem::LcmPublisherSystem
          struct /* ctor */ {

            // drake/systems/lcm/lcm_publisher_system.h:40
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_publisher_system.h:40
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_publisher_system.h:78
            const char* doc_3 =
R"""(A constructor for an LcmPublisherSystem that takes LCM message objects
on its sole abstract-valued input port. The LCM message type is
determined by the provided `serializer`.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.)""";

            // drake/systems/lcm/lcm_publisher_system.h:98
            const char* doc_4 =
R"""(A constructor for an LcmPublisherSystem that takes vector data on its
sole vector-valued input port. The vector data is mapped to message
content by the provided `translator`.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``translator``:
    The translator that converts between LCM message objects and
    drake::systems::VectorBase objects. This reference must remain
    valid for the lifetime of this object.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.)""";

            // drake/systems/lcm/lcm_publisher_system.h:118
            const char* doc_5 =
R"""(Constructor that returns a publisher System that takes vector data on
its sole vector-valued input port. The vector data are mapped to
message contents by the `translator` found in the provided
`translator_dictionary`.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``translator_dictionary``:
    A dictionary for obtaining the appropriate translator for a
    particular LCM channel. This reference must remain valid for the
    lifetime of this object.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.)""";

          } ctor;

          // drake::systems::lcm::LcmPublisherSystem::Make
          struct /* Make */ {

            // drake/systems/lcm/lcm_publisher_system.h:56
            const char* doc =
R"""(A factory method that returns an LcmPublisherSystem that takes
Value<LcmMessage> message objects on its sole abstract-valued input
port.

Template parameter ``LcmMessage``:
    message type to serialize, e.g., lcmt_drake_signal.

Parameter ``channel``:
    The LCM channel on which to publish.

Parameter ``lcm``:
    A pointer to the LCM subsystem to use, which must remain valid for
    the lifetime of this object. If null, a drake::lcm::DrakeLcm
    object is allocated and maintained internally, but see the note in
    the class comments.)""";

          } Make;

          // drake::systems::lcm::LcmPublisherSystem::get_channel_name
          struct /* get_channel_name */ {

            // drake/systems/lcm/lcm_publisher_system.h:147
            const char* doc =
R"""(Returns the channel name supplied during construction.)""";

          } get_channel_name;

          // drake::systems::lcm::LcmPublisherSystem::get_input_port
          struct /* get_input_port */ {

            // drake/systems/lcm/lcm_publisher_system.h:184
            const char* doc = R"""(Returns the sole input port.)""";

            // drake/systems/lcm/lcm_publisher_system.h:190
            const char* doc_2 = R"""()""";

          } get_input_port;

          // drake::systems::lcm::LcmPublisherSystem::get_output_port
          struct /* get_output_port */ {

            // drake/systems/lcm/lcm_publisher_system.h:196
            const char* doc = R"""()""";

          } get_output_port;

          // drake::systems::lcm::LcmPublisherSystem::get_translator
          struct /* get_translator */ {

            // drake/systems/lcm/lcm_publisher_system.h:169
            const char* doc =
R"""(Returns the translator used by this publisher. This can be used to
convert a serialized LCM message provided by
DrakeMockLcm::get_last_published_message() into a BasicVector. It is
useful in unit tests for verifying that a BasicVector was correctly
published as an LCM message. @pre this system is using a vector-valued
port (not abstract-valued).)""";

          } get_translator;

          // drake::systems::lcm::LcmPublisherSystem::lcm
          struct /* lcm */ {

            // drake/systems/lcm/lcm_publisher_system.h:176
            const char* doc =
R"""(Returns a mutable reference to the LCM object in use by this
publisher. This may have been supplied in the constructor or may be an
internally-maintained object of type drake::lcm::DrakeLcm.)""";

          } lcm;

          // drake::systems::lcm::LcmPublisherSystem::make_name
          struct /* make_name */ {

            // drake/systems/lcm/lcm_publisher_system.h:152
            const char* doc =
R"""(Returns the default name for a system that publishes ``channel``.)""";

          } make_name;

          // drake::systems::lcm::LcmPublisherSystem::set_publish_period
          struct /* set_publish_period */ {

            // drake/systems/lcm/lcm_publisher_system.h:159
            const char* doc =
R"""(Sets the publishing period of this system. See
LeafSystem::DeclarePeriodicPublish() for details about the semantics
of parameter `period`.)""";

          } set_publish_period;

        } LcmPublisherSystem;

        // drake::systems::lcm::LcmSubscriberSystem
        struct /* LcmSubscriberSystem */ {

          // drake/systems/lcm/lcm_subscriber_system.h:46
          const char* doc =
R"""(Receives LCM messages from a given channel and outputs them to a
System<double>'s port. This class stores the most recently processed
LCM message in the State. When a LCM message arrives asynchronously,
an update event is scheduled to process the message and store it in
the State at the earliest possible simulation time. The output is
always consistent with the State.

To process a LCM message, CalcNextUpdateTime() needs to be called
first to check for new messages and schedule a callback event if a new
LCM message has arrived. The message is then processed and stored in
the Context by CalcDiscreteVariableUpdates() or
CalcUnrestrictedUpdate() depending on the output type. When this
system is evaluated by the Simulator, all these operations are taken
care of by the Simulator. On the other hand, the user needs to
manually replicate this process without the Simulator.

If LCM service in use is a drake::lcm::DrakeLcmLog (not live
operation), then see drake::systems::lcm::LcmLogPlaybackSystem for a
helper to advance the log cursor in concert with the simulation.)""";

          // drake::systems::lcm::LcmSubscriberSystem::AllocateAbstractState
          struct /* AllocateAbstractState */ {

            // drake/systems/lcm/lcm_subscriber_system.h:182
            const char* doc = R"""()""";

          } AllocateAbstractState;

          // drake::systems::lcm::LcmSubscriberSystem::AllocateDiscreteState
          struct /* AllocateDiscreteState */ {

            // drake/systems/lcm/lcm_subscriber_system.h:191
            const char* doc = R"""()""";

          } AllocateDiscreteState;

          // drake::systems::lcm::LcmSubscriberSystem::DoCalcDiscreteVariableUpdates
          struct /* DoCalcDiscreteVariableUpdates */ {

            // drake/systems/lcm/lcm_subscriber_system.h:184
            const char* doc = R"""()""";

          } DoCalcDiscreteVariableUpdates;

          // drake::systems::lcm::LcmSubscriberSystem::DoCalcNextUpdateTime
          struct /* DoCalcNextUpdateTime */ {

            // drake/systems/lcm/lcm_subscriber_system.h:171
            const char* doc = R"""()""";

          } DoCalcNextUpdateTime;

          // drake::systems::lcm::LcmSubscriberSystem::DoCalcUnrestrictedUpdate
          struct /* DoCalcUnrestrictedUpdate */ {

            // drake/systems/lcm/lcm_subscriber_system.h:175
            const char* doc = R"""()""";

          } DoCalcUnrestrictedUpdate;

          // drake::systems::lcm::LcmSubscriberSystem::GetInternalMessageCount
          struct /* GetInternalMessageCount */ {

            // drake/systems/lcm/lcm_subscriber_system.h:163
            const char* doc =
R"""(Returns the internal message counter. Meant to be used with
`WaitForMessage`.)""";

          } GetInternalMessageCount;

          // drake::systems::lcm::LcmSubscriberSystem::GetMessageCount
          struct /* GetMessageCount */ {

            // drake/systems/lcm/lcm_subscriber_system.h:168
            const char* doc =
R"""(Returns the message counter stored in ``context``.)""";

          } GetMessageCount;

          // drake::systems::lcm::LcmSubscriberSystem::LcmSubscriberSystem
          struct /* ctor */ {

            // drake/systems/lcm/lcm_subscriber_system.h:48
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_subscriber_system.h:48
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_subscriber_system.h:79
            const char* doc_3 =
R"""(Constructor that returns a subscriber System that provides message
objects on its sole abstract-valued output port. The type of the
message object is determined by the ``serializer``.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``serializer``:
    The serializer that converts between byte vectors and LCM message
    objects.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";

            // drake/systems/lcm/lcm_subscriber_system.h:97
            const char* doc_4 =
R"""(Constructor that returns a subscriber System that provides vector data
on its sole vector-valued output port. The message contents are mapped
to vector data by the ``translator``.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``translator``:
    A reference to the translator that converts between LCM message
    objects and `drake::systems::VectorBase` objects. The reference
    must remain valid for the lifetime of this `LcmSubscriberSystem`
    object.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";

            // drake/systems/lcm/lcm_subscriber_system.h:114
            const char* doc_5 =
R"""(Constructor that returns a subscriber System that provides vector data
on its sole vector-valued output port. The message contents are mapped
to vector data by the a translator found in the
``translator_dictionary``.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``translator_dictionary``:
    A dictionary for obtaining the appropriate translator for a
    particular LCM channel. The reference must remain valid for the
    lifetime of this `LcmSubscriberSystem` object.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";

          } ctor;

          // drake::systems::lcm::LcmSubscriberSystem::Make
          struct /* Make */ {

            // drake/systems/lcm/lcm_subscriber_system.h:61
            const char* doc =
R"""(Factory method that returns a subscriber System that provides
Value<LcmMessage> message objects on its sole abstract-valued output
port.

Template parameter ``LcmMessage``:
    message type to deserialize, e.g., lcmt_drake_signal.

Parameter ``channel``:
    The LCM channel on which to subscribe.

Parameter ``lcm``:
    A non-null pointer to the LCM subsystem to subscribe on.)""";

          } Make;

          // drake::systems::lcm::LcmSubscriberSystem::SetDefaultState
          struct /* SetDefaultState */ {

            // drake/systems/lcm/lcm_subscriber_system.h:194
            const char* doc = R"""()""";

          } SetDefaultState;

          // drake::systems::lcm::LcmSubscriberSystem::WaitForMessage
          struct /* WaitForMessage */ {

            // drake/systems/lcm/lcm_subscriber_system.h:156
            const char* doc =
R"""(Blocks the caller until its internal message count exceeds
`old_message_count`.

Parameter ``old_message_count``:
    Internal message counter.

Parameter ``message``:
    If non-null, will return the received message. @pre If `message`
    is specified, this system must be abstract-valued.)""";

          } WaitForMessage;

          // drake::systems::lcm::LcmSubscriberSystem::get_channel_name
          struct /* get_channel_name */ {

            // drake/systems/lcm/lcm_subscriber_system.h:123
            const char* doc = R"""()""";

          } get_channel_name;

          // drake::systems::lcm::LcmSubscriberSystem::get_input_port
          struct /* get_input_port */ {

            // drake/systems/lcm/lcm_subscriber_system.h:147
            const char* doc = R"""()""";

          } get_input_port;

          // drake::systems::lcm::LcmSubscriberSystem::get_output_port
          struct /* get_output_port */ {

            // drake/systems/lcm/lcm_subscriber_system.h:135
            const char* doc = R"""(Returns the sole output port.)""";

            // drake/systems/lcm/lcm_subscriber_system.h:141
            const char* doc_2 = R"""()""";

          } get_output_port;

          // drake::systems::lcm::LcmSubscriberSystem::get_translator
          struct /* get_translator */ {

            // drake/systems/lcm/lcm_subscriber_system.h:132
            const char* doc =
R"""(Returns the translator used by this subscriber. This translator can be
used to translate a BasicVector into a serialized LCM message, which
is then passed to DrakeMockLcm::InduceSubscriberCallback(). This
mimics a message reception by an LCM subscriber and is useful for unit
testing. @pre this system is using a vector-valued port (not abstract-
valued).)""";

          } get_translator;

          // drake::systems::lcm::LcmSubscriberSystem::make_name
          struct /* make_name */ {

            // drake/systems/lcm/lcm_subscriber_system.h:121
            const char* doc =
R"""(Returns the default name for a system that subscribes to ``channel``.)""";

          } make_name;

        } LcmSubscriberSystem;

        // drake::systems::lcm::LcmTranslatorDictionary
        struct /* LcmTranslatorDictionary */ {

          // drake/systems/lcm/lcm_translator_dictionary.h:20
          const char* doc =
R"""(A dictionary that maps between LCM channel names and translators that
convert between LCM message objects and VectorBase objects. All
translators contained within the dictionary are guaranteed to remain
in existence throughout the lifespan of this object.)""";

          // drake::systems::lcm::LcmTranslatorDictionary::AddEntry
          struct /* AddEntry */ {

            // drake/systems/lcm/lcm_translator_dictionary.h:41
            const char* doc =
R"""(Adds a translator this dictionary.

Parameter ``channel_name``:
    The name of the LCM channel. Messages sent on and received from
    this channel are assumed to be compatible with ``translator``.

Parameter ``translator``:
    A pointer to the translator to use with the LCM channel.

Throws:
    s std::runtime_error If a translator for the ``channel_name`` is
    already in the dictionary.)""";

          } AddEntry;

          // drake::systems::lcm::LcmTranslatorDictionary::GetTranslator
          struct /* GetTranslator */ {

            // drake/systems/lcm/lcm_translator_dictionary.h:59
            const char* doc =
R"""(Returns a reference to the translator to use with the specified
channel. This reference is guaranteed to remain valid for the lifetime
of this dictionary.

Throws:
    s std::runtime_error if a translator for ``channel_name`` does not
    exist in this dictionary.)""";

          } GetTranslator;

          // drake::systems::lcm::LcmTranslatorDictionary::HasTranslator
          struct /* HasTranslator */ {

            // drake/systems/lcm/lcm_translator_dictionary.h:49
            const char* doc =
R"""(Returns true if and only if a translator for ``channel_name`` exists
in the dictionary.)""";

          } HasTranslator;

          // drake::systems::lcm::LcmTranslatorDictionary::LcmTranslatorDictionary
          struct /* ctor */ {

            // drake/systems/lcm/lcm_translator_dictionary.h:22
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_translator_dictionary.h:22
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_translator_dictionary.h:27
            const char* doc_3 =
R"""(The constructor. The dictionary is initially empty.)""";

          } ctor;

        } LcmTranslatorDictionary;

        // drake::systems::lcm::LcmtDrakeSignalTranslator
        struct /* LcmtDrakeSignalTranslator */ {

          // drake/systems/lcm/lcmt_drake_signal_translator.h:21
          const char* doc =
R"""(Specializes LcmAndVectorBaseTranslator to handle LCM messages of type
`drake::lcmt_drake_signal`.

Assumes the number and order of values in the LCM message and the
drake::systems::VectorBase are identical.)""";

          // drake::systems::lcm::LcmtDrakeSignalTranslator::Deserialize
          struct /* Deserialize */ {

            // drake/systems/lcm/lcmt_drake_signal_translator.h:35
            const char* doc = R"""()""";

          } Deserialize;

          // drake::systems::lcm::LcmtDrakeSignalTranslator::LcmtDrakeSignalTranslator
          struct /* ctor */ {

            // drake/systems/lcm/lcmt_drake_signal_translator.h:23
            const char* doc = R"""()""";

            // drake/systems/lcm/lcmt_drake_signal_translator.h:23
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcmt_drake_signal_translator.h:32
            const char* doc_3 =
R"""(A constructor that sets the expected sizes of the LCM message and the
VectorBase. Both the LCM message and VectorBase must be the same size.

Parameter ``size``:
    The number of elements in both `VectorBase` and
    `drake::lcmt_drake_signal`.)""";

          } ctor;

          // drake::systems::lcm::LcmtDrakeSignalTranslator::Serialize
          struct /* Serialize */ {

            // drake/systems/lcm/lcmt_drake_signal_translator.h:39
            const char* doc = R"""()""";

          } Serialize;

        } LcmtDrakeSignalTranslator;

        // drake::systems::lcm::Serializer
        struct /* Serializer */ {

          // drake/systems/lcm/serializer.h:58
          const char* doc =
R"""(Serializer is specific to a single LcmMessage type, and translates
between LCM message bytes and drake::systems::Value<LcmMessage>
objects.

Template parameter ``LcmMessage``:
    message type to serialize, e.g., lcmt_drake_signal.)""";

          // drake::systems::lcm::Serializer::CreateDefaultValue
          struct /* CreateDefaultValue */ {

            // drake/systems/lcm/serializer.h:65
            const char* doc = R"""()""";

          } CreateDefaultValue;

          // drake::systems::lcm::Serializer::Deserialize
          struct /* Deserialize */ {

            // drake/systems/lcm/serializer.h:72
            const char* doc = R"""()""";

          } Deserialize;

          // drake::systems::lcm::Serializer::Serialize
          struct /* Serialize */ {

            // drake/systems/lcm/serializer.h:81
            const char* doc = R"""()""";

          } Serialize;

          // drake::systems::lcm::Serializer::Serializer<LcmMessage>
          struct /* ctor */ {

            // drake/systems/lcm/serializer.h:60
            const char* doc = R"""()""";

            // drake/systems/lcm/serializer.h:60
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/serializer.h:62
            const char* doc_3 = R"""()""";

          } ctor;

        } Serializer;

        // drake::systems::lcm::SerializerInterface
        struct /* SerializerInterface */ {

          // drake/systems/lcm/serializer.h:22
          const char* doc =
R"""(SerializerInterface translates between LCM message bytes and
drake::systems::AbstractValue objects that contain LCM messages, e.g.,
a Value<lcmt_drake_signal>. See Serializer for a message-specific
concrete subclass.)""";

          // drake::systems::lcm::SerializerInterface::CreateDefaultValue
          struct /* CreateDefaultValue */ {

            // drake/systems/lcm/serializer.h:32
            const char* doc =
R"""(Creates a value-initialized (zeroed) instance of the message object.
The result can be used as the output object filled in by Deserialize.)""";

          } CreateDefaultValue;

          // drake::systems::lcm::SerializerInterface::Deserialize
          struct /* Deserialize */ {

            // drake/systems/lcm/serializer.h:37
            const char* doc =
R"""(Translates LCM message bytes into a drake::systems::AbstractValue
object.)""";

          } Deserialize;

          // drake::systems::lcm::SerializerInterface::Serialize
          struct /* Serialize */ {

            // drake/systems/lcm/serializer.h:44
            const char* doc =
R"""(Translates a drake::systems::AbstractValue object into LCM message
bytes.)""";

          } Serialize;

          // drake::systems::lcm::SerializerInterface::SerializerInterface
          struct /* ctor */ {

            // drake/systems/lcm/serializer.h:24
            const char* doc = R"""()""";

            // drake/systems/lcm/serializer.h:24
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/serializer.h:48
            const char* doc_3 = R"""()""";

          } ctor;

        } SerializerInterface;

        // drake::systems::lcm::UtimeMessageToSeconds
        struct /* UtimeMessageToSeconds */ {

          // drake/systems/lcm/lcm_driven_loop.h:36
          const char* doc =
R"""(A translator class for Lcm message types that have a "utime" field,
which is in micro seconds.)""";

          // drake::systems::lcm::UtimeMessageToSeconds::GetTimeInSeconds
          struct /* GetTimeInSeconds */ {

            // drake/systems/lcm/lcm_driven_loop.h:42
            const char* doc = R"""()""";

          } GetTimeInSeconds;

          // drake::systems::lcm::UtimeMessageToSeconds::UtimeMessageToSeconds<MessageType>
          struct /* ctor */ {

            // drake/systems/lcm/lcm_driven_loop.h:38
            const char* doc = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:38
            const char* doc_2 = R"""()""";

            // drake/systems/lcm/lcm_driven_loop.h:39
            const char* doc_3 = R"""()""";

          } ctor;

        } UtimeMessageToSeconds;

        // translator_system_detail
        struct /* translator_system_detail */ {

          // drake::systems::lcm::translator_system_detail::DataTypeTraits
          struct /* DataTypeTraits */ {

            // drake/systems/lcm/translator_system.h:18
            const char* doc = R"""()""";

          } DataTypeTraits;

        } translator_system_detail;

      } lcm;

      // leaf_system_detail
      struct /* leaf_system_detail */ {

        // drake::systems::leaf_system_detail::GetNextSampleTime
        struct /* GetNextSampleTime */ {

          // drake/systems/framework/leaf_system.h:45
          const char* doc = R"""()""";

        } GetNextSampleTime;

      } leaf_system_detail;

      // drake::systems::operator<<
      struct /* operator_lshift */ {

        // drake/systems/framework/basic_vector.h:188
        const char* doc = R"""()""";

      } operator_lshift;

      // plants
      struct /* plants */ {

        // drake::systems::plants::AddQuasiStaticConstraint
        struct /* AddQuasiStaticConstraint */ {

          // drake/multibody/inverse_kinematics_backend.h:84
          const char* doc =
R"""(Add a single time linear posture constraint to ``prog`` at time ``t``
covering ``vars``. ``kin_helper`` is the KinematicsCacheHelper for the
underlying model.)""";

        } AddQuasiStaticConstraint;

        // drake::systems::plants::AddSingleTimeLinearPostureConstraint
        struct /* AddSingleTimeLinearPostureConstraint */ {

          // drake/multibody/inverse_kinematics_backend.h:76
          const char* doc =
R"""(Add a single time linear posture constraint to ``prog`` at time ``t``
covering ``vars``. ``nq`` is the number of positions in the underlying
model.)""";

        } AddSingleTimeLinearPostureConstraint;

        // drake::systems::plants::GetIKSolverInfo
        struct /* GetIKSolverInfo */ {

          // drake/multibody/inverse_kinematics_backend.h:67
          const char* doc =
R"""(Translate a solver result into something expected for the info output
parameter.)""";

        } GetIKSolverInfo;

        // drake::systems::plants::IKTrajectoryHelper
        struct /* IKTrajectoryHelper */ {

          // drake/multibody/ik_trajectory_helper.h:18
          const char* doc =
R"""(This class is a helper for backend implementations of inverse
kinematics trajectory planning. It holds some general data about the
problem being computed and is able to calculate some of the
interesting parts of the optimization. It is intended to only
hold/calculate data which is independent of the solver being used.)""";

          // drake::systems::plants::IKTrajectoryHelper::CalculateCost
          struct /* CalculateCost */ {

            // drake/multibody/ik_trajectory_helper.h:52
            const char* doc =
R"""(Calculate the cost given the current ``q``, ``qdot0``, and ``qdotf``.

Returns:
    cost

Parameter ``q``:
    -- Current position estimates

Parameter ``q_nom``:
    -- Estimates for nominal postures

Parameter ``qstart_idx``:
    -- offset into q to start considering in cost calculations
    (usually 0 if the initial state is free, and 1 otherwise)

Parameter ``qdot0``:
    -- current estimate of qdot at timestep 0

Parameter ``qdotf``:
    -- current estimate of qdot at final timestep

Parameter ``fix_initial_state``:
    -- true if the initial state is fixed

Parameter ``dJ_vec``:
    Matrix to be filled in with the current gradients.)""";

          } CalculateCost;

          // drake::systems::plants::IKTrajectoryHelper::IKTrajectoryHelper
          struct /* ctor */ {

            // drake/multibody/ik_trajectory_helper.h:34
            const char* doc =
R"""(Parameter ``nq``:
    -- number of positions of the body

Parameter ``nT``:
    -- number of timesteps being planned

Parameter ``t``:
    -- array of timestep values (of length ``nT``)

Parameter ``num_qfree``:
    -- number of timesteps for which position variables are free to
    change during optimization.

Parameter ``num_qdotfree``:
    -- number of qdot states which are free to change during
    optimization (in practice, this will be 1 (final only) when the
    initial state is fixed, and 2 (initial and final) otherwise.

Parameter ``ikoptions``:
    -- options passed to inverseKinTraj

Parameter ``dt``:
    -- array of deltas between timestamps (length nT - 1)

Parameter ``dt_ratio``:
    -- ratio of consecutive values in dt (length nT - 2))""";

          } ctor;

          // drake::systems::plants::IKTrajectoryHelper::Q
          struct /* Q */ {

            // drake/multibody/ik_trajectory_helper.h:63
            const char* doc = R"""()""";

          } Q;

          // drake::systems::plants::IKTrajectoryHelper::Qa
          struct /* Qa */ {

            // drake/multibody/ik_trajectory_helper.h:64
            const char* doc = R"""()""";

          } Qa;

          // drake::systems::plants::IKTrajectoryHelper::Qv
          struct /* Qv */ {

            // drake/multibody/ik_trajectory_helper.h:65
            const char* doc = R"""()""";

          } Qv;

          // drake::systems::plants::IKTrajectoryHelper::accel_mat
          struct /* accel_mat */ {

            // drake/multibody/ik_trajectory_helper.h:69
            const char* doc = R"""()""";

          } accel_mat;

          // drake::systems::plants::IKTrajectoryHelper::accel_mat_qd0
          struct /* accel_mat_qd0 */ {

            // drake/multibody/ik_trajectory_helper.h:70
            const char* doc = R"""()""";

          } accel_mat_qd0;

          // drake::systems::plants::IKTrajectoryHelper::accel_mat_qdf
          struct /* accel_mat_qdf */ {

            // drake/multibody/ik_trajectory_helper.h:71
            const char* doc = R"""()""";

          } accel_mat_qdf;

          // drake::systems::plants::IKTrajectoryHelper::dq_inbetween_dqd0
          struct /* dq_inbetween_dqd0 */ {

            // drake/multibody/ik_trajectory_helper.h:80
            const char* doc = R"""()""";

          } dq_inbetween_dqd0;

          // drake::systems::plants::IKTrajectoryHelper::dq_inbetween_dqdf
          struct /* dq_inbetween_dqdf */ {

            // drake/multibody/ik_trajectory_helper.h:83
            const char* doc = R"""()""";

          } dq_inbetween_dqdf;

          // drake::systems::plants::IKTrajectoryHelper::dq_inbetween_dqknot
          struct /* dq_inbetween_dqknot */ {

            // drake/multibody/ik_trajectory_helper.h:77
            const char* doc = R"""()""";

          } dq_inbetween_dqknot;

          // drake::systems::plants::IKTrajectoryHelper::nT
          struct /* nT */ {

            // drake/multibody/ik_trajectory_helper.h:58
            const char* doc = R"""()""";

          } nT;

          // drake::systems::plants::IKTrajectoryHelper::nq
          struct /* nq */ {

            // drake/multibody/ik_trajectory_helper.h:57
            const char* doc = R"""()""";

          } nq;

          // drake::systems::plants::IKTrajectoryHelper::num_qdotfree
          struct /* num_qdotfree */ {

            // drake/multibody/ik_trajectory_helper.h:61
            const char* doc = R"""()""";

          } num_qdotfree;

          // drake::systems::plants::IKTrajectoryHelper::num_qfree
          struct /* num_qfree */ {

            // drake/multibody/ik_trajectory_helper.h:60
            const char* doc = R"""()""";

          } num_qfree;

          // drake::systems::plants::IKTrajectoryHelper::t
          struct /* t */ {

            // drake/multibody/ik_trajectory_helper.h:59
            const char* doc = R"""()""";

          } t;

          // drake::systems::plants::IKTrajectoryHelper::t_inbetween
          struct /* t_inbetween */ {

            // drake/multibody/ik_trajectory_helper.h:73
            const char* doc = R"""()""";

          } t_inbetween;

          // drake::systems::plants::IKTrajectoryHelper::t_samples
          struct /* t_samples */ {

            // drake/multibody/ik_trajectory_helper.h:76
            const char* doc = R"""()""";

          } t_samples;

          // drake::systems::plants::IKTrajectoryHelper::velocity_mat
          struct /* velocity_mat */ {

            // drake/multibody/ik_trajectory_helper.h:66
            const char* doc = R"""()""";

          } velocity_mat;

          // drake::systems::plants::IKTrajectoryHelper::velocity_mat_qd0
          struct /* velocity_mat_qd0 */ {

            // drake/multibody/ik_trajectory_helper.h:67
            const char* doc = R"""()""";

          } velocity_mat_qd0;

          // drake::systems::plants::IKTrajectoryHelper::velocity_mat_qdf
          struct /* velocity_mat_qdf */ {

            // drake/multibody/ik_trajectory_helper.h:68
            const char* doc = R"""()""";

          } velocity_mat_qdf;

        } IKTrajectoryHelper;

        // drake::systems::plants::KinematicsCacheHelper
        struct /* KinematicsCacheHelper */ {

          // drake/multibody/kinematics_cache_helper.h:14
          const char* doc =
R"""(Helper class to avoid recalculating a kinematics cache which is going
to be used repeatedly by multiple other classes.)""";

          // drake::systems::plants::KinematicsCacheHelper::KinematicsCacheHelper<Scalar>
          struct /* ctor */ {

            // drake/multibody/kinematics_cache_helper.h:21
            const char* doc =
R"""(Construct a cache for a tree.

Parameter ``tree``:
    tree is aliased and needs to live for the lifetime of the object.)""";

          } ctor;

          // drake::systems::plants::KinematicsCacheHelper::UpdateKinematics
          struct /* UpdateKinematics */ {

            // drake/multibody/kinematics_cache_helper.h:23
            const char* doc = R"""()""";

          } UpdateKinematics;

        } KinematicsCacheHelper;

        // drake::systems::plants::KinematicsCacheWithVHelper
        struct /* KinematicsCacheWithVHelper */ {

          // drake/multibody/kinematics_cache_helper.h:37
          const char* doc =
R"""(Stores and updates the kinematics cache for the rigid body tree.)""";

          // drake::systems::plants::KinematicsCacheWithVHelper::KinematicsCacheWithVHelper<Scalar>
          struct /* ctor */ {

            // drake/multibody/kinematics_cache_helper.h:46
            const char* doc =
R"""(Construct a cache for a tree. The kinematics information includes the
pose and spatial velocity, w.r.t q, v. And Jdotv is computed.

Parameter ``tree``:
    tree is aliased and needs to live for the lifetime of the object.)""";

          } ctor;

          // drake::systems::plants::KinematicsCacheWithVHelper::UpdateKinematics
          struct /* UpdateKinematics */ {

            // drake/multibody/kinematics_cache_helper.h:48
            const char* doc = R"""()""";

          } UpdateKinematics;

        } KinematicsCacheWithVHelper;

        // drake::systems::plants::QuasiStaticConstraintWrapper
        struct /* QuasiStaticConstraintWrapper */ {

          // drake/multibody/constraint_wrappers.h:45
          const char* doc = R"""()""";

          // drake::systems::plants::QuasiStaticConstraintWrapper::DoEval
          struct /* DoEval */ {

            // drake/multibody/constraint_wrappers.h:59
            const char* doc = R"""()""";

            // drake/multibody/constraint_wrappers.h:62
            const char* doc_2 = R"""()""";

            // drake/multibody/constraint_wrappers.h:65
            const char* doc_3 = R"""()""";

          } DoEval;

          // drake::systems::plants::QuasiStaticConstraintWrapper::QuasiStaticConstraintWrapper
          struct /* ctor */ {

            // drake/multibody/constraint_wrappers.h:52
            const char* doc =
R"""(All pointers are aliased for the lifetime of the wrapper. Also, the
wrapped QuasiStaticConstraint claims to have three constraints, but
the third was handled differently in the original SNOPT
implementation, which we won't try to reproduce here.)""";

          } ctor;

        } QuasiStaticConstraintWrapper;

        // drake::systems::plants::SetIKSolverOptions
        struct /* SetIKSolverOptions */ {

          // drake/multibody/inverse_kinematics_backend.h:70
          const char* doc = R"""(Set solver options based on IK options.)""";

        } SetIKSolverOptions;

        // drake::systems::plants::SingleTimeKinematicConstraintWrapper
        struct /* SingleTimeKinematicConstraintWrapper */ {

          // drake/multibody/constraint_wrappers.h:21
          const char* doc = R"""()""";

          // drake::systems::plants::SingleTimeKinematicConstraintWrapper::DoEval
          struct /* DoEval */ {

            // drake/multibody/constraint_wrappers.h:31
            const char* doc = R"""()""";

            // drake/multibody/constraint_wrappers.h:34
            const char* doc_2 = R"""()""";

            // drake/multibody/constraint_wrappers.h:37
            const char* doc_3 = R"""()""";

          } DoEval;

          // drake::systems::plants::SingleTimeKinematicConstraintWrapper::SingleTimeKinematicConstraintWrapper
          struct /* ctor */ {

            // drake/multibody/constraint_wrappers.h:24
            const char* doc =
R"""(All pointers are aliased for the lifetime of the wrapper.)""";

          } ctor;

        } SingleTimeKinematicConstraintWrapper;

        // drake::systems::plants::inverseKinBackend
        struct /* inverseKinBackend */ {

          // drake/multibody/inverse_kinematics_backend.h:35
          const char* doc =
R"""(This function is primarily documented through rigid_body_ik.h. All
parameters are passthroughs from there. The infeasible_constraint
parameter is currently always empty untitl MathematicalProgram
supports determining which constraints were infeasible.)""";

        } inverseKinBackend;

        // drake::systems::plants::inverseKinTrajBackend
        struct /* inverseKinTrajBackend */ {

          // drake/multibody/inverse_kinematics_backend.h:52
          const char* doc =
R"""(This function is primarily documented through rigid_body_ik.h. All
parameters are passthroughs from inverseKinTraj(). The
infeasible_constraint parameter is currently always empty untitl
MathematicalProgram supports determining which constraints were
infeasible.)""";

        } inverseKinTrajBackend;

      } plants;

      // rendering
      struct /* rendering */ {

        // drake::systems::rendering::FrameVelocity
        struct /* FrameVelocity */ {

          // drake/systems/rendering/frame_velocity.h:22
          const char* doc =
R"""(A 6-vector representing the derivatives of the position transform of
frame A in the world frame, Xdot_WA, in the form `{R_WA, p_WA}`, where
`p` is the derivatives of x-y-z translation, and `R` is the
derivatives of x-y-z rotation.

The exact order of elements is `{ωx, ωy, ωz, vx, vy, vz}`.

Template parameter ``T``:
    The Eigen scalar type. Supported scalar types are double,
    AutoDiffXd, and symbolic::Expression.)""";

          // drake::systems::rendering::FrameVelocity::DoClone
          struct /* DoClone */ {

            // drake/systems/rendering/frame_velocity.h:46
            const char* doc = R"""()""";

          } DoClone;

          // drake::systems::rendering::FrameVelocity::FrameVelocity<T>
          struct /* ctor */ {

            // drake/systems/rendering/frame_velocity.h:25
            const char* doc = R"""(Default constructor.)""";

            // drake/systems/rendering/frame_velocity.h:30
            const char* doc_2 =
R"""(Fully-parameterized constructor.

Parameter ``velocity``:
    the entire spatial velocity V_WA.)""";

            // drake/systems/rendering/frame_velocity.h:35
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::rendering::FrameVelocity::get_velocity
          struct /* get_velocity */ {

            // drake/systems/rendering/frame_velocity.h:39
            const char* doc =
R"""(Returns the entire spatial velocity V_WA.)""";

          } get_velocity;

          // drake::systems::rendering::FrameVelocity::set_velocity
          struct /* set_velocity */ {

            // drake/systems/rendering/frame_velocity.h:41
            const char* doc =
R"""(Assigns the entire spatial velocity V_WA.)""";

          } set_velocity;

        } FrameVelocity;

        // drake::systems::rendering::MakeGeometryData
        struct /* MakeGeometryData */ {

          // drake/systems/rendering/drake_visualizer_client.h:21
          const char* doc =
R"""(Returns an lcmt_viewer_geometry_message with contents that mirror the
``visual_element``.)""";

        } MakeGeometryData;

        // drake::systems::rendering::PoseAggregator
        struct /* PoseAggregator */ {

          // drake/systems/rendering/pose_aggregator.h:81
          const char* doc =
R"""(PoseAggregator is a multiplexer for heterogeneous sources of poses and
the velocities of those poses. Supported sources are: - A PoseVector
input, which is a single pose {R, p}, and is vector-valued. - A
FrameVelocity input, which corresponds to a PoseVector input, and
contains a single velocity {ω, v}, and is vector-valued. - A
PoseBundle input, which is a collection of poses and velocities, and
is abstract-valued.

PoseAggregator is stateless.

The output is a flat PoseBundle that contains all the poses and
velocities from all the inputs. Unspecified velocities are zero. By
convention, each aggregated pose or velocity is in the same world
frame of reference.

The output poses are named in the form `<source>` or
`<source>::<pose>`. - For poses derived from a PoseVector input,
<source> is the bundle name provided at construction time, and
"::<pose>" is omitted. - For poses derived from a PoseBundle input,
<source> is the bundle name provided at construction time, and <pose>
is the name found in the input PoseBundle at output evaluation time.
In any sane use case, the input names will be stable during a
simulation, but PoseAggregator is stateless and therefore can't check
whether this is actually true.

The output poses are also each assigned a model instance ID, which
must be an integer that is greater than or equal to zero. All poses
with the same model instance ID must have unique names. This enables
PoseAggregator to aggregate multiple instances of the same model. -
For poses derived from a PoseVector input, the instance ID is
specified when the input is declared. - For poses derived from a
PoseBundle input, the instance ID is obtained directly from the
PoseBundle.

In typical usage, Diagrams should contain just one PoseAggregator, and
every pose in the Diagram should appear as an input to it. Then,
Systems that need to ingest every pose in the universe, such as
renderers or sensor models, can simply depend on the output.

This class is explicitly instantiated for the following scalar types.
No other scalar types are supported. - double - AutoDiffXd -
symbolic::Expression

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar. Only
    double and AutoDiffXd are supported.)""";

          // drake::systems::rendering::PoseAggregator::AddBundleInput
          struct /* AddBundleInput */ {

            // drake/systems/rendering/pose_aggregator.h:107
            const char* doc =
R"""(Adds an input for a PoseBundle containing ``num_poses`` poses.)""";

          } AddBundleInput;

          // drake::systems::rendering::PoseAggregator::AddSingleInput
          struct /* AddSingleInput */ {

            // drake/systems/rendering/pose_aggregator.h:95
            const char* doc =
R"""(Adds an input for a PoseVector. ``name`` must be unique for all inputs
with the same ``model_instance_id``.)""";

          } AddSingleInput;

          // drake::systems::rendering::PoseAggregator::AddSinglePoseAndVelocityInput
          struct /* AddSinglePoseAndVelocityInput */ {

            // drake/systems/rendering/pose_aggregator.h:104
            const char* doc =
R"""(Adds an input for a PoseVector, and a corresponding input for a
FrameVelocity. ``name`` must be unique for all inputs with the same
``model_instance_id``.

Returns:
    Input ports for pose and velocity.)""";

          } AddSinglePoseAndVelocityInput;

          // drake::systems::rendering::PoseAggregator::PoseAggregator<T>
          struct /* ctor */ {

            // drake/systems/rendering/pose_aggregator.h:83
            const char* doc = R"""()""";

            // drake/systems/rendering/pose_aggregator.h:83
            const char* doc_2 = R"""()""";

            // drake/systems/rendering/pose_aggregator.h:85
            const char* doc_3 = R"""()""";

            // drake/systems/rendering/pose_aggregator.h:89
            const char* doc_4 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

        } PoseAggregator;

        // drake::systems::rendering::PoseBundle
        struct /* PoseBundle */ {

          // drake/systems/rendering/pose_bundle.h:40
          const char* doc =
R"""(PoseBundle is a container for a set of poses, represented by an
Isometry3, and corresponding velocities, represented by a
FrameVelocity. The poses and velocities are expressed in the world
frame: X_WFi, V_WFi. Each pose has a name and a model instance ID. If
two poses in the bundle have the same model instance ID, they must not
have the same name.

This class is explicitly instantiated for the following scalar types.
No other scalar types are supported. - double - AutoDiffXd -
symbolic::Expression

Template parameter ``T``:
    The vector element type, which must be a valid Eigen scalar. Only
    double and AutoDiffXd are supported.)""";

          // drake::systems::rendering::PoseBundle::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/rendering/pose_bundle.h:42
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::rendering::PoseBundle::PoseBundle<T>
          struct /* ctor */ {

            // drake/systems/rendering/pose_bundle.h:42
            const char* doc = R"""()""";

            // drake/systems/rendering/pose_bundle.h:42
            const char* doc_2 = R"""()""";

            // drake/systems/rendering/pose_bundle.h:44
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::rendering::PoseBundle::get_model_instance_id
          struct /* get_model_instance_id */ {

            // drake/systems/rendering/pose_bundle.h:57
            const char* doc = R"""()""";

          } get_model_instance_id;

          // drake::systems::rendering::PoseBundle::get_name
          struct /* get_name */ {

            // drake/systems/rendering/pose_bundle.h:54
            const char* doc = R"""()""";

          } get_name;

          // drake::systems::rendering::PoseBundle::get_num_poses
          struct /* get_num_poses */ {

            // drake/systems/rendering/pose_bundle.h:47
            const char* doc = R"""()""";

          } get_num_poses;

          // drake::systems::rendering::PoseBundle::get_pose
          struct /* get_pose */ {

            // drake/systems/rendering/pose_bundle.h:48
            const char* doc = R"""()""";

          } get_pose;

          // drake::systems::rendering::PoseBundle::get_velocity
          struct /* get_velocity */ {

            // drake/systems/rendering/pose_bundle.h:51
            const char* doc = R"""()""";

          } get_velocity;

          // drake::systems::rendering::PoseBundle::set_model_instance_id
          struct /* set_model_instance_id */ {

            // drake/systems/rendering/pose_bundle.h:58
            const char* doc = R"""()""";

          } set_model_instance_id;

          // drake::systems::rendering::PoseBundle::set_name
          struct /* set_name */ {

            // drake/systems/rendering/pose_bundle.h:55
            const char* doc = R"""()""";

          } set_name;

          // drake::systems::rendering::PoseBundle::set_pose
          struct /* set_pose */ {

            // drake/systems/rendering/pose_bundle.h:49
            const char* doc = R"""()""";

          } set_pose;

          // drake::systems::rendering::PoseBundle::set_velocity
          struct /* set_velocity */ {

            // drake/systems/rendering/pose_bundle.h:52
            const char* doc = R"""()""";

          } set_velocity;

        } PoseBundle;

        // drake::systems::rendering::PoseBundleToDrawMessage
        struct /* PoseBundleToDrawMessage */ {

          // drake/systems/rendering/pose_bundle_to_draw_message.h:22
          const char* doc =
R"""(PoseBundleToDrawMessage converts a PoseBundle on its single abstract-
valued input port to a Drake Visualizer Interface LCM draw message,
lcmt_viewer_draw, on its single abstract-valued output port.

The draw message will contain one link for each pose in the
PoseBundle. The name of the link will be the name of the corresponding
pose. The robot_num will be the corresponding model instance ID.)""";

          // drake::systems::rendering::PoseBundleToDrawMessage::PoseBundleToDrawMessage
          struct /* ctor */ {

            // drake/systems/rendering/pose_bundle_to_draw_message.h:24
            const char* doc = R"""()""";

            // drake/systems/rendering/pose_bundle_to_draw_message.h:24
            const char* doc_2 = R"""()""";

            // drake/systems/rendering/pose_bundle_to_draw_message.h:26
            const char* doc_3 = R"""()""";

          } ctor;

        } PoseBundleToDrawMessage;

        // drake::systems::rendering::PoseStampedTPoseVectorTranslator
        struct /* PoseStampedTPoseVectorTranslator */ {

          // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:16
          const char* doc =
R"""(The translator that converts from/to rendering::PoseVector<double>
to/from lcm message bytes which encodes
robotlocomotion::pose_stamped_t.)""";

          // drake::systems::rendering::PoseStampedTPoseVectorTranslator::AllocateOutputVector
          struct /* AllocateOutputVector */ {

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:29
            const char* doc = R"""()""";

          } AllocateOutputVector;

          // drake::systems::rendering::PoseStampedTPoseVectorTranslator::Deserialize
          struct /* Deserialize */ {

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:23
            const char* doc = R"""()""";

          } Deserialize;

          // drake::systems::rendering::PoseStampedTPoseVectorTranslator::PoseStampedTPoseVectorTranslator
          struct /* ctor */ {

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:19
            const char* doc = R"""()""";

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:19
            const char* doc_2 = R"""()""";

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:21
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::rendering::PoseStampedTPoseVectorTranslator::Serialize
          struct /* Serialize */ {

            // drake/systems/rendering/pose_stamped_t_pose_vector_translator.h:26
            const char* doc = R"""()""";

          } Serialize;

        } PoseStampedTPoseVectorTranslator;

        // drake::systems::rendering::PoseVector
        struct /* PoseVector */ {

          // drake/systems/rendering/pose_vector.h:19
          const char* doc =
R"""(A 7-vector representing the transform of frame A in the world frame,
X_WA, in the form `{p_WA, R_WA}`, where `p` is represented as an x-y-z
translation, and `R` is represented as a quaternion. The exact order
of elements is `{x, y, z, qw, qx, qy, qz}`.

Template parameter ``T``:
    The Eigen scalar type. Supported scalar types are double,
    AutoDiffXd, and symbolic::Expression.)""";

          // drake::systems::rendering::PoseVector::DoClone
          struct /* DoClone */ {

            // drake/systems/rendering/pose_vector.h:49
            const char* doc = R"""()""";

          } DoClone;

          // drake::systems::rendering::PoseVector::PoseVector<T>
          struct /* ctor */ {

            // drake/systems/rendering/pose_vector.h:22
            const char* doc = R"""(Default constructor.)""";

            // drake/systems/rendering/pose_vector.h:29
            const char* doc_2 =
R"""(Fully-parameterized constructor.

Parameter ``rotation``:
    the orientation R_WA of frame A in the world frame W.

Parameter ``translation``:
    the position vector p_WA giving A's origin measured from W's
    origin, expressed in W.)""";

          } ctor;

          // drake::systems::rendering::PoseVector::get_isometry
          struct /* get_isometry */ {

            // drake/systems/rendering/pose_vector.h:33
            const char* doc = R"""(Returns the transform X_WA.)""";

          } get_isometry;

          // drake::systems::rendering::PoseVector::get_rotation
          struct /* get_rotation */ {

            // drake/systems/rendering/pose_vector.h:42
            const char* doc = R"""(Returns the rotation R_WA.)""";

          } get_rotation;

          // drake::systems::rendering::PoseVector::get_translation
          struct /* get_translation */ {

            // drake/systems/rendering/pose_vector.h:37
            const char* doc = R"""(Returns the translation p_WA.)""";

          } get_translation;

          // drake::systems::rendering::PoseVector::set_rotation
          struct /* set_rotation */ {

            // drake/systems/rendering/pose_vector.h:44
            const char* doc = R"""(Assigns the rotation R_WA.)""";

          } set_rotation;

          // drake::systems::rendering::PoseVector::set_translation
          struct /* set_translation */ {

            // drake/systems/rendering/pose_vector.h:39
            const char* doc = R"""(Assigns the translation p_WA.)""";

          } set_translation;

        } PoseVector;

        // drake::systems::rendering::PoseVelocityInputPorts
        struct /* PoseVelocityInputPorts */ {

          // drake/systems/rendering/pose_aggregator.h:21
          const char* doc =
R"""(A container with references to the input port for the pose input, and
a reference to the input port for the velocity input.)""";

          // drake::systems::rendering::PoseVelocityInputPorts::pose_input_port
          struct /* pose_input_port */ {

            // drake/systems/rendering/pose_aggregator.h:22
            const char* doc = R"""()""";

          } pose_input_port;

          // drake::systems::rendering::PoseVelocityInputPorts::velocity_input_port
          struct /* velocity_input_port */ {

            // drake/systems/rendering/pose_aggregator.h:23
            const char* doc = R"""()""";

          } velocity_input_port;

        } PoseVelocityInputPorts;

        // pose_aggregator_detail
        struct /* pose_aggregator_detail */ {

          // drake::systems::rendering::pose_aggregator_detail::InputRecord
          struct /* InputRecord */ {

            // drake/systems/rendering/pose_aggregator.h:16
            const char* doc = R"""()""";

            // drake/systems/rendering/pose_aggregator.h:154
            const char* doc_2 = R"""()""";

            // drake::systems::rendering::pose_aggregator_detail::InputRecord::PoseInputType
            struct /* PoseInputType */ {

              // drake/systems/rendering/pose_aggregator.h:155
              const char* doc = R"""()""";

              // drake::systems::rendering::pose_aggregator_detail::InputRecord::PoseInputType::kBundle
              struct /* kBundle */ {

                // drake/systems/rendering/pose_aggregator.h:159
                const char* doc = R"""()""";

              } kBundle;

              // drake::systems::rendering::pose_aggregator_detail::InputRecord::PoseInputType::kSinglePose
              struct /* kSinglePose */ {

                // drake/systems/rendering/pose_aggregator.h:157
                const char* doc = R"""()""";

              } kSinglePose;

              // drake::systems::rendering::pose_aggregator_detail::InputRecord::PoseInputType::kSingleVelocity
              struct /* kSingleVelocity */ {

                // drake/systems/rendering/pose_aggregator.h:158
                const char* doc = R"""()""";

              } kSingleVelocity;

              // drake::systems::rendering::pose_aggregator_detail::InputRecord::PoseInputType::kUnknown
              struct /* kUnknown */ {

                // drake/systems/rendering/pose_aggregator.h:156
                const char* doc = R"""()""";

              } kUnknown;

            } PoseInputType;

            // drake::systems::rendering::pose_aggregator_detail::InputRecord::model_instance_id
            struct /* model_instance_id */ {

              // drake/systems/rendering/pose_aggregator.h:167
              const char* doc = R"""()""";

            } model_instance_id;

            // drake::systems::rendering::pose_aggregator_detail::InputRecord::name
            struct /* name */ {

              // drake/systems/rendering/pose_aggregator.h:165
              const char* doc = R"""()""";

            } name;

            // drake::systems::rendering::pose_aggregator_detail::InputRecord::num_poses
            struct /* num_poses */ {

              // drake/systems/rendering/pose_aggregator.h:163
              const char* doc = R"""()""";

            } num_poses;

            // drake::systems::rendering::pose_aggregator_detail::InputRecord::type
            struct /* type */ {

              // drake/systems/rendering/pose_aggregator.h:162
              const char* doc = R"""()""";

            } type;

          } InputRecord;

        } pose_aggregator_detail;

      } rendering;

      // scalar_conversion
      struct /* scalar_conversion */ {

        // drake::systems::scalar_conversion::FromDoubleTraits
        struct /* FromDoubleTraits */ {

          // drake/systems/framework/scalar_conversion_traits.h:83
          const char* doc =
R"""(A concrete traits class providing sugar to support for converting only
from the `double` scalar type. For example, if a
MySystem<symbolic::Expression> cannot be converted into a
MySystem<double>, it could specialize Traits as follows:

```
namespace drake {
namespace systems {
namespace scalar_conversion {
template <> struct Traits<MySystem> : public FromDoubleTraits {};
}  // namespace scalar_conversion
}  // namespace systems
}  // namespace drake
```)""";

        } FromDoubleTraits;

        // drake::systems::scalar_conversion::NonSymbolicTraits
        struct /* NonSymbolicTraits */ {

          // drake/systems/framework/scalar_conversion_traits.h:61
          const char* doc =
R"""(A concrete traits class providing sugar to disable support for
symbolic evaluation (i.e., the symbolic::Expression scalar type).

For example, if MySystem does not support the symbolic expression
scalar type, it could specialize Traits as follows:

```
namespace drake {
namespace systems {
namespace scalar_conversion {
template <> struct Traits<MySystem> : public NonSymbolicTraits {};
}  // namespace scalar_conversion
}  // namespace systems
}  // namespace drake
```)""";

        } NonSymbolicTraits;

        // drake::systems::scalar_conversion::Traits
        struct /* Traits */ {

          // drake/automotive/idm_controller.h:139
          const char* doc = R"""()""";

          // drake/automotive/pure_pursuit_controller.h:80
          const char* doc_2 = R"""()""";

          // drake/automotive/trajectory_car.h:273
          const char* doc_3 = R"""()""";

          // drake/examples/rimless_wheel/rimless_wheel.h:176
          const char* doc_4 = R"""()""";

          // drake/geometry/scene_graph.h:536
          const char* doc_5 = R"""()""";

          // drake/multibody/multibody_tree/multibody_plant/multibody_plant.h:1835
          const char* doc_6 = R"""()""";

          // drake/multibody/rigid_body_plant/rigid_body_plant.h:605
          const char* doc_7 = R"""()""";

          // drake/systems/framework/scalar_conversion_traits.h:39
          const char* doc_8 =
R"""(A templated traits class for whether an `S<T>` can be converted into
an `S<U>`; the default value is true for all values of `S`, `T`, and
`U`. Particular scalar-dependent classes (`S`) may specialize this
template to indicate whether the framework should support conversion
for any given combination of `T` and `U`.

When `Traits<S>::supported<T, U>` is `std::true_type`, the "scalar-
converting copy constructor" that relates `S`, `T`, and `U` will be
used. That constructor takes the form of, e.g., when `S` is `Foo`:

```
template <typename T>
class Foo {
  template <typename U>
  explicit Foo(const Foo<U>& other);
};
```

See system_scalar_conversion for detailed background and examples
related to scalar-type conversion support.

When `Traits<S>::supported<T, U>` is `std::false_type`, the
`S<T>::S(const S<U>&)` scalar-conversion copy constructor will not
even be mentioned by the framework, so that `S` need not even compile
for certain values of `T` and `U`.

Template parameter ``S``:
    is the scalar-templated type to copy)""";

          // drake/systems/primitives/piecewise_polynomial_affine_system.h:101
          const char* doc_9 = R"""()""";

          // drake/systems/primitives/piecewise_polynomial_linear_system.h:95
          const char* doc_10 = R"""()""";

        } Traits;

      } scalar_conversion;

      // sensors
      struct /* sensors */ {

        // drake::systems::sensors::Accelerometer
        struct /* Accelerometer */ {

          // drake/systems/sensors/accelerometer.h:97
          const char* doc =
R"""(A simulated ideal accelerometer that measures the linear acceleration
of a frame associated with a RigidBodyPlant.

The math implemented by this sensor is as follows. Let: - `v` be the
RigidBodyPlant's generalized velocity state vector. - `A` be the
accelerometer's frame with origin point `Ao`. - `W` be the world frame
with origin point `Wo`. - `v_WAo_W` be `Ao`'s translational velocity
in `W` expressed in `W`. - `J_WA` be the Jacobian matrix that relates
`v_WAo_W` to `v`. - `R_AW` be the rotation matrix from `W` to `A`.

The equation for `v_WAo_W` is as follows:

```
v_WAo_W = J_WA v
```

Let `a_WAo_W` be the `Ao`'s translational acceleration in `W`
expressed in `W`. `a_WAo_W` can be computed by taking the time
derivative of `v_WAo_W`, which is derived as follows using the chain
rule:

```
a_WAo_W = d/dt v_WAo_W = J_WA vdot_WAo_W + Jdot_WA v_WAo_W
```

`a_WAo_W` is then re-expressed in `A` using the rotation matrix
`R_AW`:

```
a_WAo_A = R_AW a_WAo_W
```

Note that `a_WA_A` does not include gravity. The constructor includes
boolean input parameter `include_gravity`, which allows the user to
specify whether the accelerometer should also sense the acceleration
due to gravity. If gravity is to be included, this acceleration
performs the following additional math:

Let: - `g_W` be the acceleration due to gravity in `W`, as specified
by RigidBodyTree::a_grav. - `g_A` be the acceleration due to gravity
in `A`.

`g_A` is computed as follows:

```
g_A = R_AW * g_W
```

`g_A` is then added to `a_WAo_A`:

```
a_WAo_A = a_WAo_A + g_A
```

This concludes the discussion of what is computed by this
accelerometer.

<B>System Input Ports:</B>

There are two input ports that are accessible via the following
accessors:

- get_plant_state_input_port(): Contains the state (i.e., position and
velocity) vector, `x`, of the RigidBodyPlant is being sensed by this
sensor.

- get_plant_state_derivative_input_port(): Contains the derivative of
the state vector, `xdot`, of the RigidBodyPlant being sensed by this
sensor.

<B>System Output Ports:</B>

This system has one output port that is accessible via the following
accessor method:

- get_output_port(): Contains the sensed acceleration data in this
sensor's frame.)""";

          // drake::systems::sensors::Accelerometer::Accelerometer
          struct /* ctor */ {

            // drake/systems/sensors/accelerometer.h:99
            const char* doc = R"""()""";

            // drake/systems/sensors/accelerometer.h:99
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/accelerometer.h:120
            const char* doc_3 =
R"""(A constructor that initializes an Accelerometer.

Parameter ``name``:
    The name of the accelerometer. This can be any value.

Parameter ``frame``:
    The frame `A` to which this accelerometer is attached (see class
    documentation for definition of `A`). This is the frame in which
    this accelerometer's output is given. This reference must remain
    valid for the lifetime of this class's instance.

Parameter ``tree``:
    The RigidBodyTree that belongs to the RigidBodyPlant being sensed
    by this sensor. This should be a reference to the same
    RigidBodyTree that is being used by the RigidBodyPlant whose
    outputs are fed into this sensor. This parameter's lifespan must
    exceed that of this class's instance.

Parameter ``include_gravity``:
    Whether to include the acceleration due to gravity in the sensor's
    readings. See this class's description for more details about the
    meaning of this parameter.)""";

          } ctor;

          // drake::systems::sensors::Accelerometer::AttachAccelerometer
          struct /* AttachAccelerometer */ {

            // drake/systems/sensors/accelerometer.h:143
            const char* doc =
R"""(Instantiates and attaches an Accelerometer to a RigidBodyPlant. It
connects the Accelerometer's plant state input port. **It does not
connect the plant state derivative input port.**

Parameter ``name``:
    The name of the sensor. This can be any value.

Parameter ``frame``:
    The frame to which the Accelerometer is attached.

Parameter ``plant``:
    The plant that the newly instantiated Accelerometer must sense.
    The provided plant must be in the provided builder.

Parameter ``include_gravity``:
    Whether to include the acceleration due to gravity in the sensor's
    readings.

Parameter ``builder``:
    A pointer to the DiagramBuilder to which the newly instantiated
    Accelerometer is added. This must not be `nullptr`.

Returns:
    A pointer to the newly instantiated and added accelerometer. The
    accelerometer is initially owned by the builder. Ownership will
    subsequently be transferred to the Diagram that is built by the
    builder.)""";

          } AttachAccelerometer;

          // drake::systems::sensors::Accelerometer::get_frame
          struct /* get_frame */ {

            // drake/systems/sensors/accelerometer.h:160
            const char* doc =
R"""(Returns this sensor's frame, which specifies its location and
orientation in the RigidBodyTree.

See also:
    get_tree())""";

          } get_frame;

          // drake::systems::sensors::Accelerometer::get_include_gravity
          struct /* get_include_gravity */ {

            // drake/systems/sensors/accelerometer.h:151
            const char* doc =
R"""(Returns whether gravity is included in this sensor's measurements.)""";

          } get_include_gravity;

          // drake::systems::sensors::Accelerometer::get_output_port
          struct /* get_output_port */ {

            // drake/systems/sensors/accelerometer.h:179
            const char* doc =
R"""(Returns the state output port, which contains the sensor's sensed
values.)""";

          } get_output_port;

          // drake::systems::sensors::Accelerometer::get_plant_state_derivative_input_port
          struct /* get_plant_state_derivative_input_port */ {

            // drake/systems/sensors/accelerometer.h:171
            const char* doc =
R"""(Returns the input port that should contain the derivative of the
generalized position and velocity vector of the RigidBodyPlant that
this sensor is sensing.)""";

          } get_plant_state_derivative_input_port;

          // drake::systems::sensors::Accelerometer::get_plant_state_input_port
          struct /* get_plant_state_input_port */ {

            // drake/systems/sensors/accelerometer.h:164
            const char* doc =
R"""(Returns the input port that should contain the generalized position
and velocity vector of the RigidBodyPlant that this sensor is sensing.)""";

          } get_plant_state_input_port;

          // drake::systems::sensors::Accelerometer::get_tree
          struct /* get_tree */ {

            // drake/systems/sensors/accelerometer.h:154
            const char* doc =
R"""(Returns the RigidBodyTree that this sensor is sensing.)""";

          } get_tree;

        } Accelerometer;

        // drake::systems::sensors::AccelerometerOutput
        struct /* AccelerometerOutput */ {

          // drake/systems/sensors/accelerometer_output.h:19
          const char* doc =
R"""(Specializes BasicVector with accessors and setters that are useful for
consumers of Accelerometer's output.)""";

          // drake::systems::sensors::AccelerometerOutput::AccelerometerOutput<T>
          struct /* ctor */ {

            // drake/systems/sensors/accelerometer_output.h:21
            const char* doc = R"""()""";

            // drake/systems/sensors/accelerometer_output.h:21
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/accelerometer_output.h:24
            const char* doc_3 =
R"""(Default constructor. Sets all rows to zero.)""";

          } ctor;

          // drake::systems::sensors::AccelerometerOutput::DoClone
          struct /* DoClone */ {

            // drake/systems/sensors/accelerometer_output.h:35
            const char* doc = R"""()""";

          } DoClone;

          // drake::systems::sensors::AccelerometerOutput::get_accel
          struct /* get_accel */ {

            // drake/systems/sensors/accelerometer_output.h:31
            const char* doc =
R"""(Returns a Vector3<T> containing the linear acceleration in the
sensor's frame. The ordering of the values in this 3-vector are `[x,
y, z]`.)""";

          } get_accel;

        } AccelerometerOutput;

        // drake::systems::sensors::AccelerometerOutputConstants
        struct /* AccelerometerOutputConstants */ {

          // drake/systems/sensors/accelerometer_output.h:10
          const char* doc = R"""()""";

        } AccelerometerOutputConstants;

        // drake::systems::sensors::BeamModel
        struct /* BeamModel */ {

          // drake/systems/sensors/beam_model.h:52
          const char* doc =
R"""(Implements the "Beam Models of Range Finders" from section 6.3 of
Probabilistic Robotics (2006), by Thrun, Burgard, and Fox

This system takes a depth measurement signal as input, and outputs a
noisy measurement version of that signal, with some probability of
returning the true measurement with Gaussian noise, but also with some
probability of occlusions (short returns), of missed detections
(returning the max depth), and of returning just a (uniform) random
measurement.

Four additional input ports (each of the same dimension as the depth
signal) are provided for the random inputs: One for determining which
of the events occurred (true + noise, short return, max return, or
uniform return), and one each for modeling the distribution of short
true but noisy returns, short returns, and uniform returns).

We deviate from the textbook model in one respect: both here and in
the textbook, the distribution over short returns and the distribution
over getting a noisy version of the true return (aka a "hit") are
truncated. The short returns are from an exponential distribution but
truncated to be less than the input depth, and "hits" are drawn from a
Gaussian centered at the input depth but truncated at the maximum
range of the sensor. In the book, these distributions are normalized
so that the total probability of getting a short return and/or hit
stays constant (independent of the input depth). Here we do not
normalize, so that the probability of getting a short return decreases
as the input depth is smaller (there is a modeled obstacle closer to
the robot), and the tails of the "hit" distribution simply cause more
max returns as the input depth gets closer to the max range. This was
done both because it is arguably a better model and because it keeps
the code much simpler (to allow AutoDiff and Symbolic) given the
modeling framework we have here that builds the output out of simple
(non-truncated) random variable inputs.

Instantiated templates for the following kinds of T's are provided: -
double - AutoDiffXd)""";

          // drake::systems::sensors::BeamModel::BeamModel<T>
          struct /* ctor */ {

            // drake/systems/sensors/beam_model.h:54
            const char* doc = R"""()""";

            // drake/systems/sensors/beam_model.h:54
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/beam_model.h:56
            const char* doc_3 = R"""()""";

            // drake/systems/sensors/beam_model.h:58
            const char* doc_4 = R"""()""";

            // drake/systems/sensors/beam_model.h:62
            const char* doc_5 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::systems::sensors::BeamModel::get_depth_input_port
          struct /* get_depth_input_port */ {

            // drake/systems/sensors/beam_model.h:64
            const char* doc = R"""()""";

          } get_depth_input_port;

          // drake::systems::sensors::BeamModel::get_event_random_input_port
          struct /* get_event_random_input_port */ {

            // drake/systems/sensors/beam_model.h:67
            const char* doc = R"""()""";

          } get_event_random_input_port;

          // drake::systems::sensors::BeamModel::get_hit_random_input_port
          struct /* get_hit_random_input_port */ {

            // drake/systems/sensors/beam_model.h:70
            const char* doc = R"""()""";

          } get_hit_random_input_port;

          // drake::systems::sensors::BeamModel::get_mutable_parameters
          struct /* get_mutable_parameters */ {

            // drake/systems/sensors/beam_model.h:80
            const char* doc = R"""()""";

          } get_mutable_parameters;

          // drake::systems::sensors::BeamModel::get_short_random_input_port
          struct /* get_short_random_input_port */ {

            // drake/systems/sensors/beam_model.h:73
            const char* doc = R"""()""";

          } get_short_random_input_port;

          // drake::systems::sensors::BeamModel::get_uniform_random_input_port
          struct /* get_uniform_random_input_port */ {

            // drake/systems/sensors/beam_model.h:76
            const char* doc = R"""()""";

          } get_uniform_random_input_port;

          // drake::systems::sensors::BeamModel::max_range
          struct /* max_range */ {

            // drake/systems/sensors/beam_model.h:82
            const char* doc = R"""()""";

          } max_range;

        } BeamModel;

        // drake::systems::sensors::BeamModelParams
        struct /* BeamModelParams */ {

          // drake/systems/sensors/gen/beam_model_params.h:44
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters.)""";

          // drake::systems::sensors::BeamModelParams::BeamModelParams<T>
          struct /* ctor */ {

            // drake/systems/sensors/gen/beam_model_params.h:55
            const char* doc =
R"""(Default constructor. Sets all rows to their default value: @arg
``lambda_short`` defaults to 1.0 dimensionless. @arg ``sigma_hit``
defaults to 0.0 m. @arg ``probability_short`` defaults to 0.0
dimensionless. @arg ``probability_miss`` defaults to 0.0
dimensionless. @arg ``probability_uniform`` defaults to 0.0
dimensionless.)""";

          } ctor;

          // drake::systems::sensors::BeamModelParams::CalcInequalityConstraint
          struct /* CalcInequalityConstraint */ {

            // drake/systems/sensors/gen/beam_model_params.h:153
            const char* doc = R"""()""";

          } CalcInequalityConstraint;

          // drake::systems::sensors::BeamModelParams::DoClone
          struct /* DoClone */ {

            // drake/systems/sensors/gen/beam_model_params.h:75
            const char* doc = R"""()""";

          } DoClone;

          // drake::systems::sensors::BeamModelParams::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/systems/sensors/gen/beam_model_params.h:128
            const char* doc =
R"""(See BeamModelParamsIndices::GetCoordinateNames().)""";

          } GetCoordinateNames;

          // drake::systems::sensors::BeamModelParams::IsValid
          struct /* IsValid */ {

            // drake/systems/sensors/gen/beam_model_params.h:133
            const char* doc =
R"""(Returns whether the current values of this vector are well-formed.)""";

          } IsValid;

          // drake::systems::sensors::BeamModelParams::SetToNamedVariables
          struct /* SetToNamedVariables */ {

            // drake/systems/sensors/gen/beam_model_params.h:67
            const char* doc =
R"""(Create a symbolic::Variable for each element with the known variable
name. This is only available for T == symbolic::Expression.)""";

          } SetToNamedVariables;

          // drake::systems::sensors::BeamModelParams::lambda_short
          struct /* lambda_short */ {

            // drake/systems/sensors/gen/beam_model_params.h:83
            const char* doc =
R"""(The rate parameter of the (truncated) exponential distribution
governing short returns

Note:
    ``lambda_short`` is expressed in units of dimensionless.

Note:
    ``lambda_short`` has a limited domain of [0.0, +Inf].)""";

          } lambda_short;

          // drake::systems::sensors::BeamModelParams::probability_miss
          struct /* probability_miss */ {

            // drake/systems/sensors/gen/beam_model_params.h:109
            const char* doc =
R"""(The probability of ignoring the input depth and simply returning the
max range of the sensor

Note:
    ``probability_miss`` is expressed in units of dimensionless.

Note:
    ``probability_miss`` has a limited domain of [0.0, 1.0].)""";

          } probability_miss;

          // drake::systems::sensors::BeamModelParams::probability_short
          struct /* probability_short */ {

            // drake/systems/sensors/gen/beam_model_params.h:99
            const char* doc =
R"""(The total probability of getting a short return is probability_short *
p(lambda_short*w_short <= input_depth)

Note:
    ``probability_short`` is expressed in units of dimensionless.

Note:
    ``probability_short`` has a limited domain of [0.0, 1.0].)""";

          } probability_short;

          // drake::systems::sensors::BeamModelParams::probability_uniform
          struct /* probability_uniform */ {

            // drake/systems/sensors/gen/beam_model_params.h:119
            const char* doc =
R"""(The probability of ignoring the input depth and simple returning a
uniform random value between 0 and the max range of the sensor

Note:
    ``probability_uniform`` is expressed in units of dimensionless.

Note:
    ``probability_uniform`` has a limited domain of [0.0, 1.0].)""";

          } probability_uniform;

          // drake::systems::sensors::BeamModelParams::set_lambda_short
          struct /* set_lambda_short */ {

            // drake/systems/sensors/gen/beam_model_params.h:84
            const char* doc = R"""()""";

          } set_lambda_short;

          // drake::systems::sensors::BeamModelParams::set_probability_miss
          struct /* set_probability_miss */ {

            // drake/systems/sensors/gen/beam_model_params.h:112
            const char* doc = R"""()""";

          } set_probability_miss;

          // drake::systems::sensors::BeamModelParams::set_probability_short
          struct /* set_probability_short */ {

            // drake/systems/sensors/gen/beam_model_params.h:102
            const char* doc = R"""()""";

          } set_probability_short;

          // drake::systems::sensors::BeamModelParams::set_probability_uniform
          struct /* set_probability_uniform */ {

            // drake/systems/sensors/gen/beam_model_params.h:122
            const char* doc = R"""()""";

          } set_probability_uniform;

          // drake::systems::sensors::BeamModelParams::set_sigma_hit
          struct /* set_sigma_hit */ {

            // drake/systems/sensors/gen/beam_model_params.h:92
            const char* doc = R"""()""";

          } set_sigma_hit;

          // drake::systems::sensors::BeamModelParams::sigma_hit
          struct /* sigma_hit */ {

            // drake/systems/sensors/gen/beam_model_params.h:91
            const char* doc =
R"""(The standard deviation of the (truncated) Gaussian distribution
governing the noisy returns of the true depth (aka hit)

Note:
    ``sigma_hit`` is expressed in units of m.

Note:
    ``sigma_hit`` has a limited domain of [0.0, +Inf].)""";

          } sigma_hit;

        } BeamModelParams;

        // drake::systems::sensors::BeamModelParamsIndices
        struct /* BeamModelParamsIndices */ {

          // drake/systems/sensors/gen/beam_model_params.h:24
          const char* doc =
R"""(Describes the row indices of a BeamModelParams.)""";

          // drake::systems::sensors::BeamModelParamsIndices::GetCoordinateNames
          struct /* GetCoordinateNames */ {

            // drake/systems/sensors/gen/beam_model_params.h:39
            const char* doc =
R"""(Returns a vector containing the names of each coordinate within this
class. The indices within the returned vector matches that of this
class. In other words,
`BeamModelParamsIndices::GetCoordinateNames()[i]` is the name for
`BasicVector::GetAtIndex(i)`.)""";

          } GetCoordinateNames;

        } BeamModelParamsIndices;

        // drake::systems::sensors::CameraInfo
        struct /* CameraInfo */ {

          // drake/systems/sensors/camera_info.h:58
          const char* doc =
R"""(Simple data structure for camera information that includes the image
size and camera intrinsic parameters.

To clarify the terminology used to describe 2D and/or 3D spaces
throughout the class, we use "coordinate system" rather than "frame".
This is because the term "frame" has two different meanings in the
computer vision field: a synonym of coordinate system, and a snapshot
out of consecutively captured images. To ensure the reader will not be
confused, we clearly differentiate the use of the terms "coordinate
system" and "frame" by using "coordinate system" to denote 2D/3D
spaces and "frame" to denote a captured image.

There are three types of the coordinate systems that are relevant to
this class: - the camera coordinate system - the image coordinate
system - the pixel coordinate system.

The camera coordinate system expresses a camera's 6D pose relative to
the world coordinate system. The camera coordinate system is defined
to be `X-right`, `Y-down` and `Z-forward`. The `Z` axis is also called
the "optical axis". Note that each axis in the camera coordinate
system is expressed in the upper case, like `(X, Y, Z)` to distinguish
from those of the image coordinate system which we explain next.

The image coordinate system is the 2D coordinate system made by
projecting the camera coordinate system onto the 2D image plane which
is perpendicular to the "optical axis". Therefore, the direction of
the each axis is `x-right` and `y-down`, and the origin of the image
coordinate system is located at the crossing point between the 2D
image plane and the "optical axis". This origin is called the "image
center" or "principal point". Note that each axis in the image
coordinate system is expressed in the lower case , like `(x, y)`.

The pixel coordinate system is also a 2D coordinate system. The main
differences between the pixel coordinate system and the image
coordinate system are the location of the origin and the direction of
the axes. The origin of the pixel coordinate system is at the left-
upper corner of the image and the direction of the each axis is the
same as those of the image coordinate system. The axes of the pixel
coordinate system are expressed using `u` and `v`, therefore the axes
directions are `u-right` and `v-down`.

For more detail including an explanation of the focal lengths, refer
to: http://docs.opencv.org/2.4/modules/calib3d/doc/camera_calibration_
and_3d_reconstruction.html and
https://en.wikipedia.org/wiki/Pinhole_camera_model.)""";

          // drake::systems::sensors::CameraInfo::CameraInfo
          struct /* ctor */ {

            // drake/systems/sensors/camera_info.h:60
            const char* doc = R"""()""";

            // drake/systems/sensors/camera_info.h:60
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/camera_info.h:72
            const char* doc_3 =
R"""(Constructor that directly sets the image size, center, and focal
lengths.

Parameter ``width``:
    The image width in pixels, must be greater than zero.

Parameter ``height``:
    The image height in pixels, must be greater than zero.

Parameter ``focal_x``:
    The focal length x in pixels.

Parameter ``focal_y``:
    The focal length y in pixels.

Parameter ``center_x``:
    The x coordinate of the image center in the pixel coordinate
    system in pixels.

Parameter ``center_y``:
    The y coordinate of the image center in the pixel coordinate
    system in pixels.)""";

            // drake/systems/sensors/camera_info.h:94
            const char* doc_4 =
R"""(Constructor that sets the image size and vertical field of view
`fov_y`. We assume there is no image offset, so the image center
`(center_x,` `center_y)` is equal to `(width / 2, height / 2)`. We
also assume the focal lengths `focal_x` and `focal_y` are identical.
The horizontal field of view `fov_x` is calculated using the aspect
ratio of the image width and height together with the vertical field
of view:

```
fov_x = 2 * atan(width / height * tan(fov_y / 2)).
```

This can be derived from the equations of the focal lengths:

```
focal_x = width / 2 / tan(fov_x / 2)
  focal_y = height / 2 / tan(fov_y / 2)
```

where `focal_x / focal_y = 1`.

Parameter ``width``:
    The image width in pixels, must be greater than zero.

Parameter ``height``:
    The image height in pixels, must be greater than zero.

Parameter ``fov_y``:
    The vertical field of view.)""";

          } ctor;

          // drake::systems::sensors::CameraInfo::center_x
          struct /* center_x */ {

            // drake/systems/sensors/camera_info.h:109
            const char* doc =
R"""(Returns the image center x value in pixels.)""";

          } center_x;

          // drake::systems::sensors::CameraInfo::center_y
          struct /* center_y */ {

            // drake/systems/sensors/camera_info.h:112
            const char* doc =
R"""(Returns the image center y value in pixels.)""";

          } center_y;

          // drake::systems::sensors::CameraInfo::focal_x
          struct /* focal_x */ {

            // drake/systems/sensors/camera_info.h:103
            const char* doc = R"""(Returns the focal length x in pixels.)""";

          } focal_x;

          // drake::systems::sensors::CameraInfo::focal_y
          struct /* focal_y */ {

            // drake/systems/sensors/camera_info.h:106
            const char* doc = R"""(Returns the focal length y in pixels.)""";

          } focal_y;

          // drake::systems::sensors::CameraInfo::height
          struct /* height */ {

            // drake/systems/sensors/camera_info.h:100
            const char* doc =
R"""(Returns the height of the image in pixels.)""";

          } height;

          // drake::systems::sensors::CameraInfo::intrinsic_matrix
          struct /* intrinsic_matrix */ {

            // drake/systems/sensors/camera_info.h:115
            const char* doc = R"""(Returns the camera intrinsic matrix.)""";

          } intrinsic_matrix;

          // drake::systems::sensors::CameraInfo::width
          struct /* width */ {

            // drake/systems/sensors/camera_info.h:97
            const char* doc =
R"""(Returns the width of the image in pixels.)""";

          } width;

        } CameraInfo;

        // drake::systems::sensors::Color
        struct /* Color */ {

          // drake/systems/sensors/color_palette.h:19
          const char* doc =
R"""(Holds r, g, b values to represent a color pixel.

Template parameter ``T``:
    A type for each color channel.)""";

          // drake::systems::sensors::Color::b
          struct /* b */ {

            // drake/systems/sensors/color_palette.h:22
            const char* doc = R"""(Green.)""";

          } b;

          // drake::systems::sensors::Color::g
          struct /* g */ {

            // drake/systems/sensors/color_palette.h:21
            const char* doc = R"""(Red.)""";

          } g;

          // drake::systems::sensors::Color::r
          struct /* r */ {

            // drake/systems/sensors/color_palette.h:20
            const char* doc = R"""()""";

          } r;

        } Color;

        // drake::systems::sensors::ColorPalette
        struct /* ColorPalette */ {

          // drake/systems/sensors/color_palette.h:67
          const char* doc =
R"""(Creates and holds a palette of colors for visualizing different
objects in a scene (the intent is for a different color to be applied
to each identified object). The colors are chosen so as to be easily
distinguishable. In other words, the intensities are spaced as widely
as possible given the number of required colors. Black, white and
gray, which has the same value for all the three color channels, are
not part of this color palette. This color palette can hold up to 1535
colors.)""";

          // drake::systems::sensors::ColorPalette::ColorPalette
          struct /* ctor */ {

            // drake/systems/sensors/color_palette.h:69
            const char* doc = R"""()""";

            // drake/systems/sensors/color_palette.h:69
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/color_palette.h:84
            const char* doc_3 =
R"""(A constructor for ColorPalette.

Parameter ``num_colors``:
    The number of colors that you want ColorPalette to hold. We assume
    this will be the number of rigid bodies in rendering scene.

Parameter ``terrain_id``:
    The id to express pixels which correspond to flat terrain. This
    will be used in the label image.

Parameter ``no_body_id``:
    The id to express pixels that have no body. This will be used in
    the label image.

Throws:
    s std::logic_error When ``num_colors`` exceeds the maximum limit,
    which is 1535.)""";

          } ctor;

          // drake::systems::sensors::ColorPalette::LookUpId
          struct /* LookUpId */ {

            // drake/systems/sensors/color_palette.h:160
            const char* doc =
R"""(Looks up an ID which corresponds to the given color.

Parameter ``color``:
    The color you want to know the corresponding ID.)""";

          } LookUpId;

          // drake::systems::sensors::ColorPalette::Normalize
          struct /* Normalize */ {

            // drake/systems/sensors/color_palette.h:119
            const char* doc =
R"""(Takes ColorI whose pixel range is [0, 255] and returns ColorD whose
pixel range is [0, 1].

Parameter ``color``:
    An input color to be normalized.)""";

          } Normalize;

          // drake::systems::sensors::ColorPalette::get_color
          struct /* get_color */ {

            // drake/systems/sensors/color_palette.h:131
            const char* doc =
R"""(Returns a color of type ColorI which corresponds to given index. The
pixel range of returned color is [0, 255].

Parameter ``index``:
    An index that corresponds to the color to be returned.)""";

          } get_color;

          // drake::systems::sensors::ColorPalette::get_normalized_color
          struct /* get_normalized_color */ {

            // drake/systems/sensors/color_palette.h:140
            const char* doc =
R"""(Returns a color of type ColorD which corresponds to given index. The
pixel range of returned color is [0, 1].

Parameter ``index``:
    An index that corresponds to the color to be returned.)""";

          } get_normalized_color;

          // drake::systems::sensors::ColorPalette::get_sky_color
          struct /* get_sky_color */ {

            // drake/systems/sensors/color_palette.h:147
            const char* doc =
R"""(Returns the color of type ColorI which corresponds to sky. The pixel
range of returned color is [0, 255].)""";

          } get_sky_color;

          // drake::systems::sensors::ColorPalette::get_terrain_color
          struct /* get_terrain_color */ {

            // drake/systems/sensors/color_palette.h:153
            const char* doc =
R"""(Returns the color of type ColorI which corresponds to flat terrain.
The pixel range of returned color is [0, 255].)""";

          } get_terrain_color;

        } ColorPalette;

        // drake::systems::sensors::DepthSensor
        struct /* DepthSensor */ {

          // drake/systems/sensors/depth_sensor.h:97
          const char* doc =
R"""(A simple model of an ideal depth sensor. Example real-world depth
sensors include Lidar, IR, sonar, etc. The depth measurements are
taken at evenly spaced pitch angles and yaw angles. Ray casting is
used to obtain the depth measurements and all pitch / yaw combinations
in a single resulting depth image are obtained at a single effective
point in time. Thus, this sensor does *not* model aliasing effects due
to the time spent scanning vertically and horizontally. For the ray
casting, DepthSensor uses collision models of RigidBodyTree.

There are two frames associated with this sensor: its base frame and
its optical frame. This sensor's specification and configuration are
defined in terms of this sensor's base frame. The base frame's origin
defines the point from which this sensor's ray casts originate. Its
+X, +Y, and +Z axes are pointing towards this sensor's "forward,"
"left", and "up" directions, respectively.

This sensor's optical frame's origin is the same as the base frame's
origin. Its +X axis defines where a particular ray cast is pointing.
There are two angles associated with a depth measurement, as described
below. Both angles are defined in terms of the sensor's base frame.
Together they define a transform between the base frame and optical
frame.

1. yaw - The horizontal scan angle that rotates about this sensor's
base frame's +Z axis using the right-hand rule. When the pitch is
zero, a yaw of zero results in this sensor measuring down the base
frame's +X axis. 2. pitch - The vertical scan angle that rotates about
this sensor's base frames's -Y axis using using the right-hand rule.
In other words, when the pitch increases from zero to PI / 2, this
sensor's optical frame is tilted to point upward. When the yaw is
zero, a pitch of zero results in this sensor measuring down the base
frame's +X axis.

To summarize, the location from which this sensor's rays emanate is
(0, 0, 0) in the base frame. When both the yaw and pitch are zero,
this sensor's base and optical frames are identical. The yaw causes
the optical frame to rotate about the base frame's +Z axis, while the
pitch causes it to rotate about this sensor's -Y axis.

This system has two output ports. The first contains the sensed values
stored in a DepthSensorOutput object. For each pitch, there is a fixed
number of yaw values as specified by num_yaw(). Each of these vector
of yaw values that share the same pitch are contiguous in the output
vector. In other words, here is pseudocode describing this sensor's
output vector:

```
for i in 0 to num_pitch():
   for j in 0 to num_yaw():
     output_vector[i * num_yaw() + j] ==
         [depth value when yaw   = min_yaw()   + j * yaw_increment() and
                           pitch = min_pitch() + i * pitch_increment()]
```

If nothing is detected between min_range and max_range, an invalid
value of DepthSensor::kTooFar is provided. Is something is detected
but the distance is less than the sensor's minimum sensing range, a
value of DepthSensor::kTooClose is provided.

Sensing errors can be expressed using a distance value of
DepthSensorOutput::GetErrorDistance(), and detected using
DepthSensorOutput::IsError() or DepthSensorOutput::IsValid(). It is
not expected to occur in this system's output because it models an
ideal sensor in which sensing errors do not occur. Sensing errors are
expected to be used by non-ideal depth sensors.

The second output port contains a PoseVector, which is `X_WS`, i.e.,
the transform from this sensor's frame to the world frame. It is
useful for converting this sensor's point cloud into the world frame.

See also:
    DepthSensorOutput

See also:
    DepthSensorSpecification)""";

          // drake::systems::sensors::DepthSensor::DepthSensor
          struct /* ctor */ {

            // drake/systems/sensors/depth_sensor.h:99
            const char* doc = R"""()""";

            // drake/systems/sensors/depth_sensor.h:99
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/depth_sensor.h:115
            const char* doc_3 =
R"""(A DepthSensor constructor.

Parameter ``name``:
    The name of the depth sensor. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance.

Parameter ``tree``:
    The RigidBodyTree containing the geometric configuration of the
    world. This parameter is aliased by a class member variable. Thus,
    its lifespan must exceed that of this class' instance.

Parameter ``frame``:
    The frame to which this depth sensor is attached.

Parameter ``specification``:
    The specifications of this sensor.)""";

          } ctor;

          // drake::systems::sensors::DepthSensor::get_frame
          struct /* get_frame */ {

            // drake/systems/sensors/depth_sensor.h:124
            const char* doc =
R"""(Returns this sensor's frame, which specifies its location and
orientation in the RigidBodyTree.)""";

          } get_frame;

          // drake::systems::sensors::DepthSensor::get_num_depth_readings
          struct /* get_num_depth_readings */ {

            // drake/systems/sensors/depth_sensor.h:141
            const char* doc =
R"""(Returns the size of the system's output, which equals the product of
num_pitch() and num_yaw().)""";

          } get_num_depth_readings;

          // drake::systems::sensors::DepthSensor::get_num_pitch
          struct /* get_num_pitch */ {

            // drake/systems/sensors/depth_sensor.h:132
            const char* doc =
R"""(Returns the number of pixel rows in the resulting depth sensor output.
This is equal to parameter DepthSensorSpecification::num_pitch_values
that's passed into the constructor.)""";

          } get_num_pitch;

          // drake::systems::sensors::DepthSensor::get_num_yaw
          struct /* get_num_yaw */ {

            // drake/systems/sensors/depth_sensor.h:137
            const char* doc =
R"""(Returns the number of pixel columns in the resulting depth sensor
output. This is equal to parameter
DepthSensorSpecification::num_yaw_values that's passed into the
constructor.)""";

          } get_num_yaw;

          // drake::systems::sensors::DepthSensor::get_pose_output_port
          struct /* get_pose_output_port */ {

            // drake/systems/sensors/depth_sensor.h:156
            const char* doc =
R"""(Returns the `X_WS` output port, which contains the transform from this
sensor's frame to the world frame.)""";

          } get_pose_output_port;

          // drake::systems::sensors::DepthSensor::get_rigid_body_tree_state_input_port
          struct /* get_rigid_body_tree_state_input_port */ {

            // drake/systems/sensors/depth_sensor.h:147
            const char* doc =
R"""(Returns the input port containing the generalized state of the
RigidBodyTree.)""";

          } get_rigid_body_tree_state_input_port;

          // drake::systems::sensors::DepthSensor::get_sensor_state_output_port
          struct /* get_sensor_state_output_port */ {

            // drake/systems/sensors/depth_sensor.h:152
            const char* doc =
R"""(Returns the state output port, which contains the sensor's sensed
values.)""";

          } get_sensor_state_output_port;

          // drake::systems::sensors::DepthSensor::get_specification
          struct /* get_specification */ {

            // drake/systems/sensors/depth_sensor.h:127
            const char* doc = R"""(Returns this sensor's specification.)""";

          } get_specification;

          // drake::systems::sensors::DepthSensor::get_tree
          struct /* get_tree */ {

            // drake/systems/sensors/depth_sensor.h:120
            const char* doc =
R"""(Returns the RigidBodyTree that this sensor is sensing.)""";

          } get_tree;

        } DepthSensor;

        // drake::systems::sensors::DepthSensorOutput
        struct /* DepthSensorOutput */ {

          // drake/systems/sensors/depth_sensor_output.h:18
          const char* doc =
R"""(Specializes BasicVector with specific getters and setters that are
useful for consumers of DepthSensor's output.

See also:
    DepthSensor.)""";

          // drake::systems::sensors::DepthSensorOutput::DepthSensorOutput<T>
          struct /* ctor */ {

            // drake/systems/sensors/depth_sensor_output.h:20
            const char* doc = R"""()""";

            // drake/systems/sensors/depth_sensor_output.h:20
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/depth_sensor_output.h:27
            const char* doc_3 =
R"""(Default constructor. Sets all rows to zero.

Parameter ``spec``:
    The sensor specification. A member variable alias is maintained.
    Thus, the lifespan of the reference object must exceed the
    lifespan of this class' instance.)""";

          } ctor;

          // drake::systems::sensors::DepthSensorOutput::DoClone
          struct /* DoClone */ {

            // drake/systems/sensors/depth_sensor_output.h:95
            const char* doc = R"""()""";

          } DoClone;

          // drake::systems::sensors::DepthSensorOutput::GetDistance
          struct /* GetDistance */ {

            // drake/systems/sensors/depth_sensor_output.h:81
            const char* doc =
R"""(Returns the measured distance within the depth image at ``yaw_index``
and ``pitch_index``.

Parameter ``yaw_index``:
    The index of the depth image pixel column containing the depth is
    to be returned. This value must be between zero and
    DepthSensor::get_num_pixel_cols().

Parameter ``pitch_index``:
    The index of the depth image pixel row containing the depth to be
    returned. This value must be between zero and
    DepthSensor::get_num_pixel_rows().

Returns:
    The measured distance at ``yaw_index`` and ``pitch_index``.

Throws:
    s std::runtime_error if ``yaw_index`` or ``pitch_index`` is
    invalid.)""";

          } GetDistance;

          // drake::systems::sensors::DepthSensorOutput::GetErrorDistance
          struct /* GetErrorDistance */ {

            // drake/systems/sensors/depth_sensor_output.h:54
            const char* doc =
R"""(Returns the depth value when an error occurs. This value can be used
in conjunction with IsError().)""";

          } GetErrorDistance;

          // drake::systems::sensors::DepthSensorOutput::GetNumValidDistanceMeasurements
          struct /* GetNumValidDistanceMeasurements */ {

            // drake/systems/sensors/depth_sensor_output.h:85
            const char* doc =
R"""(Returns the number of valid distance measurements within this output.
A value's validity is determined by IsValid().)""";

          } GetNumValidDistanceMeasurements;

          // drake::systems::sensors::DepthSensorOutput::GetPointCloud
          struct /* GetPointCloud */ {

            // drake/systems/sensors/depth_sensor_output.h:90
            const char* doc =
R"""(Returns a point cloud based on the depth image contained within this
output. Both the depth image and resulting point cloud are defined in
the sensor's base frame.)""";

          } GetPointCloud;

          // drake::systems::sensors::DepthSensorOutput::GetTooCloseDistance
          struct /* GetTooCloseDistance */ {

            // drake/systems/sensors/depth_sensor_output.h:46
            const char* doc =
R"""(Returns the depth value when the min sensing range is violated because
the object being sensed is too close. Note that this <a
href="http://www.ros.org/reps/rep-0117.html">differs from ROS</a>,
which uses negative infinity in this scenario. Drake uses zero because
it results in less devastating bugs when users fail to check for the
lower limit being hit and using negative infinity does not prevent
users from writing bad code. This value can be used in conjunction
with IsTooClose().)""";

          } GetTooCloseDistance;

          // drake::systems::sensors::DepthSensorOutput::GetTooFarDistance
          struct /* GetTooFarDistance */ {

            // drake/systems/sensors/depth_sensor_output.h:34
            const char* doc =
R"""(Returns the depth value when the max sensing range is exceeded. This
value can be used in conjunction with IsTooFar().)""";

          } GetTooFarDistance;

          // drake::systems::sensors::DepthSensorOutput::IsError
          struct /* IsError */ {

            // drake/systems/sensors/depth_sensor_output.h:57
            const char* doc =
R"""(Returns true if ``distance`` is the value returned by
GetErrorDistance().)""";

          } IsError;

          // drake::systems::sensors::DepthSensorOutput::IsTooClose
          struct /* IsTooClose */ {

            // drake/systems/sensors/depth_sensor_output.h:50
            const char* doc =
R"""(Returns true if ``distance`` is the value returned by
GetTooCloseDistance().)""";

          } IsTooClose;

          // drake::systems::sensors::DepthSensorOutput::IsTooFar
          struct /* IsTooFar */ {

            // drake/systems/sensors/depth_sensor_output.h:37
            const char* doc =
R"""(Returns true if ``distance`` is the value returned by
GetTooFarDistance().)""";

          } IsTooFar;

          // drake::systems::sensors::DepthSensorOutput::IsValid
          struct /* IsValid */ {

            // drake/systems/sensors/depth_sensor_output.h:61
            const char* doc =
R"""(Returns true if ``distance`` is valid. It is valid when it is not
erroneous and is in the sensor's sensing range.)""";

          } IsValid;

        } DepthSensorOutput;

        // drake::systems::sensors::DepthSensorSpecification
        struct /* DepthSensorSpecification */ {

          // drake/systems/sensors/depth_sensor_specification.h:16
          const char* doc =
R"""(Holds a DepthSensor's specification.

See also:
    DepthSensor.)""";

          // drake::systems::sensors::DepthSensorSpecification::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/sensors/depth_sensor_specification.h:18
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::sensors::DepthSensorSpecification::DepthSensorSpecification
          struct /* ctor */ {

            // drake/systems/sensors/depth_sensor_specification.h:18
            const char* doc = R"""()""";

            // drake/systems/sensors/depth_sensor_specification.h:18
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/depth_sensor_specification.h:21
            const char* doc_3 =
R"""(Constructs a DepthsensorSpecification with all default values.)""";

            // drake/systems/sensors/depth_sensor_specification.h:51
            const char* doc_4 =
R"""(Constructs a fully-defined DepthSensorSpecification.

Parameter ``min_yaw``:
    The minimum horizontal scan angle in the sensor's base frame. The
    horizontal scan angle is about the +Z axis. A zero angle is the +X
    axis.

Parameter ``max_yaw``:
    The maximum horizontal scan angle in the sensor's base frame.

Parameter ``min_pitch``:
    The minimum vertical scan angle in the sensor's base frame.

Parameter ``max_pitch``:
    The maximum vertical scan angle in the sensor's base frame.

Parameter ``num_yaw_values``:
    The number of yaw values at which depth measurements are taken.
    These measurements are evenly spread between ``min_yaw`` and
    ``max_yaw``. This value must be greater than or equal to 1, which
    occurs when ``min_yaw`` equals ``max_yaw``.

Parameter ``num_pitch_values``:
    The number of yaw values at which depth measurements are taken.
    These measurements are evenly spread between ``min_pitch`` and
    ``max_pitch``. This value must be greater than or equal to 1,
    which occurs when ``min_pitch`` equals ``max_pitch``.

Parameter ``min_range``:
    The minimum sensing range.

Parameter ``max_range``:
    The maximum sensing range.)""";

          } ctor;

          // drake::systems::sensors::DepthSensorSpecification::max_pitch
          struct /* max_pitch */ {

            // drake/systems/sensors/depth_sensor_specification.h:65
            const char* doc = R"""()""";

          } max_pitch;

          // drake::systems::sensors::DepthSensorSpecification::max_range
          struct /* max_range */ {

            // drake/systems/sensors/depth_sensor_specification.h:69
            const char* doc = R"""()""";

          } max_range;

          // drake::systems::sensors::DepthSensorSpecification::max_yaw
          struct /* max_yaw */ {

            // drake/systems/sensors/depth_sensor_specification.h:63
            const char* doc = R"""()""";

          } max_yaw;

          // drake::systems::sensors::DepthSensorSpecification::min_pitch
          struct /* min_pitch */ {

            // drake/systems/sensors/depth_sensor_specification.h:64
            const char* doc = R"""()""";

          } min_pitch;

          // drake::systems::sensors::DepthSensorSpecification::min_range
          struct /* min_range */ {

            // drake/systems/sensors/depth_sensor_specification.h:68
            const char* doc = R"""()""";

          } min_range;

          // drake::systems::sensors::DepthSensorSpecification::min_yaw
          struct /* min_yaw */ {

            // drake/systems/sensors/depth_sensor_specification.h:62
            const char* doc =
R"""(@name Accessors to manually specified parameters.

The following accessors are for parameter values that are manually
specified. They appear as input parameters of the constructor, and
mutator methods in this class. @{)""";

          } min_yaw;

          // drake::systems::sensors::DepthSensorSpecification::num_depth_readings
          struct /* num_depth_readings */ {

            // drake/systems/sensors/depth_sensor_specification.h:77
            const char* doc =
R"""(@name Accessors to automatically derived parameters.

The following methods return values that are derived based on the
manually specified parameters. @{)""";

          } num_depth_readings;

          // drake::systems::sensors::DepthSensorSpecification::num_pitch_values
          struct /* num_pitch_values */ {

            // drake/systems/sensors/depth_sensor_specification.h:67
            const char* doc = R"""()""";

          } num_pitch_values;

          // drake::systems::sensors::DepthSensorSpecification::num_yaw_values
          struct /* num_yaw_values */ {

            // drake/systems/sensors/depth_sensor_specification.h:66
            const char* doc = R"""()""";

          } num_yaw_values;

          // drake::systems::sensors::DepthSensorSpecification::pitch_increment
          struct /* pitch_increment */ {

            // drake/systems/sensors/depth_sensor_specification.h:79
            const char* doc = R"""()""";

          } pitch_increment;

          // drake::systems::sensors::DepthSensorSpecification::set_max_pitch
          struct /* set_max_pitch */ {

            // drake/systems/sensors/depth_sensor_specification.h:85
            const char* doc = R"""()""";

          } set_max_pitch;

          // drake::systems::sensors::DepthSensorSpecification::set_max_range
          struct /* set_max_range */ {

            // drake/systems/sensors/depth_sensor_specification.h:89
            const char* doc = R"""()""";

          } set_max_range;

          // drake::systems::sensors::DepthSensorSpecification::set_max_yaw
          struct /* set_max_yaw */ {

            // drake/systems/sensors/depth_sensor_specification.h:83
            const char* doc = R"""()""";

          } set_max_yaw;

          // drake::systems::sensors::DepthSensorSpecification::set_min_pitch
          struct /* set_min_pitch */ {

            // drake/systems/sensors/depth_sensor_specification.h:84
            const char* doc = R"""()""";

          } set_min_pitch;

          // drake::systems::sensors::DepthSensorSpecification::set_min_range
          struct /* set_min_range */ {

            // drake/systems/sensors/depth_sensor_specification.h:88
            const char* doc = R"""()""";

          } set_min_range;

          // drake::systems::sensors::DepthSensorSpecification::set_min_yaw
          struct /* set_min_yaw */ {

            // drake/systems/sensors/depth_sensor_specification.h:82
            const char* doc = R"""(@})""";

          } set_min_yaw;

          // drake::systems::sensors::DepthSensorSpecification::set_num_pitch_values
          struct /* set_num_pitch_values */ {

            // drake/systems/sensors/depth_sensor_specification.h:87
            const char* doc = R"""()""";

          } set_num_pitch_values;

          // drake::systems::sensors::DepthSensorSpecification::set_num_yaw_values
          struct /* set_num_yaw_values */ {

            // drake/systems/sensors/depth_sensor_specification.h:86
            const char* doc = R"""()""";

          } set_num_yaw_values;

          // drake::systems::sensors::DepthSensorSpecification::set_octant_1_spec
          struct /* set_octant_1_spec */ {

            // drake/systems/sensors/depth_sensor_specification.h:111
            const char* doc =
R"""(Sets ``spec`` to specify a sensor that covers octant 1 of the sensor's
base frame. It contains the following specifications:

- min_yaw = 0 - max_yaw = M_PI_2 - min_pitch = 0 - max_pitch = M_PI_2
- num_yaw_values = 10 - num_pitch_values = 5 - min_range = 0 -
max_range = 1)""";

          } set_octant_1_spec;

          // drake::systems::sensors::DepthSensorSpecification::set_x_linear_spec
          struct /* set_x_linear_spec */ {

            // drake/systems/sensors/depth_sensor_specification.h:216
            const char* doc =
R"""(Sets ``spec`` to specify a sensor with a single depth measurement
along the sensor's base frame's +X axis between 1 meter and 2 meters.
It contains the following specifications:

- min_yaw = 0 - max_yaw = 0 - min_pitch = 0 - max_pitch = 0 -
num_yaw_values = 1 - num_pitch_values = 1 - min_range = 1 - max_range
= 2)""";

          } set_x_linear_spec;

          // drake::systems::sensors::DepthSensorSpecification::set_xy_planar_spec
          struct /* set_xy_planar_spec */ {

            // drake/systems/sensors/depth_sensor_specification.h:139
            const char* doc =
R"""(Sets ``spec`` to specify a sensor that covers the sensor's base
frame's X/Y plane. It contains the following specifications:

- min_yaw = -M_PI - max_yaw = M_PI - min_pitch = 0 - max_pitch = 0 -
num_yaw_values = 50 - num_pitch_values = 1 - min_range = 0 - max_range
= 1

The specification describes a "planar" depth sensor in the sense that
`min_pitch` and `max_pitch` are both zero whereas the yaw range is
non-zero. Thus, it scans in the yaw direction, which is in the plane
formed by the X and Y axes of the sensor's base frame. Example depth
sensors that fit this description include those made by Hokuyo and
SICK.)""";

          } set_xy_planar_spec;

          // drake::systems::sensors::DepthSensorSpecification::set_xyz_spherical_spec
          struct /* set_xyz_spherical_spec */ {

            // drake/systems/sensors/depth_sensor_specification.h:192
            const char* doc =
R"""(Sets ``spec`` to specify a sensor that covers all 8 octants of the
sensor's base frame. The sensed region is in the shape of a sphere
with a radius between min_range and max_range. It contains the
following specifications:

- min_yaw = -M_PI - max_yaw = M_PI - min_pitch = -M_PI_2 - max_pitch =
M_PI_2 - num_yaw_values = 50 - num_pitch_values = 50 - min_range = 0 -
max_range = 1

Note that since min_range is 0, the sensed sphere is solid.)""";

          } set_xyz_spherical_spec;

          // drake::systems::sensors::DepthSensorSpecification::set_xz_planar_spec
          struct /* set_xz_planar_spec */ {

            // drake/systems/sensors/depth_sensor_specification.h:166
            const char* doc =
R"""(Sets ``spec`` to specify a sensor that covers the sensor's base
frame's X/Z plane. It contains the following specifications:

- min_yaw = 0 - max_yaw = 0 - min_pitch = -M_PI_2 - max_pitch = M_PI_2
- num_yaw_values = 1 - num_pitch_values = 50 - min_range = 0 -
max_range = 1

See the description of get_xy_planar_spec() for an explanation on why
the returned specification describes a "planar" depth sensor. In this
case, `min_yaw` and `max_yaw` are both equal to zero whereas the pitch
range is not zero, meaning the described sensor scans its X / Z plane.)""";

          } set_xz_planar_spec;

          // drake::systems::sensors::DepthSensorSpecification::yaw_increment
          struct /* yaw_increment */ {

            // drake/systems/sensors/depth_sensor_specification.h:78
            const char* doc = R"""()""";

          } yaw_increment;

        } DepthSensorSpecification;

        // drake::systems::sensors::DepthSensorToLcmPointCloudMessage
        struct /* DepthSensorToLcmPointCloudMessage */ {

          // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:21
          const char* doc =
R"""(A DepthSensorToLcmPointCloudMessage takes as input a DepthSensorOutput
and the pose of the depth sensor in the world (`X_WS`). If the input
port containing `X_WS` is unconnected, a std::runtime_error will be
thrown while evaluating the output of this system. This system outputs
an AbstractValue containing a `Value<bot_core::pointcloud_t>` LCM
message that defines a point cloud in the world frame. This message
can then be sent to `drake-visualizer` using LcmPublisherSystem for
visualizing the depth readings contained within the inputted
DepthSensorOutput.)""";

          // drake::systems::sensors::DepthSensorToLcmPointCloudMessage::DepthSensorToLcmPointCloudMessage
          struct /* ctor */ {

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:23
            const char* doc = R"""()""";

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:23
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:29
            const char* doc_3 =
R"""(A DepthSensorToLcmPointCloudMessage constructor.

Parameter ``spec``:
    The specification of the depth sensor whose output is being
    visualized.)""";

          } ctor;

          // drake::systems::sensors::DepthSensorToLcmPointCloudMessage::depth_readings_input_port
          struct /* depth_readings_input_port */ {

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:33
            const char* doc =
R"""(Returns the input port containing a DepthSensorOutput.)""";

          } depth_readings_input_port;

          // drake::systems::sensors::DepthSensorToLcmPointCloudMessage::pointcloud_message_output_port
          struct /* pointcloud_message_output_port */ {

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:40
            const char* doc =
R"""(Returns the abstract valued output port that contains a
`Value<bot_core::pointcloud_t>`.)""";

          } pointcloud_message_output_port;

          // drake::systems::sensors::DepthSensorToLcmPointCloudMessage::pose_input_port
          struct /* pose_input_port */ {

            // drake/systems/sensors/depth_sensor_to_lcm_point_cloud_message.h:36
            const char* doc =
R"""(Returns the input port containing `X_WS`.)""";

          } pose_input_port;

        } DepthSensorToLcmPointCloudMessage;

        // drake::systems::sensors::Gyroscope
        struct /* Gyroscope */ {

          // drake/systems/sensors/gyroscope.h:56
          const char* doc =
R"""(A simulated ideal gyroscope. It measures angular velocity along three
dimensions.

<B>The Gyroscope Math:</B>

Let: - `G` be the gyroscope's frame. - `W` be the world frame. -
`ω_G_W` be `G`'s rotational velocity expressed in `W`. - `R_GW` be the
rotation matrix from `W` to `G`. - `ω_G_G` be `G`'s rotational
velocity expressed in `G`. This is the output of the gyroscope.

The math implemented by this sensor is as follows:

```
ω_G_G = R_GW * ω_G_W
```

<B>System Input Ports:</B>

This system has one input port that is accessible via the following
accessor:

- get_input_port(): Contains the state (i.e., position and velocity)
vector, `x`, of the RigidBodyPlant being sensed by this sensor.

<B>System Output Ports:</B>

This system has one output port that is accessible via the following
accessor method:

- get_output_port(): Contains the sensed angular velocity data in this
sensor's frame. See GyroscopeOutput.)""";

          // drake::systems::sensors::Gyroscope::Gyroscope
          struct /* ctor */ {

            // drake/systems/sensors/gyroscope.h:58
            const char* doc = R"""()""";

            // drake/systems/sensors/gyroscope.h:58
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/gyroscope.h:76
            const char* doc_3 =
R"""(A constructor.

Parameter ``name``:
    The name of the gyroscope. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance within ``tree``.

Parameter ``frame``:
    The frame to which this gyroscope is attached. This is the frame
    in which this sensor's output is given. It need not be in the
    provided `tree`, but must reference a body in the `tree`.

Parameter ``tree``:
    The RigidBodyTree that belongs to the RigidBodyPlant being sensed
    by this sensor. This should be a reference to the same
    RigidBodyTree that is being used by the RigidBodyPlant whose
    outputs are fed into this sensor. This parameter's lifespan must
    exceed that of this class's instance.)""";

          } ctor;

          // drake::systems::sensors::Gyroscope::get_frame
          struct /* get_frame */ {

            // drake/systems/sensors/gyroscope.h:86
            const char* doc =
R"""(Returns this sensor's frame, which specifies its location and
orientation in the RigidBodyTree.

See also:
    get_tree())""";

          } get_frame;

          // drake::systems::sensors::Gyroscope::get_input_port
          struct /* get_input_port */ {

            // drake/systems/sensors/gyroscope.h:90
            const char* doc =
R"""(Returns the input port that should contain the generalized (i.e.,
linear and rotational) position and velocity state of the
RigidBodyTree DOFs.)""";

          } get_input_port;

          // drake::systems::sensors::Gyroscope::get_output_port
          struct /* get_output_port */ {

            // drake/systems/sensors/gyroscope.h:96
            const char* doc =
R"""(Returns a the state output port, which contains the sensor's sensed
values.)""";

          } get_output_port;

          // drake::systems::sensors::Gyroscope::get_tree
          struct /* get_tree */ {

            // drake/systems/sensors/gyroscope.h:80
            const char* doc =
R"""(Returns the RigidBodyTree that this sensor is sensing.)""";

          } get_tree;

        } Gyroscope;

        // drake::systems::sensors::GyroscopeOutput
        struct /* GyroscopeOutput */ {

          // drake/systems/sensors/gyroscope_output.h:20
          const char* doc =
R"""(Specializes BasicVector with accessors and setters that are useful for
consumers of Gyroscope's output.)""";

          // drake::systems::sensors::GyroscopeOutput::DoClone
          struct /* DoClone */ {

            // drake/systems/sensors/gyroscope_output.h:37
            const char* doc = R"""(@})""";

          } DoClone;

          // drake::systems::sensors::GyroscopeOutput::GyroscopeOutput<T>
          struct /* ctor */ {

            // drake/systems/sensors/gyroscope_output.h:22
            const char* doc = R"""()""";

            // drake/systems/sensors/gyroscope_output.h:22
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/gyroscope_output.h:25
            const char* doc_3 =
R"""(Default constructor. Sets all rows to zero.)""";

          } ctor;

          // drake::systems::sensors::GyroscopeOutput::get_rotational_velocities
          struct /* get_rotational_velocities */ {

            // drake/systems/sensors/gyroscope_output.h:33
            const char* doc =
R"""(Returns a Vector3<T> containing the rotational velocity in the
sensor's frame. The ordering of the values in this 3-vector are
`[roll, pitch, yaw]`.)""";

          } get_rotational_velocities;

        } GyroscopeOutput;

        // drake::systems::sensors::GyroscopeOutputConstants
        struct /* GyroscopeOutputConstants */ {

          // drake/systems/sensors/gyroscope_output.h:11
          const char* doc =
R"""(Defines the semantics of each index in GyroscopeOutput's vector.)""";

        } GyroscopeOutputConstants;

        // drake::systems::sensors::Image
        struct /* Image */ {

          // drake/systems/sensors/image.h:18
          const char* doc =
R"""(Simple data format for Image. For the complex calculation with the
image, consider converting this to other libaries' Matrix data format,
i.e., MatrixX in Eigen, Mat in OpenCV, and so on.

The origin of image coordinate system is on the left-upper corner.

Template parameter ``kPixelType``:
    The pixel type enum that denotes the pixel format and the data
    type of a channel.)""";

          // drake/systems/sensors/image.h:57
          const char* doc_2 =
R"""(Simple data format for Image. For the complex calculation with the
image, consider converting this to other libaries' Matrix data format,
i.e., MatrixX in Eigen, Mat in OpenCV, and so on.

The origin of image coordinate system is on the left-upper corner.

Template parameter ``kPixelType``:
    The pixel type enum that denotes the pixel format and the data
    type of a channel.)""";

          // drake::systems::sensors::Image::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
          struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

            // drake/systems/sensors/image.h:59
            const char* doc = R"""()""";

          } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

          // drake::systems::sensors::Image::Image<kPixelType>
          struct /* ctor */ {

            // drake/systems/sensors/image.h:59
            const char* doc = R"""()""";

            // drake/systems/sensors/image.h:59
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/image.h:81
            const char* doc_3 =
R"""(Image size only constructor. Specifies a width and height for the
image. All the channel values in all the pixels are initialized with
zero.

Parameter ``width``:
    Size of width for image which should be greater than zero

Parameter ``height``:
    Size of height for image which should be greater than zero)""";

            // drake/systems/sensors/image.h:89
            const char* doc_4 =
R"""(Image size and initial value constructor. Specifies a width, height
and an initial value for all the channels in all the pixels.

Parameter ``width``:
    Size of width for image which should be greater than zero.

Parameter ``height``:
    Size of height for image which should be greater than zero.

Parameter ``initial_value``:
    A value set to all the channels in all the pixels)""";

            // drake/systems/sensors/image.h:97
            const char* doc_5 = R"""(Constructs a zero-sized image.)""";

          } ctor;

          // drake::systems::sensors::Image::at
          struct /* at */ {

            // drake/systems/sensors/image.h:133
            const char* doc =
R"""(Access to the pixel located at (x, y) in image coordinate system where
x is the variable for horizontal direction and y is one for vertical
direction. To access to the each channel value in the pixel (x, y),
you can do:

ImageRgbaU8 image(640, 480, 255); uint8_t red = image.at(x, y)[0];
uint8_t green = image.at(x, y)[1]; uint8_t blue = image.at(x, y)[2];
uint8_t alpha = image.at(x, y)[3];)""";

            // drake/systems/sensors/image.h:141
            const char* doc_2 =
R"""(Const version of at() method. See the document for the non-const
version for the detail.)""";

          } at;

          // drake::systems::sensors::Image::height
          struct /* height */ {

            // drake/systems/sensors/image.h:103
            const char* doc =
R"""(Returns the size of height for the image)""";

          } height;

          // drake::systems::sensors::Image::resize
          struct /* resize */ {

            // drake/systems/sensors/image.h:113
            const char* doc =
R"""(Changes the sizes of the width and height for the image. The values
for them should be greater than zero. (To resize to zero, assign a
default- constructed Image into this; do not use this method.) All the
values in the pixels become zero after resize.)""";

          } resize;

          // drake::systems::sensors::Image::size
          struct /* size */ {

            // drake/systems/sensors/image.h:107
            const char* doc =
R"""(Returns the result of the number of pixels in a image by the number of
channels in a pixel)""";

          } size;

          // drake::systems::sensors::Image::width
          struct /* width */ {

            // drake/systems/sensors/image.h:100
            const char* doc = R"""(Returns the size of width for the image)""";

          } width;

        } Image;

        // drake::systems::sensors::ImageToLcmImageArrayT
        struct /* ImageToLcmImageArrayT */ {

          // drake/systems/sensors/image_to_lcm_image_array_t.h:25
          const char* doc =
R"""(An ImageToLcmImageArrayT takes as input an ImageRgba8U, ImageDepth32F
and ImageLabel16I. This system outputs an AbstractValue containing a
`Value<robotlocomotion::image_array_t>` LCM message that defines an
array of images (image_t). This message can then be sent to other
processes that sbscribe it using LcmPublisherSystem. Note that you
should NOT assume any particular order of those images stored in
robotlocomotion::image_array_t, instead check the semantic of those
images with robotlocomotion::image_t::pixel_format before using them.)""";

          // drake::systems::sensors::ImageToLcmImageArrayT::ImageToLcmImageArrayT
          struct /* ctor */ {

            // drake/systems/sensors/image_to_lcm_image_array_t.h:27
            const char* doc = R"""()""";

            // drake/systems/sensors/image_to_lcm_image_array_t.h:27
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/image_to_lcm_image_array_t.h:36
            const char* doc_3 =
R"""(An ImageToLcmImageArrayT constructor.

Parameter ``color_frame_name``:
    The frame name used for color image.

Parameter ``depth_frame_name``:
    The frame name used for depth image.

Parameter ``label_frame_name``:
    The frame name used for label image.

Parameter ``do_compress``:
    When true, zlib compression will be performed. The default is
    false.)""";

          } ctor;

          // drake::systems::sensors::ImageToLcmImageArrayT::color_image_input_port
          struct /* color_image_input_port */ {

            // drake/systems/sensors/image_to_lcm_image_array_t.h:42
            const char* doc =
R"""(Returns the input port containing a color image.)""";

          } color_image_input_port;

          // drake::systems::sensors::ImageToLcmImageArrayT::depth_image_input_port
          struct /* depth_image_input_port */ {

            // drake/systems/sensors/image_to_lcm_image_array_t.h:45
            const char* doc =
R"""(Returns the input port containing a depth image.)""";

          } depth_image_input_port;

          // drake::systems::sensors::ImageToLcmImageArrayT::image_array_t_msg_output_port
          struct /* image_array_t_msg_output_port */ {

            // drake/systems/sensors/image_to_lcm_image_array_t.h:52
            const char* doc =
R"""(Returns the abstract valued output port that contains a
`Value<robotlocomotion::image_array_t>`.)""";

          } image_array_t_msg_output_port;

          // drake::systems::sensors::ImageToLcmImageArrayT::label_image_input_port
          struct /* label_image_input_port */ {

            // drake/systems/sensors/image_to_lcm_image_array_t.h:48
            const char* doc =
R"""(Returns the input port containing a label image.)""";

          } label_image_input_port;

        } ImageToLcmImageArrayT;

        // drake::systems::sensors::ImageTraits
        struct /* ImageTraits */ {

          // drake/systems/sensors/pixel_types.h:63
          const char* doc = R"""(Traits class for Image.)""";

          // drake/systems/sensors/pixel_types.h:66
          const char* doc_2 = R"""()""";

          // drake/systems/sensors/pixel_types.h:73
          const char* doc_3 = R"""()""";

          // drake/systems/sensors/pixel_types.h:80
          const char* doc_4 = R"""()""";

          // drake/systems/sensors/pixel_types.h:87
          const char* doc_5 = R"""()""";

          // drake/systems/sensors/pixel_types.h:94
          const char* doc_6 = R"""()""";

          // drake/systems/sensors/pixel_types.h:101
          const char* doc_7 = R"""()""";

          // drake/systems/sensors/pixel_types.h:108
          const char* doc_8 = R"""()""";

          // drake/systems/sensors/pixel_types.h:115
          const char* doc_9 = R"""()""";

          // drake/systems/sensors/pixel_types.h:122
          const char* doc_10 = R"""()""";

        } ImageTraits;

        // drake::systems::sensors::InvalidDepth
        struct /* InvalidDepth */ {

          // drake/systems/sensors/image.h:156
          const char* doc =
R"""(Set of constants used to represent invalid depth values. Note that in
the case that a depth is not measurable, the constants defined here
are not used. Instead we set the depth to NaN.)""";

          // drake::systems::sensors::InvalidDepth::InvalidDepth
          struct /* ctor */ {

            // drake/systems/sensors/image.h:158
            const char* doc = R"""()""";

            // drake/systems/sensors/image.h:158
            const char* doc_2 = R"""()""";

          } ctor;

        } InvalidDepth;

        // drake::systems::sensors::Label
        struct /* Label */ {

          // drake/systems/sensors/image.h:173
          const char* doc = R"""(Set of labels used for label image.)""";

          // drake::systems::sensors::Label::Label
          struct /* ctor */ {

            // drake/systems/sensors/image.h:175
            const char* doc = R"""()""";

            // drake/systems/sensors/image.h:175
            const char* doc_2 = R"""()""";

          } ctor;

        } Label;

        // drake::systems::sensors::OptitrackLcmFrameSender
        struct /* OptitrackLcmFrameSender */ {

          // drake/systems/sensors/optitrack_sender.h:30
          const char* doc =
R"""(The system has one abstract-valued input port and one abstract-valued
output port. The one abstract input port accepts
geometry::FramePoseVector. The abstract output port produces
`optitrack_frame_t`.

Note that this system does not actually send this message on an LCM
channel. To send the message, the output of this system should be
connected to an input port of a systems::Value object templated on
type `optitrack_frame_t`.)""";

          // drake::systems::sensors::OptitrackLcmFrameSender::OptitrackLcmFrameSender
          struct /* ctor */ {

            // drake/systems/sensors/optitrack_sender.h:32
            const char* doc = R"""()""";

            // drake/systems/sensors/optitrack_sender.h:32
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/optitrack_sender.h:41
            const char* doc_3 =
R"""(Create an OptitrackLcmFrameSender.

Parameter ``frame_map``:
    contains a map of geometry::FrameId to the rigid body name and id
    to be published in the resulting `optitrack_rigid_body_t` and
    `optitrack_rigid_body_description_t` messages (descriptions not
    yet implemented).)""";

          } ctor;

          // drake::systems::sensors::OptitrackLcmFrameSender::get_lcm_output_port
          struct /* get_lcm_output_port */ {

            // drake/systems/sensors/optitrack_sender.h:50
            const char* doc = R"""()""";

          } get_lcm_output_port;

          // drake::systems::sensors::OptitrackLcmFrameSender::get_optitrack_input_port
          struct /* get_optitrack_input_port */ {

            // drake/systems/sensors/optitrack_sender.h:46
            const char* doc = R"""()""";

          } get_optitrack_input_port;

        } OptitrackLcmFrameSender;

        // drake::systems::sensors::PixelFormat
        struct /* PixelFormat */ {

          // drake/systems/sensors/pixel_types.h:42
          const char* doc =
R"""(The enum class to be used to express semantic meaning of pixels. This
also expresses the order of channels in a pixel if the pixel has
multiple channels.)""";

          // drake::systems::sensors::PixelFormat::kBgr
          struct /* kBgr */ {

            // drake/systems/sensors/pixel_types.h:46
            const char* doc =
R"""(The pixel format used for all the BGR images.)""";

          } kBgr;

          // drake::systems::sensors::PixelFormat::kBgra
          struct /* kBgra */ {

            // drake/systems/sensors/pixel_types.h:50
            const char* doc =
R"""(The pixel format used for all the BGRA images.)""";

          } kBgra;

          // drake::systems::sensors::PixelFormat::kDepth
          struct /* kDepth */ {

            // drake/systems/sensors/pixel_types.h:54
            const char* doc =
R"""(The pixel format used for all the depth images.)""";

          } kDepth;

          // drake::systems::sensors::PixelFormat::kExpr
          struct /* kExpr */ {

            // drake/systems/sensors/pixel_types.h:58
            const char* doc =
R"""(The pixel format used for all the symbolic images.)""";

          } kExpr;

          // drake::systems::sensors::PixelFormat::kGrey
          struct /* kGrey */ {

            // drake/systems/sensors/pixel_types.h:52
            const char* doc =
R"""(The pixel format used for all the greyscale images.)""";

          } kGrey;

          // drake::systems::sensors::PixelFormat::kLabel
          struct /* kLabel */ {

            // drake/systems/sensors/pixel_types.h:56
            const char* doc =
R"""(The pixel format used for all the labe images.)""";

          } kLabel;

          // drake::systems::sensors::PixelFormat::kRgb
          struct /* kRgb */ {

            // drake/systems/sensors/pixel_types.h:44
            const char* doc =
R"""(The pixel format used for all the RGB images.)""";

          } kRgb;

          // drake::systems::sensors::PixelFormat::kRgba
          struct /* kRgba */ {

            // drake/systems/sensors/pixel_types.h:48
            const char* doc =
R"""(The pixel format used for all the RGBA images.)""";

          } kRgba;

        } PixelFormat;

        // drake::systems::sensors::PixelType
        struct /* PixelType */ {

          // drake/systems/sensors/pixel_types.h:18
          const char* doc =
R"""(The enum class to be used for describing pixel type in Image class.
The naming rule for the enum members is: k + (pixel format) + (bit per
a channel) + (data type for channels). For the type for channels, one
of the following capital letters is used. - I: int - U: unsigned int -
F: float)""";

          // drake::systems::sensors::PixelType::kBgr8U
          struct /* kBgr8U */ {

            // drake/systems/sensors/pixel_types.h:22
            const char* doc = R"""(The pixel format used by ImageBgr8U.)""";

          } kBgr8U;

          // drake::systems::sensors::PixelType::kBgra8U
          struct /* kBgra8U */ {

            // drake/systems/sensors/pixel_types.h:26
            const char* doc = R"""(The pixel format used by ImageBgra8U.)""";

          } kBgra8U;

          // drake::systems::sensors::PixelType::kDepth16U
          struct /* kDepth16U */ {

            // drake/systems/sensors/pixel_types.h:30
            const char* doc = R"""(The pixel format used by ImageDepth16U.)""";

          } kDepth16U;

          // drake::systems::sensors::PixelType::kDepth32F
          struct /* kDepth32F */ {

            // drake/systems/sensors/pixel_types.h:32
            const char* doc = R"""(The pixel format used by ImageDepth32F.)""";

          } kDepth32F;

          // drake::systems::sensors::PixelType::kExpr
          struct /* kExpr */ {

            // drake/systems/sensors/pixel_types.h:36
            const char* doc =
R"""(The pixel format representing symbolic::Expression.)""";

          } kExpr;

          // drake::systems::sensors::PixelType::kGrey8U
          struct /* kGrey8U */ {

            // drake/systems/sensors/pixel_types.h:28
            const char* doc = R"""(The pixel format used by ImageGrey8U.)""";

          } kGrey8U;

          // drake::systems::sensors::PixelType::kLabel16I
          struct /* kLabel16I */ {

            // drake/systems/sensors/pixel_types.h:34
            const char* doc = R"""(The pixel format used by ImageLabel16I.)""";

          } kLabel16I;

          // drake::systems::sensors::PixelType::kRgb8U
          struct /* kRgb8U */ {

            // drake/systems/sensors/pixel_types.h:20
            const char* doc = R"""(The pixel format used by ImageRgb8U.)""";

          } kRgb8U;

          // drake::systems::sensors::PixelType::kRgba8U
          struct /* kRgba8U */ {

            // drake/systems/sensors/pixel_types.h:24
            const char* doc = R"""(The pixel format used by ImageRgba8U.)""";

          } kRgba8U;

        } PixelType;

        // drake::systems::sensors::RenderingConfig
        struct /* RenderingConfig */ {

          // drake/systems/sensors/rgbd_renderer.h:19
          const char* doc =
R"""(Common configurations of rendering systems.)""";

          // drake::systems::sensors::RenderingConfig::RenderingConfig
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_renderer.h:20
            const char* doc = R"""()""";

          } ctor;

          // drake::systems::sensors::RenderingConfig::fov_y
          struct /* fov_y */ {

            // drake/systems/sensors/rgbd_renderer.h:39
            const char* doc =
R"""(The renderer's camera vertical field of view in radians.)""";

          } fov_y;

          // drake::systems::sensors::RenderingConfig::height
          struct /* height */ {

            // drake/systems/sensors/rgbd_renderer.h:35
            const char* doc =
R"""(The height of the image to be rendered in pixels.)""";

          } height;

          // drake::systems::sensors::RenderingConfig::show_window
          struct /* show_window */ {

            // drake/systems/sensors/rgbd_renderer.h:51
            const char* doc =
R"""(A flag for showing visible windows for RGB and label images. If this
is false, offscreen rendering is executed. This is useful for
debugging purposes.)""";

          } show_window;

          // drake::systems::sensors::RenderingConfig::width
          struct /* width */ {

            // drake/systems/sensors/rgbd_renderer.h:31
            const char* doc =
R"""(The width of the image to be rendered in pixels.)""";

          } width;

          // drake::systems::sensors::RenderingConfig::z_far
          struct /* z_far */ {

            // drake/systems/sensors/rgbd_renderer.h:47
            const char* doc =
R"""(The maximum depth RgbdRenderer can output. Note that this is different
from renderer's clipping range where all the objects outside the range
are not rendered even in RGB image while this only affects depth
image.)""";

          } z_far;

          // drake::systems::sensors::RenderingConfig::z_near
          struct /* z_near */ {

            // drake/systems/sensors/rgbd_renderer.h:43
            const char* doc =
R"""(The minimum depth RgbdRenderer can output. Note that this is different
from renderer's clipping range where all the objects outside the range
are not rendered even in RGB image while this only affects depth
image.)""";

          } z_near;

        } RenderingConfig;

        // drake::systems::sensors::RgbdCamera
        struct /* RgbdCamera */ {

          // drake/systems/sensors/rgbd_camera.h:65
          const char* doc =
R"""(An RGB-D camera system that provides RGB, depth and label images using
visual elements of RigidBodyTree. Its image resolution is fixed at VGA
(640 x 480 pixels) for all three images. The default depth sensing
range is from 0.5 m to 5.0 m.

Let `W` be the world coordinate system. In addition to `W`, there are
three more coordinate systems that are associated with an RgbdCamera.
They are defined as follows:

* `B` - the camera's base coordinate system: X-forward, Y-left, and
Z-up.

* `C` - the camera's color sensor's optical coordinate system:
`X-right`, `Y-down` and `Z-forward`.

* `D` - the camera's depth sensor's optical coordinate system:
`X-right`, `Y-down` and `Z-forward`.

The origins of `C` and `D` (i.e., `Co` and `Do`, respectively) are
offset from `B`'s origin (`Bo`) by 0 m in `B`'s X-axis, +0.02 m in
`B`'s Y-axis, and 0 m in `B`'s Z axis. Since `C` and `D` are
coincident, the depth image is a "registered depth image" for the RGB
image. No disparity between the RGB and depth images are modeled. For
more details about the poses of `C` and `D`, see the class
documentation of CameraInfo.

Output image format: - The RGB image has four channels in the
following order: red, green blue, alpha. Each channel is represented
by a uint8_t.

- The depth image has a depth channel represented by a float. The
value stored in the depth channel holds *the Z value in `D`.* Note
that this is different from the range data used by laser range finders
(like that provided by DepthSensor) in which the depth value
represents the distance from the sensor origin to the object's
surface.

- The label image has single channel represented by a int16_t. The
value stored in the channel holds a model ID which corresponds to an
object in the scene. For the pixels corresponding to no body, namely
the sky and the flat terrain, we assign Label::kNoBody and
Label::kFlatTerrain, respectively.)""";

          // drake::systems::sensors::RgbdCamera::ConvertDepthImageToPointCloud
          struct /* ConvertDepthImageToPointCloud */ {

            // drake/systems/sensors/rgbd_camera.h:86
            const char* doc =
R"""(Converts a depth image obtained from RgbdCamera to a point cloud. If a
pixel in the depth image has NaN depth value, all the `(x, y, z)`
values in the converted point will be NaN. Similarly, if a pixel has
either InvalidDepth::kTooFar or InvalidDepth::kTooClose, the converted
point will be InvalidDepth::kTooFar. Note that this matches the
convention used by the Point Cloud Library (PCL).

Parameter ``depth_image``:
    The input depth image obtained from RgbdCamera.

Parameter ``camera_info``:
    The input camera info which is used for conversion.

Parameter ``point_cloud``:
    The pointer of output point cloud.)""";

          } ConvertDepthImageToPointCloud;

          // drake::systems::sensors::RgbdCamera::ResetRenderer
          struct /* ResetRenderer */ {

            // drake/systems/sensors/rgbd_camera.h:262
            const char* doc = R"""()""";

          } ResetRenderer;

          // drake::systems::sensors::RgbdCamera::RgbdCamera
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_camera.h:67
            const char* doc = R"""()""";

            // drake/systems/sensors/rgbd_camera.h:67
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rgbd_camera.h:131
            const char* doc_3 =
R"""(A constructor that uses the default RgbdRendererVTK renderer and
defines `B` using Euler angles. The pose of RgbdCamera will be fixed
to the world coordinate system throughout the simulation.

Parameter ``name``:
    The name of the RgbdCamera. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance.

Parameter ``tree``:
    The RigidBodyTree containing the geometric description of the
    world. The life span of this parameter must exceed that of this
    class's instance. The maximum number of bodies in the `tree` must
    be less than 1536 based on the number of the colors used for the
    label image, otherwise an exception will be thrown.

Parameter ``position``:
    The x-y-z position of `B` in `W`. This defines the translation
    component of `X_WB`.

Parameter ``orientation``:
    The roll-pitch-yaw orientation of `B` in `W`. This defines the
    orientation component of `X_WB`.

Parameter ``z_near``:
    The minimum depth distance RgbdCamera can measure. The default is
    0.5 meters.

Parameter ``z_far``:
    The maximum depth distance RgbdCamera can measure. The default is
    5 meters.

Parameter ``fov_y``:
    The RgbdCamera's vertical field of view. The default is PI / 4.

Parameter ``show_window``:
    A flag for showing a visible window. If this is false, offscreen
    rendering is executed. This is useful for debugging purposes. The
    default is true.

Parameter ``flat_terrain``:
    A flag to add a flat terrain at z = 0 in the world coordinate
    system. The default is true.

Throws:
    s std::logic_error When the number of rigid bodies in the scene
    exceeds the maximum limit 1535.)""";

            // drake/systems/sensors/rgbd_camera.h:180
            const char* doc_4 =
R"""(A constructor that uses the default RgbdRendererVTK renderer and
defines `B` using a RigidBodyFrame. The pose of RgbdCamera is fixed to
a user-defined frame and will be updated during the simulation.

Parameter ``name``:
    The name of the RgbdCamera. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance.

Parameter ``tree``:
    The RigidBodyTree containing the geometric description of the
    world. The life span of this parameter must exceed that of this
    class's instance. The maximum number of bodies in the `tree` must
    be less than 1536 based on the number of the colors used for the
    label image, otherwise an exception will be thrown.

Parameter ``frame``:
    The frame in @tree to which this camera is attached.

Parameter ``z_near``:
    The minimum depth distance RgbdCamera can measure. The default is
    0.5 meters.

Parameter ``z_far``:
    The maximum depth distance RgbdCamera can measure. The default is
    5 meters.

Parameter ``fov_y``:
    The RgbdCamera's vertical field of view. The default is PI / 4.

Parameter ``show_window``:
    A flag for showing a visible window. If this is false, offscreen
    rendering is executed. This is useful for debugging purposes. The
    default is true.

Parameter ``flat_terrain``:
    A flag to add a flat terrain at z = 0 in the world coordinate
    system. The default is true.

Throws:
    s std::logic_error When the number of rigid bodies in the scene
    exceeds the maximum limit 1535.)""";

            // drake/systems/sensors/rgbd_camera.h:217
            const char* doc_5 =
R"""(A constructor that takes a renderer and defines `B` using Euler
angles. The pose of RgbdCamera will be fixed to the world coordinate
system throughout the simulation.

Parameter ``name``:
    The name of the RgbdCamera. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance.

Parameter ``tree``:
    The RigidBodyTree containing the geometric description of the
    world. The life span of this parameter must exceed that of this
    class's instance. The maximum number of bodies in the `tree` must
    be less than 1536 based on the number of the colors used for the
    label image, otherwise an exception will be thrown.

Parameter ``position``:
    The x-y-z position of `B` in `W`. This defines the translation
    component of `X_WB`.

Parameter ``orientation``:
    The roll-pitch-yaw orientation of `B` in `W`. This defines the
    orientation component of `X_WB`.

Parameter ``renderer``:
    The rendering backend to render images for the camera. Camera
    configuration parameters are obtained from the RenderingConfig
    settings in the renderer. The renderer will be owned by this
    camera.

Throws:
    s std::logic_error When the number of rigid bodies in the scene
    exceeds the maximum limit 1535.)""";

            // drake/systems/sensors/rgbd_camera.h:247
            const char* doc_6 =
R"""(A constructor that takes a renderer and defines `B` using a
RigidBodyFrame. The pose of RgbdCamera is fixed to a user-defined
frame and will be updated during the simulation.

Parameter ``name``:
    The name of the RgbdCamera. This can be any value, but should
    typically be unique among all sensors attached to a particular
    model instance.

Parameter ``tree``:
    The RigidBodyTree containing the geometric description of the
    world. The life span of this parameter must exceed that of this
    class's instance. The maximum number of bodies in the `tree` must
    be less than 1536 based on the number of the colors used for the
    label image, otherwise an exception will be thrown.

Parameter ``frame``:
    The frame in @tree to which this camera is attached.

Parameter ``renderer``:
    The rendering backend to render images for the camera. Camera
    configuration parameters are obtained from the RenderingConfig
    settings in the renderer. The renderer will be owned by this
    camera.

Throws:
    s std::logic_error When the number of rigid bodies in the scene
    exceeds the maximum limit 1535.)""";

          } ctor;

          // drake::systems::sensors::RgbdCamera::camera_base_pose_output_port
          struct /* camera_base_pose_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:320
            const char* doc =
R"""(Returns the vector valued output port that contains a PoseVector.)""";

          } camera_base_pose_output_port;

          // drake::systems::sensors::RgbdCamera::color_camera_info
          struct /* color_camera_info */ {

            // drake/systems/sensors/rgbd_camera.h:277
            const char* doc = R"""(Reterns the color sensor's info.)""";

          } color_camera_info;

          // drake::systems::sensors::RgbdCamera::color_camera_optical_pose
          struct /* color_camera_optical_pose */ {

            // drake/systems/sensors/rgbd_camera.h:283
            const char* doc = R"""(Returns `X_BC`.)""";

          } color_camera_optical_pose;

          // drake::systems::sensors::RgbdCamera::color_image_output_port
          struct /* color_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:310
            const char* doc =
R"""(Returns the abstract valued output port that contains a RGBA image of
the type ImageRgba8U.)""";

          } color_image_output_port;

          // drake::systems::sensors::RgbdCamera::depth_camera_info
          struct /* depth_camera_info */ {

            // drake/systems/sensors/rgbd_camera.h:280
            const char* doc = R"""(Reterns the depth sensor's info.)""";

          } depth_camera_info;

          // drake::systems::sensors::RgbdCamera::depth_camera_optical_pose
          struct /* depth_camera_optical_pose */ {

            // drake/systems/sensors/rgbd_camera.h:286
            const char* doc = R"""(Returns `X_BD`.)""";

          } depth_camera_optical_pose;

          // drake::systems::sensors::RgbdCamera::depth_image_output_port
          struct /* depth_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:313
            const char* doc =
R"""(Returns the abstract valued output port that contains an
ImageDepth32F.)""";

          } depth_image_output_port;

          // drake::systems::sensors::RgbdCamera::frame
          struct /* frame */ {

            // drake/systems/sensors/rgbd_camera.h:292
            const char* doc =
R"""(Returns the RigidBodyFrame to which this RgbdCamera is attached.

Throws:
    s std::logic_error When RgbdCamera is instantiated as a fixed
    camera.)""";

          } frame;

          // drake::systems::sensors::RgbdCamera::label_image_output_port
          struct /* label_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:317
            const char* doc =
R"""(Returns the abstract valued output port that contains an label image
of the type ImageLabel16I.)""";

          } label_image_output_port;

          // drake::systems::sensors::RgbdCamera::mutable_renderer
          struct /* mutable_renderer */ {

            // drake/systems/sensors/rgbd_camera.h:274
            const char* doc = R"""(Reterns mutable renderer.)""";

          } mutable_renderer;

          // drake::systems::sensors::RgbdCamera::state_input_port
          struct /* state_input_port */ {

            // drake/systems/sensors/rgbd_camera.h:306
            const char* doc =
R"""(Returns the vector valued input port that takes a vector of `q, v`
corresponding to the positions and velocities associated with the
RigidBodyTree.)""";

          } state_input_port;

          // drake::systems::sensors::RgbdCamera::tree
          struct /* tree */ {

            // drake/systems/sensors/rgbd_camera.h:301
            const char* doc =
R"""(Returns the RigidBodyTree to which this RgbdCamera is attached.)""";

          } tree;

        } RgbdCamera;

        // drake::systems::sensors::RgbdCameraDiscrete
        struct /* RgbdCameraDiscrete */ {

          // drake/systems/sensors/rgbd_camera.h:378
          const char* doc =
R"""(Wraps a continuous RgbdCamera with zero order holds to have it
function as a discrete sensor.)""";

          // drake::systems::sensors::RgbdCameraDiscrete::RgbdCameraDiscrete
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_camera.h:380
            const char* doc = R"""()""";

            // drake/systems/sensors/rgbd_camera.h:380
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rgbd_camera.h:391
            const char* doc_3 =
R"""(Constructs a diagram containing a (non-registered) RgbdCamera that
will update at a given rate.

Parameter ``period``:
    Update period (sec).

Parameter ``render_label_image``:
    If true, renders label image (which requires additional overhead).
    If false, `label_image_output_port` will raise an error if called.)""";

          } ctor;

          // drake::systems::sensors::RgbdCameraDiscrete::camera
          struct /* camera */ {

            // drake/systems/sensors/rgbd_camera.h:396
            const char* doc =
R"""(Returns reference to RgbdCamera intsance.)""";

          } camera;

          // drake::systems::sensors::RgbdCameraDiscrete::camera_base_pose_output_port
          struct /* camera_base_pose_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:425
            const char* doc =
R"""(See also:
    RgbdCamera::camera_base_pose_output_port().)""";

          } camera_base_pose_output_port;

          // drake::systems::sensors::RgbdCameraDiscrete::color_image_output_port
          struct /* color_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:410
            const char* doc =
R"""(See also:
    RgbdCamera::color_image_output_port().)""";

          } color_image_output_port;

          // drake::systems::sensors::RgbdCameraDiscrete::depth_image_output_port
          struct /* depth_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:415
            const char* doc =
R"""(See also:
    RgbdCamera::depth_image_output_port().)""";

          } depth_image_output_port;

          // drake::systems::sensors::RgbdCameraDiscrete::label_image_output_port
          struct /* label_image_output_port */ {

            // drake/systems/sensors/rgbd_camera.h:420
            const char* doc =
R"""(See also:
    RgbdCamera::label_image_output_port().)""";

          } label_image_output_port;

          // drake::systems::sensors::RgbdCameraDiscrete::mutable_camera
          struct /* mutable_camera */ {

            // drake/systems/sensors/rgbd_camera.h:399
            const char* doc =
R"""(Returns reference to RgbdCamera intsance.)""";

          } mutable_camera;

          // drake::systems::sensors::RgbdCameraDiscrete::period
          struct /* period */ {

            // drake/systems/sensors/rgbd_camera.h:402
            const char* doc =
R"""(Returns update period for discrete camera.)""";

          } period;

          // drake::systems::sensors::RgbdCameraDiscrete::state_input_port
          struct /* state_input_port */ {

            // drake/systems/sensors/rgbd_camera.h:405
            const char* doc =
R"""(See also:
    RgbdCamera::state_input_port().)""";

          } state_input_port;

        } RgbdCameraDiscrete;

        // drake::systems::sensors::RgbdRenderer
        struct /* RgbdRenderer */ {

          // drake/systems/sensors/rgbd_renderer.h:80
          const char* doc =
R"""(Abstract interface of RGB-D renderers, which render RGB, depth and
label images using VisualElement. The coordinate system of
RgbdRenderer's viewpoint `R` is `X-right`, `Y-down` and `Z-forward`
with respect to the rendered images.

Output image format: - RGB (ImageRgba8U) : the RGB image has four
channels in the following order: red, green, blue and alpha. Each
channel is represented by a uint8_t.

- Depth (ImageDepth32F) : the depth image has a depth channel
represented by a float. For a point in space `P`, the value stored in
the depth channel holds *the Z-component of the position vector
`p_RP`.* Note that this is different from the range data used by laser
range finders (like that provided by DepthSensor) in which the depth
value represents the distance from the sensor origin to the object's
surface.

- Label (ImageLabel16I) : the label image has single channel
represented by a int16_t. The value stored in the channel holds a
model ID which corresponds to an object in the scene. For the pixels
corresponding to no body, namely the sky and the flat terrain, we
assign Label::kNoBody and Label::kFlatTerrain, respectively.)""";

          // drake::systems::sensors::RgbdRenderer::AddFlatTerrain
          struct /* AddFlatTerrain */ {

            // drake/systems/sensors/rgbd_renderer.h:99
            const char* doc =
R"""(Adds a flat terrain in the rendering scene.)""";

          } AddFlatTerrain;

          // drake::systems::sensors::RgbdRenderer::RegisterVisual
          struct /* RegisterVisual */ {

            // drake/systems/sensors/rgbd_renderer.h:119
            const char* doc =
R"""(Registers a visual element to a rigid body and returns the ID of the
visual element. The element is uniquely identified using `body_id` and
`visual_id`.

Parameter ``visual``:
    A visual element to be registered. See VisualElement for more
    detail.

Parameter ``body_id``:
    The ID of a rigid body that you want a visual to be associated
    with. Note that you can associate more than one visual with a
    rigid body.

Returns:
    visual_id A local visual ID associated with given `body_id`.
    `nullopt` will be returned if `visual` contains an unsupported
    shape. We assume `visual_id` will be used together with `body_id`
    when you call UpdateVisualPose() later.)""";

          } RegisterVisual;

          // drake::systems::sensors::RgbdRenderer::RenderColorImage
          struct /* RenderColorImage */ {

            // drake/systems/sensors/rgbd_renderer.h:149
            const char* doc =
R"""(Renders and outputs the rendered color image.

Parameter ``color_image_out``:
    The rendered color image.)""";

          } RenderColorImage;

          // drake::systems::sensors::RgbdRenderer::RenderDepthImage
          struct /* RenderDepthImage */ {

            // drake/systems/sensors/rgbd_renderer.h:154
            const char* doc =
R"""(Renders and outputs the rendered depth image.

Parameter ``depth_image_out``:
    The rendered depth image.)""";

          } RenderDepthImage;

          // drake::systems::sensors::RgbdRenderer::RenderLabelImage
          struct /* RenderLabelImage */ {

            // drake/systems/sensors/rgbd_renderer.h:159
            const char* doc =
R"""(Renders and outputs the rendered label image.

Parameter ``label_image_out``:
    The rendered label image.)""";

          } RenderLabelImage;

          // drake::systems::sensors::RgbdRenderer::RgbdRenderer
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_renderer.h:82
            const char* doc = R"""()""";

            // drake/systems/sensors/rgbd_renderer.h:82
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rgbd_renderer.h:93
            const char* doc_3 =
R"""(A constructor for RgbdRenderer.

Parameter ``config``:
    Configurations of the renderer. See RenderingConfig.

Parameter ``X_WC``:
    The initial pose of the renderer's unique camera viewpoint `C` in
    the world coordinate system. The camera pose `C` can be updated by
    calling `UpdateViewpoint` later on. Default value: Identity.
    TODO(thduynguyen, kunimatsu-tri): Handle multiple viewpoints, e.g.
    for stereo depth camera?)""";

          } ctor;

          // drake::systems::sensors::RgbdRenderer::UpdateViewpoint
          struct /* UpdateViewpoint */ {

            // drake/systems/sensors/rgbd_renderer.h:144
            const char* doc =
R"""(Updates renderer's camera viewpoint with given pose X_WC.

Parameter ``X_WC``:
    The pose of renderer's camera viewpoint in the world coordinate
    system.)""";

          } UpdateViewpoint;

          // drake::systems::sensors::RgbdRenderer::UpdateVisualPose
          struct /* UpdateVisualPose */ {

            // drake/systems/sensors/rgbd_renderer.h:137
            const char* doc =
R"""(Updates the pose of a visual with given pose X_WV.

Parameter ``X_WV``:
    The pose of a visual in the world coordinate system.

Parameter ``body_id``:
    The ID of a rigid body that the visual you want to update is
    associated with.

Parameter ``visual_id``:
    The local ID of a visual that is associated with a rigid body and
    you want to update.)""";

          } UpdateVisualPose;

          // drake::systems::sensors::RgbdRenderer::color_palette
          struct /* color_palette */ {

            // drake/systems/sensors/rgbd_renderer.h:165
            const char* doc =
R"""(Returns the color palette of this renderer.)""";

          } color_palette;

          // drake::systems::sensors::RgbdRenderer::config
          struct /* config */ {

            // drake/systems/sensors/rgbd_renderer.h:162
            const char* doc =
R"""(Returns the configuration object of this renderer.)""";

          } config;

        } RgbdRenderer;

        // drake::systems::sensors::RgbdRendererOSPRay
        struct /* RgbdRendererOSPRay */ {

          // drake/systems/sensors/rgbd_renderer_ospray.h:13
          const char* doc =
R"""(An RgbdRenderer implementation using OSPRay via VTK.)""";

          // drake::systems::sensors::RgbdRendererOSPRay::RgbdRendererOSPRay
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_renderer_ospray.h:15
            const char* doc = R"""()""";

            // drake/systems/sensors/rgbd_renderer_ospray.h:15
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rgbd_renderer_ospray.h:17
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::sensors::RgbdRendererOSPRay::SetBackground
          struct /* SetBackground */ {

            // drake/systems/sensors/rgbd_renderer_ospray.h:27
            const char* doc =
R"""(Sets file path for background image. The image file format must be
jpeg.

Throws:
    s std::runtime_error if the file doesn't exist or is not jpeg.)""";

          } SetBackground;

        } RgbdRendererOSPRay;

        // drake::systems::sensors::RgbdRendererVTK
        struct /* RgbdRendererVTK */ {

          // drake/systems/sensors/rgbd_renderer_vtk.h:12
          const char* doc =
R"""(An RgbdRenderer implementation using VTK.)""";

          // drake::systems::sensors::RgbdRendererVTK::RgbdRendererVTK
          struct /* ctor */ {

            // drake/systems/sensors/rgbd_renderer_vtk.h:14
            const char* doc = R"""()""";

            // drake/systems/sensors/rgbd_renderer_vtk.h:14
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rgbd_renderer_vtk.h:16
            const char* doc_3 = R"""()""";

          } ctor;

        } RgbdRendererVTK;

        // drake::systems::sensors::RotaryEncoders
        struct /* RotaryEncoders */ {

          // drake/systems/sensors/rotary_encoders.h:23
          const char* doc =
R"""(Simple model to capture the quantization and calibration offset
effects of a rotary encoder. Consider combining this with a
ZeroOrderHold system to capture the sampled-data effects.

The inputs to this system are assumed to be in radians, and the
outputs of the system are also in radians.)""";

          // drake::systems::sensors::RotaryEncoders::RotaryEncoders<T>
          struct /* ctor */ {

            // drake/systems/sensors/rotary_encoders.h:25
            const char* doc = R"""()""";

            // drake/systems/sensors/rotary_encoders.h:25
            const char* doc_2 = R"""()""";

            // drake/systems/sensors/rotary_encoders.h:29
            const char* doc_3 =
R"""(Quantization-only constructor. Specifies one ticks_per_revolution
count for every element of the input port.)""";

            // drake/systems/sensors/rotary_encoders.h:36
            const char* doc_4 =
R"""(Selector-only constructor. Provides arguments to select particular
indices from the input signal to use in the output. Since
ticks_per_revolution is not being set, the outputs will NOT be
quantized.

Parameter ``input_port_size``:
    Dimension of the expected input signal

Parameter ``input_vector_indices``:
    List of indices)""";

            // drake/systems/sensors/rotary_encoders.h:40
            const char* doc_5 = R"""(Quantization and Selector constructor.)""";

            // drake/systems/sensors/rotary_encoders.h:46
            const char* doc_6 =
R"""(Scalar-converting copy constructor. See system_scalar_conversion.)""";

          } ctor;

          // drake::systems::sensors::RotaryEncoders::get_calibration_offsets
          struct /* get_calibration_offsets */ {

            // drake/systems/sensors/rotary_encoders.h:54
            const char* doc =
R"""(Retrieve the calibration offset parameters.)""";

          } get_calibration_offsets;

          // drake::systems::sensors::RotaryEncoders::set_calibration_offsets
          struct /* set_calibration_offsets */ {

            // drake/systems/sensors/rotary_encoders.h:49
            const char* doc = R"""(Set the calibration offset parameters.)""";

          } set_calibration_offsets;

        } RotaryEncoders;

        // drake::systems::sensors::VisualTag
        struct /* VisualTag */ {

          // drake/systems/sensors/rgbd_renderer.h:102
          const char* doc = R"""()""";

        } VisualTag;

        // vtk_util
        struct /* vtk_util */ {

          // drake::systems::sensors::vtk_util::ConvertToVtkTransform
          struct /* ConvertToVtkTransform */ {

            // drake/systems/sensors/vtk_util.h:36
            const char* doc =
R"""(Converts the provided `Eigen::Isometry3d` to a `vtkTransform`.

Parameter ``transform``:
    The transform to convert into a `vtkTransform`.)""";

          } ConvertToVtkTransform;

          // drake::systems::sensors::vtk_util::CreateSquarePlane
          struct /* CreateSquarePlane */ {

            // drake/systems/sensors/vtk_util.h:31
            const char* doc =
R"""(Creates a square plane of the given size. The plane's z axis is its
normal and is coincident with the z axis of the world coordinate
system. The plane's center is at (0, 0, 0) of both the world
coordinate system and plane's coordinate system. The ranges of the
plane's x and y are `(- size / 2, size / 2)`.

Parameter ``size``:
    The size of the plane.)""";

          } CreateSquarePlane;

          // drake::systems::sensors::vtk_util::MakeVtkPointerArray
          struct /* MakeVtkPointerArray */ {

            // drake/systems/sensors/vtk_util.h:44
            const char* doc =
R"""(Makes vtkPointerArray from one or multiple pointer(s) for VTK objects
wrapped by vtkNew.

Template parameter ``transform``:
    The transform to convert into a `vtkTransform`.)""";

          } MakeVtkPointerArray;

        } vtk_util;

      } sensors;

      // system_scalar_converter_detail
      struct /* system_scalar_converter_detail */ {

        // drake::systems::system_scalar_converter_detail::Make
        struct /* Make */ {

          // drake/systems/framework/system_scalar_converter.h:226
          const char* doc = R"""()""";

          // drake/systems/framework/system_scalar_converter.h:249
          const char* doc_2 = R"""()""";

        } Make;

      } system_scalar_converter_detail;

      // trajectory_optimization
      struct /* trajectory_optimization */ {

        // drake::systems::trajectory_optimization::AddDirectCollocationConstraint
        struct /* AddDirectCollocationConstraint */ {

          // drake/systems/trajectory_optimization/direct_collocation.h:124
          const char* doc =
R"""(Helper method to add a DirectCollocationConstraint to the ``prog``,
ensuring that the order of variables in the binding matches the order
expected by the constraint.)""";

        } AddDirectCollocationConstraint;

        // drake::systems::trajectory_optimization::DirectCollocation
        struct /* DirectCollocation */ {

          // drake/systems/trajectory_optimization/direct_collocation.h:24
          const char* doc =
R"""(DirectCollocation implements the approach to trajectory optimization
as described in C. R. Hargraves and S. W. Paris. Direct trajectory
optimization using nonlinear programming and collocation. J Guidance,
10(4):338-342, July-August 1987. It assumes a first-order hold on the
input trajectory and a cubic spline representation of the state
trajectory, and adds dynamic constraints (and running costs) to the
midpoints as well as the knot points in order to achieve a 3rd order
integration accuracy.)""";

          // drake::systems::trajectory_optimization::DirectCollocation::DirectCollocation
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:26
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:26
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:41
            const char* doc_3 =
R"""(Constructs the MathematicalProgram% and adds the collocation
constraints.

Parameter ``system``:
    A dynamical system to be used in the dynamic constraints. This
    system must support System::ToAutoDiffXd. Note that this is
    aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of knot points in the trajectory.

Parameter ``minimum_timestep``:
    Minimum spacing between sample times.

Parameter ``maximum_timestep``:
    Maximum spacing between sample times.)""";

          } ctor;

          // drake::systems::trajectory_optimization::DirectCollocation::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:54
            const char* doc = R"""()""";

          } ReconstructInputTrajectory;

          // drake::systems::trajectory_optimization::DirectCollocation::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:57
            const char* doc = R"""()""";

          } ReconstructStateTrajectory;

        } DirectCollocation;

        // drake::systems::trajectory_optimization::DirectCollocationConstraint
        struct /* DirectCollocationConstraint */ {

          // drake/systems/trajectory_optimization/direct_collocation.h:79
          const char* doc =
R"""(Implements the direct collocation constraints for a first-order hold
on the input and a cubic polynomial representation of the state
trajectories.

Note that the DirectCollocation implementation allocates only ONE of
these constraints, but binds that constraint multiple times (with
different decision variables, along the trajectory).)""";

          // drake::systems::trajectory_optimization::DirectCollocationConstraint::DirectCollocationConstraint
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:81
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:81
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:84
            const char* doc_3 = R"""()""";

          } ctor;

          // drake::systems::trajectory_optimization::DirectCollocationConstraint::DoEval
          struct /* DoEval */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:93
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:96
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/direct_collocation.h:99
            const char* doc_3 = R"""()""";

          } DoEval;

          // drake::systems::trajectory_optimization::DirectCollocationConstraint::num_inputs
          struct /* num_inputs */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:90
            const char* doc = R"""()""";

          } num_inputs;

          // drake::systems::trajectory_optimization::DirectCollocationConstraint::num_states
          struct /* num_states */ {

            // drake/systems/trajectory_optimization/direct_collocation.h:89
            const char* doc = R"""()""";

          } num_states;

        } DirectCollocationConstraint;

        // drake::systems::trajectory_optimization::DirectTranscription
        struct /* DirectTranscription */ {

          // drake/systems/trajectory_optimization/direct_transcription.h:21
          const char* doc =
R"""(DirectTranscription is perhaps the simplest implementation of a
multiple shooting method, where we have decision variables
representing the control and input at every sample time in the
trajectory, and one-step of numerical integration provides the dynamic
constraints between those decision variables.)""";

          // drake::systems::trajectory_optimization::DirectTranscription::DirectTranscription
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/direct_transcription.h:23
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/direct_transcription.h:23
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/direct_transcription.h:40
            const char* doc_3 =
R"""(Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for simple discrete-time
systems (with a single periodic timestep update). Continuous-time
systems must call one of the constructors that takes bounds on the
timestep as an argument.

Parameter ``system``:
    A dynamical system to be used in the dynamic constraints. This
    system must support System::ToAutoDiffXd. Note that this is
    aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of knot points in the trajectory.)""";

            // drake/systems/trajectory_optimization/direct_transcription.h:55
            const char* doc_4 =
R"""(Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for *linear* discrete-time
systems (with a single periodic timestep update).

Parameter ``system``:
    A linear system to be used in the dynamic constraints. Note that
    this is aliased for the lifetime of this object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of knot points in the trajectory.)""";

            // drake/systems/trajectory_optimization/direct_transcription.h:70
            const char* doc_5 =
R"""(Constructs the MathematicalProgram and adds the dynamic constraints.
This version of the constructor is only for *linear time-varying*
discrete-time systems (with a single periodic timestep update).

Parameter ``system``:
    A linear time-varying system to be used in the dynamic
    constraints. Note that this is aliased for the lifetime of this
    object.

Parameter ``context``:
    Required to describe any parameters of the system. The values of
    the state in this context do not have any effect. This context
    will also be "cloned" by the optimization; changes to the context
    after calling this method will NOT impact the trajectory
    optimization.

Parameter ``num_time_samples``:
    The number of knot points in the trajectory.)""";

          } ctor;

          // drake::systems::trajectory_optimization::DirectTranscription::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {

            // drake/systems/trajectory_optimization/direct_transcription.h:81
            const char* doc =
R"""(Get the input trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";

          } ReconstructInputTrajectory;

          // drake::systems::trajectory_optimization::DirectTranscription::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {

            // drake/systems/trajectory_optimization/direct_transcription.h:87
            const char* doc =
R"""(Get the state trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";

          } ReconstructStateTrajectory;

        } DirectTranscription;

        // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator
        struct /* GeneralizedConstraintForceEvaluator */ {

          // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:17
          const char* doc =
R"""(This evaluator computes the generalized constraint force Jᵀλ ∈ ℝ ᴺᵛ,
where Nᵥ is the size of the generalized velocities. The Jacobian J may
or may not depend on generalized position q and/or other variables.)""";

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::ComposeEvalInputVector
          struct /* ComposeEvalInputVector */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:56
            const char* doc =
R"""(Compose the input `x` to the Eval function, given λ and the part of x
that is not in λ. This is a helper function, so that the user does not
need to remember which part of x corresponds to λ, and which part
corresponds to non-λ.)""";

          } ComposeEvalInputVector;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::DoEval
          struct /* DoEval */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:80
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:83
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:86
            const char* doc_3 = R"""()""";

          } DoEval;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::DoEvalGeneric
          struct /* DoEvalGeneric */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:98
            const char* doc = R"""()""";

          } DoEvalGeneric;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::EvalConstraintJacobian
          struct /* EvalConstraintJacobian */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:111
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:117
            const char* doc_2 = R"""()""";

          } EvalConstraintJacobian;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::GeneralizedConstraintForceEvaluator
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:30
            const char* doc =
R"""(Constructor.

Parameter ``tree``:
    Note ``tree`` is aliased for the lifetime of of this object.

Parameter ``num_vars``:
    Number of variables, including λ.

Parameter ``lambda_size``:
    λ is a lambda_size x 1 vector. @Note the Jᵀλ ∈ ℝ ᴺᵛ, where Nᵥ is
    the size of the generalized velocities. So the size of the output
    vector is always Nᵥ. To evaluate Jᵀλ, it may or may not depend on
    variables such as contact force λ, generalized position q, or some
    additional variables, so the size of the input variable to this
    evaluator should be specified by the user.)""";

          } ctor;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::GetLambdaFromEvalInputVector
          struct /* GetLambdaFromEvalInputVector */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:68
            const char* doc =
R"""(Get the non-lambda part from the eval input vector. */)""";

          } GetLambdaFromEvalInputVector;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::GetNonLambdaFromEvalInputVector
          struct /* GetNonLambdaFromEvalInputVector */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:74
            const char* doc =
R"""(Get the lambda part from the eval input vector. */)""";

          } GetNonLambdaFromEvalInputVector;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::lambda_size
          struct /* lambda_size */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:39
            const char* doc = R"""(Getter for lambda_size. */)""";

          } lambda_size;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::non_lambda_size
          struct /* non_lambda_size */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:36
            const char* doc =
R"""(Getter for the size of non_lambda part in the evaluator variables. */)""";

          } non_lambda_size;

          // drake::systems::trajectory_optimization::GeneralizedConstraintForceEvaluator::tree
          struct /* tree */ {

            // drake/systems/trajectory_optimization/generalized_constraint_force_evaluator.h:42
            const char* doc = R"""(Getter for the tree. */)""";

          } tree;

        } GeneralizedConstraintForceEvaluator;

        // drake::systems::trajectory_optimization::JointLimitConstraintForceEvaluator
        struct /* JointLimitConstraintForceEvaluator */ {

          // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:16
          const char* doc =
R"""(Evaluates the joint limit constraint force. For a single joint
(revolute or prismatic), whose index in the velocity vector is i, its
joint limit force has the form [0, 0, ..., 0, -λᵤ+λₗ, 0, ... ,0], that
only the i'th entry is non-zero. where λᵤ / λₗ are the joint limit
force from upper / lower limit respectively. We assume that both λᵤ
and λₗ are non-negative.)""";

          // drake::systems::trajectory_optimization::JointLimitConstraintForceEvaluator::EvalConstraintJacobian
          struct /* EvalConstraintJacobian */ {

            // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:38
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:41
            const char* doc_2 = R"""()""";

          } EvalConstraintJacobian;

          // drake::systems::trajectory_optimization::JointLimitConstraintForceEvaluator::JointLimitConstraintForceEvaluator
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:24
            const char* doc =
R"""(Constructor.

Parameter ``tree``:
    The tree on which the joint limit force is evaluated.

Parameter ``joint_velocity_index``:
    The joint whose velocity index equals to joint_velocity_index has
    joint limit force.)""";

          } ctor;

          // drake::systems::trajectory_optimization::JointLimitConstraintForceEvaluator::LowerLimitForceIndexInLambda
          struct /* LowerLimitForceIndexInLambda */ {

            // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:35
            const char* doc = R"""()""";

          } LowerLimitForceIndexInLambda;

          // drake::systems::trajectory_optimization::JointLimitConstraintForceEvaluator::UpperLimitForceIndexInLambda
          struct /* UpperLimitForceIndexInLambda */ {

            // drake/systems/trajectory_optimization/joint_limit_constraint_force_evaluator.h:34
            const char* doc =
R"""(The constraint force λ contains both the joint upper limit force λᵤ,
and the joint lower limit force λₗ. The following two method returns
the indices of λᵤ / λₗ in λ.)""";

          } UpperLimitForceIndexInLambda;

        } JointLimitConstraintForceEvaluator;

        // drake::systems::trajectory_optimization::MultipleShooting
        struct /* MultipleShooting */ {

          // drake/systems/trajectory_optimization/multiple_shooting.h:37
          const char* doc =
R"""(MultipleShooting is an abstract class for trajectory optimization that
creates decision variables for inputs, states, and (optionally) sample
times along the trajectory, then provides a number of methods for
working with those decision variables.

Subclasses must implement the abstract methods: DoAddRunningCost()
ReconstructInputTrajectory() ReconstructStateTrajectory() using all of
the correct interpolation schemes for the specific transcription
method, and should add the constraints to impose the System% dynamics
in their constructor.

This class assumes that there are a fixed number (N) time
steps/samples, and that the trajectory is discretized into timesteps h
(N-1 of these), state x (N of these), and control input u (N of
these).)""";

          // drake::systems::trajectory_optimization::MultipleShooting::AddConstraintToAllKnotPoints
          struct /* AddConstraintToAllKnotPoints */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:132
            const char* doc =
R"""(Adds a constraint to all knot points, where any instances of time(),
state(), and/or input() placeholder variables are substituted with the
relevant variables for each current time index.)""";

          } AddConstraintToAllKnotPoints;

          // drake::systems::trajectory_optimization::MultipleShooting::AddDurationBounds
          struct /* AddDurationBounds */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:164
            const char* doc =
R"""(Adds a constraint on the total duration of the trajectory.

Throws:
    s std::runtime_error if timesteps are not declared as decision
    variables.)""";

          } AddDurationBounds;

          // drake::systems::trajectory_optimization::MultipleShooting::AddEqualTimeIntervalsConstraints
          struct /* AddEqualTimeIntervalsConstraints */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:159
            const char* doc =
R"""(Adds constraints to enforce that all timesteps have equal duration.

Throws:
    s std::runtime_error if timesteps are not declared as decision
    variables.)""";

          } AddEqualTimeIntervalsConstraints;

          // drake::systems::trajectory_optimization::MultipleShooting::AddFinalCost
          struct /* AddFinalCost */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:171
            const char* doc =
R"""(Adds a cost to the final time, of the form @f[ cost = e(t,x,u), @f]
where any instances of time(), state(), and/or input() placeholder
variables are substituted with the relevant variables for each current
time index.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:180
            const char* doc_2 =
R"""(Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations. Note:
Derived classes will need to type using
MultipleShooting::AddFinalCost; to "unhide" this method.)""";

          } AddFinalCost;

          // drake::systems::trajectory_optimization::MultipleShooting::AddInputTrajectoryCallback
          struct /* AddInputTrajectoryCallback */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:204
            const char* doc =
R"""(Adds a callback method to visualize intermediate results of the
trajectory optimization. The callback should be of the form
MyVisualization(sample_times, values), where breaks is a N-by-1
VectorXd of sample times, and values is a num_inputs-by-N MatrixXd
representing the current (intermediate) value of the input trajectory
at the break points in each column.

Note: Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support callbacks.
For instance, adding a visualization callback to a quadratic
programming problem may result in using a nonlinear programming solver
as the default solver.)""";

          } AddInputTrajectoryCallback;

          // drake::systems::trajectory_optimization::MultipleShooting::AddRunningCost
          struct /* AddRunningCost */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:119
            const char* doc =
R"""(Adds an integrated cost to all time steps, of the form @f[ cost =
\int_0^T g(t,x,u) dt, @f] where any instances of time(), state(),
and/or input() placeholder variables are substituted with the relevant
variables for each current time index. The particular integration
scheme is determined by the derived class implementation.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:124
            const char* doc_2 =
R"""(Adds support for passing in a (scalar) matrix Expression, which is a
common output of most symbolic linear algebra operations.)""";

          } AddRunningCost;

          // drake::systems::trajectory_optimization::MultipleShooting::AddStateTrajectoryCallback
          struct /* AddStateTrajectoryCallback */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:221
            const char* doc =
R"""(Adds a callback method to visualize intermediate results of the
trajectory optimization. The callback should be of the form
MyVisualization(sample_times, values), where sample_times is a N-by-1
VectorXd of sample times, and values is a num_states-by-N MatrixXd
representing the current (intermediate) value of the state trajectory
at the break points in each column.

Note: Just like other costs/constraints, not all solvers support
callbacks. Adding a callback here will force
MathematicalProgram::Solve to select a solver that support callbacks.
For instance, adding a visualization callback to a quadratic
programming problem may result in using a nonlinear programming solver
as the default solver.)""";

          } AddStateTrajectoryCallback;

          // drake::systems::trajectory_optimization::MultipleShooting::AddTimeIntervalBounds
          struct /* AddTimeIntervalBounds */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:154
            const char* doc =
R"""(Adds bounds on all time intervals.

Parameter ``lower_bound``:
    A scalar double lower bound.

Parameter ``upper_bound``:
    A scalar double upper bound.

Throws:
    s std::runtime_error if timesteps are not declared as decision
    variables.)""";

          } AddTimeIntervalBounds;

          // drake::systems::trajectory_optimization::MultipleShooting::GetInputSamples
          struct /* GetInputSamples */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:259
            const char* doc =
R"""(Returns a matrix containing the input values (arranged in columns) at
each knot point at the solution.)""";

          } GetInputSamples;

          // drake::systems::trajectory_optimization::MultipleShooting::GetSampleTimes
          struct /* GetSampleTimes */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:248
            const char* doc =
R"""(Returns a vector containing the elapsed time at each knot point.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:253
            const char* doc_2 =
R"""(Returns a vector containing the elapsed time at each knot point at the
solution.)""";

          } GetSampleTimes;

          // drake::systems::trajectory_optimization::MultipleShooting::GetStateSamples
          struct /* GetStateSamples */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:263
            const char* doc =
R"""(Returns a matrix containing the state values (arranged in columns) at
each knot point at the solution.)""";

          } GetStateSamples;

          // drake::systems::trajectory_optimization::MultipleShooting::MultipleShooting
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:39
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:39
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:290
            const char* doc_3 =
R"""(Constructs a MultipleShooting instance with fixed sample times.

Parameter ``num_inputs``:
    Number of inputs at each sample point.

Parameter ``num_states``:
    Number of states at each sample point.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``fixed_timestep``:
    The spacing between sample times.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:301
            const char* doc_4 =
R"""(Constructs a MultipleShooting instance with sample times as decision
variables.

Parameter ``num_inputs``:
    Number of inputs at each sample point.

Parameter ``num_states``:
    Number of states at each sample point.

Parameter ``num_time_samples``:
    Number of time samples.

Parameter ``minimum_timestep``:
    Minimum spacing between sample times.

Parameter ``maximum_timestep``:
    Maximum spacing between sample times.)""";

          } ctor;

          // drake::systems::trajectory_optimization::MultipleShooting::N
          struct /* N */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:318
            const char* doc = R"""()""";

          } N;

          // drake::systems::trajectory_optimization::MultipleShooting::ReconstructInputTrajectory
          struct /* ReconstructInputTrajectory */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:270
            const char* doc =
R"""(Get the input trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints. Requires that the system has at least one
input port.)""";

          } ReconstructInputTrajectory;

          // drake::systems::trajectory_optimization::MultipleShooting::ReconstructStateTrajectory
          struct /* ReconstructStateTrajectory */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:276
            const char* doc =
R"""(Get the state trajectory at the solution as a PiecewisePolynomial. The
order of the trajectory will be determined by the integrator used in
the dynamic constraints.)""";

          } ReconstructStateTrajectory;

          // drake::systems::trajectory_optimization::MultipleShooting::SetInitialTrajectory
          struct /* SetInitialTrajectory */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:243
            const char* doc = R"""()""";

          } SetInitialTrajectory;

          // drake::systems::trajectory_optimization::MultipleShooting::SubstitutePlaceholderVariables
          struct /* SubstitutePlaceholderVariables */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:306
            const char* doc =
R"""(Replaces e.g. placeholder_x_var_ with x_vars_ at time interval
``interval_index``, for all placeholder variables.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:311
            const char* doc_2 =
R"""(Replaces e.g. placeholder_x_var_ with x_vars_ at time interval
``interval_index``, for all placeholder variables.)""";

          } SubstitutePlaceholderVariables;

          // drake::systems::trajectory_optimization::MultipleShooting::final_state
          struct /* final_state */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:100
            const char* doc =
R"""(Returns the decision variables associated with the state, x, at the
final time index.)""";

          } final_state;

          // drake::systems::trajectory_optimization::MultipleShooting::fixed_timestep
          struct /* fixed_timestep */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:278
            const char* doc = R"""()""";

          } fixed_timestep;

          // drake::systems::trajectory_optimization::MultipleShooting::h_vars
          struct /* h_vars */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:324
            const char* doc = R"""()""";

          } h_vars;

          // drake::systems::trajectory_optimization::MultipleShooting::initial_state
          struct /* initial_state */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:93
            const char* doc =
R"""(Returns the decision variables associated with the state, x, at the
initial time index.)""";

          } initial_state;

          // drake::systems::trajectory_optimization::MultipleShooting::input
          struct /* input */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:79
            const char* doc =
R"""(Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
input, u, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:107
            const char* doc_2 =
R"""(Returns the decision variables associated with the input, u, at time
index ``index``.)""";

          } input;

          // drake::systems::trajectory_optimization::MultipleShooting::num_inputs
          struct /* num_inputs */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:314
            const char* doc = R"""()""";

          } num_inputs;

          // drake::systems::trajectory_optimization::MultipleShooting::num_states
          struct /* num_states */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:316
            const char* doc = R"""()""";

          } num_states;

          // drake::systems::trajectory_optimization::MultipleShooting::state
          struct /* state */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:69
            const char* doc =
R"""(Returns placeholder decision variables (not actually declared as
decision variables in the MathematicalProgram) associated with the
state, x, but with the time-index undetermined. These variables will
be substituted for real decision variables at particular times in
methods like AddRunningCost. Passing these variables directly into
objectives/constraints for the parent classes will result in an error.)""";

            // drake/systems/trajectory_optimization/multiple_shooting.h:85
            const char* doc_2 =
R"""(Returns the decision variables associated with the state, x, at time
index ``index``.)""";

          } state;

          // drake::systems::trajectory_optimization::MultipleShooting::time
          struct /* time */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:59
            const char* doc =
R"""(Returns a placeholder decision variable (not actually declared as a
decision variable in the MathematicalProgram) associated with the
time, t. This variable will be substituted for real decision variables
at particular times in methods like AddRunningCost. Passing this
variable directly into objectives/constraints for the parent classes
will result in an error.)""";

          } time;

          // drake::systems::trajectory_optimization::MultipleShooting::timestep
          struct /* timestep */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:47
            const char* doc =
R"""(Returns the decision variable associated with the timestep, h, at time
index ``index``.

Throws:
    s std::runtime_error if timesteps are not declared as decision
    variables.)""";

          } timestep;

          // drake::systems::trajectory_optimization::MultipleShooting::timesteps_are_decision_variables
          struct /* timesteps_are_decision_variables */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:320
            const char* doc = R"""()""";

          } timesteps_are_decision_variables;

          // drake::systems::trajectory_optimization::MultipleShooting::u_vars
          struct /* u_vars */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:326
            const char* doc = R"""()""";

          } u_vars;

          // drake::systems::trajectory_optimization::MultipleShooting::x_vars
          struct /* x_vars */ {

            // drake/systems/trajectory_optimization/multiple_shooting.h:328
            const char* doc = R"""()""";

          } x_vars;

        } MultipleShooting;

        // drake::systems::trajectory_optimization::PositionConstraintForceEvaluator
        struct /* PositionConstraintForceEvaluator */ {

          // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:16
          const char* doc =
R"""(Evaluates the generalized constraint force from
RigidBodyTree::positionConstraint. For example, loop joint constraint
is a position constraint.)""";

          // drake::systems::trajectory_optimization::PositionConstraintForceEvaluator::EvalConstraintJacobian
          struct /* EvalConstraintJacobian */ {

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:39
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:42
            const char* doc_2 = R"""()""";

          } EvalConstraintJacobian;

          // drake::systems::trajectory_optimization::PositionConstraintForceEvaluator::PositionConstraintForceEvaluator
          struct /* ctor */ {

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:19
            const char* doc = R"""()""";

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:19
            const char* doc_2 = R"""()""";

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:27
            const char* doc_3 =
R"""(Constructor.

Parameter ``tree``:
    The tree on which the position constraint force is evaluated.

Parameter ``kinematics_cache_helper``:
    . The helper class to update the kinematics cache. The kinematics
    cache is useful when computing the Jacobian of the position
    constraint.)""";

          } ctor;

          // drake::systems::trajectory_optimization::PositionConstraintForceEvaluator::generalized_positions_size
          struct /* generalized_positions_size */ {

            // drake/systems/trajectory_optimization/position_constraint_force_evaluator.h:36
            const char* doc =
R"""(The size of the generalized position vector to evaluate the position
constraint Jacobian.)""";

          } generalized_positions_size;

        } PositionConstraintForceEvaluator;

      } trajectory_optimization;

      // value_detail
      struct /* value_detail */ {

        // drake::systems::value_detail::ValueTraitsImpl
        struct /* ValueTraitsImpl */ {

          // drake/systems/framework/value.h:30
          const char* doc = R"""()""";

        } ValueTraitsImpl;

      } value_detail;

    } systems;

    // drake::temp_directory
    struct /* temp_directory */ {

      // drake/common/temp_directory.h:15
      const char* doc =
R"""(Returns a directory location suitable for temporary files.

Returns:
    The value of the environment variable TEST_TMPDIR if defined or
    otherwise ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX where each
    X is replaced by a character from the portable filename character
    set. Any trailing / will be stripped from the output.

Throws:
    s std::runtime_error If the path referred to by TEST_TMPDIR or
    ${TMPDIR:-/tmp}/robotlocomotion_drake_XXXXXX cannot be created,
    does not exist, or is not a directory.)""";

    } temp_directory;

    // trajectories
    struct /* trajectories */ {

      // drake::trajectories::ExponentialPlusPiecewisePolynomial
      struct /* ExponentialPlusPiecewisePolynomial */ {

        // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:20
        const char* doc =
R"""(y(t) = K * exp(A * (t - t_j)) * alpha.col(j) +
piecewise_polynomial_part(t))""";

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::Clone
        struct /* Clone */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:55
          const char* doc = R"""()""";

        } Clone;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:24
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::ExponentialPlusPiecewisePolynomial<T>
        struct /* ctor */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:24
          const char* doc = R"""()""";

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:24
          const char* doc_2 = R"""()""";

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:26
          const char* doc_3 = R"""()""";

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:29
          const char* doc_4 = R"""()""";

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:50
          const char* doc_5 = R"""()""";

        } ctor;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::MakeDerivative
        struct /* MakeDerivative */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:61
          const char* doc = R"""()""";

        } MakeDerivative;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::cols
        struct /* cols */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:68
          const char* doc = R"""()""";

        } cols;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::derivative
        struct /* derivative */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:59
          const char* doc = R"""()""";

        } derivative;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::rows
        struct /* rows */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:66
          const char* doc = R"""()""";

        } rows;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::shiftRight
        struct /* shiftRight */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:70
          const char* doc = R"""()""";

        } shiftRight;

        // drake::trajectories::ExponentialPlusPiecewisePolynomial::value
        struct /* value */ {

          // drake/common/trajectories/exponential_plus_piecewise_polynomial.h:57
          const char* doc = R"""()""";

        } value;

      } ExponentialPlusPiecewisePolynomial;

      // drake::trajectories::PiecewisePolynomial
      struct /* PiecewisePolynomial */ {

        // drake/common/trajectories/piecewise_polynomial.h:47
        const char* doc =
R"""(A scalar multi-variate piecewise polynomial.

PiecewisePolynomial represents a list of contiguous segments in time
with a Matrix of Polynomials defined for each segment. The term
segment is used for piece.

An example of a piecewise polynomial is a function of x segments in
time, where for each segment a different polynomial is defined. For a
more specific example, consider the absolute value function, which is
a piecewise function. It uses one function for inputs values < 0, and
another function for input values > 0:

```
int abs(int x)
{
  if (x<0) {
    return -x;
  }
  else return x;
}
```

PiecewisePolynomials can be added, subtracted, and multiplied. They
cannot be divided because Polynomials are not closed under division.

Template parameter ``T``:
    is a scalar type. Explicit instantiations are provided for: -
    double)""";

        // drake::trajectories::PiecewisePolynomial::Clone
        struct /* Clone */ {

          // drake/common/trajectories/piecewise_polynomial.h:78
          const char* doc = R"""()""";

        } Clone;

        // drake::trajectories::PiecewisePolynomial::ConcatenateInTime
        struct /* ConcatenateInTime */ {

          // drake/common/trajectories/piecewise_polynomial.h:429
          const char* doc =
R"""(Concatenates ``other`` at the end, yielding a continuous trajectory
from current start_time() to ``other`` end_time().

Parameter ``other``:
    PiecewisePolynomial instance to concatenate.

Throws:
    std::runtime_error if trajectories' dimensions do not match each
    other (either rows() or cols() does not match between this and
    ``other``).

Throws:
    std::runtime_error if this end_time() and ``other`` start_time()
    are not within PiecewiseTrajectory<T>::kEpsilonTime from each
    other.)""";

        } ConcatenateInTime;

        // drake::trajectories::PiecewisePolynomial::Cubic
        struct /* Cubic */ {

          // drake/common/trajectories/piecewise_polynomial.h:201
          const char* doc =
R"""(Constructs a third order PiecewisePolynomial from `breaks` and
`knots`. The PiecewisePolynomial is constructed such that the interior
segments have the same value, first and second derivatives at
`breaks`. `knot_dot_at_start` and `knot_dot_at_end` are used for the
first and last first derivatives.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `knots` has
    inconsistent dimensions, `knots_dot_at_start` or `knot_dot_at_end`
    and `knots` have inconsistent dimensions, `breaks` has length
    smaller than 2.)""";

          // drake/common/trajectories/piecewise_polynomial.h:215
          const char* doc_2 =
R"""(Eigen version of Cubic(breaks, knots, knots_dot_start, knots_dot_end)
where each column of knots is used as a knot point, and knots.cols()
== breaks.size().

@overloads PiecewisePolynomial<T> Cubic(breaks, knots,
knots_dot_start, knots_dot_end))""";

          // drake/common/trajectories/piecewise_polynomial.h:235
          const char* doc_3 =
R"""(Constructs a third order PiecewisePolynomial from `breaks`, `knots`
and `knots`dot. Each segment is fully specified by @knots and
@knot_dot at both ends. Second derivatives are not continuous.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `breaks` and
    `knots`dot have different length, `knots` has inconsistent
    dimensions, `knots_dot` and `knots` have inconsistent dimensions,
    `breaks` has length smaller than 2.)""";

          // drake/common/trajectories/piecewise_polynomial.h:247
          const char* doc_4 =
R"""(Eigen version of Cubic(breaks, knots, knots_dot) where each column of
knots and knots_dot are used as the knot point/derivative.
knots.cols() == knots_dot.cols() == breaks.size().

@overloads PiecewisePolynomial<T> Cubic(breaks, knots, knots_dot))""";

          // drake/common/trajectories/piecewise_polynomial.h:284
          const char* doc_5 =
R"""(Constructs a third order PiecewisePolynomial from `breaks` and
`knots`. The PiecewisePolynomial is constructed such that the interior
segments have the same value, first and second derivatives at
`breaks`. If `periodic_end_condition` is `false` (default), then the
"Not-a-knot" end condition is used here, which means the third
derivatives are continuous for the first two and last two segments. If
`periodic_end_condition` is `true`, then the first and second
derivatives between the end of the last segment and the beginning of
the first segment will be continuous. Note that the periodic end
condition does not require the first and last knot to be collocated,
nor does it add an additional knot to connect the first and last
segments. Only first and second derivative continuity is enforced. See
https://en.wikipedia.org/wiki/Spline_interpolation,
https://www.math.uh.edu/~jingqiu/math4364/spline.pdf, and
http://www.maths.lth.se/na/courses/FMN081/FMN081-06/lecture11.pdf for
more about cubic splines and their end conditions. The MATLAB files
"spline.m" and "csape.m" are also good references.

``breaks`` and ``knots`` must have at least 3 elements. The "not-a-
knot" condition is ill-defined for two knots, and the "periodic"
condition would produce a straight line (use `FirstOrderHold` for this
instead).

Parameter ``periodic_end_condition``:
    Determines whether the "not-a-knot" (`false`) or the periodic
    spline (`true`) end condition is used.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `knots` has
    inconsistent dimensions, `breaks` has length smaller than 3.)""";

          // drake/common/trajectories/piecewise_polynomial.h:295
          const char* doc_6 =
R"""(Eigen version of Cubic(breaks, knots) where each column of knots is
used as a knot point and knots.cols() == breaks.size().

@overloads PiecewisePolynomial<T> Cubic(breaks, knots))""";

        } Cubic;

        // drake::trajectories::PiecewisePolynomial::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/common/trajectories/piecewise_polynomial.h:50
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::trajectories::PiecewisePolynomial::FirstOrderHold
        struct /* FirstOrderHold */ {

          // drake/common/trajectories/piecewise_polynomial.h:116
          const char* doc =
R"""(Constructs a piecewise linear PiecewisePolynomial.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `knots` has
    inconsistent dimensions, `breaks` has length smaller than 2.)""";

          // drake/common/trajectories/piecewise_polynomial.h:127
          const char* doc_2 =
R"""(Eigen version of FirstOrderHold(breaks, knots) where each column of
knots is used as a knot point, and knots.cols() == breaks.size().

@overloads PiecewisePolynomial<T> FirstOrderHold(breaks, knots))""";

        } FirstOrderHold;

        // drake::trajectories::PiecewisePolynomial::MakeDerivative
        struct /* MakeDerivative */ {

          // drake/common/trajectories/piecewise_polynomial.h:314
          const char* doc = R"""()""";

        } MakeDerivative;

        // drake::trajectories::PiecewisePolynomial::Pchip
        struct /* Pchip */ {

          // drake/common/trajectories/piecewise_polynomial.h:167
          const char* doc =
R"""(Constructs a third order PiecewisePolynomial from `breaks` and
`knots`. First derivatives are chosen to be "shape preserving", i.e.
if `knots` is monotonic within some interval, the interpolated data
will also be monotonic. The second derivative is not guaranteed to be
smooth across the entire spline.

Pchip stands for "Piecewise Cubic Hermite Interpolating Polynomial".
For more details, refer to the matlab file "pchip.m".
http://home.uchicago.edu/~sctchoi/courses/cs138/interp.pdf is also a
good reference.

If ``zero_end_point_derivatives`` is false, the first and last first
derivative is chosen using a non-centered, shape-preserving three-
point formulae. See equation (2.10) in the following reference for
more details. http://www.mi.sanu.ac.rs/~gvm/radovi/mon.pdf If
``zero_end_point_derivatives`` is true, they are set to zeros.

If ``zero_end_point_derivatives`` is false, ``breaks`` and ``knots``
must have at least 3 elements for the algorithm to determine the first
derivatives.

If ``zero_end_point_derivatives`` is true, ``breaks`` and ``knots``
may have 2 or more elements. For the 2 elements case, the result is
equivalent to computing a cubic polynomial whose values are given by
``knots``, and derivatives set to zero.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `knots` has
    inconsistent dimensions, `breaks` has length smaller than 3 and
    zero_end_point_derivatives is false, `breaks` has length smaller
    than 2 and zero_end_point_derivatives is true.)""";

          // drake/common/trajectories/piecewise_polynomial.h:180
          const char* doc_2 =
R"""(Eigen version of Pchip(breaks, knots, zero_end_point_derivatives)
where each column of knots is used as a knot point, and knots.cols()
== breaks.size().

@overloads PiecewisePolynomial<T> Pchip(breaks, knots,
zero_end_point_derivatives))""";

        } Pchip;

        // drake::trajectories::PiecewisePolynomial::PiecewisePolynomial<T>
        struct /* ctor */ {

          // drake/common/trajectories/piecewise_polynomial.h:50
          const char* doc = R"""()""";

          // drake/common/trajectories/piecewise_polynomial.h:50
          const char* doc_2 = R"""()""";

          // drake/common/trajectories/piecewise_polynomial.h:58
          const char* doc_3 = R"""()""";

          // drake/common/trajectories/piecewise_polynomial.h:62
          const char* doc_4 = R"""()""";

          // drake/common/trajectories/piecewise_polynomial.h:69
          const char* doc_5 = R"""()""";

          // drake/common/trajectories/piecewise_polynomial.h:73
          const char* doc_6 = R"""()""";

        } ctor;

        // drake::trajectories::PiecewisePolynomial::ZeroOrderHold
        struct /* ZeroOrderHold */ {

          // drake/common/trajectories/piecewise_polynomial.h:92
          const char* doc =
R"""(Constructs a piecewise constant PiecewisePolynomial. Note that
constructing a PiecewisePolynomial requires at least two knot points,
although in this case, the second knot point's value is ignored, and
only its break time is used.

Throws:
    s std::runtime_error if `breaks` and `knots` have different
    length, `breaks` is not strictly increasing, `knots` has
    inconsistent dimensions, `breaks` has length smaller than 2.)""";

          // drake/common/trajectories/piecewise_polynomial.h:103
          const char* doc_2 =
R"""(Eigen version of ZeroOrderHold(breaks, knots) where each column of
knots is used as a knot point, and knots.cols() == breaks.size().

@overloads PiecewisePolynomial<T> ZeroOrderHold(breaks, knots))""";

        } ZeroOrderHold;

        // drake::trajectories::PiecewisePolynomial::cols
        struct /* cols */ {

          // drake/common/trajectories/piecewise_polynomial.h:369
          const char* doc =
R"""(Returns the column count of each and every PolynomialMatrix segment.)""";

        } cols;

        // drake::trajectories::PiecewisePolynomial::derivative
        struct /* derivative */ {

          // drake/common/trajectories/piecewise_polynomial.h:312
          const char* doc =
R"""(Takes the derivative of this PiecewisePolynomial.

Returns a PiecewisePolynomial where each segment is the derivative of
the segment in the input PiecewisePolynomial. Any rules or limitations
of Polynomial::derivative also apply to this function.

If `derivative_order` is given, takes the nth derivative of this
PiecewisePolynomial.)""";

        } derivative;

        // drake::trajectories::PiecewisePolynomial::empty
        struct /* empty */ {

          // drake/common/trajectories/piecewise_polynomial.h:344
          const char* doc = R"""()""";

        } empty;

        // drake::trajectories::PiecewisePolynomial::getPolynomial
        struct /* getPolynomial */ {

          // drake/common/trajectories/piecewise_polynomial.h:359
          const char* doc = R"""()""";

        } getPolynomial;

        // drake::trajectories::PiecewisePolynomial::getPolynomialMatrix
        struct /* getPolynomialMatrix */ {

          // drake/common/trajectories/piecewise_polynomial.h:357
          const char* doc = R"""()""";

        } getPolynomialMatrix;

        // drake::trajectories::PiecewisePolynomial::getSegmentPolynomialDegree
        struct /* getSegmentPolynomialDegree */ {

          // drake/common/trajectories/piecewise_polynomial.h:362
          const char* doc = R"""()""";

        } getSegmentPolynomialDegree;

        // drake::trajectories::PiecewisePolynomial::integral
        struct /* integral */ {

          // drake/common/trajectories/piecewise_polynomial.h:329
          const char* doc =
R"""(Takes the integral of this PiecewisePolynomial.

Returns a PiecewisePolynomial that is the indefinite integral of this
one. Any rules or limitations of Polynomial::integral also apply to
this function.

If `value_at_start_time` is given, it does the following only for the
first segment: adds that constant as the constant term (zeroth-order
coefficient) of the resulting Polynomial.)""";

          // drake/common/trajectories/piecewise_polynomial.h:341
          const char* doc_2 =
R"""(Takes the integral of this PiecewisePolynomial.

Returns a PiecewisePolynomial that is the indefinite integral of this
one. Any rules or limitations of Polynomial::integral also apply to
this function.

If `value_at_start_time` is given, it does the following only for the
first segment: adds value_at_start_time(row,col) as the constant term
(zeroth-order coefficient) of the resulting Polynomial.)""";

        } integral;

        // drake::trajectories::PiecewisePolynomial::isApprox
        struct /* isApprox */ {

          // drake/common/trajectories/piecewise_polynomial.h:417
          const char* doc =
R"""(Checks if a PiecewisePolynomial is approximately equal to this one.

Checks that every coefficient of `other` is within `tol` of the
corresponding coefficient of this PiecewisePolynomial. Throws an
exception if any Polynomial in either PiecewisePolynomial is not
univariate.)""";

        } isApprox;

        // drake::trajectories::PiecewisePolynomial::operator*
        struct /* operator_mul */ {

          // drake/common/trajectories/piecewise_polynomial.h:401
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_mul;

        // drake::trajectories::PiecewisePolynomial::operator*=
        struct /* operator_imul */ {

          // drake/common/trajectories/piecewise_polynomial.h:381
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_imul;

        // drake::trajectories::PiecewisePolynomial::operator+
        struct /* operator_add */ {

          // drake/common/trajectories/piecewise_polynomial.h:393
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

          // drake/common/trajectories/piecewise_polynomial.h:405
          const char* doc_2 =
R"""(Throws:
    s std::runtime_error if offset.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_add;

        // drake::trajectories::PiecewisePolynomial::operator+=
        struct /* operator_iadd */ {

          // drake/common/trajectories/piecewise_polynomial.h:373
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

          // drake/common/trajectories/piecewise_polynomial.h:385
          const char* doc_2 =
R"""(Throws:
    s std::runtime_error if offset.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_iadd;

        // drake::trajectories::PiecewisePolynomial::operator-
        struct /* operator_sub */ {

          // drake/common/trajectories/piecewise_polynomial.h:397
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

          // drake/common/trajectories/piecewise_polynomial.h:409
          const char* doc_2 =
R"""(Throws:
    s std::runtime_error if offset.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_sub;

        // drake::trajectories::PiecewisePolynomial::operator-=
        struct /* operator_isub */ {

          // drake/common/trajectories/piecewise_polynomial.h:377
          const char* doc =
R"""(Throws:
    s std::runtime_error if other.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

          // drake/common/trajectories/piecewise_polynomial.h:389
          const char* doc_2 =
R"""(Throws:
    s std::runtime_error if offset.segment_times is not within
    PiecewiseFunction::kEpsilonTime from this->segment_times.)""";

        } operator_isub;

        // drake::trajectories::PiecewisePolynomial::rows
        struct /* rows */ {

          // drake/common/trajectories/piecewise_polynomial.h:366
          const char* doc =
R"""(Returns the row count of each and every PolynomialMatrix segment.)""";

        } rows;

        // drake::trajectories::PiecewisePolynomial::scalarValue
        struct /* scalarValue */ {

          // drake/common/trajectories/piecewise_polynomial.h:346
          const char* doc = R"""()""";

        } scalarValue;

        // drake::trajectories::PiecewisePolynomial::setPolynomialMatrixBlock
        struct /* setPolynomialMatrixBlock */ {

          // drake/common/trajectories/piecewise_polynomial.h:433
          const char* doc = R"""()""";

        } setPolynomialMatrixBlock;

        // drake::trajectories::PiecewisePolynomial::shiftRight
        struct /* shiftRight */ {

          // drake/common/trajectories/piecewise_polynomial.h:431
          const char* doc = R"""()""";

        } shiftRight;

        // drake::trajectories::PiecewisePolynomial::slice
        struct /* slice */ {

          // drake/common/trajectories/piecewise_polynomial.h:437
          const char* doc = R"""()""";

        } slice;

        // drake::trajectories::PiecewisePolynomial::value
        struct /* value */ {

          // drake/common/trajectories/piecewise_polynomial.h:355
          const char* doc =
R"""(Evaluates the PiecewisePolynomial at the given time ``t``.

Parameter ``t``:
    The time at which to evaluate the PiecewisePolynomial.

Returns:
    The matrix of evaluated values.)""";

        } value;

      } PiecewisePolynomial;

      // drake::trajectories::PiecewiseQuaternionSlerp
      struct /* PiecewiseQuaternionSlerp */ {

        // drake/common/trajectories/piecewise_quaternion.h:33
        const char* doc =
R"""(A class representing a trajectory for quaternions that are
interpolated using piecewise slerp (spherical linear interpolation).
All the orientation knots are expected to be with respect to the same
parent reference frame, i.e. q_i represents the rotation R_PBi for the
orientation of frame B at the ith knot in a fixed parent frame P. The
world frame is a common choice for the parent frame. The angular
velocity and acceleration are also relative to the parent frame and
expressed in the parent frame. Since there is a sign ambiguity when
using quaternions to represent orientation, namely q and -q represent
the same orientation, the internal quaternion representations ensure
that q_n.dot(q_{n+1}) >= 0. Another intuitive way to think about this
is that consecutive quaternions have the shortest geodesic distance on
the unit sphere.

Template parameter ``T``:
    , double.)""";

        // drake::trajectories::PiecewiseQuaternionSlerp::Clone
        struct /* Clone */ {

          // drake/common/trajectories/piecewise_quaternion.h:71
          const char* doc = R"""()""";

        } Clone;

        // drake::trajectories::PiecewiseQuaternionSlerp::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/common/trajectories/piecewise_quaternion.h:35
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::trajectories::PiecewiseQuaternionSlerp::MakeDerivative
        struct /* MakeDerivative */ {

          // drake/common/trajectories/piecewise_quaternion.h:98
          const char* doc =
R"""(Throws:
    s std::runtime_error (always) because it is not implemented yet.)""";

        } MakeDerivative;

        // drake::trajectories::PiecewiseQuaternionSlerp::PiecewiseQuaternionSlerp<T>
        struct /* ctor */ {

          // drake/common/trajectories/piecewise_quaternion.h:35
          const char* doc = R"""()""";

          // drake/common/trajectories/piecewise_quaternion.h:35
          const char* doc_2 = R"""()""";

          // drake/common/trajectories/piecewise_quaternion.h:40
          const char* doc_3 =
R"""(Builds an empty PiecewiseQuaternionSlerp.)""";

          // drake/common/trajectories/piecewise_quaternion.h:47
          const char* doc_4 =
R"""(Builds a PiecewiseQuaternionSlerp.

Throws:
    s std::logic_error if breaks and quaternions have different
    length, or breaks have length < 2.)""";

          // drake/common/trajectories/piecewise_quaternion.h:56
          const char* doc_5 =
R"""(Builds a PiecewiseQuaternionSlerp.

Throws:
    s std::logic_error if breaks and rot_matrices have different
    length, or breaks have length < 2.)""";

          // drake/common/trajectories/piecewise_quaternion.h:65
          const char* doc_6 =
R"""(Builds a PiecewiseQuaternionSlerp.

Throws:
    s std::logic_error if breaks and ang_axes have different length,
    or breaks have length < 2.)""";

        } ctor;

        // drake::trajectories::PiecewiseQuaternionSlerp::angular_acceleration
        struct /* angular_acceleration */ {

          // drake/common/trajectories/piecewise_quaternion.h:107
          const char* doc =
R"""(Interpolates angular acceleration.

Parameter ``t``:
    Time for interpolation.

Returns:
    The interpolated angular acceleration at `t`, which is always zero
    for slerp.)""";

        } angular_acceleration;

        // drake::trajectories::PiecewiseQuaternionSlerp::angular_velocity
        struct /* angular_velocity */ {

          // drake/common/trajectories/piecewise_quaternion.h:92
          const char* doc =
R"""(Interpolates angular velocity.

Parameter ``t``:
    Time for interpolation.

Returns:
    The interpolated angular velocity at `t`, which is constant per
    segment.)""";

        } angular_velocity;

        // drake::trajectories::PiecewiseQuaternionSlerp::cols
        struct /* cols */ {

          // drake/common/trajectories/piecewise_quaternion.h:75
          const char* doc = R"""()""";

        } cols;

        // drake::trajectories::PiecewiseQuaternionSlerp::get_quaternion_knots
        struct /* get_quaternion_knots */ {

          // drake/common/trajectories/piecewise_quaternion.h:117
          const char* doc =
R"""(Getter for the internal quaternion knots. Note: the returned
quaternions might be different from the ones used for construction
because the internal representations are set to always be the
"closest" w.r.t to the previous one.

Returns:
    the internal knot points.)""";

        } get_quaternion_knots;

        // drake::trajectories::PiecewiseQuaternionSlerp::is_approx
        struct /* is_approx */ {

          // drake/common/trajectories/piecewise_quaternion.h:126
          const char* doc =
R"""(Returns true if all the corresponding segment times are within ``tol``
seconds, and the angle difference between the corresponding quaternion
knot points are within ``tol``.)""";

        } is_approx;

        // drake::trajectories::PiecewiseQuaternionSlerp::orientation
        struct /* orientation */ {

          // drake/common/trajectories/piecewise_quaternion.h:82
          const char* doc =
R"""(Interpolates orientation.

Parameter ``t``:
    Time for interpolation.

Returns:
    The interpolated quaternion at `t`.)""";

        } orientation;

        // drake::trajectories::PiecewiseQuaternionSlerp::rows
        struct /* rows */ {

          // drake/common/trajectories/piecewise_quaternion.h:73
          const char* doc = R"""()""";

        } rows;

        // drake::trajectories::PiecewiseQuaternionSlerp::value
        struct /* value */ {

          // drake/common/trajectories/piecewise_quaternion.h:84
          const char* doc = R"""()""";

        } value;

      } PiecewiseQuaternionSlerp;

      // drake::trajectories::PiecewiseTrajectory
      struct /* PiecewiseTrajectory */ {

        // drake/common/trajectories/piecewise_trajectory.h:21
        const char* doc =
R"""(Abstract class that implements the basic logic of maintaining
consequent segments of time (delimited by `breaks`) to implement a
trajectory that is represented by simpler logic in each segment or
"piece".

Template parameter ``T``:
    is the scalar type. Explicit instantions are provided for - double)""";

        // drake::trajectories::PiecewiseTrajectory::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/common/trajectories/piecewise_trajectory.h:57
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::trajectories::PiecewiseTrajectory::PiecewiseTrajectory<T>
        struct /* ctor */ {

          // drake/common/trajectories/piecewise_trajectory.h:57
          const char* doc = R"""()""";

          // drake/common/trajectories/piecewise_trajectory.h:57
          const char* doc_2 = R"""()""";

          // drake/common/trajectories/piecewise_trajectory.h:58
          const char* doc_3 = R"""()""";

          // drake/common/trajectories/piecewise_trajectory.h:61
          const char* doc_4 =
R"""(``breaks`` increments must be greater or equal to kEpsilonTime.)""";

        } ctor;

        // drake::trajectories::PiecewiseTrajectory::RandomSegmentTimes
        struct /* RandomSegmentTimes */ {

          // drake/common/trajectories/piecewise_trajectory.h:51
          const char* doc = R"""()""";

        } RandomSegmentTimes;

        // drake::trajectories::PiecewiseTrajectory::SegmentTimesEqual
        struct /* SegmentTimesEqual */ {

          // drake/common/trajectories/piecewise_trajectory.h:63
          const char* doc = R"""()""";

        } SegmentTimesEqual;

        // drake::trajectories::PiecewiseTrajectory::breaks
        struct /* breaks */ {

          // drake/common/trajectories/piecewise_trajectory.h:66
          const char* doc = R"""()""";

        } breaks;

        // drake::trajectories::PiecewiseTrajectory::duration
        struct /* duration */ {

          // drake/common/trajectories/piecewise_trajectory.h:34
          const char* doc = R"""()""";

        } duration;

        // drake::trajectories::PiecewiseTrajectory::end_time
        struct /* end_time */ {

          // drake/common/trajectories/piecewise_trajectory.h:32
          const char* doc = R"""()""";

          // drake/common/trajectories/piecewise_trajectory.h:38
          const char* doc_2 = R"""()""";

        } end_time;

        // drake::trajectories::PiecewiseTrajectory::get_mutable_breaks
        struct /* get_mutable_breaks */ {

          // drake/common/trajectories/piecewise_trajectory.h:67
          const char* doc = R"""()""";

        } get_mutable_breaks;

        // drake::trajectories::PiecewiseTrajectory::get_number_of_segments
        struct /* get_number_of_segments */ {

          // drake/common/trajectories/piecewise_trajectory.h:28
          const char* doc = R"""()""";

        } get_number_of_segments;

        // drake::trajectories::PiecewiseTrajectory::get_segment_index
        struct /* get_segment_index */ {

          // drake/common/trajectories/piecewise_trajectory.h:45
          const char* doc = R"""()""";

        } get_segment_index;

        // drake::trajectories::PiecewiseTrajectory::get_segment_times
        struct /* get_segment_times */ {

          // drake/common/trajectories/piecewise_trajectory.h:47
          const char* doc = R"""()""";

        } get_segment_times;

        // drake::trajectories::PiecewiseTrajectory::is_time_in_range
        struct /* is_time_in_range */ {

          // drake/common/trajectories/piecewise_trajectory.h:43
          const char* doc =
R"""(Returns true iff `t >= getStartTime() && t <= getEndTime()`.)""";

        } is_time_in_range;

        // drake::trajectories::PiecewiseTrajectory::segment_number_range_check
        struct /* segment_number_range_check */ {

          // drake/common/trajectories/piecewise_trajectory.h:49
          const char* doc = R"""()""";

        } segment_number_range_check;

        // drake::trajectories::PiecewiseTrajectory::start_time
        struct /* start_time */ {

          // drake/common/trajectories/piecewise_trajectory.h:30
          const char* doc = R"""()""";

          // drake/common/trajectories/piecewise_trajectory.h:36
          const char* doc_2 = R"""()""";

        } start_time;

      } PiecewiseTrajectory;

      // drake::trajectories::Trajectory
      struct /* Trajectory */ {

        // drake/common/trajectories/trajectory.h:20
        const char* doc =
R"""(A Trajectory represents a time-varying matrix, indexed by a single
scalar double time.

Template parameter ``T``:
    is a Scalar type for the data that is returned.)""";

        // drake::trajectories::Trajectory::Clone
        struct /* Clone */ {

          // drake/common/trajectories/trajectory.h:27
          const char* doc =
R"""(Returns:
    A deep copy of this Trajectory.)""";

        } Clone;

        // drake::trajectories::Trajectory::DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE
        struct /* DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE */ {

          // drake/common/trajectories/trajectory.h:61
          const char* doc = R"""()""";

        } DRAKE_COPYABLE_DEMAND_COPY_CAN_COMPILE;

        // drake::trajectories::Trajectory::MakeDerivative
        struct /* MakeDerivative */ {

          // drake/common/trajectories/trajectory.h:42
          const char* doc =
R"""(Takes the derivative of this Trajectory.

Parameter ``derivative_order``:
    The number of times to take the derivative before returning.

Returns:
    The nth derivative of this object.)""";

        } MakeDerivative;

        // drake::trajectories::Trajectory::Trajectory<T>
        struct /* ctor */ {

          // drake/common/trajectories/trajectory.h:61
          const char* doc = R"""()""";

          // drake/common/trajectories/trajectory.h:61
          const char* doc_2 = R"""()""";

          // drake/common/trajectories/trajectory.h:62
          const char* doc_3 = R"""()""";

        } ctor;

        // drake::trajectories::Trajectory::cols
        struct /* cols */ {

          // drake/common/trajectories/trajectory.h:53
          const char* doc =
R"""(Returns:
    The number of columns in the matrix returned by value().)""";

        } cols;

        // drake::trajectories::Trajectory::end_time
        struct /* end_time */ {

          // drake/common/trajectories/trajectory.h:57
          const char* doc = R"""()""";

        } end_time;

        // drake::trajectories::Trajectory::rows
        struct /* rows */ {

          // drake/common/trajectories/trajectory.h:48
          const char* doc =
R"""(Returns:
    The number of rows in the matrix returned by value().)""";

        } rows;

        // drake::trajectories::Trajectory::start_time
        struct /* start_time */ {

          // drake/common/trajectories/trajectory.h:55
          const char* doc = R"""()""";

        } start_time;

        // drake::trajectories::Trajectory::value
        struct /* value */ {

          // drake/common/trajectories/trajectory.h:34
          const char* doc =
R"""(Evaluates the trajectory at the given time ``t``.

Parameter ``t``:
    The time at which to evaluate the trajectory.

Returns:
    The matrix of evaluated values.)""";

        } value;

      } Trajectory;

    } trajectories;

    // drake::uhash
    struct /* uhash */ {

      // drake/common/hash.h:202
      const char* doc =
R"""(A hashing functor, somewhat like `std::hash`. Given an item of type
``T``, applies hash_append to it, directing the bytes to append into
the given ``HashAlgorithm``, and then finally returning the
algorithm's result.)""";

      // drake::uhash::operator()
      struct /* operator_call */ {

        // drake/common/hash.h:206
        const char* doc = R"""()""";

      } operator_call;

    } uhash;

  } drake;

  // encodePiecewisePolynomial
  struct /* encodePiecewisePolynomial */ {

    // drake/systems/controllers/polynomial_encode_decode.h:49
    const char* doc = R"""()""";

  } encodePiecewisePolynomial;

  // encodePolynomial
  struct /* encodePolynomial */ {

    // drake/systems/controllers/polynomial_encode_decode.h:10
    const char* doc = R"""()""";

  } encodePolynomial;

  // encodePolynomialMatrix
  struct /* encodePolynomialMatrix */ {

    // drake/systems/controllers/polynomial_encode_decode.h:18
    const char* doc = R"""()""";

  } encodePolynomialMatrix;

  // evaluateXYZExpmapCubicSpline
  struct /* evaluateXYZExpmapCubicSpline */ {

    // drake/systems/controllers/controlUtil.h:119
    const char* doc = R"""()""";

  } evaluateXYZExpmapCubicSpline;

  // expandDefaults
  struct /* expandDefaults */ {

    // drake/systems/controllers/yaml_util.h:15
    const char* doc = R"""()""";

  } expandDefaults;

  // get
  struct /* get */ {

    // drake/systems/controllers/yaml_util.h:20
    const char* doc = R"""()""";

  } get;

  // getActiveSupportMask
  struct /* getActiveSupportMask */ {

    // drake/systems/controllers/controlUtil.h:43
    const char* doc = R"""()""";

  } getActiveSupportMask;

  // getActiveSupports
  struct /* getActiveSupports */ {

    // drake/systems/controllers/controlUtil.h:52
    const char* doc = R"""()""";

  } getActiveSupports;

  // getCols
  struct /* getCols */ {

    // drake/systems/controllers/controlUtil.h:70
    const char* doc = R"""()""";

  } getCols;

  // getRobotJointIndexMap
  struct /* getRobotJointIndexMap */ {

    // drake/systems/controllers/controlUtil.h:137
    const char* doc = R"""()""";

  } getRobotJointIndexMap;

  // getRows
  struct /* getRows */ {

    // drake/systems/controllers/controlUtil.h:63
    const char* doc = R"""()""";

  } getRows;

  // inSupport
  struct /* inSupport */ {

    // drake/systems/controllers/controlUtil.h:82
    const char* doc = R"""()""";

  } inSupport;

  // individualSupportCOPs
  struct /* individualSupportCOPs */ {

    // drake/systems/controllers/controlUtil.h:106
    const char* doc = R"""()""";

  } individualSupportCOPs;

  // inverseKin
  struct /* inverseKin */ {

    // drake/multibody/rigid_body_ik.h:52
    const char* doc =
R"""(inverseKin solves the inverse kinematics problem min_q
(q-q_nom)'*Q*(q-q_nom) s.t lb<=constraint(q)<=ub

Parameter ``q_seed``:
    an nq x 1 double vector. The initial guess for the optimization
    problem

Parameter ``q_nom``:
    an nq x 1 double vector. The nominal posture that the robot wants
    to stay close to

Parameter ``num_constraints``:
    The number of RigidBodyConstraints

Parameter ``constraint_array``:
    Each entry in constraint_array is a RigidBodyConstraint type.
    Currently support QuasiStaticConstraintType,
    PostureConstraintType, SingleTimeKinematicConstraintType and
    SingleTimeLinearPostureConstraintType.

Returns:
    q_sol an nq x 1 double vector. The optimized posture

Returns:
    info = 1 The optimization is successful = 3 The optimization is
    successful. But optimality is not strictly satisfied = 4 The
    optimization is successful. But feasibility is not strictly
    satisfied = 5 The optimization is successful. But SNOPT runs out
    of iterations = 6 The optimization is successful. But SNOPT runs
    out of major iterations = 12 Fails to find a solution. The linear
    constraints are not satisfied = 13 Fails to find a solution. The
    nonlinear constraints are not satisfied = 31 Fails to find a
    solution. The iterations limit is reached. Set iterations limit in
    ikoptions = 32 Fails to find a solution. The major iterations
    limit is reached. Set major iterations limit in ikoptions = 41
    Fails to find a solution because the numerics of the problem is
    bad. for more information of these info, check SNOPT manual for
    reference www.stanford.edu/group/SOL/guides/sndoc7.pdf

Returns:
    infeasible_constraint. When the problem is infeasible,
    infeasible_constraint contains the name of the infeasible
    constraints

Parameter ``ikoptions``:
    The options to set parameters of IK problem.)""";

  } inverseKin;

  // inverseKinPointwise
  struct /* inverseKinPointwise */ {

    // drake/multibody/rigid_body_ik.h:135
    const char* doc =
R"""(inverseKinPointwise solves inverse kinematics problem at each t[i]
individually

Parameter ``nT``:
    The length of time samples

Parameter ``t``:
    t[i] is the i'th time to solve the inverse kinematics problem

Parameter ``q_seed``:
    An nq x nT double matrix. q_seed.col(i) is the seed for the
    inverse kinematics problem at t[i]

Parameter ``q_nom``:
    An nq x nT double matrix. q_nom.col(i) is the nominal posture for
    the inverse kinematics problem at t[i]

Parameter ``num_constraints``:
    Same as in inverseKin

Parameter ``constraint_array``:
    Same as in inverseKin

Returns:
    q_sol An nq x nT double matrix. q_sol.col(i) is the solution to
    inverse kinematics problem at t[i]

Returns:
    info info[i] is the info for the inverse kinematics problem at
    t[i]. The meaning of info[i] is explained in inverseKin

Returns:
    infeasible_constraint infeasible_constraint[i] are the names of
    infeasible constraints at t[i]

Parameter ``ikoptions``:
    The options to set parameters of IK problem. if
    ikoptions.sequentialSeedFlag = true, then the at time t[i], if
    t[i-1] is solved successfully, then q_sol.col(i-1) would be used
    as the seed for t[i]. If the solver fails to find a posture at
    t[i-1], then q_seed.col(i) would be used as the seed for t[i] if
    ikoptions.sequentialSeedFlag = false, then q_seed.col(i) would
    always be used as the seed at t[i])""";

  } inverseKinPointwise;

  // inverseKinPointwiseSimple
  struct /* inverseKinPointwiseSimple */ {

    // drake/multibody/rigid_body_ik.h:148
    const char* doc =
R"""(Simplified (non-template) version of inverseKinPointwise. Useful for
generating bindings to non-C++ languages.)""";

  } inverseKinPointwiseSimple;

  // inverseKinSimple
  struct /* inverseKinSimple */ {

    // drake/multibody/rigid_body_ik.h:75
    const char* doc =
R"""(Simplified (non-template) version of inverseKin. Useful for generating
bindings to non-C++ languages.)""";

  } inverseKinSimple;

  // inverseKinTraj
  struct /* inverseKinTraj */ {

    // drake/multibody/rigid_body_ik.h:187
    const char* doc =
R"""(inverseKinTraj solves the inverse kinematics problem at all time
together. Try to generate a smooth trajectory by assuming cubic spline
for the posture, and minimize the acceleration of the interpolated
trajectory min_(q, qdot, qddot) sum(q(t(i))-q_nom(t(i)))'*Q*(q(t(i))-q
_nom(t(i)))+qdot(t(i))'*Qv*qdot(t(i))+qddot(t(i))'*Qa*qddot(t(i))

Parameter ``nT``:
    The length of time samples

Parameter ``t``:
    t[i] is the i'th time

Parameter ``q_seed``:
    An nq x nT double matrix. q_seed.col(i) is the seed for the
    inverse kinematics problem at t[i]

Parameter ``q_nom``:
    An nq x nT double matrix. q_nom.col(i) is the seed for the inverse
    kinematics problem at t[i]

Parameter ``num_constraints``:
    The number of constraints

Parameter ``constraint_array``:
    Accept all categories of RigidBodyConstraint

Returns:
    q_sol An nq x nT double matrix. q_sol.col(i) is the solution
    posture at time t[i]

Returns:
    qdot_sol An nq x nT double matrix. qdot_sol.col(i) is the solution
    posture velocity at time t[i]

Returns:
    qddot_sol An nq x nT double matrix. qddot_sol.col(i) is the
    solution posture acceleration at time t[i]

Returns:
    info Same as in inverseKin

Returns:
    infeasible_constraint Same as in inverseKin

Returns:
    ikoptions Set parameters for inverse kinematics problem
    ikoptions.fixInitialState = True The initial posture and velocity
    at time t[0] will be fixed to the seed posture q_seed.col(0) and
    seed velocity qdot0_seed ikoptions.fixInitialState = False The
    solver will search for the initial posture and velocity)""";

  } inverseKinTraj;

  // inverseKinTrajSimple
  struct /* inverseKinTrajSimple */ {

    // drake/multibody/rigid_body_ik.h:204
    const char* doc =
R"""(Simplified (non-template) version of inverseKinTraj. Useful for
generating bindings to non-C++ languages.)""";

  } inverseKinTrajSimple;

  // isSupportElementActive
  struct /* isSupportElementActive */ {

    // drake/systems/controllers/controlUtil.h:38
    const char* doc = R"""()""";

  } isSupportElementActive;

  // loadAllParamSets
  struct /* loadAllParamSets */ {

    // drake/systems/controllers/yaml_util.h:25
    const char* doc = R"""()""";

    // drake/systems/controllers/yaml_util.h:27
    const char* doc_2 = R"""()""";

  } loadAllParamSets;

  // loadSingleParamSet
  struct /* loadSingleParamSet */ {

    // drake/systems/controllers/yaml_util.h:23
    const char* doc = R"""()""";

  } loadSingleParamSet;

  // originAttributesToTransform
  struct /* originAttributesToTransform */ {

    // drake/multibody/parsers/xml_util.h:158
    const char* doc = R"""()""";

  } originAttributesToTransform;

  // parseKinematicModifications
  struct /* parseKinematicModifications */ {

    // drake/systems/controllers/yaml_util.h:33
    const char* doc = R"""()""";

  } parseKinematicModifications;

  // parseKinematicTreeMetadata
  struct /* parseKinematicTreeMetadata */ {

    // drake/systems/controllers/yaml_util.h:31
    const char* doc = R"""()""";

  } parseKinematicTreeMetadata;

  // parseScalarAttribute
  struct /* parseScalarAttribute */ {

    // drake/multibody/parsers/xml_util.h:33
    const char* doc = R"""()""";

  } parseScalarAttribute;

  // parseScalarValue
  struct /* parseScalarValue */ {

    // drake/multibody/parsers/xml_util.h:13
    const char* doc = R"""()""";

    // drake/multibody/parsers/xml_util.h:24
    const char* doc_2 = R"""()""";

  } parseScalarValue;

  // parseStringValue
  struct /* parseStringValue */ {

    // drake/multibody/parsers/xml_util.h:152
    const char* doc = R"""()""";

  } parseStringValue;

  // parseVectorAttribute
  struct /* parseVectorAttribute */ {

    // drake/multibody/parsers/xml_util.h:132
    const char* doc = R"""()""";

    // drake/multibody/parsers/xml_util.h:137
    const char* doc_2 = R"""()""";

  } parseVectorAttribute;

  // parseVectorValue
  struct /* parseVectorValue */ {

    // drake/multibody/parsers/xml_util.h:142
    const char* doc = R"""()""";

    // drake/multibody/parsers/xml_util.h:147
    const char* doc_2 = R"""()""";

  } parseVectorValue;

  // poseValueToTransform
  struct /* poseValueToTransform */ {

    // drake/multibody/parsers/xml_util.h:163
    const char* doc = R"""()""";

  } poseValueToTransform;

  // resolveCenterOfPressure
  struct /* resolveCenterOfPressure */ {

    // drake/multibody/resolve_center_of_pressure.h:11
    const char* doc = R"""()""";

  } resolveCenterOfPressure;

  // s1Trajectory
  struct /* s1Trajectory */ {

    // drake/systems/controllers/zmpUtil.h:22
    const char* doc = R"""()""";

  } s1Trajectory;

  // sign
  struct /* sign */ {

    // drake/multibody/joints/drake_joint_impl.h:123
    const char* doc = R"""()""";

  } sign;

  // surfaceTangents
  struct /* surfaceTangents */ {

    // drake/systems/controllers/controlUtil.h:85
    const char* doc = R"""()""";

  } surfaceTangents;

  // tinyxml2
  struct /* tinyxml2 */ {

    // tinyxml2::XMLElement
    struct /* XMLElement */ {

      // drake/multibody/rigid_body_frame.h:13
      const char* doc = R"""()""";

    } XMLElement;

  } tinyxml2;

} root;


#if defined(__GNUG__)
#pragma GCC diagnostic pop
#endif

