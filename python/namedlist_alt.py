# Alternative impl, motivated by: https://bitbucket.org/ericvsmith/namedlist
from collections import namedtuple
import ctypes

import numpy as np


class NamedViewBase(object):
    """Base for classes generated by ``namedview``."""

    _fields = None  # To be specified by inherited classes.

    def __init__(self, value):
        """Creates a view on ``value``. Any mutations on this instance will be
        reflected in ``value``, and any mutations on ``value`` will be
        reflected in this instance."""
        assert self._fields is not None, (
            "Class must be generated by ``namedview``")
        assert len(self._fields) == len(value)
        object.__setattr__(self, '_value', value)

    @classmethod
    def get_fields(cls):
        """Returns all fields for this class or object."""
        return cls._fields

    def __getitem__(self, i):
        return self._value[i]

    def __setitem__(self, i, value_i):
        self._value[i] = value_i

    def __setattr__(self, name, value):
        """Prevent setting additional attributes."""
        if not hasattr(self, name):
            raise AttributeError("Cannot add attributes!")
        object.__setattr__(self, name, value)

    def __len__(self):
        return len(self._value)

    def __iter__(self):
        return iter(self._value)

    def __array__(self):
        """Proxy for use with NumPy."""
        return np.asarray(self._value)

    def __repr__(self):
        """Provides human-readable breakout of each field and value."""
        value_strs = []
        for i, field in enumerate(self._fields):
            value_strs.append("{}={}".format(field, repr(self._value[i])))
        return "{}({})".format(self.__class__.__name__, ", ".join(value_strs))

    @staticmethod
    def _item_property(index):
        # Maps an item (at a given index) to a property.
        return property(
            fget=lambda self: self.__getitem__(index),
            fset=lambda self, value: self.__setitem__(index, value))


def namedview(name, fields):
    """
    Creates a class that is a named view with given ``fields``. When the class
    is instantiated, it must be given the object that it will be a proxy for.

    Example::
        MyView = namedview("MyView", ('a', 'b'))

        value = np.array([1, 2])
        view = MyView(value)
        view.a = 10  # `value` is now [10, 2]
        value[1] = 100  # `view` is now [10, 100]
        view[:] = 3  # `value` is now [3, 3]

    For more details, see ``NamedViewBase``.
    """
    base_cls = (NamedViewBase,)
    type_dict = dict(_fields=tuple(fields))
    for i, field in enumerate(fields):
        type_dict[field] = NamedViewBase._item_property(i)
    cls = type(name, base_cls, type_dict)
    return cls


def is_same_array(a, b):
    # https://stackoverflow.com/questions/43885090/comparing-numpy-object-references
    return (a.shape == b.shape) and (a == b).all() and a.ctypes.data == b.ctypes.data


def test_main():
    MyView = namedview("MyView", ['a', 'b', 'c'])
    MyTuple = namedtuple("MyTuple", ['a', 'b', 'c'])

    print(MyView)
    print(MyTuple)

    print("[ Simple List ]")
    value = [1, 2, 3]
    view = MyView(value)
    print(MyTuple._fields)
    print(MyView.get_fields())
    print(view.get_fields())
    print(view.a)
    view[0] = 10
    print(view.a)
    view[1] = -100
    view.c = 1000

    tup = MyTuple(a=1, b=2, c=3)
    print(tup)

    print(view)
    print(value)
    view[:] = [111, 222, 333]
    print(view)
    print(value)
    try:
        view.bad_value = 1
        assert False
    except AttributeError:
        pass

    # Ensure compatibility with `np.array`, with minimal copying.
    X = np.asarray(view)
    print(repr(X))
    assert isinstance(X, np.ndarray)
    assert X.shape == (3,)

    print("[ Array 1D ]")
    array = np.array([4, 5, 6])
    aview = MyView(array)
    print(aview.a)
    aview[[1, 2]] = [50, 60]
    print(array)
    print(aview)
    # - Ensure minimal copying.
    assert is_same_array(array, np.asarray(aview))
    assert not is_same_array(array, np.array([4, 5, 6]))

    # Maybe not useful, but meh.
    print("[ Array 2D ]")
    mat = np.eye(3)
    mview = MyView(mat)
    print(mview)
    print(mview.a)
    print(mview[0, 0])
    mview.a[0] = 10
    print(mview.b)
    print(mat)


"""
Example output:

<class '__main__.MyView'>
<class '__main__.MyTuple'>
[ Simple List ]
('a', 'b', 'c')
('a', 'b', 'c')
('a', 'b', 'c')
1
10
MyTuple(a=1, b=2, c=3)
MyView(a=10, b=-100, c=1000)
[10, -100, 1000]
MyView(a=111, b=222, c=333)
[111, 222, 333]
array([111, 222, 333])
[ Array 1D ]
4
[ 4 50 60]
MyView(a=4, b=50, c=60)
[ Array 2D ]
MyView(a=array([ 1.,  0.,  0.]), b=array([ 0.,  1.,  0.]), c=array([ 0.,  0.,  1.]))
[ 1.  0.  0.]
1.0
[ 0.  1.  0.]
[[ 10.   0.   0.]
 [  0.   1.   0.]
 [  0.   0.   1.]]
"""


if __name__ == "__main__":
    test_main()
